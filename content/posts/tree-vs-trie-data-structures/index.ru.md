---
title: Различие между деревьями и префиксными деревьями Tries vs Trees?
seoTitle: Различие между деревьями и префиксными деревьями Tries vs Trees
description:  Различие между деревьями и префиксными деревьями Tries vs Trees
toc: true
tags: []
series: []
categories: [Programming]
date: 2024-02-16
lastMod: 2024-02-16
featuredImage: https://picsum.photos/700/165?grayscale
authors: [roman-kurnovskii]
---

Несмотря на похожесть названий, эти структуры данных выполняют разные задачи, и понимание их различий крайне важно для их эффективного применения.

## Дерево (Tree)

{{< img src="<https://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Tree_%28computer_science%29.svg/440px-Tree_%28computer_science%29.svg.png>" height="250px" float="right">}}

Структура данных дерево - это коллекция сущностей, называемых **узлами**, соединенных **рёбрами**.

Каждый узел содержит значение и список ссылок на свои дочерние узлы. Первый узел дерева называется **корнем**. Визуализируя, структура данных дерева напоминает **перевернутое дерево**, с корнем на верху и листьями (узлами без детей) внизу.

Деревья являются иерархическими, нелинейными структурами данных.

Они отлично подходят для представления <mark>отношений между объектами</mark>, и их операции обычно имеют логарифмическую временную сложность, что делает их эффективными для операций поиска.

Создадим простое бинарное дерево на Python, где каждый узел может иметь максимум двух детей:

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

root = Node(1)
root.left = Node(2)
root.right = Node(3)
```

Здесь у нас есть дерево с корневым узлом, хранящим значение 1. Корневой узел имеет двух детей: левый ребенок хранит значение 2, а правый ребенок хранит значение 3.

## Префиксное дерево (Trie)

{{< img src="<https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg>"  height="200px" float="right">}}

Trie, также известное как префиксное дерево, - это тип дерева, специализирующийся на управлении последовательностями, обычно строками. Каждый узел (кроме корня) соответствует символу или строке, и каждый путь вниз по дереву может представлять слово или префикс.

Основная характеристика - это быстрый поиск данных. Они могут проверить, существует ли слово или префикс в наборе данных за время O(M), где M - длина слова.

Пример структуры данных на Python:

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.end_of_string = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.end_of_string = True
```

В этом примере каждый узел имеет словарь под названием children для хранения ссылок на свои дочерние узлы. Флаг end_of_string помогает определить, формирует ли текущая конкатенация символов допустимое слово.

## Tries vs Trees

Несмотря на общие свойства (основаны на структуре деревьев), Tries и деревья предназначены для разных случаев использования.

Хранение данных: Общего назначения дерево может хранить любой тип данных - числа, строки, объекты, тогда как Tries специально используется для хранения последовательностей, как строки или массивы.

Значение узла: В дереве каждый узел содержит значение. В Tries узлы сами по себе не содержат значения - вместо этого значение - это путь от корня к этому узлу.

Эффективность: Tries невероятно эффективны при поиске слова или префикса в словаре. С другой стороны, деревья более эффективны для широкого спектра операций, таких как поиск, вставка и удаление произвольных значений.

Использование памяти: Tries могут использовать больше памяти из-за ссылок в каждом узле, особенно при работе с большим алфавитом. Каждый узел в Tries поддерживает коллекцию (часто словарь или массив) всех своих дочерних узлов. Однако в бинарном дереве каждый узел должен содержать ссылку максимум на два дочерних узла.

Время поиска: Tries имеют более быстрое время поиска для определенных задач. Например, поиск слова в Tries занимает время O(M), где M - длина слова. Для сбалансированного бинарного дерева поиска временная сложность составит O(log N), где N - количество элементов в дереве.
