---
title: 19 - Автоматизация задачи с помощью bash-скриптов
description: Автоматизация задачи с помощью bash-скриптов
toc: true
authors:
tags: [devops, bash]
categories:
series: 
date: "2022-05-09"
lastmod: "2022-05-09"
featuredImage:
draft: false
id: 1048774
---
## Автоматизация задачи с помощью bash-скриптов

Оболочка, которую мы собираемся использовать сегодня, — это bash, но мы рассмотрим другую оболочку завтра, когда будем углубляться в ZSH.

BASH - **B**ourne **A**gain **Sh**ell («возрождённый» shell)

Мы могли бы почти посвятить целую секцию из 7 дней написанию сценариев оболочки, как и языкам программирования. Bash дает нам возможность работать вместе с другими инструментами автоматизации для достижения цели.

Я до сих пор разговариваю со многими людьми, которые настроили несколько сложных сценариев оболочки, чтобы что-то произошло, и они полагаются на этот сценарий для некоторых из наиболее важных вещей в бизнесе, я не говорю, что нам нужно понимать сценарии оболочки/bash. для этой цели это не путь. Но мы должны изучить сценарии оболочки/bash, чтобы работать вместе с нашими инструментами автоматизации и для специальных задач.

Одним из примеров, который мы использовали, может быть VAGRANTFILE, который мы использовали для создания нашей виртуальной машины, мы могли бы обернуть его в простой сценарий bash, который удалял и обновлял его каждый понедельник утром, чтобы у нас была свежая копия нашей виртуальной машины Linux. каждую неделю мы могли бы также добавлять весь программный стек, который нам нужен, на указанную машину с Linux и так далее с помощью одного сценария bash.

Я думаю, что еще одна вещь, которую я, по крайней мере, слышу, это то, что практические вопросы по скриптам становятся все более и более очевидными во всех интервью.

### Начало

Как и в случае со многим, что мы рассмотрим за все эти 90 дней, единственный реальный способ научиться — это делать. Практический опыт поможет впитать все это в вашу мышечную память.

Прежде всего, нам понадобится текстовый редактор. В [День 17](../Day17) мы рассказали, наверное, о двух самых распространенных текстовых редакторах и немного о том, как их использовать.

Давайте приступим прямо к делу и создадим наш первый сценарий оболочки.

`touch 90DaysOfDevOps.sh` - создает файл 90DaysOfDevOps.sh

За ним следует `nano 90DaysOfDevOps.sh`, это откроет наш новый пустой сценарий оболочки в nano. Опять же, вы можете выбрать другой текстовый редактор.

Первая строка всех скриптов bash должна выглядеть примерно так: `#!/usr/bin/bash`, это путь к вашему двоичному файлу bash.

Однако вы должны проверить это в терминале, запустив `which bash`, если вы не используете Ubuntu, вы также можете попробовать `whereis bash` из терминала.

Однако вы можете увидеть другие пути, перечисленные в уже созданных сценариях оболочки, которые могут включать:

- `#!/bin/bash`
- `#!/usr/bin/env bash`

В следующей строке нашего скрипта я хотел бы добавить комментарий и добавить цель скрипта или хотя бы какую-то информацию обо мне. Вы можете сделать это, используя `#`. Это позволяет нам комментировать определенные строки в нашем коде и предоставлять описания того, что будут делать следующие команды. Я считаю, что чем больше заметок, тем лучше для пользователя, особенно если вы делитесь этим.

Иногда я использую figlet, программу, которую мы установили ранее в разделе Linux, для создания аски-арта, чтобы начать что-то в наших скриптах.

![](../images/Day19_Linux1.png?v1)
Все команды, которые мы использовали ранее в этом разделе Linux ([День 15](../Day15)) можно использовать здесь как простую команду для тестирования нашего скрипта.

Давайте добавим в наш скрипт простой блок кода.

``` 
mkdir 90DaysOfDevOps
cd 90DaysOfDevOps
touch Day19
ls 
```
Затем вы можете сохранить это и выйти из текстового редактора. Если мы запустим наш скрипт с `./90DaysOfDevOps.sh`, вы должны получить сообщение об отказе в разрешении. Вы можете проверить права доступа к этому файлу с помощью команды `ls -la`, и вы увидите, что у нас нет прав на выполнение этого файла.

![](../images/Day19_Linux2.png?v1)

Мы можем изменить это, используя `chmod +x 90DaysOfDevOps.sh`, и тогда вы увидите `x`, означающий, что теперь мы можем запустить (execute) наш скрипт.

![](../images/Day19_Linux3.png?v1)

Теперь мы можем снова запустить наш скрипт, используя `./90DaysOfDevOps.sh` после того, как запуск скрипта создал новый каталог, перешел в этот каталог, а затем создал новый файл.

![](../images/Day19_Linux4.png?v1)

Довольно простые вещи, но вы можете начать понимать, как это можно использовать для вызова других инструментов, как часть способов сделать вашу жизнь проще и автоматизировать вещи.

### Переменные, условные операторы
Большая часть этого раздела на самом деле является повторением того, что мы рассмотрели, когда изучали Golang, но я думаю, что нам стоит углубиться в это снова.

- ### Переменные

Переменные позволяют нам один раз определить конкретный повторяющийся термин, который используется в потенциально сложном сценарии.

Чтобы добавить переменную, вы просто добавляете ее вот так на чистую строку в вашем скрипте.

`challenge="90DaysOfDevOps"`

Таким образом, когда и где мы используем `$challenge` в нашем коде, если мы изменим переменную, это будет отражено повсюду.

![](../images/Day19_Linux5.png?v1)

Если мы сейчас запустим наш скрипт `sh`, вы увидите распечатку, которая была добавлена к нашему скрипту.

![](../images/Day19_Linux5.png?v1)

Мы также можем запросить пользовательский ввод, который может установить наши переменные, используя следующее:

``` 
echo "Enter your name"
read name
```
Затем это определило бы ввод как переменную `$name`. Затем мы могли бы использовать это позже.

- ### Условные операторы

Может быть, мы хотим узнать, кто участвует в нашем марафоне "90 дней" и сколько дней они прошли, мы можем определить это, используя условные выражения `if` `if-else` `else-if`, это то, что мы определили ниже в нашем скрипте. .

```
#!/bin/bash
#  ___   ___  ____                   ___   __ ____              ___
# / _ \ / _ \|  _ \  __ _ _   _ ___ / _ \ / _|  _ \  _____   __/ _ \ _ __  ___
#| (_) | | | | | | |/ _` | | | / __| | | | |_| | | |/ _ \ \ / / | | | '_ \/ __|
# \__, | |_| | |_| | (_| | |_| \__ \ |_| |  _| |_| |  __/\ V /| |_| | |_) \__ \
#   /_/ \___/|____/ \__,_|\__, |___/\___/|_| |____/ \___| \_/  \___/| .__/|___/
#                         |___/                                     |_|
#
# This script is to demonstrate bash scripting!

# Variables to be defined

ChallengeName=#90DaysOfDevOps
TotalDays=90

# User Input

echo "Enter Your Name"
read name
echo "Welcome $name to $ChallengeName"
echo "How Many Days of the $ChallengeName challenge have you completed?"
read DaysCompleted

if [ $DaysCompleted -eq 90 ]
then
  echo "You have finished, well done"
elif [ $DaysCompleted -lt 90 ]
then
  echo "Keep going you are doing great"
else
  echo "You have entered the wrong amount of days"
fi
```
Вы также можете видеть из вышеприведенного, что мы проводим некоторые сравнения или сверяем значения друг с другом, чтобы перейти к следующему этапу. У нас есть разные варианты, которые стоит отметить.

- `eq` - if the two values are equal will return TRUE
- `ne` - if the two values are not equal will return TRUE
- `gt` - if the first value is greater than the second value will return TRUE
- `ge` - if the first value is greater than or equal to the second value will return TRUE
- `lt` - if the first value is less than the second value will return TRUE
- `le` - if the first value is less than or equal to the second value will return TRUE

Мы также можем использовать сценарии bash для получения информации о файлах и папках, это называется условиями файлов.

- `-d file` True if the file is a directory
- `-e file` True if the file exists
- `-f file` True if the provided string is a file 
- `g file` True if the group id is set on a file
- `-r file` True if the file is readable
- `-s file` True if the file has a non-zero size

```
FILE="90DaysOfDevOps.txt"
if [ -f "$FILE" ]
then 
  echo "$FILE is a file"
else 
  echo "$FILE is not a file"
fi
```

![](../images/Day19_Linux7.png?v1)
При условии, что этот файл все еще находится в нашем каталоге, мы должны вернуть первую команду `echo`. Но если мы удалим этот файл, мы должны получить вторую команду `echo`.

![](../images/Day19_Linux8.png?v1)
Надеюсь, вы увидите, как это можно использовать для экономии времени при поиске в системе определенных элементов.

Я нашел этот удивительный репозиторий на GitHub, в котором, кажется, бесконечное количество скриптов [DevOps Bash Tools] (https://github.com/HariSekhon/DevOps-Bash-tools/blob/master/README)
### Пример 

**Scenario**: У нас есть наша компания под названием «90DaysOfDevOps», и мы работаем некоторое время, и теперь пришло время расширить команду с 1 человека до гораздо большего в ближайшие недели. Я пока единственный, кто знает процесс адаптации, поэтому мы хотим чтобы уменьшить это узкое место, автоматизировав некоторые из этих задач.

**Requirements**: 
- Пользователь может быть передан в качестве аргумента командной строки.
- Пользователь создается с именем аргумента командной строки.
- Пароль может быть проанализирован как аргумент командной строки.
- Пароль установлен для пользователя
- Отображается сообщение об успешном создании учетной записи.

Давайте начнем с создания нашего сценария оболочки с помощью `touch create_user.sh`.

Прежде чем мы двинемся дальше, давайте также создадим этот исполняемый файл, используя `chmod +x create_user.sh`

затем мы можем использовать `nano create_user.sh`, чтобы начать редактирование нашего скрипта для сценария, который мы установили.

Мы можем взглянуть на первое требование «Пользователь может быть передан в качестве аргумента командной строки», мы можем использовать следующее

```
#! /usr/bin/bash

#A user can be passed in as a command line argument
echo "$1"
```

![](../images/Day19_Linux9.png?v1)

Идем далее и запускаем `./create_user.sh Michael`, замените Michael своим именем при запуске скрипта.
![](../images/Day19_Linux10.png?v1)

Далее мы можем выполнить второе требование: «Пользователь создается с именем аргумента командной строки», это можно сделать с помощью команды `useradd`. Опция `-m` предназначена для создания домашнего каталога пользователя как /home/username.
```
#! /usr/bin/bash

#A user can be passed in as a command line argument
echo "$1 user account being created."

#A user is created with the name of command line argument
sudo useradd -m "$1"

```
Предупреждение: если вы не укажете имя учетной записи пользователя, произойдет ошибка, поскольку мы не заполнили переменную `$1`

Затем мы можем проверить, была ли создана эта учетная запись с помощью команды `awk -F: '{print $1}' /etc/passwd`.

[More about awk linux command](https://www.freecodecamp.org/news/the-linux-awk-command-linux-and-unix-usage-syntax-examples/)

![](../images/Day19_Linux11.png?v1)

Наше следующее требование: «Пароль может быть проанализирован как аргумент командной строки». Во-первых, мы никогда не собираемся делать это в продакшене, нам нужно проработать список требований в лаборатории, чтобы понять.
```
#! /usr/bin/bash

#A user can be passed in as a command line argument
echo "$1 user account being created."

#A user is created with the name of command line argument
sudo useradd -m "$1"

#A password can be parsed in as a command line argument.
sudo chpasswd <<< "$1":"$2"
```
Если мы затем запустим этот скрипт с двумя параметрами `./create_user.sh пароль 90DaysOfDevOps`

На изображении ниже вы можете видеть, что мы выполнили наш скрипт, он создал нашего пользователя и пароль, а затем мы вручную перешли к этому пользователю и подтвердили это с помощью команды whoami.

![](../images/Day19_Linux12.png?v1)

Последнее требование: «Отображается сообщение об успешном создании учетной записи». На самом деле у нас уже есть это в верхней строке нашего кода, и мы можем видеть на снимке экрана выше, что у нас есть «созданная учетная запись пользователя 90DaysOfDevOps». Это осталось от нашего тестирования с параметром `$1`.

Теперь этот сценарий можно использовать для быстрого подключения и настройки новых пользователей в наших системах Linux. Но, может быть, вместо того, чтобы некоторым историческим людям приходилось работать с этим, а затем получать новые имена пользователей или пароли для других людей, мы могли бы добавить некоторый пользовательский ввод, который мы ранее рассмотрели ранее, для захвата наших переменных.

``` 
#! /usr/bin/bash

echo "What is your intended username?"
read  username
echo "What is your password"
read  password

#A user can be passed in as a command line argument
echo "$username user account being created."

#A user is created with the name of command line argument
sudo useradd -m $username

#A password can be parsed in as a command line argument.
sudo chpasswd <<< $username:$password
```

Шаги стали более интерактивными,

![](../images/Day19_Linux14.png?v1)

Просто чтобы закончить это, возможно, мы хотим вывести успешный вывод, чтобы сказать, что наша новая учетная запись пользователя завершена.

![](../images/Day19_Linux15.png?v1)

Одна вещь, которую я заметил, это то, что мы отображаем пароль на нашем входе, мы можем скрыть это, используя флаг `-s` в строке кода `read -s password`

![](../images/Day19_Linux16.png?v1)

Если вы хотите удалить пользователя, которого вы создали для лабораторных целей, вы можете сделать это с помощью `sudo userdel test_user`

Еще раз, я не говорю, что это будет то, что вы будете создавать в своей повседневной жизни, но я думал, что это то, что подчеркнет гибкость того, для чего вы можете использовать сценарии оболочки.

Подумайте о любых повторяющихся задачах, которые вы выполняете каждый день, неделю или месяц, и о том, как вы могли бы лучше автоматизировать это. Первым вариантом, вероятно, будет использование сценария bash, прежде чем переходить к более сложной территории.

Я создал очень простой bash-файл, который помогает мне развернуть кластер Kubernetes с помощью minikube на моем локальном компьютере вместе со службами данных и Kasten K10, чтобы продемонстрировать требования и нужды, связанные с управлением данными. [Project Pace](https://github.com/MichaelCade/project_pace/blob/main/singlecluster_demo.sh). Но я не счел уместным поднимать вопрос здесь, поскольку мы еще не рассмотрели Kubernetes.

## Ресурсы 

- [Bash in 100 seconds](https://www.youtube.com/watch?v=I4EWvMFj37g)
- [Bash script with practical examples - Full Course](https://www.youtube.com/watch?v=TPRSJbtfK4M)
- [Client SSH GUI - Remmina](https://remmina.org/)
- [The Beginner's guide to SSH](https://www.youtube.com/watch?v=2QXkrLVsRmk)
- [Vim in 100 Seconds](https://www.youtube.com/watch?v=-txKSRn0qeA)
- [Vim tutorial](https://www.youtube.com/watch?v=IiwGbcd8S7I)
- [Learn the Linux Fundamentals - Part 1](https://www.youtube.com/watch?v=kPylihJRG70)
- [Linux for hackers (don't worry you don't need to be a hacker!)](https://www.youtube.com/watch?v=VbEx7B_PTOE)
