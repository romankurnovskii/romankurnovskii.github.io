---
title: 4. Условия
description: Python 101
toc: true
authors:
tags:
categories:
series:
featuredImage:
date: "2022-06-28"
lastmod: 2022-12-22
draft: false
weight: 4
---

В каждом компьютерном языке есть хотя бы один условный оператор. Чаще всего этот оператор представляет собой структуру **if/elif/else**. 

В [Python 3.10](https://www.python.org/downloads/release/python-3100/) добавилась структура [**match/case**](https://peps.python.org/pep-0636/)

Условный оператор проверяет, является ли утверждение истинным или ложным. Это, собственно, все, что он делает. Также рассмотрим следующие булевы операции: **and, or** и **not**. Эти операции могут изменять поведение условного оператора простыми и сложными способами, в зависимости от проекта.

## Оператор if

Оператор if в Python довольно прост в использовании. Давайте потратим несколько минут на рассмотрение нескольких примеров, чтобы лучше познакомиться с этой конструкцией.

```python
>>> if 2 > 1:
        print("This is a True statement!")
    This is a True Statement!
``

Это условие проверяет "правдивость" следующего утверждения: 2 > 1. Поскольку это утверждение оценивается как True, оно приведет к печати последней строки примера на экран или в **стандартный выход** (stdout).

    **Python заботится о пробелах**

    Язык Python очень заботится о пробелах. Вы заметили, что в нашем условном выражении выше мы отступили от кода внутри оператора if на четыре пробела. Это очень важно! Если вы не сделаете отступы между блоками кода должным образом, код не будет выполняться правильно. Он может вообще не выполниться.

    Также **не** смешивайте табуляцию и пробелы. IDLE будет жаловаться, что с файлом что-то не так, и вам будет трудно понять, в чем дело. Рекомендуемое количество пробелов для отступа в блоке кода - четыре. На самом деле вы можете отступать от текста на любое количество пробелов, если вы последовательны. Однако правило 4 пробелов рекомендовано в Руководстве по стилю Python, и именно его придерживаются разработчики кода Python.

Давайте рассмотрим другой пример:

```python
>>> var1 = 1
>>> var2 = 3
>>> if var1 > var2:
        print("This is also True")
```

В этой статье мы сравниваем две переменные, которые отвечают на вопрос: 1 > 3? Очевидно, что 1 не больше 3, поэтому ничего не выводится. Но что, если мы хотим, чтобы он что-то вывел? Вот тут-то и приходит на помощь оператор **else**. Давайте изменим условие, чтобы добавить этот элемент:

```python
if var1 > var2:
    print("This is also True")
else:
    print("That was False!")
```
Если вы запустите этот код, он выведет строку, которая следует за оператором **else**. Давайте сменим передачу и получим немного информации от пользователя, чтобы сделать это поинтереснее. В Python 3.x тоже есть встроенная функция **input**, но она пытается выполнить то, что введено как выражение Python.

```python
value = input("How much is that doggy in the window? \n")

value = int(value)

if value < 10:
    print("That's a great deal!")
elif 10 <= value <= 20:
    print("I'd still pay that...")
else:
    print("Wow! That's too much!")
```

Давайте немного разложим всё это по полочкам. Первая строка запрашивает у пользователя сумму. В следующей строке он преобразует введенный пользователем результат в целое число. Так что если вы введете число с плавающей запятой, например **1.23**, оно будет усечено до **1**. Если вы введете не число, то получите исключение. Мы рассмотрим, как обрабатывать исключения в следующей главе, поэтому пока просто введите целое число.

В следующих нескольких строках вы увидите, как мы проверяем 3 различных случая: меньше 10, больше или равно 10, но меньше или равно 20 или что-то еще. Для каждого из этих случаев выводится своя строка. Попробуйте поместить этот код в IDLE и сохранить его. Затем запустите его несколько раз с разными входными данными, чтобы посмотреть, как он работает.

Вы можете добавить несколько операторов **elif** ко всему условию. Оператор **else** необязателен, но является хорошим вариантом по умолчанию.

## match/case

```python
color = "yellow"
match color:
  case "red":
    print("The color is red")
  case "yellow":
    print("Wow, you picked yellow")
  case "green":
    print("We are using a  green color")
  case "blue":
    print("Blue like the sea...")
```

```python
match command.split():
    case ["quit"]:
        print("Goodbye!")
        quit_game()
    case ["look"]:
        current_room.describe()
    case ["get", obj]:
        character.get(obj, current_room)
    case ["go", direction]:
        current_room = current_room.neighbor(direction)
```

## or/and/not

Теперь мы готовы к изучению булевых операций (and, or, not). Согласно документации Python, их порядок приоритета таков: сначала **or**, затем **and**, затем **not**. Вот как они работают:

- `or` означает, что если любое условие, которое "перечислено" вместе, равно True, то выполняется следующее утверждение
- and означает, что для выполнения следующего утверждения все утверждения должны быть True
- not означает, что если условие оценивается как False, то оно является True. На мой взгляд, это самый запутанный вариант.

Давайте рассмотрим несколько примеров каждого из них. Мы начнем с **or**.

```python
x = 10
y = 20

if x < 10 or y > 15:
    print("This statement was True!")
```
Здесь мы создаем пару переменных и проверяем, если одна из них меньше десяти, а другая больше 15. Поскольку последняя больше 15, выполняется оператор print. Как видите, если одно или оба утверждения равны True, то выполняется оператор print. Давайте посмотрим, как работает **end**:

```python
x = 10
y = 10
if x == 10 and y == 15:
    print("This statement was True")
else:
    print("The statement was False!")
```
Если вы выполните приведенный выше код, вы увидите, что первое утверждение не выполняется. Вместо него выполняется оператор под **else**. Почему так? Потому что мы проверяем, что x **и** y равны 10 и 15 соответственно. В данном случае это не так, поэтому мы переходим к else. Таким образом, когда вы **соединяете** два оператора вместе, **оба** оператора должны иметь значение True, чтобы выполнить следующий код. Также обратите внимание, что для проверки равенства в Python необходимо использовать двойной знак равенства. Одинарный знак равенства известен как **оператор присваивания** и предназначен только для присвоения значения переменной. Если бы вы попытались выполнить приведенный выше код с одним из операторов, имеющим только один знак равенства, вы бы получили сообщение о неправильном синтаксисе.

Обратите внимание, что вы также можете использовать **or** и **and** более чем два оператора вместе. Однако я не рекомендую этого делать, так как чем больше утверждений, тем сложнее их понять и отладить.

Теперь мы готовы рассмотреть операцию **not**.

```python
my_list = [1, 2, 3, 4]
x = 10
if x not in my_list:
    print("'x' is not in the list, so this is True!")
```
В этом примере мы создаем список, содержащий четыре целых числа. Затем мы пишем тест, который спрашивает, нет ли "x" в этом списке. Поскольку "x" равно 10, оператор оценивается как True, и сообщение выводится на экран. Другим способом проверки на **not** является использование восклицательного знака, например, так:

```python
x = 10
if x != 11:
    print("x is not equal to 11!")
```
При желании вы можете комбинировать операцию **not** с двумя другими для создания более сложных условных операторов. Вот простой пример:

```python
my_list = [1, 2, 3, 4]
x = 10
z = 11
if x not in my_list and z != 10:
    print("This is True!")
```
## Проверка на ничто (None)

Поскольку мы говорим об утверждениях, которые оцениваются в True, нам, вероятно, нужно рассказать о том, что оценивается в **False**. В Python есть ключевое слово `False`, которое я уже несколько раз упоминал. Однако пустая строка, кортеж или список также оцениваются как `False`. Есть также еще одно ключевое слово, которое в основном оценивается как `False` и называется `None`. Значение None используется для обозначения отсутствия значения. Это своего рода аналог `Null`, который можно встретить в базах данных. Давайте посмотрим на код, чтобы лучше понять, как все это работает:

```python
empty_list = []
empty_tuple = ()
empty_string = ""
nothing = None

if empty_list == []:
    print("It's an empty list!")

if empty_tuple:
    print("It's not an empty tuple!")

if not empty_string:
    print("This is an empty string!")

if not nothing:
    print("Then it's nothing!")
```
Первые четыре строки задают четыре переменные. Далее мы создаем четыре условия для их проверки. Первое проверяет, действительно ли **empty_list** пуст. Второе условие проверяет, есть ли что-то в **empty_tuple**. Да, вы все правильно поняли, второе условие имеет значение True, только если кортеж **не** пуст! Последние два условия делают противоположное второму. Третье проверяет, **является** ли строка пустой, а четвертое - действительно ли переменная **nothing** является None.

Оператор not означает, что мы проверяем противоположное значение. Другими словами, мы проверяем, является ли значение НЕ True. Поэтому в третьем примере мы проверяем, является ли пустая строка ПО НАСТОЯЩЕМУ пустой. Вот другой способ написать то же самое:

```python
if empty_string == "":
    print("This is an empty string!")
```
Чтобы действительно закрепить это, давайте установим переменную **empty_string**, чтобы она действительно содержала что-то:

```python
>>> empty_string = "something"
>>> if empty_string == "":
        print("This is an empty string!")
```
Если вы выполните это, то увидите, что ничего не будет выведено, так как мы выведем что-то только в том случае, если переменная является пустой строкой.

Обратите внимание, что ни одна из этих переменных не равна другой. Они просто оцениваются одинаково. Чтобы доказать это, мы рассмотрим пару быстрых примеров:

```python
>>> empty_list == empty_string
False
>>> empty_string == nothing
False
```

Как видите, они не равны друг другу. В реальном мире вы часто будете проверять свои структуры данных на наличие данных. Некоторые программисты предпочитают просто обернуть свои структуры в обработчик исключений, и если они окажутся пустыми, они поймают исключение. Другие предпочитают использовать вышеупомянутую стратегию, когда вы действительно проверяете структуру данных на наличие в ней данных. Обе стратегии являются правильными.

Я нахожу оператор **not** немного запутанным и не использую его часто. Но время от времени он может оказаться полезным.

## Специальные символы

Строки могут содержать специальные символы, такие как табуляция или новая строка. Мы должны знать о них, поскольку иногда они могут появляться и вызывать проблемы. Например, символ новой строки определяется как `\n`, а символ табуляции - как `\t`. Давайте рассмотрим несколько примеров, чтобы вы лучше поняли, что они делают:

```python
>>> print("I have a \n new line in the middle")
I have a
 new line in the middle
>>> print("This sentence is \ttabbed!")
This sentence is    tabbed!
```
Был ли вывод таким, как вы ожидали? В первом примере в середине предложения стоит буква "n", что заставляет вывести новую строку. Поскольку у нас есть пробел после символа новой строки, вторая строка отделена пробелом. Второй пример показывает, что происходит, когда внутри предложения есть символ табуляции.

Иногда в строке необходимо использовать управляющие символы, например, обратную косую черту. Чтобы использовать экранирующие символы, необходимо использовать обратную косую черту, поэтому в случае с обратной косой чертой необходимо ввести две обратные косые черты. Давайте посмотрим:

```python
>>> print("This is a backslash \")
Traceback (most recent call last):
  File "<string>", line 1, in <fragment>
EOL while scanning string literal: <string>, line 1, pos 30
>>> print("This is a backslash \\")
This is a backslash \
```
Вы заметите, что первый пример сработал не очень хорошо. Python думал, что мы экранируем двойную кавычку, поэтому он не мог определить, где находится конец строки (EOL), и выдавал ошибку. Во втором примере обратная косая черта экранирована должным образом.

## if __name__ == “__main__”

Вы увидите очень распространенный условный оператор, используемый во многих примерах Python. Вот как он выглядит

```python
if __name__ == "__main__":
    # do something!
```

Располагается в конце файла. Это говорит Python, что вы хотите выполнить следующий код, только если эта программа будет выполнена как отдельный файл. Я часто использую эту конструкцию, чтобы проверить, что мой код работает так, как я ожидаю. Мы обсудим это позже в книге, но всякий раз, когда вы создаете сценарий Python, вы создаете модуль Python. Если вы напишете его хорошо, вы можете захотеть импортировать его в другой модуль. Когда вы импортируете модуль, он **не** будет выполнять код, находящийся под условным обозначением, потому что **__name__** больше не будет равен **"__main__"**.
