---
title: 437. Path Sum III
seoTitle: LeetCode 437. Path Sum III | Решение на Python.
description: LeetCode 437. Найти количество всех путей в бинарном дереве, которые суммируются в определенное число. Разбор задачи.
toc: true
tags: [Binary Tree, DFS, Easy]
categories: [Algorithms, Easy, LeetCodeTop75]
date: 2023-08-28
lastmod: 2023-09-05
featuredImage: https://picsum.photos/700/241?grayscale
weight: 437
---

[LeetCode задача 437](<https://leetcode.com/problems/path-sum-iii/>)

## Задача

Дан корень бинарного дерева, в котором каждый узел содержит целочисленное значение. Найти количество путей в этом дереве, в которых сумма значений узлов равна заданному числу `sum`.

Путь может начинаться и заканчиваться на любом узле, но он должен идти вниз (с родителя к потомку).

## Подсказки

Задачу можно решить, используя рекурсивный обход дерева. (Depth-First Search (DFS)).

## Подход

Идея заключается в рекурсивном обходе каждого узла и подсчете всех возможных путей с заданной суммой, начиная с этого узла. После этого нужно агрегировать эти значения для всех узлов.

Одним из наиболее простых способов решения является рекурсивный обход дерева и проверка каждого возможного пути. Это можно сделать, запустив рекурсию для каждого узла в дереве, начиная с корня, и для каждого из них рекурсивно проверять все возможные пути вниз по дереву.

## Алгоритм

1. **DFS с "памятью"**: Мы можем использовать DFS, чтобы пройти по всем путям в дереве, и на каждом этапе проверить, сколько путей можно завершить в этом узле с нужной суммой.
2. **Хранение промежуточных сумм**: По мере движения вниз по дереву, мы можем хранить сумму всех узлов в текущем пути. Это позволит нам быстро проверить, можно ли создать подпуть с нужной суммой.
3. **Обновление ответа**: Когда мы достигаем листа, мы можем проверить, создает ли текущий путь нужную сумму. Если да, увеличьте счетчик.
4. **Возврат результата**: В конечном итоге верните количество всех подходящих путей.

1. Начните с корня дерева и рекурсивно обходите все узлы.
2. Для каждого узла запустите еще одну рекурсию, чтобы проверить все пути, начинающиеся с этого узла.
3. Подсчитайте количество путей, которые дают заданную сумму.

1. Инициализируйте переменную для подсчета количества путей.
2. Запустите DFS с корня дерева.

## Решение

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def dfs(node, target, current_sum, prefix_sums):
    if not node:
        return 0
    
    count = 0
    current_sum += node.val
    
    # Найти нужное количество путей, которые заканчиваются на текущем узле
    count += prefix_sums.get(current_sum - target, 0)
    
    # Обновление префиксных сумм
    prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1
    
    # Рекурсивно проверить оба поддерева
    count += dfs(node.left, target, current_sum, prefix_sums)
    count += dfs(node.right, target, current_sum, prefix_sums)
    
    # Откат изменений
    prefix_sums[current_sum] -= 1
    
    return count

def pathSum(root: TreeNode, target: int) -> int:
    return dfs(root, target, 0, {0: 1})
```
