---
title: 27. Профилирование кода
description: Python 101
toc: true
authors:
tags:
categories:
series:
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 27
---

Профилирование кода - это попытка найти узкие места в вашем коде. Профилирование должно выявить, какие части вашего кода занимают больше всего времени на выполнение. Узнав это, вы можете посмотреть на эти части кода и попытаться найти способы их оптимизации. Python содержит три встроенных профайлера: **cProfile**, **profile** и **hotshot**. Согласно документации Python, hotshot "больше не поддерживается и может быть отменен в будущей версии Python". Модуль **profile** - это чистый модуль Python, но он добавляет много накладных расходов в профилируемые программы. Поэтому мы сосредоточимся на **cProfile**, который имеет интерфейс, имитирующий модуль profile.

## Профилирование кода с помощью cProfile

Профилирование кода с помощью cProfile достаточно просто. Все, что вам нужно сделать, это импортировать модуль и вызвать его функцию **run**. Давайте рассмотрим простой пример:

```python
>>> import hashlib
>>> import cProfile
>>> cProfile.run("hashlib.md5(b'abcdefghijkl').digest()")
         4 function calls in 0.000 CPU seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {_hashlib.openssl_md5}
        1    0.000    0.000    0.000    0.000 {method 'digest' of '_hashlib.HASH' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```

Здесь мы импортируем модуль **hashlib** и используем cProfile для профилирования создания хэша MD5. Первая строка показывает, что было 4 вызова функций. Следующая строка говорит нам о том, как упорядочены результаты. Согласно документации, стандартное имя относится к крайнему правому столбцу. Здесь есть несколько столбцов.

-  **ncalls** - количество выполненных вызовов.
-  **tottime** - общее время, проведенное в данной функции.
-  **percall** - это отношение tottime к ncalls.
-  **cumtime** - суммарное время, проведенное в данной и всех подфункциях. Это работает также и с рекурсивными функциями!
-  Второй столбец **percall** - это коэффициент cumtime, деленный на примитивные вызовы
-  **filename:lineno(function)** предоставляет соответствующие данные каждой функции


Примитивный вызов - это вызов, который не был вызван с помощью рекурсии.

Это не очень интересный пример, поскольку здесь нет очевидных узких мест. Давайте создадим кусок кода с некоторыми встроенными узкими местами и посмотрим, обнаружит ли их профайлер.

```python
import time

def fast():
    """"""
    print("I run fast!")

def slow():
    """"""
    time.sleep(3)
    print("I run slow!")

def medium():
    """"""
    time.sleep(0.5)
    print("I run a little slowly...")

def main():
    """"""
    fast()
    slow()
    medium()

if __name__ == '__main__':
    main()
```

В этом примере мы создаем четыре функции. Первые три выполняются с разной скоростью. Функция **fast** будет выполняться с нормальной скоростью; функция **medium** будет выполняться примерно полсекунды, а *slow** функции потребуется около 3 секунд. Функция **main** вызывает остальные три. Теперь давайте запустим cProfile против этой маленькой глупой программы:

```python
>>> import cProfile
>>> import ptest
>>> cProfile.run('ptest.main()')
I run fast!
I run slow!
I run a little slowly...
         8 function calls in 3.500 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    3.500    3.500 <string>:1(<module>)
        1    0.000    0.000    0.500    0.500 ptest.py:15(medium)
        1    0.000    0.000    3.500    3.500 ptest.py:21(main)
        1    0.000    0.000    0.000    0.000 ptest.py:4(fast)
        1    0.000    0.000    3.000    3.000 ptest.py:9(slow)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        2    3.499    1.750    3.499    1.750 {time.sleep}
```

На этот раз мы видим, что программе потребовалось 3,5 секунды для выполнения. Если вы изучите результаты, то увидите, что cProfile определил **slow** функцию как занявшую 3 секунды. Это самое большое узкое место после **main** функции. Обычно, когда вы обнаруживаете такое узкое место, вы пытаетесь найти более быстрый способ выполнения кода или, возможно, решаете, что время выполнения является приемлемым. В данном примере мы знаем, что лучший способ ускорить работу функции - удалить вызов **time.sleep** или, по крайней мере, уменьшить длительность сна.

Вы также можете вызвать cProfile в командной строке, а не использовать его в интерпретаторе. Вот один из способов сделать это:

```python
python -m cProfile ptest.py
```

Это позволит запустить cProfile против вашего сценария точно так же, как мы делали это раньше. Но что если вы хотите сохранить результаты работы профайлера? Это легко сделать с помощью cProfile! Все, что вам нужно сделать, это передать ему команду **-o**, за которой следует имя (или путь) выходного файла. Вот пример:

```python
python -m cProfile -o output.txt ptest.py

```

К сожалению, файл, который он выводит, не совсем удобен для чтения. Если вы хотите прочитать этот файл, то вам нужно использовать модуль Python pstats. Вы можете использовать **pstats** для форматирования вывода различными способами. Вот код, который показывает, как получить результат, похожий на тот, что мы видели до сих пор:

```python
>>> import pstats
>>> p = pstats.Stats("output.txt")
>>> p.strip_dirs().sort_stats(-1).print_stats()
Thu Mar 20 18:32:16 2014    output.txt

         8 function calls in 3.501 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    3.501    3.501 ptest.py:1(<module>)
        1    0.001    0.001    0.500    0.500 ptest.py:15(medium)
        1    0.000    0.000    3.501    3.501 ptest.py:21(main)
        1    0.001    0.001    0.001    0.001 ptest.py:4(fast)
        1    0.001    0.001    3.000    3.000 ptest.py:9(slow)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        2    3.499    1.750    3.499    1.750 {time.sleep}


<pstats.Stats instance at 0x017C9030>
```

Вызов **strip_dirs** удалит из вывода все пути к модулям, а вызов **sort_stats** выполнит сортировку, которую мы привыкли видеть. В документации по cProfile есть множество действительно интересных примеров, показывающих различные способы извлечения информации с помощью модуля pstats.

## Подведение итогов

На данном этапе вы должны уметь использовать модуль **cProfile** для диагностики причин медленной работы вашего кода. Возможно, вы также захотите взглянуть на модуль Python **timeit**. Он позволяет засекать время на небольших участках кода, если вы не хотите разбираться со сложностями, связанными с профилированием. Есть также несколько других модулей сторонних разработчиков, которые хорошо подходят для профилирования, например, проекты line_profiler и memory_profiler.
