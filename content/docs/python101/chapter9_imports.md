---
title: 9. Импортирование
description: Python 101
toc: true
authors:
tags:
categories:
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 9
---

Python поставляется с большим количеством готового кода. Эти части кода известны как модули и пакеты. Модуль - это один импортируемый файл Python, а пакет состоит из двух или более модулей. Пакет может быть импортирован так же, как и модуль. Каждый раз, когда вы сохраняете собственный сценарий Python, вы создаете модуль. Это, конечно, может быть далеко не самым полезным модулем, но тем не менее. В этой главе мы узнаем, как импортировать модули, используя несколько различных методов. Давайте начнем!

## import this

Python предоставляет ключевое слово **import** для импорта модулей. Давайте попробуем:

```sh
import this
```

Если вы запустите этот код в интерпретаторе, на выходе вы должны увидеть что-то вроде следующего:

```sh
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

Вы нашли "пасхальное яйцо" в Python, известное как "Zen of Python". На самом деле это своего рода неофициальная лучшая практика для Python. Mодуль **this** на самом деле ничего не делает, но он предоставляет забавный способ показать, как импортировать что-то. Давайте действительно импортируем что-то, что мы можем использовать, например, модуль **math**:

```sh
>>> import math
>>> math.sqrt(4)
2.0
```

Здесь мы импортировали модуль **math**, а затем сделали кое-что новое. Мы вызвали одну из его функций, **sqrt** (т.е. квадратный корень). Чтобы вызвать метод импортированного модуля, мы должны использовать следующий синтаксис: **имя_модуля.имя_метода(аргумент)**. В этом примере мы нашли квадратный корень из 4. Модуль **math** имеет множество других функций, которые мы можем использовать, например, cos (косинус), **factorial, log** (логарифм) и т. д. Вы можете вызывать эти функции точно так же, как и **sqrt**. Единственное, что вам нужно будет проверить, принимают ли они дополнительные аргументы или нет. Теперь давайте рассмотрим другой способ импорта.

## Использование from для импорта

Некоторым людям не нравится, что все, что они вводят, должно сопровождаться именем модуля. В Python есть решение для этого! Вы можете импортировать из модуля только те функции, которые вам нужны. Давайте представим, что мы хотим импортировать только функцию **sqrt*:

```sh
>>> from math import sqrt
>>> sqrt(16)
4.0
```

Это работает практически так, как читается: **из модуля math импортируйте функцию sqrt**. Позвольте мне объяснить это по-другому. Мы используем ключевое слово Python **from** для импорта функции **sqrt** из модуля **math**. Вы также можете использовать этот метод для импорта нескольких функций из модуля math:

```sh
>>> from math import pi, sqrt
```

В этом примере мы импортируем и **pi**, и **sqrt**. Если вы пытались получить доступ к **pi**, то, возможно, заметили, что на самом деле это значение, а не функция, которую можно вызвать. Она просто возвращает значение pi. Когда вы выполняете импорт, вы можете импортировать значение, функцию или даже другой модуль! Есть еще один способ импортировать материал, который мы должны рассмотреть. Давайте узнаем, как импортировать все!

## Импорт всего!

Python предоставляет возможность импортировать **все** функции и значения из модуля. На самом деле это **плохая** идея, так как это может привести к загрязнению вашего **пространства имен**. Пространство имен - это место, где находятся все ваши переменные в течение жизни программы. Допустим, у вас есть своя переменная с именем **sqrt**, например, так:

```sh
>>> from math import sqrt
>>> sqrt = 5
```

Теперь вы только что изменили функцию **sqrt** на переменную, которая хранит значение 5. Это называется затенением (shadowing). Это особенно хитрый способ упрощения своей жизни, когда вы выполняете импорт всего из модуля. Давайте взглянем:

```sh
>>> from math import *
>>> sqrt = 5
>>> sqrt(16)
Traceback (most recent call last):
  File "<string>", line 1, in <fragment>
TypeError: 'int' object is not callable
```
Чтобы импортировать все, вместо указания списка элементов мы просто используем подстановочный знак "*", который означает, что мы хотим импортировать все. Если мы не знаем, что находится в модуле **math**, мы не поймем, что только что провалили одну из импортированных функций. Когда мы пытаемся вызвать функцию **sqrt** после присвоения её целому числу, мы обнаружим, что она больше не работает.

Поэтому в большинстве случаев рекомендуется импортировать элементы из модулей, используя один из предыдущих методов, упомянутых в этой главе. Из этого правила есть несколько исключений. Некоторые модули созданы для импорта с помощью метода "*". Одним из ярких примеров является Tkinter, набор инструментов, входящий в состав Python, который позволяет создавать пользовательские интерфейсы для настольных компьютеров. Причина, по которой импортировать Tkinter таким образом якобы можно, заключается в том, что модули названы так, что вы вряд ли будете использовать их повторно.

## Подведение итогов

Теперь вы знаете все об импорте в Python. В состав Python входят десятки модулей, которые вы можете использовать для придания дополнительной функциональности вашим программам. Вы можете использовать встроенные модули для опроса вашей ОС, получения информации из реестра Windows, настройки утилит протоколирования, разбора XML и многого, многого другого. Мы рассмотрим некоторые из этих модулей во второй части этой книги.

В следующей главе мы рассмотрим создание собственных функций. Я думаю, что следующая тема окажется для вас очень полезной.
