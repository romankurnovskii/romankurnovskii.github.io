---
title: 7. Обработка исключений
description: Python 101
toc: true
authors:
tags:
categories:
series: 
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 7
---

Что вы делаете, когда в вашей программе происходит что-то плохое? Допустим, вы пытаетесь открыть файл, но вводите неправильный путь или запрашиваете у пользователя информацию, а он вводит какой-то мусор. Вы не хотите, чтобы ваша программа аварийно завершилась, поэтому вы реализуете обработку исключений. В Python эта конструкция обычно обернута в так называемый **try/except**. В этой главе мы рассмотрим следующие темы:

- Общие типы исключений
- Обработка исключений с помощью **try/except**
- Изучим, как работает **try/except/finally**
- Исследуем, как оператор **else** работает в сочетании с **try/except**.

Давайте начнем с изучения некоторых наиболее распространенных исключений, которые встречаются в Python. Примечание: ошибка и исключение - это просто разные слова, которые описывают одно и то же, когда мы говорим об обработке исключений.

## Распространенные исключения

Вы уже видели несколько исключений. Вот список наиболее распространенных встроенных исключений (определения взяты из [документации Python](http://docs.python.org/2/library/exceptions.html)):

    - **Exception** (это то, на чем построены почти все остальные)
    - **AttributeError** - Возникает, когда ссылка на атрибут или присвоение не удается.
    - **IOError** - Возникает, когда операция ввода/вывода (например, оператор печати, встроенная функция open() или метод объекта файла) не выполняется по причине, связанной с вводом/выводом, например, "файл не найден" или "диск заполнен".
    -  **ImportError** - Возникает, когда оператор import не может найти определение модуля или когда при **импорте from ...** не удается найти имя, которое должно быть импортировано.
    - *IndexError** - Возникает, когда подскрипт последовательности выходит за пределы диапазона.
    - **KeyError** - Возникает, когда ключ отображения (словаря) не найден в наборе существующих ключей.
    - **KeyboardInterrupt** - Возникает, когда пользователь нажимает клавишу прерывания (обычно Control-C или Delete).
    - **NameError** - Возникает, когда не найдено локальное или глобальное имя.
    - **OSError** - Возникает, когда функция возвращает системную ошибку.
    - **SyntaxError** - Возникает, когда синтаксический анализатор встречает синтаксическую ошибку.
    - **TypeError** - Возникает, когда операция или функция применяется к объекту неподходящего типа. Связанное значение представляет собой строку, содержащую подробную информацию о несоответствии типа.
    - **ValueError** - Возникает, когда встроенная операция или функция получает аргумент, имеющий правильный тип, но несоответствующее значение, и ситуация не описывается более точным исключением, таким как IndexError.
    - **ZeroDivisionError** - Возникает, когда второй аргумент операции деления или модуляции равен нулю.

Существует также множество других исключений, но, скорее всего, вы не будете сталкиваться с ними так часто. Однако, если вам интересно, вы можете прочитать о них в [документации Python](http://docs.python.org/2/library/exceptions.html).

## Как работать с исключениями

Обработка исключений в Python очень проста. Давайте потратим немного времени на написание нескольких примеров, которые будут вызывать исключения. Мы начнем с одной из самых распространенных проблем в информатике: деление на ноль.

```sh
>>> 1 / 0
Traceback (most recent call last):
    File "<string>", line 1, in <fragment>
ZeroDivisionError: integer division or modulo by zero

>>> try:
        1 / 0
    except ZeroDivisionError:
        print("You cannot divide by zero!")

You cannot divide by zero!
```
Если вы вспомните уроки начальной математики, то вспомните, что нельзя делить на ноль. В Python эта операция приводит к ошибке, как видно из первой половины примера. Чтобы поймать ошибку, мы обернем операцию оператором **try/except**.

**Голые исключения**

Вот еще один способ поймать ошибку:

```sh
>>> try:
        1 / 0
    except:
        print("You cannot divide by zero!")
```
Это **не** рекомендуется! В Python это известно как **"голое исключение"**, , что означает, что будут найдены вообще все исключения. Причина, по которой не рекомендуется так делать, заключается в том, что вы не знаете, какое именно исключение вы отлавливаете. Когда у вас есть что-то вроде **except ZeroDivisionError**, вы, очевидно, пытаетесь поймать ошибку деления на ноль. В коде, написанном выше, вы не можете указать, что именно вам нужно выявить.

Давайте рассмотрим еще несколько примеров.

```sh
>>> my_dict = {"a":1, "b":2, "c":3}
>>> try:
        value = my_dict["d"]
    except KeyError:
        print("That key does not exist!")

That key does not exist!
>>> my_list = [1, 2, 3, 4, 5]
>>> try:
        my_list[6]
    except IndexError:
        print("That index is not in the list!")

That index is not in the list!
```
В первом примере мы создаем словарь из 3 элементов. Затем мы пытаемся получить доступ к ключу, которого нет в словаре. Поскольку ключа нет в словаре, возникает ошибка **KeyError**, которую мы выявляем. Во втором примере показан список длиной 5 элементов. Мы пытаемся взять 7-й объект из индекса. Помните, что списки Python начинаются с нуля поэтому когда вы говорите [6], вы запрашиваете 7-й элемент. В любом случае поскольку элементов всего 5, возникает ошибка **IndexError**, которую мы также выявляем.

Вы также можете поймать несколько исключений с помощью одного оператора. Есть несколько различных способов сделать это. Давайте посмотрим:

```sh
my_dict = {"a":1, "b":2, "c":3}
try:
    value = my_dict["d"]
except IndexError:
    print("This index does not exist!")
except KeyError:
    print("This key is not in the dictionary!")
except:
    print("Some other error occurred!")

```
Это самый стандартный способ выявить несколько исключений. Сначала мы попробовали открыть доступ к несуществующему ключу, которого нет в нашем словаре. При помощи try/except мы проверили код на наличие ошибки KeyError, которая находится во втором операторе **except**. Обратите внимание на то, что в конце кода у нас появилась «голое» исключение. Обычно это не рекомендуется, но вы, вероятно, будете сталкиваться с этим время от времени, поэтому полезно знать об этом. Также обратите внимание, что в большинстве случаев вам не нужно использовать целый блок кода для обработки нескольких исключений. Обычно, целый блок используется для выявления одного единственного исключения.

Вот еще один способ перехвата нескольких исключений:

```sh
try:
    value = my_dict["d"]
except (IndexError, KeyError):
    print("An IndexError or KeyError occurred!")
```
Обратите внимание, что в этом примере мы помещаем ошибки, которые хотим перехватить, внутрь круглых скобок. Проблема этого метода в том, что трудно определить, трудно сказать какая именно ошибка произошла, поэтому рекомендуется использовать предыдущий пример.

В большинстве случаев, когда возникает исключение, необходимо уведомить пользователя, выведя сообщение на экран или записав его в журнал. В зависимости от серьезности ошибки, вам может понадобиться завершить работу программы. Иногда перед выходом из программы необходимо выполнить очистку. Например, если вы открыли соединение с базой данных, вам нужно будет закрыть его, перед выходом из программы, или вы можете закончить с открытым соединением. Другой пример - закрытие дескриптора файла, в который вы записывали данные. Подробнее о работе с файлами вы узнаете в следующей главе. Но сначала нам нужно научиться убирать за собой. Это легко сделать с оператором **finally**.

## Оператор finally

Оператор finally очень прост в использовании. Давайте рассмотрим глупый пример:

```sh
my_dict = {"a":1, "b":2, "c":3}

try:
    value = my_dict["d"]
except KeyError:
    print("A KeyError occurred!")
finally:
    print("The finally statement has executed!")
```
Если вы запустите это код, оно отобразиться и в операторе **except** и в **finally**. Это довольно просто, верно? Теперь вы можете использовать оператор finally, чтобы убрать за собой. В конце оператора **finally** вы также можете поместить код завершения.

## try, except, или else!

Оператор **try/except** также имеет пункт **else**. ОН будет выполняться только в том случае, если не возникнет ошибок. Давайте потратим несколько минут на рассмотрение нескольких примеров:

```sh
кmy_dict = {"a":1, "b":2, "c":3}

try:
    value = my_dict["a"]
except KeyError:
    print("A KeyError occurred!")
else:
    print("No error occurred!")од
```
Мы видим словарь с 3 элементами, и в **try/except** мы обращаемся к существующему ключу. Это работает, поэтому ошибка **KeyError** **не** возникает. Поскольку ошибки нет, **else** выполняется, и на экран выводится сообщение "No error occurred!". Теперь добавим оператор **finally**:

```sh
my_dict = {"a":1, "b":2, "c":3}

try:
    value = my_dict["a"]
except KeyError:
    print("A KeyError occurred!")
else:
    print("No error occurred!")
finally:
    print("The finally statement ran!")
```
Если вы запустите этот пример, он выполнит утверждения **else** и **finally**. В большинстве случаев оператор else не используется, поскольку любой код, следующий за **try/except**, будет выполнен, если не возникло ошибок. Единственное хорошее использование оператора **else**, которое я видел, это когда вы хотите выполнить **вторую** часть кода, которая **также** может вызвать ошибку. Конечно, если ошибка возникнет в **else**, то она не будет поймана.

## Подведение итогов

Теперь вы должны уметь обрабатывать исключения в своем коде. Если вы обнаружите, что ваш код вызывает исключение, вы будете знать, как выявить его таким образом, чтобы поймать ошибку и спокойно выйти или продолжить работу без прерывания.

Теперь мы готовы двигаться дальше и узнать о том, как работать с файлами в Python.
