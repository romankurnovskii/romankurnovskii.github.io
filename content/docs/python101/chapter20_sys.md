# Глава 20 - Модуль sys

Модуль **sys** предоставляет специфические для системы параметры и функции. Мы сузим наше исследование до следующих:

- sys.argv
- sys.executable
- sys.exit
- sys.modules
- sys.path
- sys.platform
- sys.stdin/stdout/stderr

## sys.argv

Значение **sys.argv** - это список аргументов командной строки Python, которые были переданы сценарию Python. Первый аргумент, **argv[0]** - это имя самого сценария Python. В зависимости от платформы, на которой вы работаете, первый аргумент может содержать полный путь к скрипту или только имя файла. Для получения дополнительной информации следует изучить документацию.

Давайте попробуем выполнить несколько примеров, чтобы ознакомиться с этим небольшим инструментом:

```sh
>>> import sys
>>> sys.argv
['']
```

Если вы выполните это в интерпретаторе, то получите список с пустой строкой. Давайте создадим файл с именем "sysargv.py" со следующим содержимым:

```sh
# sysargv.py
import sys

print(sys.argv)
```
Теперь запустите код в IDLE. Вы должны увидеть, что он выведет список с одним элементом, содержащим путь к вашему скрипту. Давайте попробуем передать скрипту несколько аргументов. Откройте терминал / консоль и измените директорию (используйте команду "cd") на ту, где находится ваш скрипт. Затем запустите что-то вроде этого:

![](sys_argv.jpg)

Вы заметите, что он выводит на экран следующее:

```sh
['sysargv.py', '-v', 'somefile.py']
```

Первый аргумент - это имя написанного нами сценария. Следующие два аргумента в списке - это аргументы, которые мы передали нашему скрипту в командной строке.

## sys.executable

Значение **sys.executable** - это абсолютный путь к интерпретатору Python. Это полезно, когда вы используете чужую машину и вам нужно знать, где установлен Python. На некоторых системах эта команда будет неудачной и вернет пустую строку или None. Вот как ее использовать:

```sh
>>> import sys
>>> sys.executable
'C:\\Python27\\pythonw.exe'
```

##sys.exit

Функция **sys.exit()** позволяет разработчику выйти из Python. Функция **exit** принимает необязательный аргумент, обычно целое число, которое выдает статус завершения. Ноль считается "успешным завершением". Обязательно проверьте, имеет ли ваша операционная система какие-либо специальные значения для статусов выхода, чтобы вы могли следовать им в своем приложении. Обратите внимание, что когда вы вызываете **exit**, он вызывает исключение **SystemExit**, что позволяет функциям очистки работать в в **конечных** пунктах блоков **try / except**.

Давайте рассмотрим, как вызвать exit:

```sh
>>> import sys
>>> sys.exit(0)

Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    sys.exit(0)
SystemExit: 0
```

Когда вы запустите этот код в IDLE, вы увидите, что возникла ошибка SystemExit. Давайте создадим несколько сценариев, чтобы проверить это. Сначала нужно создать главный сценарий, программу, которая будет вызывать другой сценарий Python. Назовем его "call_exit.py". Поместите в него следующий код:

```sh
# call_exit.py
import subprocess

code = subprocess.call(["python.exe", "exit.py"])
print(code)
```

Теперь создайте еще один Python-скрипт под названием "exit.py" и сохраните его в той же папке. Поместите в него следующий код:

```sh
import sys

sys.exit(0)
```

Теперь давайте попробуем запустить этот код:

![](call_exit.jpg)

На скриншоте выше видно, что написанный нами сценарий exit вернул ноль, поэтому он был успешно запущен. Вы также узнали, как вызвать другой сценарий Python из самого Python!

## sys.path

Значение **path** модуля sys - это список строк, который определяет путь поиска модулей. По сути, это указывает Python, в каких местах искать модуль, когда он пытается его импортировать. Согласно документации Python, **sys.path** инициализируется из переменной окружения PYTHONPATH, плюс по умолчанию, зависящему от установки. Давайте попробуем:

```sh
>>> import sys
>>> print(sys.path)
['',
'C:\\Python27\\Lib\\idlelib',
'C:\\Python27\\lib\\site-packages\\setuptools-0.9.5-py2.7.egg',
'C:\\Python27\\lib\\site-packages\\pip-1.3.1-py2.7.egg',
'C:\\Python27\\lib\\site-packages\\sphinx-1.2b3-py2.7.egg',
'C:\\Python27\\lib\\site-packages\\docutils-0.11-py2.7.egg',
'C:\\Python27\\lib\\site-packages\\pygments-1.6-py2.7.egg',
'C:\\Windows\\system32\\python27.zip', '
C:\\Python27\\DLLs',
'C:\\Python27\\lib',
'C:\\Python27\\lib\\plat-win',
'C:\\Python27\\lib\\lib-tk',
'C:\\Python27',
'C:\\Python27\\lib\\site-packages',
'C:\\Python27\\lib\\site-packages\\PIL',
'C:\\Python27\\lib\\site-packages\\wx-2.9.4-msw']
```

Данная функция может быть весьма полезной во время отладки причины, по которой модуль не импортируется. Вы также можете изменить путь. Так как данная функция является путем, мы можем добавлять или удалять путь из неё. Давайте взглянем на то, как добавлять путь:

```sh
>>> sys.path.append("/path/to/my/module")
```

Я оставлю удаление пути в качестве упражнения для читателя.

## sys.platform

Значение **sys.platform** - это идентификатор платформы. Вы можете использовать его для добавления модулей для конкретной платформы в **sys.path**, импорта различных модулей в зависимости от платформы или запуска различных частей кода. Давайте посмотрим:

```sh
>>> import sys
>>> sys.platform
'win32'
```

Это говорит нам о том, что Python запущен на машине Windows. Вот пример того, как мы можем использовать эту информацию:

```sh
>>> os = sys.platform
>>> if os == "win32":
        # use Window-related code here
        import _winreg
    elif os.startswith('linux'):
        # do something Linux specific
        import subprocess
        subprocess.Popen(["ls, -l"])
```

Приведенный выше код показывает, как мы можем проверить, используем ли мы определенную операционную систему. Если мы находимся в Windows, мы получим информацию из реестра Window с помощью модуля Python под названием **_winreg**. Если мы находимся в Linux, мы можем выполнить команду **ls**, чтобы получить информацию о каталоге, в котором мы находимся.

## sys.stdin / stdout / stderr

Параметры **stdin, stdout** и **stderr** соответствуют файловым объектам, которые соответствуют стандартным потокам ввода, вывода и ошибок интерпретатора, соответственно. **stdin** используется для всех входных данных интерпретатора, кроме скриптов, в то время как **stdout** используется для вывода операторов ** print** и **expression**. Основная причина, по которой я упоминаю об этом, заключается в том, что иногда вам потребуется перенаправить stdout или stderr или оба потока в файл, например, в журнал или на какой-либо дисплей в созданном вами пользовательском графическом интерфейсе. Вы также можете перенаправить stdin, но я редко видел, чтобы это делалось.

## Подведение итогов

В модуле **sys** есть много других значений и методов. Обязательно посмотрите его в документации Python, раздел 27.1. Вы многому научились в этой главе. Теперь вы знаете, как выйти из программы Python, как получить информацию о платформе, как работать с аргументами, передаваемыми из командной строки, и многое другое. В следующей главе мы узнаем о потоках Python!
