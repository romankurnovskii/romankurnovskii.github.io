---
title: 5. Циклы
description: Python 101
toc: true
authors:
tags:
categories:
series:
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 5
---


В каждом языке программирования, который я пробовал, есть какая-то конструкция циклов. В большинстве из них их больше одного. В мире Python есть два типа циклов:

- цикл **for** и
- цикл **while**


Вы увидите, что цикл **for** является самым популярным. Циклы используются, когда вы хотите сделать что-то много раз. Обычно вам нужно выполнить какую-то операцию или набор операций над фрагментом данных снова и снова. Вот здесь-то и приходят на помощь циклы. С их помощью очень легко применять подобную логику к вашим данным.

Давайте начнем изучать, как работают эти забавные структуры!

## Цикл for

Как упоминалось выше, цикл используется, когда вы хотите выполнить итерацию по чему-либо n-ное количество раз. Это будет немного проще понять, если мы рассмотрим пример. Давайте воспользуемся встроенной в Python функцией **range**. Функция range создаст список длиной n. 

```sh
>>> range(5)
range(0, 5)
```

Как видите, вышеприведенная функция **range** принимает целое число и возвращает объект range. Функция range также принимает начальное значение, конечное значение и значение шага. Вот еще два примера:

```sh
>>> range(5,10)
range(5, 10)
>>> list(range(1, 10, 2))
[1, 3, 5, 7, 9]
```

Первый пример демонстрирует, что вы можете передать начальное и конечное значение, и функция range вернет числа от начального значения до конечного, но не включая его. Таким образом, в случае 5-10 мы получим 5-9. Второй пример показывает, как использовать функцию **list**, чтобы заставить функцию range возвращать каждый второй элемент от 1 до 10. Таким образом, она начинает с единицы, пропускает два и т.д. Теперь вам, наверное, интересно, какое отношение это имеет к циклам. Один из простых способов показать, как работает цикл, - это использовать функцию range! Посмотрите:

```sh
>>> for number in range(5):
       print(number)

0
1
2
3
4
```

Что здесь произошло? Давайте прочитаем слева направо, чтобы понять это. Для каждого числа в диапазоне 5 выведите это число. Мы знаем, что если вызвать range со значением 5, то он вернет список из 5 элементов. Поэтому каждый раз, проходя через цикл, он выводит каждый из элементов. Приведенный выше цикл for был бы эквивалентен следующему:


```sh
>>> for number in [0, 1, 2, 3, 4]:
       print(number)
```

Функция range просто делает его немного меньше. Цикл for может выполнять цикл над любым итератором Python. Мы уже видели, как он может выполнять итерацию над списком. Давайте посмотрим, может ли он также выполнять итерацию над словарем

```sh
>>> a_dict = {"one":1, "two":2, "three":3}
>>> for key in a_dict:
       print(key)

three
two
one
```

Когда вы используете цикл **for** со словарем, вы увидите, что он автоматически перебирает ключи. Нам не нужно было говорить **for key в a_dict.keys()** (хотя это тоже сработало бы). Python просто сделал все правильно за нас. Вам возможно интересно, почему ключи выводятся в другом порядке, чем они были определены в словаре. Как вы помните из главы 3, словари неупорядочены, поэтому при итерации по ним ключи могут располагаться в любом порядке.

Теперь, если вы знаете, что ключи можно отсортировать, вы можете сделать это до того, как начнете итерацию по ним. Давайте немного изменим словарь, чтобы посмотреть, как это работает.

```sh
>>> a_dict = {1:"one", 2:"two", 3:"three"}
>>> keys = a_dict.keys()
>>> keys = sorted(keys)
>>> for key in keys:
       print(key)

1
2
3
```

Давайте немного разберемся, что делает этот код. Во-первых, мы создаем словарь, в котором ключами являются целые числа, а не строки. Затем мы извлекаем ключи из словаря. Каждый раз, когда вы вызываете метод keys(), он возвращает неупорядоченный список ключей. Если вы выведите их и обнаружите, что они расположены в порядке возрастания, то это просто случайность. Теперь у нас есть представление ключей словаря, которые хранятся в переменной **keys**. Мы сортируем ее, а затем с помощью цикла **for** перебираем ее.

Теперь мы готовы сделать все немного интереснее. Мы собираемся перебирать диапазон, но хотим вывести только четные числа. Для этого мы хотим использовать условный оператор вместо параметра step диапазона. Вот один из способов сделать это:

```sh
>>> for number in range(10):
        if number % 2 == 0:
            print(number)

0
2
4
6
8
```

Вы, вероятно, задаетесь вопросом, что здесь происходит. Что случилось со знаком процента? В Python знак % называется оператором модуляции. Когда вы используете оператор модуляции, он возвращает остаток. При делении четного числа на два остатка нет, поэтому мы выводим эти числа. Вы, скорее всего, не будете часто использовать оператор modulus, но я думаю он может быть полезным время от времени.

Теперь мы готовы к изучению цикла **while**.

## Цикл while

Цикл while также используется для повторения участков кода, но вместо того, чтобы повторять цикл n раз, он будет повторяться только до тех пор, пока не будет выполнено определенное условие. Давайте рассмотрим очень простой пример:

```sh
>>> i = 0
>>> while i < 10:
        print(i)
        i = i + 1
```

Цикл while - это что-то вроде условного оператора. Вот что означает этот код: пока переменная i меньше десяти, выведите это значение. Затем в конце мы увеличиваем значение i на единицу. Если вы запустите этот код, он должен вывести 0-9, каждый на своей строке, а затем остановиться. Если вы удалите ту часть, где мы увеличиваем значение i, то в итоге у вас получится бесконечный цикл. Это обычно плохо. Бесконечных циклов следует избегать, они известны как логические ошибки.

Существует другой способ выйти из цикла. Использованием встроенной функции **break**. Давайте посмотрим, как это работает:

```sh
>>> while i < 10:
        print(i)
        if i == 5:
            break
        i += 1

0
1
2
3
4
5
```

В этом фрагменте кода мы добавляем условие, чтобы проверить, равна ли переменная i 5 когда-либо. Если да, то мы выходим из цикла. Как видно из примера вывода, как только значение i достигает 5, код останавливается, несмотря на то, что мы сказали циклу while продолжать цикл, пока значение не достигнет 10. Вы также заметите, что мы изменили способ увеличения значения, использовав **+=**. Это удобное сокращение, которое можно использовать и для других математических операций, таких как вычитание (-=) и умножение (*=).

Встроенная функция break известна как **инструмент управления потоком**. Есть еще одна, называемая **continue**, которая используется для пропуска итерации или продолжения следующей итерации. Вот один из способов её использования:

```sh
i = 0

while i < 10:
    if i == 3:
        i += 1
        continue

    print(i)

    if i == 5:
        break
    i += 1
```

Немного запутано, не так ли? По сути, мы добавили второе условие, которое проверяет, равно ли i 3. Если да, то мы увеличиваем переменную и продолжаем следующий цикл, который фактически пропускает вывод значения 3 на экран. Как и раньше, когда мы достигаем значения 5, мы выходим из цикла.

Есть еще одна тема, которую мы должны рассмотреть в отношении циклов, и это оператор **else**.

## Для чего нужно else в циклах

Оператор else в циклах выполняется только в случае успешного завершения цикла. В основном оператор else используется для поиска элементов:


```sh
my_list = [1, 2, 3, 4, 5]

for i in my_list:
    if i == 3:
        print("Item found!")
        break
    print(i)
else:
    print("Item not found!")
```

В этом коде мы выходим из цикла, когда i становится равным 3. В результате оператор else будет пропущен. Если вы хотите поэкспериментировать, вы можете изменить условие так, чтобы оно искало значение, которого нет в списке, что приведет к выполнению оператора else. Честно говоря, за все годы работы программистом я ни разу не видел, чтобы кто-то использовал эту структуру. Большинство примеров, которые я видел, это блоггеры, пытающиеся объяснить, для чего она используется. Я видел несколько примеров, когда она используется для выдачи ошибки, если элемент не найден в итерабельной таблице, где был поиск. Вы можете прочитать довольно подробную статью одного из разработчиков ядра Python [здесь](https://ncoghlan_devs-python-notes.readthedocs.org/en/latest/python_concepts/break_else.html).

## Подведение итогов

Надеюсь, теперь вы видите ценность циклов Python. Они упрощают повторение и довольно просты для понимания. Скорее всего, вы будете видеть цикл **for** гораздо чаще, чем цикл **while**. На самом деле, мы рассмотрим еще один способ использования цикла **for** в следующей главе, когда будем изучать генераторы! Если вы все еще не совсем понимаете, как все работает, возможно, вам стоит перечитать эту главу, прежде чем продолжать.
