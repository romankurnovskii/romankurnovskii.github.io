---
title: 18. Модуль sqlite
description: Python 101
toc: true
authors:
tags:
categories:
series:
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 18
---

**SQLite** - это самодостаточный, безсерверный, безконфигурационный транзакционный движок базы данных SQL. Python получил модуль **sqlite3** еще в версии 2.5, что означает, что вы можете создавать базы данных SQLite с любым текущим Python без загрузки дополнительных зависимостей. Mozilla использует базы данных SQLite в своем популярном браузере Firefox для хранения закладок и другой различной информации. В этой главе вы узнаете следующее:

    - Как создать базу данных SQLite
    - Как вставить данные в таблицу
    - Как редактировать данные
    - Как удалить данные
    - Основные SQL-запросы

Другими словами, вместо того, чтобы рассказывать о модуле **sqlite3** по кусочкам, мы рассмотрим, как его реально использовать.

Если вы хотите осмотреть свою базу данных визуально, вы можете использовать плагин SQLite Manager для Firefox (просто найдите его в Google) или, если вам нравится командная строка, вы можете использовать оболочку командной строки SQLite.

## Как создать базу данных и вставить некоторые данные

Создать базу данных в SQLite очень просто, но для этого нужно знать немного SQL. Вот код, который создаст базу данных для хранения музыкальных альбомов:

```sh
import sqlite3

conn = sqlite3.connect("mydatabase.db") # or use :memory: to put it in RAM

cursor = conn.cursor()

# create a table
cursor.execute("""CREATE TABLE albums
                  (title text, artist text, release_date text,
                   publisher text, media_type text)
               """)
```

Сначала мы должны импортировать модуль **sqlite3** и создать соединение с базой данных. Вы можете передать ему путь к файлу, имя файла или просто использовать специальную строку ":memory:" для создания базы данных в памяти. В нашем случае мы создали ее на диске в файле под названием **mydatabase.db**. Далее мы создаем объект курсора, который позволяет взаимодействовать с базой данных и добавлять записи, среди прочего. Здесь мы используем синтаксис SQL для создания таблицы с именем **albums** с 5 текстовыми полями: title, artist, release_date, publisher и media_type. SQLite поддерживает только пять **типов данных**: null, integer, real, text и blob. Давайте построим этот код и вставим некоторые данные в нашу новую таблицу!

**Примечание: Если вы выполните команду CREATE TABLE, а база данных уже существует, вы получите сообщение об ошибке.**


```sh
# insert some data
cursor.execute("""INSERT INTO albums
                  VALUES ('Glow', 'Andy Hunter', '7/24/2012',
                          'Xplore Records', 'MP3')"""
               )

# save data to database
conn.commit()

# insert multiple records using the more secure "?" method
albums = [('Exodus', 'Andy Hunter', '7/9/2002', 'Sparrow Records', 'CD'),
          ('Until We Have Faces', 'Red', '2/1/2011', 'Essential Records', 'CD'),
          ('The End is Where We Begin', 'Thousand Foot Krutch', '4/17/2012', 'TFKmusic', 'CD'),
          ('The Good Life', 'Trip Lee', '4/10/2012', 'Reach Records', 'CD')]
cursor.executemany("INSERT INTO albums VALUES (?,?,?,?,?)", albums)
conn.commit()

```

Здесь мы используем команду INSERT INTO SQL для вставки записи в нашу базу данных. Обратите внимание, что каждый элемент должен быть заключен в одинарные кавычки. Это может усложниться, если вам нужно вставить строки, содержащие одинарные кавычки. В любом случае, чтобы сохранить запись в базе данных, мы должны **создать** ее. Следующий фрагмент кода показывает, как добавить сразу несколько записей с помощью метода **executemany** курсора. Обратите внимание, что мы используем вопросительные знаки (?) вместо подстановки строк (%s) для вставки значений.  Обратите внимание, что использование строки замещения НЕ безопасно, так как может стать причиной появления атаки инъекций SQL . Метод вопросительных знаков намного лучше, а использование SQLAlchemy еще лучше, потому что он делает все экранирование за вас, и вам не придется возиться с преобразованием встроенных одинарных кавычек в то, что примет SQLite.

## Обновление и удаление записей

Возможность обновления записей в базе данных является ключевым условием сохранения точности данных. Если вы не можете обновлять записи, то ваши данные быстро устареют и станут бесполезными. Иногда вам также необходимо удалять строки из данных. В этом разделе мы рассмотрим обе эти темы. Для начала, давайте выполним обновление!

```sh
import sqlite3

conn = sqlite3.connect("mydatabase.db")
cursor = conn.cursor()

sql = """
UPDATE albums
SET artist = 'John Doe'
WHERE artist = 'Andy Hunter'
"""
cursor.execute(sql)
conn.commit()
```

Здесь мы используем команду SQL **UPDATE** для обновления таблицы альбомов. Вы можете использовать **SET** для изменения поля, поэтому в данном случае мы изменим поле artist на John Doe в любой записи **WHERE**, поле artist установлено на Andy Hunter. Разве это не просто? Обратите внимание, что если вы не зафиксируете изменения, то ваши изменения не будут записаны в базу данных. Команда **DELETE** почти так же проста. Давайте проверим это!


```sh
import sqlite3

conn = sqlite3.connect("mydatabase.db")
cursor = conn.cursor()

sql = """
DELETE FROM albums
WHERE artist = 'John Doe'
"""
cursor.execute(sql)
conn.commit()
```

Удаление даже проще, чем обновление. SQL состоит всего из 2 строк! В данном случае все, что нам нужно было сделать, это указать SQLite, из какой таблицы удалять (альбомы) и какие записи удалять с помощью предложения WHERE. Таким образом, он искал все записи, у которых в поле artist было указано "John Doe", и удалял их.

## Основные запросы в SQLite

Запросы в SQLite практически не отличаются от тех, которые вы используете для других баз данных, таких как MySQL или Postgres. Вы просто используете обычный синтаксис SQL для выполнения запросов, а затем заставляете объект курсора выполнить SQL. Вот несколько примеров:

```sh
import sqlite3

conn = sqlite3.connect("mydatabase.db")
#conn.row_factory = sqlite3.Row
cursor = conn.cursor()

sql = "SELECT * FROM albums WHERE artist=?"
cursor.execute(sql, [("Red")])
print(cursor.fetchall())  # or use fetchone()

print("\nHere's a listing of all the records in the table:\n")
for row in cursor.execute("SELECT rowid, * FROM albums ORDER BY artist"):
    print(row)

print("\nResults from a LIKE query:\n")
sql = """
SELECT * FROM albums
WHERE title LIKE 'The%'"""
cursor.execute(sql)
print(cursor.fetchall())
```

Первый запрос, который мы выполняем, это SELECT *, что означает, что мы хотим выбрать все записи, которые соответствуют имени исполнителя, которое мы вводим, в данном случае это **"Red"**. Далее мы выполняем SQL и используем **fetchall()**, чтобы вернуть все результаты. Вы также можете использовать **fetchone()**, чтобы получить первый результат. Вы также заметите, что здесь есть закомментированная секция, связанная с таинственным **row_factory**. Если вы уберете эту строку из комментария, результаты будут возвращаться в виде объектов Row, которые подобны словарям Python и дают вам доступ к полям строки, как словарь. Однако вы не можете выполнять присваивание элементов с объектом Row.

Второй запрос очень похож на первый, но он возвращает все записи в базе данных и упорядочивает результаты по имени исполнителя в порядке возрастания. Здесь также показано, как мы можем перебирать результаты в цикле. Последний запрос показывает, как использовать команду LIKE в SQL для поиска частичных фраз. В данном случае мы выполняем поиск по всей таблице названий, которые начинаются со слова "The". Знак процента (%) является оператором подстановки.

## Подведение итогов

Теперь вы знаете, как использовать Python для создания базы данных SQLite. Вы можете создавать, обновлять и удалять записи, а также выполнять запросы к базе данных.
