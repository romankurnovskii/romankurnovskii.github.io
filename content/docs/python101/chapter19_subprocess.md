# Глава 19 - Модуль subprocess

Модуль **subprocess** дает разработчику возможность запускать процессы или программы из Python. Другими словами, вы можете запускать приложения и передавать им аргументы с помощью модуля subprocess. Модуль subprocess был добавлен в Python 2.4, чтобы заменить модули **os**, состоящие из os.popen, os.spawn и os.system, а также заменить popen2 и старый модуль **commands**. Мы рассмотрим следующие аспекты модуля subprocess:

    - функция вызова
    - класс Popen
    - как взаимодействовать с порожденным процессом.

    Давайте начнем!

## Функция вызова call

Модуль subprocess предоставляет функцию **call**. Эта функция позволяет вам вызвать другую программу, дождаться завершения команды и затем вернуть код возврата. Она принимает один или несколько аргументов, а также следующие ключевые аргументы (с их значениями по умолчанию): stdin=None, stdout=None, stderr=None, shell=False.

Рассмотрим простой пример:

```sh
>>> import subprocess
>>> subprocess.call("notepad.exe")
0
```

Если вы запустите эту программу на машине под управлением Windows, вы увидите, что открылся блокнот. Вы заметите, что IDLE ждет, пока вы закроете Блокнот, а затем возвращает код ноль (0). Это означает, что программа завершилась успешно. Если вы получаете что-либо, кроме нуля, то это обычно означает, что произошла какая-то ошибка.

Обычно, когда вы вызываете эту функцию, вы хотите присвоить полученный код возврата переменной, чтобы вы могли проверить, соответствует ли результат ожиданию. Давайте сделаем это:

```sh
>>> code = subprocess.call("notepad.exe")
>>> if code == 0:
        print("Success!")
    else:
        print("Error!")
Success!
```

Если вы запустите этот код, вы увидите, что он выводит на экран сообщение **Success!**. Метод **call** также принимает аргументы для передачи в выполняемую программу. Давайте посмотрим, как это работает:

```sh
>>> code = subprocess.call(["ping", "www.yahoo.com"])

Pinging ds-any-fp3-real.wa1.b.yahoo.com [98.139.180.149] with 32 bytes of data:
Reply from 98.139.180.149: bytes=32 time=66ms TTL=45
Reply from 98.139.180.149: bytes=32 time=81ms TTL=45
Reply from 98.139.180.149: bytes=32 time=81ms TTL=45
Reply from 98.139.180.149: bytes=32 time=69ms TTL=45

Ping statistics for 98.139.180.149:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 66ms, Maximum = 81ms, Average = 74ms
>>> code
0
```

Обратите внимание, что в этом примере мы передаем список аргументов. Первый элемент в списке - это программа, которую мы хотим вызвать. Все остальное в списке - это аргументы, которые мы хотим передать этой программе. Итак, в этом примере мы выполняем команду ping для сайта Yahoo. Вы заметите, что код возврата равен нулю, так что все завершилось успешно.

Вы также можете выполнить программу с помощью оболочки операционной системы. Это добавляет уровень абстракции к процессу и повышает вероятность возникновения проблем с безопасностью. Вот официальное предупреждение документации Python по этому вопросу:

**Выполнение необработанных вводных данных из ненадежного источника делает программу уязвимой для внедрений в оболочку, что является серьезным недостатком безопасности, который может привести к произвольному исполнению команд. По этой причине, применение shell=True настоятельно не рекомендуется в случаях, когда командная строка создана во внешнем входе.**

Обычная рекомендация - не использовать его, если внешний процесс или человек может изменить аргументы вызова. Если вы сами что-то жестко кодируете, то это не так важно.

## Класс Popen

Класс **Popen** выполняет дочернюю программу в новом процессе. В отличие от метода call, он не ждет завершения вызванного процесса, если вы не попросите его об этом с помощью метода **wait**. Давайте попробуем запустить Notepad через Popen и посмотрим, в чем разница:

```sh
>>> program = "notepad.exe"
>>> subprocess.Popen(program)
<subprocess.Popen object at 0x01EE0430>
```

Здесь мы создаем переменную **program** и присваиваем ей значение "notepad.exe". Затем мы передаем ее классу Popen. Когда вы запустите эту программу, вы увидите, что она немедленно возвращает объект **subprocess.Popen** и вызванное приложение выполняется. Давайте заставим Popen ждать завершения работы программы:

```sh
>>> program = "notepad.exe"
>>> process = subprocess.Popen(program)
>>> code = process.wait()
>>> print(code)
0
```

Когда вы делаете это в IDLE, блокнот всплывает и может оказаться перед сеансом IDLE. Просто уберите блокнот с дороги, но не закрывайте его!  Вам нужно указать вашему процессу подождать, пока вы не получите код возврата. После того, как вы впишете эту строку, закройте блокнот и впишите код. Или вы можете просто поместить весь этот код в сохраненный файл Python и запустить его.

Обратите внимание на то, что использование метода **wait** может вызвать блокировку дочернего процесса при использовании команды stdout/stderr=PIPE, когда процесс генерирует достаточно выходных данных для блокировки pipe Для облегчения этой ситуации можно использовать метод **communicate**. Мы рассмотрим этот метод в следующем разделе.

Теперь давайте попробуем запустить Popen, используя несколько аргументов:

```sh
>>> subprocess.Popen(["ls", "-l"])
<subprocess.Popen object at 0xb7451001>
```

Если вы запустите этот код в Linux, вы увидите возникшее сообщение объекта Popen, затем перечень разрешений и содержимого той или иной папки, которую вы используете. Вы можете использовать аргумент shell совместно с Popen, но с теми же предостережениями, что и с методом call.

## Обучение общению

Существует несколько способов взаимодействия с процессом, который вы вызвали. Мы остановимся на том, как использовать метод **communicate** модуля subprocess. Давайте посмотрим:

```sh
args = ["ping", "www.yahoo.com"]
process = subprocess.Popen(args,
                           stdout=subprocess.PIPE)

data = process.communicate()
print(data)
```

В этом примере кода мы создаем переменную **args** для хранения нашего списка аргументов. Затем мы перенаправляем стандартный выход (stdout) на наш subprocess, чтобы мы могли общаться с ним. Сам метод **communicate** позволяет нам общаться с процессом, который мы только что создали. На самом деле мы можем передавать процессу входные данные с помощью этого метода. Но в нашем примере, мы используем этот метод для чтения stdout. Обратите внимание на то, что когда вы запускаете этот код, цель которого – поддержка связи, он будет дожидаться финиша процесса, После чего выдаст кортеж, состоящий из двух элементов, которые являются содержимым stdout и stderr. Вот результат:

```sh
('Pinging ds-any-fp3-real.wa1.b.yahoo.com [98.139.180.149] with 32 bytes of data:
Reply from 98.139.180.149: bytes=32 time=139ms TTL=45
Reply from 98.139.180.149: bytes=32 time=162ms TTL=45
Reply from 98.139.180.149: bytes=32 time=164ms TTL=45
Reply from 98.139.180.149: bytes=32 time=110ms TTL=45
Ping statistics for 98.139.180.149:
Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
Minimum = 110ms, Maximum = 164ms, Average = 143ms
', None)

```

Это довольно некрасиво. Давайте заставим его вывести результат в более читабельном формате?

```sh
import subprocess

args = ["ping", "www.yahoo.com"]
process = subprocess.Popen(args, stdout=subprocess.PIPE)

data = process.communicate()
for line in data:
    print(line)
```

Если вы запустите этот код, на экране должно появиться нечто похожее на следующее:

```sh
Pinging ds-any-fp3-real.wa1.b.yahoo.com [98.139.180.149] with 32 bytes of data:
Reply from 98.139.180.149: bytes=32 time=67ms TTL=45
Reply from 98.139.180.149: bytes=32 time=68ms TTL=45
Reply from 98.139.180.149: bytes=32 time=70ms TTL=45
Reply from 98.139.180.149: bytes=32 time=69ms TTL=45

Ping statistics for 98.139.180.149:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 67ms, Maximum = 70ms, Average = 68ms

None
```
Последняя строка, в которой написано "None", является результатом stderr, что означает, что ошибок не было.

##Подведение итогов

На данный момент у вас есть знания, позволяющие эффективно использовать модуль subprocess. Вы можете открыть процесс двумя различными способами, знаете, как дождаться кода возврата, и знаете, как взаимодействовать с созданным вами дочерним процессом.

В следующей главе мы рассмотрим модуль **sys**.
