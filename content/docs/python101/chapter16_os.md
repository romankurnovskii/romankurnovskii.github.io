# Глава 16 - Модуль os

Модуль os имеет множество применений. Мы не будем рассматривать все его возможности. Вместо этого мы получим обзор его возможностей, а также рассмотрим один из его подмодулей, известный как **os.path**. В частности, мы рассмотрим следующее:

- os.name
- os.environ
- os.chdir()
- os.getcwd()
- os.getenv()
- os.putenv()
- os.mkdir()
- os.makedirs()
- os.remove()
- os.rename()
- os.rmdir()
- os.startfile()
- os.walk()
- os.path

Кажется, что этого очень много, но существует примерно в десять раз больше других действий, которые может выполнять модуль os. В этой главе мы просто дадим вам небольшое представление о том, что доступно. Чтобы использовать любой из методов, упомянутых в этом разделе, вам нужно импортировать модуль **os**, как показано ниже:

```sh
import os
```

Давайте начнем изучать, как использовать этот модуль!

## os.name

Модуль os имеет как вызываемые функции, так и обычные значения. В случае с os.name это просто значение. Когда вы обращаетесь к os.name, вы получите информацию о том, на какой платформе вы работаете. Вы увидите одно из следующих значений: 'posix', 'nt', 'os2', 'ce', 'java', 'riscos'. Давайте посмотрим, что мы получим при запуске на Windows 7:


```sh
>>> import os
>>> os.name
'nt'
```

Это говорит нам о том, что наш экземпляр Python запущен на компьютере под управлением Windows. Откуда мы это знаем? Потому что Microsoft начала называть свою операционную систему NT много лет назад. Например, Windows 7 также известна как Windows NT 6.1.

## os.environ, os.getenv() и os.putenv()

Значение **os.environ** известно как объект **mapping**, который возвращает словарь переменных окружения пользователя. Вы можете этого не знать, но каждый раз, когда вы используете свой компьютер, устанавливаются некоторые переменные окружения. Они могут дать вам ценную информацию, например, количество процессоров, тип ЦП, имя компьютера и т.д. Давайте посмотрим, что мы можем узнать о нашей машине:

```sh
>>> import os
>>> os.environ
{'ALLUSERSPROFILE': 'C:\\ProgramData',
 'APPDATA': 'C:\\Users\\mike\\AppData\\Roaming',
 'CLASSPATH': '.;C:\\Program Files\\QuickTime\\QTSystem\\QTJava.zip',
 'COMMONPROGRAMFILES': 'C:\\Program Files\\Common Files',
 'COMPUTERNAME': 'MIKE-PC',
 'COMSPEC': 'C:\\Windows\\system32\\cmd.exe',
 'FP_NO_HOST_CHECK': 'NO',
 'HOMEDRIVE': 'C:',
 'HOMEPATH': '\\Users\\mike',
 'LOCALAPPDATA': 'C:\\Users\\mike\\AppData\\Local',
 'LOGONSERVER': '\\\\MIKE-PC',
 'NUMBER_OF_PROCESSORS': '2',
 'OS': 'Windows_NT',
 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC',
 'PROCESSOR_ARCHITECTURE': 'x86',
 'PROCESSOR_IDENTIFIER': 'x86 Family 6 Model 15 Stepping 13, GenuineIntel',
 'PROCESSOR_LEVEL': '6',
 'PROGRAMDATA': 'C:\\ProgramData',
 'PROGRAMFILES': 'C:\\Program Files',
 'PSMODULEPATH': 'C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\',
 'PUBLIC': 'C:\\Users\\Public',
 'PYTHONIOENCODING': 'cp437',
 'QTJAVA': 'C:\\Program Files\\QuickTime\\QTSystem\\QTJava.zip',
 'SESSIONNAME': 'Console',
 'SYSTEMDRIVE': 'C:',
 'SYSTEMROOT': 'C:\\Windows',
 'TEMP': 'C:\\Users\\mike\\AppData\\Local\\Temp',
 'TMP': 'C:\\Users\\mike\\AppData\\Local\\Temp',
 'USERDOMAIN': 'mike-PC',
 'USERNAME': 'mike',
 'USERPROFILE': 'C:\\Users\\mike',
 'VBOX_INSTALL_PATH': 'C:\\Program Files\\Oracle\\VirtualBox\\',
 'VS90COMNTOOLS': 'C:\\Program Files\\Microsoft Visual Studio 9.0\\Common7\\Tools\\',
 'WINDIR': 'C:\\Windows',
 'WINDOWS_TRACING_FLAGS': '3',
 'WINDOWS_TRACING_LOGFILE': 'C:\\BVTBin\\Tests\\installpackage\\csilogfile.log',
 'WINGDB_ACTIVE': '1',
 'WINGDB_PYTHON': 'c:\\python27\\python.exe',
 'WINGDB_SPAWNCOOKIE': 'rvlxwsGdD7SHYIJm'}

```

Ваш результат не будет таким же, как у меня, поскольку конфигурация ПК у всех немного отличается, но вы увидите нечто похожее. Как вы могли заметить, это возвращает словарь. Значит, вы можете получить доступ к переменным окружения, используя обычные методы работы со словарями. Вот пример:

```sh
>>> print(os.environ["TMP"])
'C:\\Users\\mike\\AppData\\Local\\Temp'
```

Вы также можете использовать функцию **os.getenv** для доступа к этой переменной среды:

```sh
>>> os.getenv("TMP")
'C:\\Users\\mike\\AppData\\Local\\Temp'
```

Преимущество использования os.getenv() вместо словаря os.environ заключается в том, что если вы попытаетесь получить доступ к несуществующей переменной окружения, функция getenv просто вернет None. Если бы вы сделали то же самое с os.environ, то получили бы ошибку. Давайте попробуем это сделать, чтобы вы могли увидеть, что произойдет:

```sh
>>> os.environ["TMP2"]
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    os.environ["TMP2"]
  File "C:\Python27\lib\os.py", line 423, in __getitem__
    return self.data[key.upper()]
KeyError: 'TMP2'

>>> print(os.getenv("TMP2"))
None
```
## os.chdir() и os.getcwd()

Функция **os.chdir** позволяет нам изменить каталог, в котором в данный момент запущена наша сессия Python. Если вы хотите узнать, в каком каталоге вы сейчас находитесь, то вызовите **os.getcwd()**. Давайте попробуем использовать обе функции:

```sh
>>> os.getcwd()
'C:\\Python27'
>>> os.chdir(r"c:\Users\mike\Documents")
>>> os.getcwd()
'c:\\Users\\mike\\Documents'
```

Код выше показывает нам, что мы начали работу в каталоге Python по умолчанию, когда мы запускаем этот код в IDLE. Затем мы меняем папки с помощью **os.chdir()**. Наконец, мы вызываем os.getcwd() во второй раз, чтобы убедиться, что мы успешно перешли в папку.

## os.mkdir() и os.makedirs()

Возможно, вы уже догадались, но два метода, рассматриваемые в этом разделе, используются для создания каталогов. Первый из них - **os.mkdir()**, который позволяет нам создать одну папку. Давайте попробуем это сделать:

```sh
>>> os.mkdir("test")
>>> path = r'C:\Users\mike\Documents\pytest'
>>> os.mkdir(path
```

Первая строка кода создаст папку с именем **test** в текущем каталоге. Вы можете использовать методы из предыдущего раздела, чтобы выяснить, куда вы только что запустили свой код, если забыли. Во втором примере путь присваивается переменной, а затем мы передаем путь в os.mkdir(). Это позволяет вам создать папку в любом месте вашей системы, на которое у вас есть права.

Функция **os.makedirs()** создаст все промежуточные папки в пути, если они еще не существуют. В принципе, это означает, что вы можете создать путь, содержащий вложенные папки. Я часто так делаю, когда создаю файл журнала, который находится в датированной структуре папок, например, Год/Месяц/День. Давайте рассмотрим пример:

```sh
>>> path = r'C:\Users\mike\Documents\pytest\2014\02\19'
>>> os.makedirs(path)
```

Что здесь произошло? Этот код просто создал кучу папок! Если в вашей системе все еще была папка **pytest**, то она просто добавила папку **2014** с другой папкой внутри, которая также содержала папку. Попробуйте сделать это сами, используя правильный путь в вашей системе.

## os.remove() и os.rmdir()

Функции **os.remove()** и **os.rmdir()** используются для удаления файлов и каталогов соответственно. Давайте рассмотрим пример работы **os.remove()**:

```sh
>>> os.remove("test.txt")
```

Этот фрагмент кода попытается удалить файл с именем **test.txt** из текущего рабочего каталога. Если он не сможет найти файл, вы, скорее всего, получите какую-либо ошибку. Вы также получите ошибку, если файл используется (т.е. заблокирован) или у вас нет разрешения на удаление файла. Возможно, вы также захотите проверить **os.unlink**, который делает то же самое. Термин **unlink** - это традиционное название этой процедуры в Unix.

Теперь давайте рассмотрим пример **os.rmdir()**:

```sh
>>> os.rmdir("pytest")
```

Приведенный выше код попытается удалить каталог с именем **pytest** из текущего рабочего каталога. Если попытка успешна, вы увидите, что каталог больше не существует. Если каталог не существует, у вас нет разрешения на его удаление или каталог не пуст, будет выдана ошибка. Возможно, вы также захотите взглянуть на **os.removedirs()**, которая может рекурсивно удалять вложенные пустые каталоги.

## os.rename(src, dst)

Функция os.rename() переименовывает файл или папку. Давайте рассмотрим пример переименования файла:

```sh
>>> os.rename("test.txt", "pytest.txt")
```

В этом примере мы говорим **os.rename** переименовать файл с именем **test.txt** в **pytest.txt**. Это происходит в нашем текущем рабочем каталоге. Вы увидите ошибку, если попытаетесь переименовать несуществующий файл или если у вас нет соответствующего разрешения на переименование файла.

Существует также функция **os.renames**, которая рекурсивно переименовывает каталог или файл.

## os.startfile()

Метод **os.startfile()** позволяет нам "запустить" файл с помощью связанной с ним программы. Другими словами, мы можем открыть файл с помощью связанной с ним программы, как если бы вы дважды щелкнули по PDF-файлу, и он открылся бы в Adobe Reader. Давайте попробуем!

```sh
>>> os.startfile(r'C:\Users\mike\Documents\labels.pdf')
```

В приведенном выше примере я передаю **os.startfile** полный путь, который указывает ему открыть файл под названием **labels.pdf**. На моей машине это приведет к открытию PDF в Adobe Reader. Вы должны попробовать открыть свои собственные PDF, MP3 и фотографии с помощью этого метода, чтобы увидеть, как он работает.

## os.walk()

Метод os.walk() дает нам способ итерации по пути корневого уровня. Это означает, что мы можем передать путь в эту функцию и получить доступ ко всем его подкаталогам и файлам. Давайте воспользуемся одной из папок Python, которые у нас есть под рукой, чтобы протестировать эту функцию. Мы будем использовать: C:\Python27\Tools

```sh
>>> path = r'C:\Python27\Tools'
>>> for root, dirs, files in os.walk(path):
        print(root)

C:\Python27\Tools
C:\Python27\Tools\i18n
C:\Python27\Tools\pynche
C:\Python27\Tools\pynche\X
C:\Python27\Tools\Scripts
C:\Python27\Tools\versioncheck
C:\Python27\Tools\webchecker
```

При желании можно также перебирать **dirs** и **files**. Вот один из способов сделать это:

```sh
>>> for root, dirs, files in os.walk(path):
        print(root)
        for _dir in dirs:
            print(_dir)
        for _file in files:
            print(_file)
```

Этот фрагмент кода выведет много информации, поэтому я не буду показывать его вывод здесь, но не стесняйтесь попробовать. Теперь мы готовы к изучению работы с путями!

## os.path

Подмодуль **os.path** модуля **os** имеет множество замечательных функций, встроенных в него. Мы рассмотрим следующие функции:

    - basename
    - exists
    - isdir и isfile
    - join
    - split

В этом подмодуле есть много других функций. Вы можете прочитать о них в документации Python, раздел 10.1.

## os.path.basename

Функция **basename** возвращает только имя файла пути. Вот пример:


```sh
>>> os.path.basename(r'C:\Python27\Tools\pynche\ChipViewer.py')
'ChipViewer.py'
```

Это полезно, когда мне нужно использовать имя файла для именования какого-либо связанного файла, например, файла лога. Это часто случается, когда я обрабатываю файл данных.

## os.path.dirname

Функция **dirname** возвращает только часть пути, связанную с каталогом. Это легче понять, если мы посмотрим на некоторый код:

```sh
>>> os.path.dirname(r'C:\Python27\Tools\pynche\ChipViewer.py')
'C:\\Python27\\Tools\\pynche'
```

В этом примере мы просто получаем путь к каталогу. Это также полезно, когда вы хотите сохранить другие файлы рядом с обрабатываемым файлом, например, вышеупомянутый файл лога.

## os.path.exists

Функция **exists** сообщит вам, существует ли путь или нет. Все, что вам нужно сделать, это передать ей путь. Давайте посмотрим:

```sh
>>> os.path.exists(r'C:\Python27\Tools\pynche\ChipViewer.py')
True
>>> os.path.exists(r'C:\Python27\Tools\pynche\fake.py')
False
```

В первом примере мы передаем функции **exists** реальный путь, и она возвращает **True**, что означает, что путь существует. Во втором примере мы передали ей плохой путь, и она сообщила нам, что путь не существует, вернув **False**.

## os.path.isdir / os.path.isfile

Методы **isdir** и **isfile** тесно связаны с методом **exists** тем, что они также проверяют существование. Однако **isdir** проверяет только, является ли путь каталогом, а **isfile** - только, является ли путь файлом. Если вы хотите проверить, существует ли путь независимо от того, является ли он файлом или каталогом, то вам нужно использовать метод **exists**. В любом случае, давайте рассмотрим несколько примеров:

```sh
>>> os.path.isfile(r'C:\Python27\Tools\pynche\ChipViewer.py')
True
>>> os.path.isdir(r'C:\Python27\Tools\pynche\ChipViewer.py')
False
>>> os.path.isdir(r'C:\Python27\Tools\pynche')
True
>>> os.path.isfile(r'C:\Python27\Tools\pynche')
False
```

Уделите немного времени изучению этого набора примеров. В первом примере мы передаем путь к файлу и проверяем, действительно ли этот путь является файлом. Затем во втором примере тот же путь проверяется на то, является ли он каталогом. Вы можете сами посмотреть, что из этого получилось. Затем в последних двух примерах мы немного изменили ситуацию, передав путь к каталогу тем же двум функциям. Эти примеры демонстрируют, как работают эти две функции.

## os.path.join

Метод **join** дает вам возможность соединить один или несколько компонентов пути вместе с помощью соответствующего разделителя. Например, в Windows разделителем является обратная косая черта, а в Linux - прямая косая черта. Вот как это работает:

```sh
>>> os.path.join(r'C:\Python27\Tools\pynche', 'ChipViewer.py')
'C:\\Python27\\Tools\\pynche\\ChipViewer.py'
```

В этом примере мы объединили путь к каталогу и путь к файлу, чтобы получить полностью квалифицированный путь. Обратите внимание, что метод join не проверяет, существует ли результат!

## os.path.split

Метод **split** разбивает путь на кортеж, содержащий каталог и файл. Давайте посмотрим:

```sh
>>> os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py')
('C:\\Python27\\Tools\\pynche', 'ChipViewer.py')
```

Этот пример показывает, что происходит, когда мы указываем путь к файлу. Посмотрим, что произойдет, если в конце пути не будет имени файла:

```sh
>>> os.path.split(r'C:\Python27\Tools\pynche')
('C:\\Python27\\Tools', 'pynche')
```

Как вы можете видеть, он взял путь и разделил его таким образом, что последняя вложенная папка стала вторым элементом кортежа, а остальная часть пути - первым элементом.

Для нашего последнего примера я подумал, что вы захотите увидеть типичный случай использования **split**:

```sh
>>> dirname, fname = os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py')
>>> dirname
'C:\\Python27\\Tools\\pynche'
>>> fname
'ChipViewer.py'
```

Здесь показано, как выполнить множественное присваивание. Когда вы разделяете путь, он возвращает двухэлементный кортеж. Поскольку у нас две переменные слева, первый элемент кортежа присваивается первой переменной, а второй элемент - второй переменной.

## Подведение итогов

К этому моменту вы должны быть хорошо знакомы с модулем **os**s. В этой главе вы узнали следующее:

- как работать с переменными окружения
- изменять каталоги и определять текущий рабочий каталог
- создавать и удалять папки и файлы
- переименовывать файлы/папки
- запускать файл и связанное с ним приложение
- перемещаться по каталогу
- работать с путями

В модуле **os** есть множество других функций, которые здесь не рассматриваются. Обязательно прочитайте документацию, чтобы узнать, что еще вы можете делать. В следующей главе мы познакомимся с модулями **email** и **smtplib**.
