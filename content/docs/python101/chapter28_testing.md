---
title: 28. Введение в тестирование
description: Python 101
toc: true
authors:
tags:
categories:
series:
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 28
---

Python включает пару встроенных модулей для тестирования кода. Эти два метода называются **doctest** и **unittest**. Сначала мы рассмотрим, как использовать **doctest**, а во втором разделе мы представим модульные тесты, используя Test Driven Development.

## Тестирование с помощью doctest

Модуль doctest будет искать в вашем коде фрагменты текста, напоминающие интерактивные сессии Python. Затем он выполнит эти сессии, чтобы проверить, что они работают именно так, как написано. Это означает, что если вы написали пример в docstring, который показывает вывод с пробелом или табуляцией, то фактический вывод функции также должен содержать пробел. В большинстве случаев именно в docstring вы захотите поместить свои тесты. Будут рассмотрены следующие аспекты работы с doctest:

-  Как запустить doctest из терминала
-  Как использовать doctest внутри модуля
-  Как запустить doctest из отдельного файла.

Давайте начнем!

## Запуск doctest через терминал

Мы начнем с создания действительно простой функции, которая будет удваивать все, что ей дано. Мы включим пару тестов в **docstring** функции. Вот код (обязательно сохраните его под именем "dtest1.py"):

```python
# dtest1.py

def double(a):
    """
    >>> double(4)
    8
    >>> double(9)
    18
    """
    return a*2
```

Теперь нам нужно просто запустить этот код в doctest. Откройте терминал (или командную строку) и измените директории на папку, содержащую ваш скрипт. Вот скриншот того, что я сделал:

![](../img/doctest.jpg)

Вы заметите, что в первом примере я выполнил следующее:

```python
python -m doctest dtest1.py
```

Это запустило тест и ничего не вывело на экран. Когда вы не видите ничего на экране, это означает, что все тесты прошли успешно. Во втором примере показана следующая команда:

```python
python -m doctest -v dtest1.py

```

"-v" означает, что мы хотим получить подробный вывод, что мы и получили. Откройте код снова и добавьте пробел после "18" в строке docstring. Затем снова запустите тест. Вот вывод, который я получил:

![](../img/doctest_error.jpg)

В сообщении об ошибке говорится, что ожидалось "18", а получилось "18". Что здесь происходит? Мы добавили пробел после "18" в нашу строку документа, поэтому doctest на самом деле ожидал получить число "18", за которым следует пробел. Также остерегайтесь помещать словари в качестве вывода в примерах docstring. Словари могут располагаться в любом порядке, поэтому вероятность того, что они совпадут с реальным выводом, не очень велика.

## Запуск doctest внутри модуля

Давайте немного изменим пример, чтобы импортировать модуль **doctest** и использовать его функцию **testmod**.

```python
def double(a):
    """
    >>> double(4)
    8
    >>> double(9)
    18
    """
    return a*2

if __name__ == "__main__":
    import doctest
    doctest.testmod(verbose=True)
```

Здесь мы импортируем **doctest** и вызываем **doctest.testmod**. Мы передаем ему ключевой аргумент **verbose=True**, чтобы мы могли увидеть некоторые выходные данные. В противном случае этот скрипт будет выполняться без какого-либо вывода, что будет означать, что тесты прошли успешно.

Если вы не хотите жестко кодировать опцию verbose, вы также можете сделать это в командной строке:

```python
python dtest2.py -v
```

Теперь мы готовы узнать, как поместить тесты в отдельный файл.

## Запуск doctest из отдельного файла

Модуль doctest также поддерживает размещение тестов в отдельном файле. Это позволяет нам отделить тесты от кода. Давайте вычленим тесты из предыдущего примера и поместим их в текстовый файл с именем **tests.txt*:

```python
The following are tests for dtest2.py

>>> from dtest2 import double
>>> double(4)
8
>>> double(9)
18
```

Давайте запустим этот тестовый файл в командной строке. Вот как:

![](../img/doctest_from_file.jpg)

Вы заметите, что синтаксис для вызова doctest с текстовым файлом такой же, как и для вызова его с файлом Python. Результаты также одинаковы. В данном случае есть три теста вместо двух, потому что мы также импортируем модуль. Вы также можете запускать тесты, находящиеся в текстовом файле, внутри интерпретатора Python. Вот один из примеров:

![](../img/doctest_from_file_intepreter.jpg)

Здесь мы просто импортируем **doctest** и вызываем его метод **testfile**. Обратите внимание, что вам также нужно передать имя файла или путь к нему функции **testfile**. Она вернет объект **TestResults**, содержащий информацию о том, сколько тестов было выполнено и сколько из них не удалось.

## Разработка, управляемая тестами, с помощью unittest

В этом разделе вы узнаете о разработке под управлением тестов (TDD) в Python с помощью встроенного в Python модуля unittest. Я хочу поблагодарить Мэтта и Аарона за их помощь в демонстрации того, как TDD работает в реальном мире. Чтобы продемонстрировать концепции TDD, мы рассмотрим, как забивать кегли в Python. Если вы еще не знаете правил игры в боулинг, воспользуйтесь Google. Как только вы узнали правила, пришло время написать несколько тестов. Если вы не знали, идея Test Driven Development заключается в том, что вы пишете тесты ДО того, как пишете фактический код. В этой главе мы напишем тест, а затем код для прохождения теста. Мы будем итерационно переходить от написания тестов к написанию кода, пока не закончим. В этой главе мы напишем всего три теста. Давайте начнем!

## Первый тест

Первым тестом мы протестируем наш игровой объект и посмотрим, сможет ли он вычислить правильное общее количество очков, если мы бросим одиннадцать раз и каждый раз будем сбивать только одну кеглю. Это должно дать нам общее число одиннадцать.

```python
import unittest

class TestBowling(unittest.TestCase):
    """"""

    def test_all_ones(self):
        """Constructor"""
        game = Game()
        game.roll(11, 1)
        self.assertEqual(game.score, 11)
```

Это довольно простой тест. Мы создаем игровой объект, а затем вызываем его метод **roll** одиннадцать раз, причем каждый раз счет равен единице. Затем мы используем метод **assertEqual** из модуля **unittest** для проверки правильности счета игрового объекта (то есть одиннадцати). Следующий шаг - написать самый простой код, который вы можете придумать, чтобы тест прошел. Вот один из примеров:

```python
class Game:
    """"""

    def __init__(self):
        """Constructor"""
        self.score = 0

    def roll(self, numOfRolls, pins):
        """"""
        for roll in numOfRolls:
            self.score += pins
```

Для простоты вы можете просто скопировать и вставить это в тот же файл с вашим тестом. Мы разобьем их на два файла для нашего следующего теста. В любом случае, как вы можете видеть, наш класс **Game** очень прост. Все, что было необходимо для прохождения теста, это свойство score и метод **roll**, который может его обновлять.

Давайте запустим тест и посмотрим, пройдет ли он! Самый простой способ запустить тесты - добавить следующие две строки кода в конец файла:

```python
if __name__ == '__main__':
    unittest.main()
```

Затем просто запустите файл Python через командную строку. Если вы это сделаете, вы должны получить что-то вроде следующего:

```python
E
======================================================================
ERROR: test_all_ones (__main__.TestBowling)
Constructor
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Users\Mike\Documents\Scripts\Testing\bowling\test_one.py",
 line 27, in test_all_ones
    game.roll(11, 1)
  File "C:\Users\Mike\Documents\Scripts\Testing\bowling\test_one.py",
 line 15, in roll
    for roll in numOfRolls:
TypeError: 'int' object is not iterable

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
```

Упс! Где-то здесь у нас ошибка. Похоже, что мы передаем целое число, а затем пытаемся выполнить итерацию по нему. Это не работает! Чтобы все заработало, нам нужно изменить метод roll нашего объекта Game на следующий:

```python
def roll(self, numOfRolls, pins):
    """"""
    for roll in range(numOfRolls):
        self.score += pins
```

Если вы запустите тест сейчас, вы должны получить следующее:

```python
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK

```

Обратите внимание на ".", потому что это важно. Эта маленькая точка означает, что был выполнен один тест и что он прошел. Надпись "OK" в конце также указывает на этот факт. Если вы изучите исходный вывод, то заметите, что он начинается с буквы "E", означающей ошибку, а точки там нет! Давайте перейдем к тесту №2.

## Второй тест

Во втором тесте мы проверим, что происходит, когда мы получаем страйк. Нам придется изменить первый тест, чтобы использовать список для количества сбитых кеглей в каждом кадре, поэтому мы рассмотрим оба теста. Вы, вероятно, обнаружите, что это довольно распространенный процесс, когда вам может понадобиться отредактировать пару тестов из-за фундаментальных изменений в том, на что вы тестируете. Обычно это происходит только в начале вашего кодирования, и в дальнейшем вы станете лучше, так что вам не придется этого делать. Поскольку я делаю это в первый раз, я не думал достаточно далеко вперед. В любом случае, давайте посмотрим на код:

```python
from game import Game
import unittest

class TestBowling(unittest.TestCase):
    """"""

    def test_all_ones(self):
        """Constructor"""
        game = Game()
        pins = [1 for i in range(11)]
        game.roll(11, pins)
        self.assertEqual(game.score, 11)

    def test_strike(self):
        """
        A strike is 10 + the value of the next two rolls. So in this case
        the first frame will be 10+5+4 or 19 and the second will be
        5+4. The total score would be 19+9 or 28.
        """
        game = Game()
        game.roll(11, [10, 5, 4])
        self.assertEqual(game.score, 28)

if __name__ == '__main__':
    unittest.main()
```

Давайте посмотрим на наш первый тест и на то, как он изменился. Да, здесь мы немного нарушаем правила, когда речь идет о TDD. Не стесняйтесь НЕ изменять первый тест и посмотрите, что сломается. В методе **test_all_ones** мы установили переменную **pins** равной list comprehension, что создало список из одиннадцати единиц. Затем мы передали его в метод **roll** нашего **game** объекта вместе с количеством бросков.

Во втором тесте мы бросаем страйк в первом броске, пятерку во втором и четверку в третьем. Заметьте, что мы пошли по головам и сказали, что передаем одиннадцать бросков, но передаем только три. Это означает, что нам нужно установить остальные восемь бросков на нули. Далее мы используем наш надежный метод **assertEqual**, чтобы проверить, получили ли мы правильное общее число. Наконец, обратите внимание, что теперь мы импортируем класс **Game**, а не сохраняем его вместе с тестами. Теперь нам нужно реализовать код, необходимый для прохождения этих двух тестов. Давайте рассмотрим одно из возможных решений:

```python
class Game:
    """"""

    def __init__(self):
        """Constructor"""
        self.score = 0
        self.pins = [0 for i in range(11)]

    def roll(self, numOfRolls, pins):
        """"""
        x = 0
        for pin in pins:
            self.pins[x] = pin
            x += 1
        x = 0
        for roll in range(numOfRolls):
            if self.pins[x] == 10:
                self.score = self.pins[x] + self.pins[x+1] + self.pins[x+2]
            else:
                self.score += self.pins[x]
            x += 1
        print(self.score)

```

Сразу после этого вы заметите, что у нас есть новый атрибут класса под названием self.pins, который содержит список кеглей по умолчанию, состоящий из одиннадцати нулей. Затем в нашем методе roll в первом цикле мы добавляем нужные очки в нужную позицию в списке self.pins. Затем во втором цикле мы проверяем, равна ли сумма сбитых кеглей десяти. Если да, то мы добавляем его и следующие два очка к счету. В противном случае мы делаем то же самое, что и раньше. В конце метода мы выводим счет, чтобы проверить, соответствует ли он нашим ожиданиям. На этом этапе мы готовы к написанию нашего последнего теста.

## Третий (и последний) тест

В нашем последнем тесте мы проверим правильность результата, который будет получен, если кто-то бросит запасной вариант. Тест прост, решение немного сложнее. Пока мы здесь, мы немного рефакторим код теста. Как обычно, сначала мы рассмотрим тест.

```python
from game_v2 import Game
import unittest

class TestBowling(unittest.TestCase):
    """"""

    def setUp(self):
        """"""
        self.game = Game()

    def test_all_ones(self):
        """
        If you don't get a strike or a spare, then you just add up the
        face value of the frame. In this case, each frame is worth
        one point, so the total is eleven.
        """
        pins = [1 for i in range(11)]
        self.game.roll(11, pins)
        self.assertEqual(self.game.score, 11)

    def test_spare(self):
        """
        A spare is worth 10, plus the value of your next roll. So in this
        case, the first frame will be 5+5+5 or 15 and the second will be
        5+4 or 9. The total is 15+9, which equals 24,
        """
        self.game.roll(11, [5, 5, 5, 4])
        self.assertEqual(self.game.score, 24)

    def test_strike(self):
        """
        A strike is 10 + the value of the next two rolls. So in this case
        the first frame will be 10+5+4 or 19 and the second will be
        5+4. The total score would be 19+9 or 28.
        """
        self.game.roll(11, [10, 5, 4])
        self.assertEqual(self.game.score, 28)

if __name__ == '__main__':
    unittest.main()
```

Во-первых, мы добавили метод **setUp**, который будет создавать для нас объект self.game для каждого теста. Если бы мы обращались к базе данных или чему-то подобному, у нас, вероятно, был бы метод tear down для закрытия соединений, файлов и тому подобных вещей. Они выполняются в начале и в конце каждого теста, соответственно, если они существуют. Тесты **test_all_ones** и **test_strike** в основном одинаковы, за исключением того, что теперь они используют "self.game". Единственный новый тест - **test_spare**. В документации объясняется, как работают запасные части, а код состоит всего из двух строк. Да, вы можете разобраться в этом. Давайте посмотрим на код, который нам понадобится для прохождения этих тестов:

```python
# game_v2.py

class Game:
    """"""

    def __init__(self):
        """Constructor"""
        self.score = 0
        self.pins = [0 for i in range(11)]

    def roll(self, numOfRolls, pins):
        """"""
        x = 0
        for pin in pins:
            self.pins[x] = pin
            x += 1
        x = 0
        spare_begin = 0
        spare_end = 2
        for roll in range(numOfRolls):
            spare = sum(self.pins[spare_begin:spare_end])
            if self.pins[x] == 10:
                self.score = self.pins[x] + self.pins[x+1] + self.pins[x+2]
            elif spare == 10:
                self.score = spare + self.pins[x+2]
                x += 1
            else:
                self.score += self.pins[x]
            x += 1
            if x == 11:
                break
            spare_begin += 2
            spare_end += 2
        print(self.score)
```

Для этой части головоломки мы добавляем условный оператор в наш цикл. Чтобы вычислить значение запасного, мы используем позиции списка **spare_begin** и **spare_end**, чтобы получить нужные значения из нашего списка, а затем суммируем их. Вот для чего нужна переменная **spare**. Возможно, ее лучше поместить в elif, но я оставлю это на усмотрение читателя. Технически, это только первая половина запасного результата. Вторая половина - это следующие два броска, которые вы найдете в вычислениях в части elif текущего кода. Остальная часть кода не изменилась.

## Другие примечания

Как вы уже догадались, модуль unittest имеет гораздо больше возможностей, чем то, что было рассмотрено здесь. Существует множество других утверждений, которые можно использовать для проверки результатов. Вы можете пропускать тесты, запускать тесты из командной строки, использовать TestLoader для создания набора тестов и многое, многое другое. Обязательно прочитайте полную [документацию](http://docs.python.org/2/library/unittest.html), когда у вас будет такая возможность, так как это руководство лишь поверхностно изучает эту библиотеку.

## Подведение итогов

На данном этапе вы должны понимать, как эффективно использовать модули doctest и unittest в своем собственном коде. Вам следует прочитать документацию Python по этим двум модулям, поскольку там есть дополнительная информация о других опциях и функциональных возможностях, которые вы можете найти полезными. Вы также знаете немного о том, как использовать концепции Test Driven Development при написании собственных сценариев.
