---
title: 8. Работа с файлами
description: Python 101
toc: true
authors:
tags:
categories:
series:
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 10
---

Эта глава знакомит с темой чтения и записи данных в файлы на жестком диске. Вы увидите, что читать и записывать файлы в Python очень просто. Давайте приступим!

## Как читать файл

В Python есть встроенная функция open, которую мы можем использовать для открытия файла для чтения. Создайте текстовый файл с именем "test.txt" со следующим содержимым:

```sh
This is a test file
line 2
line 3
this line intentionally left blank
```
Вот несколько примеров, которые показывают, как использовать **open** для чтения:

```sh
handle = open("test.txt")
handle = open(r"C:\Users\mike\py101book\data\test.txt", "r")
```
Первый пример откроет файл с именем **test.txt** в режиме "только для чтения". Это стандартный режим функции открытия файлов. Обратите внимание, что в первом примере мы не указали полный путь к файлу, который хотим открыть. Python автоматически ищет **test.txt** в папке, в которой запущен сценарий. Если он не найдет его, то вы получите ошибку IOError.

Во втором примере показан полный путь к файлу, но обратите внимание на то, что он начинается с "r". Это значит, что мы указываем Python, чтобы строка обрабатывалась как исходная. Давайте посмотрим на разницу между исходной строкой и обычной:

```sh
>>> print("C:\Users\mike\py101book\data\test.txt")
C:\Users\mike\py101book\data        est.txt
>>> print(r"C:\Users\mike\py101book\data\test.txt")
C:\Users\mike\py101book\data\test.txt
```

Как видно из примера, когда мы не определяем строку как исходную, мы получаем неправильный путь.. Почему это происходит? Как вы помните из главы о строках, есть некоторые специальные символы, которые должны быть экранированы, например, "n" или "t". В данном случае мы видим "t" (т.е. табуляцию), поэтому строка послушно добавляет табуляцию к нашему пути и портит его.

Вторым аргументом во втором примере также является "r". Это говорит open, что мы хотим открыть файл в режиме только для чтения. Другими словами, это делает то же самое, что и первый пример, но более явно. Теперь давайте действительно прочитаем файл!

Запишите следующие строки в сценарий Python и сохраните его в том же месте, где находится файл test.txt:

```sh
handle = open("test.txt", "r")
data = handle.read()
print(data)
handle.close()
```

Если вы запустите эту программу, она откроет файл и прочитает весь файл как строку в переменную **data**. Затем мы печатаем эти данные и закрываем дескриптор файла. Следует всегда закрывать дескриптор файла, так как неизвестно когда и какая именно программа захочет получить к нему доступ. Закрытие файла также поможет сохранить память и избежать появления странных багов в программе. Вы можете указать Python читать по строке за раз, читать все строки в список Python или читать файл по частям. Последний вариант очень удобен, когда вы имеете дело с очень большими файлами и не хотите читать их целиком, что может заполнить память компьютера.

Давайте потратим немного времени на рассмотрение различных способов чтения файлов.

```sh
handle = open("test.txt", "r")
data = handle.readline() # read just one line
print(data)
handle.close()
```
Если вы запустите этот пример, он прочитает только первую строку вашего текстового файла и распечатает ее. Это не слишком полезно, поэтому давайте попробуем метод readlines() дескриптора файла:

```sh
handle = open("test.txt", "r")
data = handle.readlines() # read ALL the lines!
print(data)
handle.close()
```

После выполнения этого кода вы увидите список Python, выведенный на экран, потому что это то, что возвращает метод **readlines**: список! Давайте уделим немного времени тому, как читать файл по частям.

## Как читать файлы по частям

Самый простой способ читать файл по частям - использовать цикл. Сначала мы научимся читать файл строка за строкой, а затем - по килобайту за раз. Для первого примера мы будем использовать цикл **for**:

```sh
handle = open("test.txt", "r")

for line in handle:
    print(line)

handle.close()
```
Здесь  мы открываем файл в дескрипторе в режиме "только чтение", а затем используем цикл **for** для итерации по нему. Вы увидите, что в Python можно выполнять итерации над всеми видами объектов (строки, списки, кортежи, ключи в словаре и т.д.). Это было довольно просто, верно? Теперь давайте сделаем это по частям!

```sh
handle = open("test.txt", "r")

while True:
    data = handle.read(1024)
    print(data)
    if not data:
        break
```
В этом примере мы используем цикл **while** в Python для чтения по одному килобайту файла за раз. Как вы, вероятно, знаете, килобайт - это 1024 байта или символа. Теперь давайте представим, что мы хотим прочитать двоичный файл, например PDF.

## Как прочитать двоичный файл

Прочитать двоичный файл очень просто. Все что вам нужно, это изменить способ доступа к файлу:

```sh
handle = open("test.pdf", "rb")
```

Мы изменили способ доступа к файлу на rb, что означает **read-binary**. Вам может понадобиться читать двоичные файлы, когда вы скачиваете PDF-файлы из Интернета или передаете файлы с компьютера на компьютер.

## Запись файлов в Python

Если вы следили за развитием событий, то, вероятно, догадываетесь, режимы написания файлов в Python это “w” и “wb” для write-mode и write-binary-mode соответственно. Теперь давайте взглянем на простой пример того, как они применяются.

**ВНИМАНИЕ**: При использовании режимов "w" или "wb", если файл уже существует, он будет перезаписан без предупреждения! Вы можете проверить, существует ли файл до того, как вы его откроете, с помощью модуля **os** в Python. См. раздел **os.path.exists** в **Главе 16**.

```sh
handle = open("test.txt", "w")
handle.write("This is a test!")
handle.close()
```

Это было просто! Все, что мы сделали, это изменили режим файла на "w" и вызвали метод **write** дескриптора файла, чтобы записать текст в файл. У дескриптора файла также есть метод **writelines**, который принимает список строк, которые дескриптор записывает на диск по порядку.

## Использование оператора with

В Python есть небольшой встроенный оператор **with**, который можно использовать для упрощения чтения и записи файлов. Оператор **with** создает то, что в Python известно как **менеджер контекста**, который автоматически закроет файл, когда вы закончите его обработку. Давайте посмотрим, как это работает:

```sh
with open("test.txt") as file_handler:
    for line in file_handler:
        print(line)
```

Синтаксис оператора with немного странный, но вы быстро разберетесь в нем. По сути, мы делаем замену:

```sh
handle = open("test.txt")
```
на это:

```sh
with open("test.txt") as file_handler:
```
Вы можете выполнять все обычные операции ввода-вывода файлов, которые вы обычно делаете, пока вы находитесь внутри блока кода **with**. Как только вы покинете этот блок кода, дескриптор файла закроется, и вы больше не сможете его использовать. Да, вы правильно прочитали. Вам больше не нужно явно закрывать дескриптор файла, поскольку оператор **with** делает это автоматически! Попробуйте изменить некоторые предыдущие примеры из этой главы так, чтобы в них тоже использовался метод **with**.

## Выявление ошибок

Иногда при работе с файлами случаются неприятные вещи. Файл заблокирован, потому что его использует другой процесс, или у вас возникла какая-то ошибка разрешения. Когда это происходит, вероятно, возникнет ошибка **IOError**. В этом разделе мы рассмотрим, как ловить ошибки обычным способом и как ловить их с помощью оператора **with**. Подсказка: идея в обоих случаях практически одинакова!

```sh
try:
    file_handler = open("test.txt")
    for line in file_handler:
        print(line)
except IOError:
    print("An IOError has occurred!")
finally:
    file_handler.close()
```

В приведенном выше примере мы помещаем обычный код в конструкции **try/except**. Если возникает ошибка, мы выводим сообщение на экран. Обратите внимание, что мы также закрываем файл с помощью оператора **finally**. Теперь мы готовы рассмотреть, как сделать то же самое, используя оператор **with**:

```sh
try:
    with open("test.txt") as file_handler:
        for line in file_handler:
            print(line)
except IOError:
    print("An IOError has occurred!")
```

Как вы уже догадались, мы просто обернули блок **with** таким же образом, как и в предыдущем примере. Разница в том, что нам не нужен оператор finally, так как менеджер контекста сделает это за нас.

## Подведение итогов

К этому моменту вы должны быть достаточно хорошо знакомы с работой с файлами в Python. Теперь вы знаете, как читать и записывать файлы, используя старый стиль и новый стиль **with**. Скорее всего, вы встретите оба стиля в реальной жизни. В следующей главе мы узнаем, как импортировать другие модули, поставляемые с Python. Это позволит нам создавать программы, используя готовые модули. Давайте начнем!
