---
title: 10. Функции
description: Python 101
toc: true
authors:
tags:
categories:
series:
featuredImage:
date: "2022-06-28"
lastmod: "2022-06-28"
draft: false
weight: 10
---


Функция - это структура, которую вы определяете. Вы можете решать, есть ли у них аргументы или нет. Вы можете добавить аргументы в виде ключевых слов и аргументы по умолчанию. Функция - это блок кода, который начинается с ключевого слова def, имени функции и двоеточия. Вот простой пример:

```sh
>>> def a_function():
        print("You just created a function!")
```

Эта функция ничего не делает, кроме вывода какого-то текста. Чтобы вызвать функцию, нужно напечатать ее имя, за которым следуют открытые и закрытые круглые скобки:

```sh
>>> a_function()
You just created a function!
```

Просто, да?

## Пустая функция (заглушка)

Иногда, когда вы пишете код, вы просто хотите написать определения функций, не вставляя в них никакого кода. Я делал это в качестве своеобразного наброска. Это помогает вам увидеть, как будет выглядеть ваше приложение. Вот пример:

```sh
>>> def empty_function():
        pass
```

Вот нечто новое: оператор **pass**. По сути, это операция null, то есть при выполнении pass ничего не происходит.

## Передача аргументов в функцию

Теперь мы готовы узнать, как создать функцию, которая может принимать аргументы, а также как передать эти аргументы в функцию. Давайте создадим простую функцию, которая может складывать два числа:

```sh
>>> def add(a, b):
        return a + b

>>> add(1, 2)
3
```

Все функции что-то возвращают. Если не указать ей, что она должна что-то вернуть, то она вернет None. В данном случае мы говорим ей вернуть **a + b**. Как видите, мы можем вызвать функцию, передав два значения. Если вы передадите недостаточно или слишком много аргументов, то получите ошибку:

```sh
>>> add(1)
Traceback (most recent call last):
  File "<string>", line 1, in <fragment>
TypeError: add() takes exactly 2 arguments (1 given)
```

Вы также можете вызвать функцию, передав ей имя аргументов:

```sh
>>> add(a=2, b=3)
5
>>> total = add(b=4, a=5)
>>> print(total)
9
```

Вы заметите, что не имеет значения, в каком порядке вы передаете их в функцию, лишь бы они были названы правильно. Во втором примере видно, что мы присваиваем результат функции переменной с именем **total**. Это обычный способ вызова функции, поскольку вы захотите что-то сделать с результатом. Вам, вероятно, интересно, что произойдет, если мы передадим аргументы с неправильными именами. Будет ли это работать? Давайте узнаем:

```sh
>>> add(c=5, d=2)
Traceback (последний последний вызов):
  Файл "<string>", строка 1, в <фрагменте>.
TypeError: add() получил неожиданный аргумент ключевого слова 'c'
```

Упс! Мы получили ошибку. Это означает, что мы передали аргумент с ключевым словом, который функция не распознала. Какое совпадение, аргументы с ключевыми словами - наша следующая тема!

## Аргументы с ключевыми словами

Функции также могут принимать аргументы в виде ключевых слов! На самом деле они могут принимать как обычные аргументы, так и аргументы с ключевыми словами. Значит, вы можете указать, какие ключевые слова какими являются, и передать их. Вы видели такое поведение в предыдущем примере.

```sh
>>> def keyword_function(a=1, b=2):
        return a+b

>>> keyword_function(b=4, a=5)
9
```

Вы также могли бы вызвать эту функцию без указания ключевых слов. Эта функция также демонстрирует концепцию аргументов по умолчанию. Каким образом? Ну, попробуйте вызвать функцию вообще без аргументов!

```sh
>>> keyword_function()
3
```

Функция вернула число 3! Почему? Причина в том, что **a** и **b** имеют значения по умолчанию 1 и 2 соответственно. Теперь давайте создадим функцию, которая имеет как обычный аргумент, так и пару аргументов в виде ключевых слов:

```sh
>>> def mixed_function(a, b=2, c=3):
        return a+b+c

>>> mixed_function(b=4, c=5)
Traceback (most recent call last):
  File "<string>", line 1, in <fragment>
TypeError: mixed_function() takes at least 1 argument (2 given)
>>> mixed_function(1, b=4, c=5)
10
>>> mixed_function(1)
6
```

В приведенном выше коде есть 3 примера. Давайте рассмотрим каждый из них. В первом примере мы пытаемся вызвать нашу функцию, используя только аргументы ключевого слова. Это приведет нас к непонятной ошибке. В Traceback говорится, что наша функция принимает хотя бы один аргумент, но было передано два. Что же здесь происходит? Дело в том, что первый аргумент является обязательным, так как он ничем не задан, поэтому если вы вызываете функцию только с аргументами ключевых слов, это приводит к ошибке.

Во втором примере мы вызываем смешанную функцию с 3 значениями, называя два из них. Это работает и дает нам ожидаемый результат - 1+4+5=10. Третий пример показывает, что произойдет, если мы вызовем функцию, передав только одно значение... то, которое не имеет значения по умолчанию. Это также работает, если взять значение "1" и добавить его к двум значениям по умолчанию "2" и "3", чтобы получить результат "6"! Разве это не круто?

## *args и **kwargs

Вы также можете настроить функции на прием любого количества аргументов или ключевых слов, используя специальный синтаксис. Чтобы получить бесконечное количество аргументов, используйте *args, а для бесконечного количества аргументов ключевых слов - **kwargs. Слова "args" и "kwargs" не имеют значения. Это просто условность. Вы могли бы назвать их *bill и **ted, и это работало бы точно так же. Ключ здесь в количестве звездочек.

Примечание: в дополнение к соглашению о *args и **kwargs, вы также будете время от времени встречать *a и **kw.

Давайте рассмотрим небольшой пример:

```sh
>>> def many(*args, **kwargs):
        print(args)
        print(kwargs)

>>> many(1, 2, 3, name="Mike", job="programmer")
(1, 2, 3)
{'job': 'programmer', 'name': 'Mike'}
```

Сначала мы создадим нашу функцию, используя новый синтаксис, а затем вызовем ее с тремя обычными аргументами и двумя аргументами в виде ключевых слов. Сама функция выведет оба типа аргументов. Как видите, параметр **args** превращается в кортеж, а **kwargs** - в словарь. Вы можете увидеть этот тип кодирования в исходном тексте Python и во многих сторонних пакетах Python.

## Замечание об области видимости и глобальных значениях

В Python есть понятие области видимости, как и в большинстве языков программирования. Область видимости подскажет нам, когда переменная доступна для использования и где. Если мы определяем переменные внутри функции, то эти переменные могут быть использованы только внутри этой функции. После завершения функции они больше не могут быть использованы, поскольку **выходят из области видимости**. Давайте рассмотрим пример:

```sh
def function_a():
    a = 1
    b = 2
    return a+b

def function_b():
    c = 3
    return a+c

print( function_a() )
print( function_b() )
```

Если вы запустите этот код, вы получите следующую ошибку:

```sh
NameError: global name 'a' is not defined
```

Это происходит потому, что переменная **a** определена только в первой функции и недоступна во второй. Это можно обойти, сказав Python, что **a** является **глобальной** переменной. Давайте посмотрим, как это делается:

```sh
def function_a():
    global a
    a = 1
    b = 2
    return a+b

def function_b():
    c = 3
    return a+c

print(function_a())
print(function_b())
```

Этот код будет работать, потому что мы сказали Python сделать переменную глобальной, что означает, что она будет доступна везде в нашей программе. Обычно это плохая идея не рекомендуется. А всё потому, что в этом случае трудно определить, когда переменная определена. Другая проблема заключается в том, что, определив глобальную переменную в одном месте, мы можем случайно переопределить ее значение в другом, что впоследствии может привести к логическим ошибкам, которые трудно отладить.

## Советы по кодированию

Одной из самых больших проблем, которую необходимо усвоить начинающим программистам, является идея "Не повторяй себя"(Don’t Repeat Yourself -DRY). Эта концепция заключается в избегании написания одного и того же кода более одного раза. Если вы обнаружите, что делаете это, то знайте, что этот кусок кода должен быть помещен в функцию. Основная причина заключается в том, что в будущем вам почти наверняка понадобится снова изменить этот кусок кода, а если он находится в нескольких местах, то чтобы изменить его, вам придется вспоминать где ещё вы его писали.

Копирование и вставка одного и того же фрагмента кода повсюду - это пример **"спагетти-кода"**. Старайтесь максимально избегать этого. В какой-то момент вы пожалеете об этом либо потому, что вам придется исправлять его, либо потому, что вы найдете чужой код с подобными проблемами, который вам придется поддерживать.

## Подведение итогов

Теперь у вас есть базовые знания, необходимые для эффективного использования функций. Вам следует попрактиковаться в создании некоторых простых функций и попробовать вызывать их различными способами. После того как вы немного поиграете с функциями или просто решите, что хорошо понимаете концепции, вы можете перейти к следующей главе, посвященной классам.
