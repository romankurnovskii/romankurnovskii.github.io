<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/categories/algorithms/</link><description>Recent content in Algorithms on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/categories/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Two Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</guid><description>LeetCode problem
Problem Statement In this problem, you&amp;rsquo;re given an array of integers nums and an integer target. Your task is to find the indices of two numbers in the array that add up to the target. The input array is guaranteed to have exactly one solution, and you can&amp;rsquo;t use the same element twice. The indices can be returned in any order.
Naive Solution A naive solution would involve using two nested loops to iterate through each pair of elements in the array and check if their sum is equal to the target.</description></item><item><title>Algorithms 101</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/</guid><description>Smart / OKR What is SMART and OKR
SMART Specific:
Goal: prepare for contests. Pass 50-&amp;gt;75-&amp;gt;100% of contest problems in time Improve python skills. Improve understanding of common algorithms and data structures. Measurable: How will we know that change has occurred?
solve top 100 questions that cover common algorithms and data structures. Achievable:
participate in LeetCode contest, solve 50%+ problems in time. Relevant: Is it possible to achieve this objective?
achievable with practice. improve skills in solving business problems more efficiently, quickly, understandable.</description></item><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</guid><description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. First accepted Idea:
Loop through lists add each value to the list reverse list calculate sum create linked list from reversed sum class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def createLinkedNode(values): head = ListNode(values[0]) current = head for i in values[1:]: node = ListNode(i) current.</description></item><item><title>3. Longest Substring Without Repeating Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</guid><description>LeetCode problem
Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. First accepted Idea:
Loop through string Calculate max count of elements in substring If get double element, then go back until get this element and do step 2. Proceed the main loop class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: uniqs = set() len_max = 0 len_current = 0 idx = 0 for i in s: if i in uniqs: len_max = max(len_max, len_current) len_current = 1 uniqs = set(i) for j in reversed(s[:idx]): if j == i: break else: len_current += 1 uniqs.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:
Convert number to int Remove minus if exist (or convert module of number) reverse class Solution: def reverse(self, x: int) -&amp;gt; int: reversed_int = [] str_int = str(x) if x &amp;lt; 0: str_int = str_int[1:] for i in reversed(range(len(str_int))): reversed_int.</description></item><item><title>8. String to Integer (atoi)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</guid><description>LeetCode problem
// .js /** * @param {string} s * @return {number} */ var myAtoi = function(s) { let res = 0; let num = parseInt(s); if(num &amp;gt;= 2147483648){ res = 2147483647; } else if (num &amp;lt;= -2147483648){ res = -2147483648; } else if (isNaN(num)) { res = 0; } else { res = num; } return res; };</description></item><item><title>9. Palindrome Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</guid><description>LeetCode problem 9. Palindrome Number
Problem Statement Determine whether an integer is a palindrome without converting it to a string.
Naive Solution A straightforward solution might be to convert the integer to a string and check if it reads the same both ways. However, this challenge encourages solving it without such conversion.
Hints &amp;amp; Tips By reversing the number and comparing it to the original, you can determine if it&amp;rsquo;s a palindrome.
Approach Instead of converting the number to a string, we can reverse its digits using mathematical operations and then compare the reversed number to the original number.</description></item><item><title>1777A - Everybody Likes Good Arrays! - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</guid><description>1777A - Everybody Likes Good Arrays! (greedy, math, 800)
Statement You have an array of numbers, and you want to make it &amp;ldquo;good.&amp;rdquo; A good array is one where every pair of adjacent numbers has different parity (one is even, and the other is odd). You can do this by performing operations on pairs of adjacent numbers with the same parity (both even or both odd), and replacing them with their product. Logic Loop through the array Check the parity of the current element and the previous element If the parity is the same, perform the operation and increment the operation counter Repeat steps 2 and 3 until the end of the array Return the operation counter Solution def solve(n, ar): res = 0 i = 0 while i &amp;lt; len(ar) - 1: if ar[i] % 2 == ar[i + 1] % 2: ar[i] = ar[i] * ar[i + 1] del ar[i + 1] res += 1 else: i += 1 return res Optimized Solution Check how many times the parity changes in the given array.</description></item><item><title>1809A - Garland - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1809a/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1809a/</guid><description>1809A - Garland (implementation, 800)
Explanation If all the light bulbs have the same color, it is impossible to turn them all on, as you can&amp;rsquo;t perform the operation on the same color consecutively. In this case, print -1. If there are 3 light bulbs of the same color and one light bulb of a different color, it takes 6 operations to turn them all on: Turn on the different colored light bulb Turn on one of the other colored light bulbs Turn off the different colored light bulb Turn on the second light bulb of the same color Turn on the different colored light bulb Turn on the third light bulb of the same color In all other cases, it takes 4 operations to turn all the light bulbs on, as you can switch the light bulbs on in a sequence without violating the color restriction.</description></item><item><title>Plan</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/plan/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/plan/</guid><description>Stage 1: Implementation and Greedy 1809A - Garland (implementation, 800) 1807A - Plus or Minus (implementation, 800) 1807B - Grab the Candies (greedy, 800) 1807C - Find and Replace (greedy, implementation, strings, 800) 1798A - Showstopper (greedy, implementation, sortings, 800) 1799A - Recent Actions (data structures, greedy, implementation, math, 800) 1788A - One and Two (brute force, implementation, math, 800) 1778A - Flip Flop Sum (greedy, implementation, 800) 1772A - A+B? (implementation, 800) 1796B - Asterisk-Minor Template (implementation, strings, 1000) Stage 2: Combinatorics and Geometry 1777A - Everybody Likes Good Arrays!</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</guid><description>LeetCode problem 11
Problem Statement The problem involves an array of integers height, where each element represents the height of a line. These lines, along with the x-axis, form a series of containers. Your goal is to find the two lines that form the container with the greatest area.
Naive Solution The naive solution is to consider all pairs of lines and calculate the area of water each pair can contain. You would keep track of the maximum area encountered.</description></item><item><title>12. Integer to Roman</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/12/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/12/</guid><description>LeetCode problem 12
class Solution: def intToRoman(self, num: int) -&amp;gt; str: cs = (&amp;#39;M&amp;#39;, &amp;#39;CM&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;CD&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;XC&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;XL&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;IX&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;IV&amp;#39;, &amp;#39;I&amp;#39;) vs = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) res = [] for c, v in zip(cs, vs): while num &amp;gt;= v: num -= v res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>14. Longest Common Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</guid><description>LeetCode problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. First accepted Idea:
class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: strs.sort() l = strs[0] r = strs[-1] if l == r: return l res = &amp;#34;&amp;#34; for i in range(0, len(l)): if l[i] == r[i]: res += l[i] else: return res return res</description></item><item><title>15. 3Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</guid><description>LeetCode problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</guid><description>LeetCode problem
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] Example 2:
Input: digits = &amp;quot;&amp;quot; Output: [] First accepted class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] result = [&amp;#39;&amp;#39;] for d in digits: d = int(d) tmp = [] for letter in letters[d]: for word in result: word += letter tmp.</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem
Given the &amp;lsquo;head&amp;rsquo; of a linked list, remove the &amp;rsquo;nth&amp;rsquo; node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Idea:
Two pointers. Second pointer starts from nth position. Run while second pointer exist. First version:
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description></item><item><title>1787A - Exponential Equation - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</guid><description>1787A - Exponential Equation (constructive algorithms, math, 800)
Logic The equation is a mix of multiplication and exponential operations. Given the nature of exponential operations, $𝑥^𝑦$ and $𝑦^𝑥$ can grow very large very quickly as x and y increase.
We can try to simplify the equation.
If we can somehow set one of the variables x or y to 1, the equation simplifies.
This is because any number (except zero) raised to the power of 1 is the number itself, and any number raised to the power of 0 is 1.</description></item><item><title>1807A - Plus or Minus - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807a/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807a/</guid><description>1807A - Plus or Minus (implementation, 800)
Solution t = int(input()) for _ in range(t): a, b, c = map(int, input().split()) print(&amp;#39;+&amp;#39; if a + b == c else &amp;#39;-&amp;#39;)</description></item><item><title>Python template for contests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/cp-template/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/cp-template/</guid><description>Clean template ############################################# Libraries ###################################################### import bisect import sys import math import os import time from queue import PriorityQueue from io import BytesIO, IOBase from collections import defaultdict, Counter from bisect import bisect_right ############################################# Definitions ###################################################### INF = sys.maxsize BUFSIZE = 4096 ############################################# Inputs ###################################################### # def inp(): return sys.stdin.readline().rstrip(&amp;#34;\r\n&amp;#34;) # read line as string # def inp_int(): return int(inp()) # read input as integer. &amp;#39;1&amp;#39; -&amp;gt; 1 # def inp_int_list(): return list(map(int, inp().split())) # def inp_str_list(): return list(inp()) ############################################# Solution ###################################################### def solve(): n = list(map(int, input().</description></item><item><title>20. Valid Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</guid><description>LeetCode problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true First accepted Idea:</description></item><item><title>21. Merge Two Sorted Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</guid><description>LeetCode problem
You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: list1 = [], list2 = [0] Output: [0] First accepted Idea:
Get smallest head. Loop and update its next.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
class Solution: def generateParenthesis(self, n): res = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: res.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return res</description></item><item><title>24. Swap Nodes in Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/24/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/24/</guid><description>LeetCode problem 24
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def swapPairs(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) pre, cur = dummy, head while cur and cur.next: t = cur.next cur.next = t.next t.next = cur pre.next = t pre, cur = cur, cur.next return dummy.next</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</guid><description>LeetCode problem
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>28. Find the Index of the First Occurrence in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/28/</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/28/</guid><description>LeetCode problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
Example 2:
Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.</description></item><item><title>1777B - Emordnilap - 900</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</guid><description>1777B - Emordnilap (combinatorics, greedy, math, 900)
Statement In this problem, we need to find the &amp;ldquo;beauty&amp;rdquo; of all permutations of a certain length n. The beauty of a permutation is defined as the number of inversions in an array that is created by combining the permutation and its reverse.
Logic The key insight is that every permutation of length n has the same beauty.
This is because the structure of the array created by concatenating a permutation with its reverse ensures that there will always be the same number of inversions, regardless of the order of the numbers in the original permutation.</description></item><item><title>1807B - Grab the Candies - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807b/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807b/</guid><description>1807B - Grab the Candies (greedy, 800)
Explanation Read the number of bags and the list of candies in the bags. Calculate the total number of candies with even and odd amounts separately. Compare the total amount of candies with even and odd amounts. If Mihai has strictly more candies than Bianca, output &amp;ldquo;YES&amp;rdquo;. Otherwise, output &amp;ldquo;NO&amp;rdquo;. Solution t = int(input()) for _ in range(t): n = int(input()) ar = list(map(int, input().split())) m = 0 b = 0 if n == 1: print(&amp;#39;YES&amp;#39; if ar[0] % 2 == 0 else &amp;#39;NO&amp;#39;) else: for x in ar: if x % 2 == 0: m += x else: b += x print(&amp;#39;YES&amp;#39; if m &amp;gt; b else &amp;#39;NO&amp;#39;)</description></item><item><title>Algorithms</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/</guid><description>Intro Big-O Cheat Sheet Sort Insertion sort sorts an array by continuously picking an element, starting from the second element, and inserting it in its correct position in the sorted part of the array to its left. It does this by shifting larger elements one position ahead of their current position, making room for the new element.
def insertion_sort(array): for i in range(1, len(array)): value = array[i] while i &amp;gt; 0 and array[i - 1] &amp;gt; value: array[i] = array[i - 1] i -= 1 array[i] = value return array Selection sort works by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first unsorted element.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]
Code Idea:</description></item><item><title>36. Valid Sudoku</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</guid><description>LeetCode problem
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</description></item><item><title>1773F - Football - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</guid><description>1773F - Football (constructive algorithms, 800)
Logic Solution def solve(): n = int(input()) # number of matches a = int(input()) # goals scored b = int(input()) # goals conceded if n == 1: if a == b: print(1) else: print(0) print(f&amp;#34;{a}:{b}&amp;#34;) return matches = [[0, 0] for _ in range(n + 1)] draw = 0 match = 1 while match &amp;lt;= n and a &amp;gt; 0: a -= 1 matches[match] = [1, 0] match += 1 if a &amp;gt; 0: matches[1] = [matches[1][0] + a, 0] if b &amp;gt; 0: if match == n + 1: matches[1][0] += 1 matches[n][0] -= 1 matches[n][1] = b else: while match &amp;lt;= n and b &amp;gt; 0: b -= 1 matches[match][1] += 1 match += 1 if b &amp;gt; 0: matches[n][1] += b for i in range(1, n + 1): if matches[i][0] == matches[i][1]: draw += 1 print(draw) for i in range(1, n + 1): print(f&amp;#34;{matches[i][0]}:{matches[i][1]}&amp;#34;) solve() Codeforces Editorial PDF</description></item><item><title>1807C - Find and Replace - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807c/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807c/</guid><description>1807C - Find and Replace (greedy, implementation, strings, 800)
Solution t = int(input()) for _ in range(t): n = int(input()) s = input() reserved_binaries = {} binary_values = [] for c in s: val = reserved_binaries.get(c, None) if not binary_values: binary_values.append(1) if val == binary_values[-1]: print(&amp;#39;NO&amp;#39;) break if not val: val = 1 if binary_values[-1] == 0 else 0 reserved_binaries[c] = val binary_values.append(val) else: print(&amp;#39;YES&amp;#39;)</description></item><item><title>01: Implementation &amp; Greedy</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/</guid><description>Implementation Implementation problems are typically straightforward and involve writing code to solve a problem based on the given description. There are no specific techniques for implementation problems, as they can vary widely.
However, the following tips can help you tackle these problems:
Read the problem statement carefully and make sure you understand the requirements. Break the problem down into smaller tasks and solve each task step by step. Write clear, modular code to make debugging easier. Test your solution with the given examples and edge cases.</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: result_permutation = [] if len(nums) == 1: # base case return [nums[:]] for _ in nums: tmp_removed = nums.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</guid><description>LeetCode problem
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify matrix in-place instead.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dd = {} for s in strs: s_sort = &amp;#34;&amp;#34;.</description></item><item><title>02: Combinatorics &amp; Geometry</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/</guid><description>Combinatorics Combinatorics is the study of counting, arranging, and selecting discrete objects. It deals with problems that involve combinations, permutations, and the principles of counting. Combinatorics is used in problems, especially involving optimization or enumeration.
Concepts Permutations A permutation is an arrangement of objects in a specific order. The number of possible permutations of n objects is n! (factorial of n).
Combinations A combination is a selection of objects without considering the order. The number of combinations of n objects taken r at a time is given by the binomial coefficient: $$C(n, r) = n!</description></item><item><title>1798A - Showstopper - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1798a/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1798a/</guid><description>1798A - Showstopper (greedy, implementation, sortings, 800)
Update a and b in a such way so in a always put the largest and in b smallest.
Solution def solve(a,b,n): a_max = a[0] for i in range(n): max_v = max(a[i], b[i]) min_v = min(a[i], b[i]) a[i] = max_v b[i] = min_v a_max = max(a_max, max_v) if a[-1] &amp;gt;= a_max and b[-1] &amp;gt;= max(b): return &amp;#39;Yes&amp;#39; return &amp;#39;No&amp;#39; t = int(input()) for _ in range(t): n = int(input()) a = list(map(int, input().</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive
class Solution: def myPow(self, x, n): if not n: return 1 if n &amp;lt; 0: return 1 / self.</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>56. Merge Intervals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</guid><description>LeetCode problem
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:
Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Approach 1:
class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort() res = [intervals[0]] for ir in range(1, len(intervals)): if intervals[ir][0] &amp;gt;= res[-1][0] and intervals[ir][0] &amp;lt;= res[-1][1]: # [1,3],[2,6] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) elif res[-1][0] &amp;gt;= intervals[ir][0] and res[-1][0] &amp;lt;= intervals[ir][1]: # [1,3],[0,4] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) else: res.</description></item><item><title>1799A - Recent Actions - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1799a/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1799a/</guid><description>1799A - Recent Actions (data structures, greedy, implementation, math, 800)
Explanation On Codeforces, the &amp;ldquo;Recent Actions&amp;rdquo; field shows the last n posts with recent actions. Initially, there are posts numbered 1 to n in the field, in order from top to bottom. There are also infinitely many posts not in the field, numbered with integers n+1, n+2, and so on.
When a recent action happens in post p:
If it is in the &amp;ldquo;Recent Actions&amp;rdquo; field, it moves from its position to the top position.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 10^9.</description></item><item><title>66. Plus One</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</guid><description>LeetCode problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Example 1:
Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.</description></item><item><title>69. Sqrt(x)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</guid><description>LeetCode problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2. Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>1788A - One and Two - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1788a/</link><pubDate>Tue, 28 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1788a/</guid><description>1788A - One and Two (brute force, implementation, math, 800)
This problem is about finding a specific index 𝑘 in a given sequence of integers $𝑎_1,𝑎_2,…,𝑎_𝑛$, where each element is either 1 or 2. The goal is to determine whether there exists an integer 𝑘 such that the product of all elements from $𝑎_1$ to $𝑎_𝑘$ is equal to the product of all elements from $𝑎_𝑘+1$ to $𝑎_𝑛$.
Because of product of 1 doesn&amp;rsquo;t change the result we can focus on 2.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>73. Set Matrix Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</guid><description>LeetCode problem
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Approach 1:
Idea:
LeetCode Submission
class Solution: def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None: rows = len(matrix) cols = len(matrix[0]) # 1. Check first row/column for zero&amp;#39;s first_row_has_zero = 0 in matrix[0] first_col_has_zero = 0 in list(zip(*matrix))[0] # 2.</description></item><item><title>75. Sort Colors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</guid><description>LeetCode problem
This problem is also known as the Dutch National Flag problem. One solution is to use three pointers to partition the array into three sections: red, white, and blue.
Here&amp;rsquo;s the algorithm:
Initialize three pointers: left, mid, and right. Initialize left to 0, mid to 0, and right to n-1, where n is the length of the input array. While mid is less than or equal to right: If nums[mid] is 0, swap nums[mid] with nums[left], increment mid and left.</description></item><item><title>78. Subsets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</guid><description>LeetCode problem
In this solution, we start with an empty list in the results array.
For each element in the nums array, we append that element to all of the subsets in the results array to create new subsets, and then add these new subsets to the results array.
By doing this for all elements in nums, we generate all possible subsets.
class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [[]] for i in nums: for j in range(len(res)): cur = [] cur.</description></item><item><title>1778A - Flip Flop Sum - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1778a/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1778a/</guid><description>1778A - Flip Flop Sum (greedy, implementation, 800)
There are three possible conditions:
-1 -1 - all negative. In this case sum -2 becomes sum 2. Plus 4. -1 1 - different, no sum change. 1 1 - all positive. 2 becomes -2. Diff is -4. Solution def solve(): n = int(input()) ar = list(map(int, input().split())) s = 0 # sum # three conditions: all 1, all -1, at least one -1 has_diff = False has2_positive = 0 has2_negative = 0 s += ar[0] for idx in range(1, n): if ar[idx] == ar[idx-1]: if ar[idx] == -1: has2_negative = 4 # -2 -&amp;gt; +2, diff 4 else: has2_positive = -4 # +2 =&amp;gt; +1, diff 1 else: has_diff = True s += ar[idx] if has2_negative: s += has2_negative elif has_diff: .</description></item><item><title>88. Merge Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</link><pubDate>Sun, 30 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</guid><description>LeetCode problem
First accepted class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify nums1 in-place instead. &amp;#34;&amp;#34;&amp;#34; i = len(nums1) - n for j in nums2: nums1[i] = j i += 1 nums1.sort()</description></item><item><title>1772A - A+B? - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1772a/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1772a/</guid><description>1772A - A+B? (implementation, 800)
Solution def solve(): a, b = input().split(&amp;#39;+&amp;#39;) res = int(a) + int(b) print(res) for _ in range(int(input())): solve()</description></item><item><title>94. Binary Tree Inorder Traversal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</guid><description>LeetCode problem
Given the root of a binary tree, return the inorder traversal of its nodes' values.
Example 1:
Input: root = [1,null,2,3] Output: [1,3,2] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Thoughts Don&amp;rsquo;t understand what needed. Why:
1-null-2-3 becomes 1-3-2 [1,2,5,7,8,9,10] becomes [7,2,8,1,9,5,10] In 1-null-2-3 1 becomes the first because we loop to its left node which is null, then come back and first value here is 1.</description></item><item><title>1796B - One and Two - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1796b/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1796b/</guid><description>Asterisk-Minor Template (implementation, strings, 1000)
If the first characters of both strings are the same, create a template that consists of the common character followed by an asterisk (e.g., a*). If the last characters of both strings are the same, create a template that consists of an asterisk followed by the common character (e.g., *b). If neither the first nor the last characters are the same, iterate through string a and check for any 2-character substring that also appears in string b.</description></item><item><title>131. Palindrome Partitioning</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to generate all possible partitions of the given string and then check if every substring in each partition is a palindrome.
However, this approach would be inefficient, as there would be an exponential number of partitions to check.
Approach:
Using Backtracking.
Logic:
Define a helper function, is_palindrome, to check if a given substring is a palindrome. Define the backtrack function to find all palindrome partitions recursively. This function will take the current position in the string and the current partition as input arguments.</description></item><item><title>134. Gas Station</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to try starting from each gas station and check if you can complete the circuit. For each gas station, calculate the remaining gas in the tank after traveling to the next station.
If the gas is not enough to travel to the next station, stop and try starting from the next gas station.
Approach:
In this problem, we can use a greedy algorithm
We can keep track of the total gas and total cost while iterating through the gas stations.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode problem
The problem asks to create a deep copy of a given linked list with a random pointer in each node. A deep copy means that the new linked list will have completely new nodes, and none of its pointers should point to the nodes in the original list. Both the next and random pointers of the new nodes should point to the new nodes in the copied list in the same order as the original list.</description></item><item><title>139. Word Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</guid><description>LeetCode problem
Approach:
Dynamic Programming.
Logic:
Using DP:
Iterate through each character of string s. Generate all possible substrings ending at the current index. Check if the substring is in wordDict: If it is, check if the index before the substring&amp;rsquo;s first index is marked as True (this indicates that the part of the string before the current substring can be segmented into words in wordDict). If it is, then mark the current index as True. Solution:
class Solution: def wordBreak(self, s, wordDict): n = len(s) dp = [False] * n for end in range(1, n + 1): # 1.</description></item><item><title>141. Linked List Cycle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</guid><description>LeetCode problem 141
Problem Statement The problem asks us to determine if a given linked list contains a cycle. A cycle in a linked list occurs when a node&amp;rsquo;s next pointer points back to a previous node in the list, causing an infinite loop.
Hints &amp;amp; Tips In this problem, you can take advantage of the Floyd&amp;rsquo;s &amp;ldquo;Tortoise and Hare&amp;rdquo; cycle detection algorithm. This algorithm allows you to detect a cycle in O(1) space and O(n) time complexity, where n is the number of nodes.</description></item><item><title>146. LRU Cache</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</guid><description>LeetCode problem
The operations we need to support are get and put which should both be done in O(1) time.
get(key) should return the value if the key exists in the cache, otherwise return -1. put(key, value) should update the value of the key if the key exists; otherwise, this method should insert the key-value pair into the cache. If the cache is full, this method should also evict the least recently used key-value pair. Approach Use Doubly Linked List or Python OrderedDict</description></item><item><title>148. Sort List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</guid><description>LeetCode problem
Naive Solution Traverse the linked list, adding each node&amp;rsquo;s value to a Python list sort that list create a new linked list from the sorted values return the head of this new list. This solution would have a time complexity of O(n log n) due to the sort operation and a space complexity of O(n) because of the extra list we&amp;rsquo;re creating.
class Solution: def sortList(self, head): values = [] node = head while node: values.append(node.val) node = node.</description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</guid><description>LeetCode задача 151
Задача На вход подается строка s. Нам необходимо перевернуть порядок слов в этой строке. Слова определяются как последовательность символов без пробелов. Слова в s разделены хотя бы одним пробелом. Нужно вернуть строку, в которой слова расположены в обратном порядке, разделенные одним пробелом.
Важно: строка s может содержать начальные или конечные пробелы или множественные пробелы между двумя словами. В возвращаемой строке должен быть только один пробел, разделяющий слова. Лишние пробелы не включаем.
Подход Для решения задачи мы можем разделить строку на слова, используя пробел в качестве разделителя, а затем просто объединить их в обратном порядке.</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>160. Intersection of Two Linked Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</link><pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</guid><description>LeetCode problem
Solution 1 Using hashmap.
# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode): nodes = set() cur = headA while cur: nodes.add(cur) cur = cur.next cur = headB while cur: if cur in nodes: return cur cur = cur.next return None Solution 2 Initialize two pointers, one for each head. Move each pointer to the next node in its list. If a pointer reaches the end of its list, move it to the start of the other list.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem 166
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>171. Excel Sheet Column Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</guid><description>LeetCode problem
The column titles in an Excel sheet are designed similar to a base-26 number system. The columns start from &amp;lsquo;A&amp;rsquo; (which is 1) to &amp;lsquo;Z&amp;rsquo; (which is 26), then after &amp;lsquo;Z&amp;rsquo;, the column titles go to &amp;lsquo;AA&amp;rsquo; (which is 27), &amp;lsquo;AB&amp;rsquo; (28), and so on.
This problem is essentially asking us to convert a base-26 number (represented by uppercase English letters) to a decimal number.
That means that for each &amp;ldquo;new&amp;rdquo; index in columnTitle we already pass alphabet.</description></item><item><title>172. Factorial Trailing Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/172/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/172/</guid><description>LeetCode problem 172
class Solution: def trailingZeroes(self, n: int) -&amp;gt; int: res = 0 while n: n //= 5 res += n return res</description></item><item><title>173. Binary Search Tree Iterator</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/173/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/173/</guid><description>LeetCode problem 173
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] while root: self.stack.append(root) root = root.left def next(self) -&amp;gt; int: cur = self.stack.pop() node = cur.right while node: self.stack.append(node) node = node.left return cur.val def hasNext(self) -&amp;gt; bool: return len(self.stack) &amp;gt; 0 # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.</description></item><item><title>176. Second Highest Salary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/176/</guid><description>LeetCode problem 176
Drop any duplicate salary values to avoid counting duplicates as separate salary ranks Sort the unique salaries in descending order and get the second highest salary If the second highest salary doesn&amp;rsquo;t exist (e.g., there are fewer than two unique salaries), return None Create a DataFrame with the second highest salary import pandas as pd def second_highest_salary(employee: pd.DataFrame) -&amp;gt; pd.DataFrame: unique_salaries = employee[&amp;#34;salary&amp;#34;].drop_duplicates() second_highest = ( unique_salaries.nlargest(2).iloc[-1] if len(unique_salaries) &amp;gt;= 2 else None ) if second_highest is None: return pd.</description></item><item><title>177. Nth Highest Salary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/177/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/177/</guid><description>LeetCode problem 177
import pandas as pd def nth_highest_salary(employee: pd.DataFrame, N: int) -&amp;gt; pd.DataFrame: unique_salaries = employee.salary.unique() if len(unique_salaries) &amp;lt; N: return pd.DataFrame([np.NaN], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;]) salary = sorted(unique_salaries, reverse=True)[N - 1] return pd.DataFrame([salary], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;])</description></item><item><title>178. Rank Scores</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/178/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/178/</guid><description>LeetCode problem 178
import pandas as pd def order_scores(scores: pd.DataFrame) -&amp;gt; pd.DataFrame: # Use the rank method to assign ranks to the scores in descending order with no gaps scores[&amp;#34;rank&amp;#34;] = scores[&amp;#34;score&amp;#34;].rank(method=&amp;#34;dense&amp;#34;, ascending=False) # Drop id column &amp;amp; Sort the DataFrame by score in descending order result_df = scores.drop(&amp;#34;id&amp;#34;, axis=1).sort_values(by=&amp;#34;score&amp;#34;, ascending=False) return result_df</description></item><item><title>179. Largest Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/179/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/179/</guid><description>LeetCode problem 179
class Solution: def largestNumber(self, nums: List[int]) -&amp;gt; str: nums = [str(v) for v in nums] nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b &amp;lt; b + a else -1)) return &amp;#34;0&amp;#34; if nums[0] == &amp;#34;0&amp;#34; else &amp;#34;&amp;#34;.join(nums)</description></item><item><title>180. Consecutive Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/180/</guid><description>LeetCode problem 180
import pandas as pd def consecutive_numbers(logs: pd.DataFrame) -&amp;gt; pd.DataFrame: all_the_same = lambda lst: lst.nunique() == 1 logs[&amp;#34;is_consecutive&amp;#34;] = ( logs[&amp;#34;num&amp;#34;].rolling(window=3, center=True, min_periods=3).apply(all_the_same) ) return ( logs.query(&amp;#34;is_consecutive == 1.0&amp;#34;)[[&amp;#34;num&amp;#34;]] .drop_duplicates() .rename(columns={&amp;#34;num&amp;#34;: &amp;#34;ConsecutiveNums&amp;#34;}) )</description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</guid><description>LeetCode problem
Problem Statement Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Naive Solution A simple, but inefficient, approach would be to rotate the array k times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations.</description></item><item><title>190. Reverse Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</guid><description>LeetCode problem
This task involves understanding how binary representation works. An unsigned integer is a 32-bit value, where each bit represents a power of 2, from 2^0 (the least significant bit) to 2^31 (the most significant bit).
Unsigned Integers (often called &amp;ldquo;uints&amp;rdquo;) are just like integers (whole numbers) but have the property that they don&amp;rsquo;t have a + or - sign associated with them. Thus they are always non-negative (zero or positive).
Naive Solution A naive solution to this problem could involve converting the number to a binary string, reversing the string, and then converting it back to an integer.</description></item><item><title>191. Number of 1 Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</guid><description>LeetCode problem
Problem Statement Given an integer value represented in binary format, we need to count the number of &amp;lsquo;1&amp;rsquo; bits in its binary representation.
Naive Solution The naive solution for this problem would be to convert the binary number into a string and then simply iterate over the string and count the number of &amp;lsquo;1&amp;rsquo;s. However, this solution is not optimal and is not taking advantage of the properties of binary numbers.
Algorithm The optimal solution for this problem involves using bitwise operation.</description></item><item><title>202. Happy Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</link><pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a number n. We have to determine whether this number is a &amp;ldquo;happy&amp;rdquo; number or not. A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.</description></item><item><title>206. Reverse Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/206/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/206/</guid><description>LeetCode problem 206
Problem Statement Reverse a given singly linked list and return its head. A singly linked list is a data structure consisting of nodes, where each node has a value and a reference to the next node in the sequence.
Naive Solution A naive approach could be to traverse the entire linked list once to read all its elements into an array. Then, we could reverse the array and construct a new linked list from it. This would work, but it takes up additional space for the array.</description></item><item><title>229. Majority Element II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/229/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/229/</guid><description>LeetCode problem 229
Problem Statement Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Naive Solution The immediate solution would involve using a hashmap or dictionary to track the occurrence of each number in the array. After which, we can iterate over the dictionary to find numbers whose occurrences are greater than n/3.
Hints &amp;amp; Tips There can be at most one or two majority elements which appear more than n/3 times in the array.</description></item><item><title>234. Palindrome Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</guid><description>LeetCode problem
Problem Statement Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
Naive Solution A simple solution to this problem is to:
traverse the linked list storing the value of each node in an array. Then, we could compare the array with its reversed version.
If they match, the linked list is a palindrome. Otherwise, it is not.
This solution takes O(n) time (where n is the number of nodes in the list), as we need to traverse the list once.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</guid><description>LeetCode problem
Problem Statement The problem is to find a product of all elements in the given integer array nums, except for the i-th element, and return a new array with the results. You must design an algorithm that runs in O(n) time and doesn&amp;rsquo;t use the division operation. The challenge here is to solve this problem with O(1) extra space complexity.
Naive Solution A naive solution could be to calculate the product of all elements in the array, then iterate through the array and replace each element with the total product divided by the element.</description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</guid><description>LeetCode problem
Problem Statement The problem is asking to move all zeros in an integer array to the end of the array while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.
Naive Solution A naive solution could be to create a new list, iterate over the array, add non-zero elements to the new list and count zero elements. Then extend the new list with the same amount of zeros as counted.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode problem 287
Problem Statement Given an array of integers nums containing n + 1 integers where each integer is within the range [1, n], you need to find and return the only duplicate number present in nums.
The key constraints:
You shouldn&amp;rsquo;t modify the array nums. You should only use constant extra space. Naive Solution One possible naive solution would be to use a nested loop to compare each element with every other element in the array. This approach, however, is not efficient and has a time complexity of O(n^2), which doesn&amp;rsquo;t scale well with large inputs.</description></item><item><title>332. Reconstruct Itinerary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</guid><description>LeetCode problem
Problem Statement Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from &amp;ldquo;JFK&amp;rdquo;, thus, the itinerary must begin with &amp;ldquo;JFK&amp;rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
Naive Solution One naive solution would be to use backtracking and try all possible combinations of tickets to form a valid itinerary.</description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</guid><description>LeetCode problem
Problem Statement The task is to determine if the given list of numbers contains an increasing subsequence of length three. This means we need to find three indices i, j, and k in the list such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k].
Naive Solution One possible naive solution is to use three nested loops to go through all possible triples in the list and check if they are increasing. But this solution is very inefficient, has a time complexity of O(n³), and does not meet the follow-up constraints of the problem.</description></item><item><title>343. Integer Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/343/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/343/</guid><description>LeetCode problem 343
Problem Statement Given a positive integer n, our task is to divide it into the sum of k positive integers, where $k \geq 2$, in such a way that the product of these integers is maximized. Our goal is to determine the maximum possible product.
Naive Solution A straightforward or naive way to solve this would be to consider all potential combinations to divide the number n and calculate the product for each division. This method, while comprehensive, would be inefficient and impractical for larger values of n.</description></item><item><title>345. Reverse Vowels of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</guid><description>LeetCode problem
Problem Statement Given a string s, the task is to reverse only all the vowels in the string and return it. The vowels are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;, and they can appear in both lower and upper cases, more than once.
Naive Solution The naive approach to solve this problem would be to:
Initialize an empty string result. Traverse the given string s from the start to the end. If the current character is a vowel, find the next vowel in the string starting from the end, add it to result, and remove it from the string.</description></item><item><title>389. Find the Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/389/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/389/</guid><description>LeetCode problem 389
Problem Statement Given two strings s and t, the string t is generated by shuffling the characters of s and adding one additional character at a random position. The task is to identify and return that extra character.
Naive Solution A naive solution would involve comparing the characters in both strings one by one to detect the extra character in t. This method is not efficient as it could take a linear amount of time for strings of considerable lengths.</description></item><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</guid><description>LeetCode problem 392
Problem Statement Given two strings s and t, you need to determine if s is a subsequence of t. To be a subsequence, you can remove characters from t without reordering to form s.
Naive Solution The naive approach would be to generate all subsequences of string t and then check if string s is one of them. However, generating all subsequences of t can be computationally expensive especially when the length of t is large.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode problem
Problem Statement Given an encoded string, the task is to decode it to produce a string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.
Naive Solution A naive approach would be to repeatedly look for a pattern in the string where there is a number followed by square brackets. For each such pattern found, replace it with the string inside the square brackets repeated &amp;lsquo;k&amp;rsquo; times. This would work but might not be the most efficient solution, especially for nested brackets.</description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</guid><description>LeetCode problem
Problem Statement Given a list of characters, chars, you are required to compress the list using the following algorithm:
Start with an empty string, s. For each group of consecutive repeating characters in chars: If the group&amp;rsquo;s length is 1, append the character to s. Otherwise, append the character followed by the group&amp;rsquo;s length. The compressed string s should be stored back in the chars list. The length of the group that is 10 or longer will be split into multiple characters in chars.</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode problem 605
In this problem, we are given a flowerbed represented by an integer array flowerbed, where 0 represents an empty plot and 1 represents a plot with a flower.
We need to determine if we can plant n new flowers in the flowerbed without violating the rule that no two adjacent plots can have flowers.
Naive Solution To solve this problem, we can use a greedy approach. We iterate through the flowerbed and check each plot. If a plot is empty and its adjacent plots are also empty, we can plant a flower in that plot.</description></item><item><title>643. Maximum Average Subarray I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</guid><description>LeetCode problem
Problem Statement Given an integer array nums consisting of n elements and an integer k, find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. The result must be accurate up to a decimal point of 10^(-5).
Naive Solution A straightforward approach would be to calculate the average for every possible subarray of length k. For each starting point, sum the next k numbers and determine the average.</description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</guid><description>LeetCode problem
Problem Statement Given an array of integers nums, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.
Naive Solution A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode problem 725
Problem Statement The problem asks you to divide a given singly linked list into k different parts such that the sizes of these parts are as nearly equal as possible. The parts should appear in the same order as in the original list, and earlier parts should not be smaller than later parts.
Naive Solution A naive approach would involve counting the length of the list and then traversing the list multiple times to create each part.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode problem
Problem Statement Imagine a row of asteroids moving in space. Each asteroid has a size (given by its absolute value) and a direction it&amp;rsquo;s moving in (given by its sign: positive for right, negative for left). All asteroids move at the same speed. Your task is to determine the final state of the asteroids after all collisions have been resolved.
Two important points to note:
When two asteroids of different directions meet, the smaller one explodes. If they are of the same size, both explode.</description></item><item><title>777. Swap Adjacent in LR String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/777/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/777/</guid><description>LeetCode problem 777
class Solution: def canTransform(self, start: str, end: str) -&amp;gt; bool: n = len(start) i = j = 0 while 1: while i &amp;lt; n and start[i] == &amp;#39;X&amp;#39;: i += 1 while j &amp;lt; n and end[j] == &amp;#39;X&amp;#39;: j += 1 if i &amp;gt;= n and j &amp;gt;= n: return True if i &amp;gt;= n or j &amp;gt;= n or start[i] != end[j]: return False if start[i] == &amp;#39;L&amp;#39; and i &amp;lt; j: return False if start[i] == &amp;#39;R&amp;#39; and i &amp;gt; j: return False i, j = i + 1, j + 1</description></item><item><title>779. K-th Symbol in Grammar</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/779/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/779/</guid><description>LeetCode problem 779
class Solution: def kthGrammar(self, n: int, k: int) -&amp;gt; int: return (k - 1).bit_count() &amp;amp; 1</description></item><item><title>781. Rabbits in Forest</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/781/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/781/</guid><description>LeetCode problem 781
class Solution: def numRabbits(self, answers: List[int]) -&amp;gt; int: counter = Counter(answers) return sum([math.ceil(v / (k + 1)) * (k + 1) for k, v in counter.items()])</description></item><item><title>784. Letter Case Permutation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/784/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/784/</guid><description>LeetCode problem 784
class Solution: def letterCasePermutation(self, s: str) -&amp;gt; List[str]: res = [] n = sum(c.isalpha() for c in s) for i in range(1 &amp;lt;&amp;lt; n): j, t = 0, [] for c in s: if c.isalpha(): c = c.lower() if (i &amp;gt;&amp;gt; j) &amp;amp; 1 else c.upper() j += 1 t.append(c) res.append(&amp;#39;&amp;#39;.join(t)) return res</description></item><item><title>785. Is Graph Bipartite</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/785/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/785/</guid><description>LeetCode problem 785
class Solution: def isBipartite(self, graph: List[List[int]]) -&amp;gt; bool: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(len(graph))) for u, g in enumerate(graph): for v in g: if find(u) == find(v): return False p[find(v)] = find(g[0]) return True</description></item><item><title>786. K-th Smallest Prime Fraction</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/786/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/786/</guid><description>LeetCode problem 786
class Solution: def kthSmallestPrimeFraction(self, arr: List[int], k: int) -&amp;gt; List[int]: h = [(1 / y, 0, j + 1) for j, y in enumerate(arr[1:])] heapify(h) for _ in range(k - 1): _, i, j = heappop(h) if i + 1 &amp;lt; j: heappush(h, (arr[i + 1] / arr[j], i + 1, j)) return [arr[h[0][1]], arr[h[0][2]]]</description></item><item><title>787. Cheapest Flights Within K Stops</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/787/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/787/</guid><description>LeetCode problem 787
class Solution: def findCheapestPrice( self, n: int, flights: List[List[int]], src: int, dst: int, k: int ) -&amp;gt; int: @cache def dfs(u, k): if u == dst: return 0 if k &amp;lt;= 0: return inf k -= 1 res = inf for v, p in g[u]: res = min(res, dfs(v, k) + p) return res g = defaultdict(list) for u, v, p in flights: g[u].append((v, p)) res = dfs(src, k + 1) return -1 if res &amp;gt;= inf else res</description></item><item><title>788. Rotated Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/788/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/788/</guid><description>LeetCode problem 788
class Solution: def rotatedDigits(self, n: int) -&amp;gt; int: @cache def dfs(pos, ok, limit): if pos &amp;lt;= 0: return ok up = a[pos] if limit else 9 res = 0 for i in range(up + 1): if i in (0, 1, 8): res += dfs(pos - 1, ok, limit and i == up) if i in (2, 5, 6, 9): res += dfs(pos - 1, 1, limit and i == up) return res a = [0] * 6 l = 1 while n: a[l] = n % 10 n //= 10 l += 1 return dfs(l, 0, True)</description></item><item><title>789. Escape The Ghosts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/789/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/789/</guid><description>LeetCode problem 789
class Solution: def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -&amp;gt; bool: tx, ty = target return all(abs(tx - x) + abs(ty - y) &amp;gt; abs(tx) + abs(ty) for x, y in ghosts)</description></item><item><title>790. Domino and Tromino Tiling</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/790/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/790/</guid><description>LeetCode problem 790
class Solution: def numTilings(self, n: int) -&amp;gt; int: f = [1, 0, 0, 0] mod = 10**9 + 7 for i in range(1, n + 1): g = [0] * 4 g[0] = (f[0] + f[1] + f[2] + f[3]) % mod g[1] = (f[2] + f[3]) % mod g[2] = (f[1] + f[3]) % mod g[3] = f[0] f = g return f[0]</description></item><item><title>791. Custom Sort String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/791/</guid><description>LeetCode problem 791
class Solution: def customSortString(self, order: str, s: str) -&amp;gt; str: cnt = Counter(s) res = [] for c in order: res.append(c * cnt[c]) cnt[c] = 0 for c, v in cnt.items(): res.append(c * v) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>792. Number of Matching Subsequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/792/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/792/</guid><description>LeetCode problem 792
class Solution: def numMatchingSubseq(self, s: str, words: List[str]) -&amp;gt; int: def check(w): i = -1 for c in w: j = bisect_right(d[c], i) if j == len(d[c]): return False i = d[c][j] return True d = defaultdict(list) for i, c in enumerate(s): d[c].append(i) return sum(check(w) for w in words)</description></item><item><title>794. Valid Tic-Tac-Toe State</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/794/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/794/</guid><description>LeetCode problem 794
class Solution: def validTicTacToe(self, board: List[str]) -&amp;gt; bool: def win(x): for i in range(3): if all(board[i][j] == x for j in range(3)): return True if all(board[j][i] == x for j in range(3)): return True if all(board[i][i] == x for i in range(3)): return True return all(board[i][2 - i] == x for i in range(3)) x = sum(board[i][j] == &amp;#39;X&amp;#39; for i in range(3) for j in range(3)) o = sum(board[i][j] == &amp;#39;O&amp;#39; for i in range(3) for j in range(3)) if x !</description></item><item><title>795. Number of Subarrays with Bounded Maximum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/795/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/795/</guid><description>LeetCode problem 795
class Solution: def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -&amp;gt; int: n = len(nums) l, r = [-1] * n, [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;lt;= v: stk.pop() if stk: l[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: r[i] = stk[-1] stk.append(i) return sum( (i - l[i]) * (r[i] - i) for i, v in enumerate(nums) if left &amp;lt;= v &amp;lt;= right )</description></item><item><title>797. All Paths From Source to Target</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/797/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/797/</guid><description>LeetCode problem 797
class Solution: def allPathsSourceTarget(self, graph: List[List[int]]) -&amp;gt; List[List[int]]: def dfs(t): if t[-1] == len(graph) - 1: res.append(t[:]) return for v in graph[t[-1]]: t.append(v) dfs(t) t.pop() res = [] dfs([0]) return res</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</guid><description>LeetCode problem 799
class Solution: def champagneTower(self, poured: int, query_row: int, query_glass: int) -&amp;gt; float: f = [poured] for i in range(1, query_row + 1): g = [0] * (i + 1) for j, v in enumerate(f): if v &amp;gt; 1: half = (v - 1) / 2 g[j] += half g[j + 1] += half f = g return min(1, f[query_glass])</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/799/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/799/</guid><description>LeetCode problem 799
Problem Statement You are tasked with modeling a champagne tower. Glasses are stacked in a pyramid, with each row having one more glass than the previous. When champagne is poured into the top glass and it overflows, the overflowed champagne is split equally between the two glasses below. The objective is to determine how full a specified glass will be after pouring a given amount of champagne.
Naive Solution One could imagine a simulation, where we pour champagne into the top glass and then, glass-by-glass, simulate the overflow until we reach the desired glass.</description></item><item><title>802. Find Eventual Safe States</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/802/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/802/</guid><description>LeetCode problem 802
class Solution: def eventualSafeNodes(self, graph: List[List[int]]) -&amp;gt; List[int]: def dfs(i): if color[i]: return color[i] == 2 color[i] = 1 for j in graph[i]: if not dfs(j): return False color[i] = 2 return True n = len(graph) color = [0] * n return [i for i in range(n) if dfs(i)]</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>Round #849/1791 (Div. 4)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/849-div-4-1791/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/849-div-4-1791/</guid><description>TODO G2 Contest date: 2023-02-03
Contest problems
Editorial
Template with function snippets
A. Codeforces Checking https://codeforces.com/contest/1791/problem/A
Solution:
def solve(letter): code = &amp;#34;codeforces&amp;#34; if letter in code: print(&amp;#34;YES&amp;#34;) else: print(&amp;#34;NO&amp;#34;) for _ in range(int(inp())): letter = inp() solve(letter) B. Following Directions https://codeforces.com/contest/1791/problem/B
geometry, implementation, *800
Solution:
def solve(n, s): x = 0 y = 0 for move in s: if move == &amp;#39;L&amp;#39;: x -= 1 elif move == &amp;#39;R&amp;#39;: x += 1 elif move == &amp;#39;U&amp;#39;: y += 1 elif move == &amp;#39;D&amp;#39;: y -= 1 if x == 1 and y == 1: print(&amp;#34;YES&amp;#34;) break else: print(&amp;#34;NO&amp;#34;) for _ in range(int(inp())): # attempts num = int(inp()) letter = inp() solve(num, letter) C.</description></item><item><title>880. Decoded String at Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/880/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/880/</guid><description>LeetCode problem 880
Problem Statement Given an encoded string s, the encoded string is transformed into a tape based on the following criteria:
When a letter is encountered, it&amp;rsquo;s written on the tape. When a digit d is encountered, the current content of the tape is repeated d - 1 more times. You are required to find and return the kth letter (1-indexed) on the decoded tape.
Naive Solution A straightforward solution would involve constructing the entire decoded tape and then simply accessing the kth character.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1004/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1004/</guid><description>LeetCode Problem 1004
Problem Statement Given a binary array nums and an integer k, the task is to return the maximum number of consecutive 1&amp;rsquo;s in the array, with the possibility to flip at most k 0&amp;rsquo;s.
Naive Solution A straight forward approach is to try flipping every combination of k zeros and checking for the longest sequence of 1&amp;rsquo;s. This would involve nested loops, with the outer loop iterating through the array and the inner loops flipping zeros and calculating sequences of 1&amp;rsquo;s.</description></item><item><title>1048. Longest String Chain</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</guid><description>LeetCode problem 1048
Problem Statement You are given an array of words where each word consists of lowercase English letters. Your task is to determine the longest string chain you can form given this list. A word A can be a predecessor of word B if by adding exactly one letter to A (at any position), B is formed. The objective is to find the longest sequence where each word is a predecessor of the next.
Naive Solution The straightforward brute-force way would be to try all possible combinations of word chains.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode problem
Problem Statement The problem is about finding a greatest common divisor (GCD) of two strings. The term &amp;ldquo;GCD&amp;rdquo; might be familiar from mathematics, as the largest number that divides two numbers without leaving a remainder. Here, we extend the idea to strings: a string x is a GCD of strings str1 and str2 if x can be repeatedly appended to itself to obtain str1 and str2.
Naive Solution A naive approach would be to find all possible divisors of str1 and str2, and then find the largest common divisor.</description></item><item><title>1101. The Earliest Moment When Everyone Become Friends</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1101/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1101/</guid><description>LeetCode problem 1101
class UnionFind: __slots__ = (&amp;#39;p&amp;#39;, &amp;#39;size&amp;#39;) def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x: int) -&amp;gt; int: if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a: int, b: int) -&amp;gt; bool: pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def earliestAcq(self, logs: List[List[int]], n: int) -&amp;gt; int: uf = UnionFind(n) for t, x, y in sorted(logs): if uf.</description></item><item><title>1102. Path With Maximum Minimum Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1102/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1102/</guid><description>LeetCode problem 1102
class UnionFind: __slots__ = (&amp;#34;p&amp;#34;, &amp;#34;size&amp;#34;) def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x: int) -&amp;gt; int: if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a: int, b: int) -&amp;gt; bool: pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def maximumMinimumPath(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) uf = UnionFind(m * n) q = [(v, i, j) for i, row in enumerate(grid) for j, v in enumerate(row)] q.</description></item><item><title>1104. Path In Zigzag Labelled Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1104/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1104/</guid><description>LeetCode problem 1104
class Solution: def pathInZigZagTree(self, label: int) -&amp;gt; List[int]: x = i = 1 while (x &amp;lt;&amp;lt; 1) &amp;lt;= label: x &amp;lt;&amp;lt;= 1 i += 1 res = [0] * i while i: res[i - 1] = label label = ((1 &amp;lt;&amp;lt; (i - 1)) + (1 &amp;lt;&amp;lt; i) - 1 - label) &amp;gt;&amp;gt; 1 i -= 1 return res</description></item><item><title>1105. Filling Bookcase Shelves</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1105/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1105/</guid><description>LeetCode problem 1105
class Solution: def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -&amp;gt; int: n = len(books) f = [0] * (n + 1) for i, (w, h) in enumerate(books, 1): f[i] = f[i - 1] + h for j in range(i - 1, 0, -1): w += books[j - 1][0] if w &amp;gt; shelfWidth: break h = max(h, books[j - 1][1]) f[i] = min(f[i], f[j - 1] + h) return f[n]</description></item><item><title>1109. Corporate Flight Bookings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1109/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1109/</guid><description>LeetCode problem 1109
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) def update(self, x, delta): while x &amp;lt;= self.n: self.c[x] += delta x += x &amp;amp; -x def query(self, x): s = 0 while x: s += self.c[x] x -= x &amp;amp; -x return s class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -&amp;gt; List[int]: tree = BinaryIndexedTree(n) for first, last, seats in bookings: tree.update(first, seats) tree.update(last + 1, -seats) return [tree.</description></item><item><title>1110. Delete Nodes And Return Forest</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1110/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1110/</guid><description>LeetCode problem 1110
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def delNodes( self, root: Optional[TreeNode], to_delete: List[int] ) -&amp;gt; List[TreeNode]: def dfs(root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: if root is None: return None root.left, root.right = dfs(root.left), dfs(root.right) if root.val not in s: return root if root.left: res.append(root.left) if root.right: res.append(root.right) return None s = set(to_delete) res = [] if dfs(root): res.</description></item><item><title>1111. Maximum Nesting Depth of Two Valid Parentheses Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1111/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1111/</guid><description>LeetCode problem 1111
class Solution: def maxDepthAfterSplit(self, seq: str) -&amp;gt; List[int]: res = [0] * len(seq) x = 0 for i, c in enumerate(seq): if c == &amp;#34;(&amp;#34;: res[i] = x &amp;amp; 1 x += 1 else: x -= 1 res[i] = x &amp;amp; 1 return res</description></item><item><title>1115. Print FooBar Alternately</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1115/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1115/</guid><description>LeetCode problem 1115
from threading import Semaphore class FooBar: def __init__(self, n): self.n = n self.f = Semaphore(1) self.b = Semaphore(0) def foo(self, printFoo: &amp;#34;Callable[[], None]&amp;#34;) -&amp;gt; None: for _ in range(self.n): self.f.acquire() # printFoo() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line. printFoo() self.b.release() def bar(self, printBar: &amp;#34;Callable[[], None]&amp;#34;) -&amp;gt; None: for _ in range(self.n): self.b.acquire() # printBar() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line. printBar() self.f.release()</description></item><item><title>1116. Print Zero Even Odd</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1116/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1116/</guid><description>LeetCode problem 1116
from threading import Semaphore class ZeroEvenOdd: def __init__(self, n): self.n = n self.z = Semaphore(1) self.e = Semaphore(0) self.o = Semaphore(0) # printNumber(x) outputs &amp;#34;x&amp;#34;, where x is an integer. def zero(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(self.n): self.z.acquire() printNumber(0) if i % 2 == 0: self.o.release() else: self.e.release() def even(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(2, self.n + 1, 2): self.e.acquire() printNumber(i) self.z.release() def odd(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(1, self.</description></item><item><title>1120. Maximum Average Subtree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1120/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1120/</guid><description>LeetCode problem 1120
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maximumAverageSubtree(self, root: Optional[TreeNode]) -&amp;gt; float: def dfs(root): if root is None: return 0, 0 ls, ln = dfs(root.left) rs, rn = dfs(root.right) s = root.val + ls + rs n = 1 + ln + rn nonlocal res res = max(res, s / n) return s, n res = 0 dfs(root) return res</description></item><item><title>1123. Lowest Common Ancestor of Deepest Leaves</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1123/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1123/</guid><description>LeetCode problem 1123
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def lcaDeepestLeaves(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: def dfs(root): if root is None: return None, 0 l, d1 = dfs(root.left) r, d2 = dfs(root.right) if d1 &amp;gt; d2: return l, d1 + 1 if d1 &amp;lt; d2: return r, d2 + 1 return root, d1 + 1 return dfs(root)[0]</description></item><item><title>1207. Unique Number of Occurrences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1207/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1207/</guid><description>LeetCode problem
Problem Statement Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
Naive Solution A naive approach would be to create a dictionary to store the count of each integer, then iterate over the dictionary and compare each count with the counts of other integers. This approach requires O(n^2) time complexity, where n is the length of the array. This is not efficient for large input sizes.</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1359/</guid><description>LeetCode problem 1359
Problem Statement You&amp;rsquo;re tasked with finding all valid sequences of pickup and delivery events for n orders such that for every order, the delivery always comes after its respective pickup. Because the answer can be immense, you&amp;rsquo;re to return the result modulo (10^9 + 7).
Naive Solution A straightforward approach might be to generate all potential permutations of pickup and delivery actions and then exclude the unsuitable ones. However, this method would be exceedingly inefficient and would not scale for larger n values.</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1372/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1372/</guid><description>LeetCode problem 1372
Problem Statement Given the root of a binary tree, the task is to find the longest ZigZag path contained in that tree. A ZigZag path is defined by a sequence starting at any node and switching between left and right directions at each subsequent step.
Naive Solution A simplistic approach would be to kick off from every node and emulate the ZigZag movement until it&amp;rsquo;s no longer feasible, all the while updating the longest path encountered.</description></item><item><title>1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1420/</link><pubDate>Thu, 21 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1420/</guid><description>LeetCode Problem 1420
Problem Statement In this problem, we have three integers, n, m, and k. We need to construct an array arr having the following properties:
It consists of exactly n integers. Each integer in the array is between 1 and m inclusive. After executing a certain algorithm on arr, we get a value known as search_cost. Our goal is to ensure search_cost is equal to k. The main challenge is determining how many ways we can construct such an array arr.</description></item><item><title>1431. Kids With the Greatest Number of Candies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1431/</link><pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1431/</guid><description>LeetCode problem 1431. Kids With the Greatest Number of Candies
Problem Statement Imagine you&amp;rsquo;re in a classroom with a bunch of kids, and each kid has a certain number of candies. You, being super generous, have some extra candies to give away. Now, you&amp;rsquo;re wondering, if you give all these extra candies to one kid at a time, will that kid end up having the most candies in the class? And you want to check this for every kid in the class.</description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</guid><description>LeetCode Problem 1456
Problem Statement Given a string s and an integer k, the task is to return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.
Naive Solution The most straightforward solution to this problem is to take every possible substring of length k and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length k.</description></item><item><title>1481. Least Number of Unique Integers after K Removals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1481/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1481/</guid><description>LeetCode problem 1481
class Solution: def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -&amp;gt; int: counter = Counter(arr) for i, v in enumerate(sorted(counter.values())): k -= v if k &amp;lt; 0: return len(counter) - i return 0</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1657. Determine if Two Strings Are Close</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</guid><description>LeetCode problem
Problem Statement Two strings are considered close if you can attain one from the other using two operations:
Swap any two existing characters. Transform every occurrence of one existing character into another existing character, and do the same with the other character. The challenge is to determine whether two given strings are close or not.
Naive Solution A naive approach might involve trying every possible combination of operations on the two strings until they match or until you&amp;rsquo;ve exhausted all possibilities.</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1658/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1658/</guid><description>LeetCode problem 1658
Problem Statement You have an integer array nums and another integer x. In a single operation, you can either remove the leftmost or the rightmost element from the array nums and decrement x by the value of the removed element. The question is: What is the minimum number of operations required to reduce x to exactly zero? If it&amp;rsquo;s not feasible, the answer should be -1.
Naive Solution The naive approach would be to explore every possible combination of removing elements from the start or the end, recursively.</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1732/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1732/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a biker who is going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal to 0.
We are also given an integer array gain of length n where gain[i] represents the net gain in altitude between points i and i + 1 for all 0 &amp;lt;= i &amp;lt; n. The net gain could be negative, indicating a decrease in altitude, or positive, indicating an increase in altitude.</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1768/</guid><description>LeetCode problem
Problem Statement The task is to merge two strings alternately, i.e., take one character from the first string, then one from the second, then again from the first, and so on. If one string finishes before the other, the remaining characters from the longer string are appended at the end.
Naive Solution A naive approach could involve maintaining two pointers, one for each string, and incrementally appending characters from each string to the result. Once we reach the end of one string, we append the rest of the other string to the result.</description></item><item><title>1887. Reduction Operations to Make the Array Elements Equal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1887/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1887/</guid><description>LeetCode Problem 1887
Problem Statement The goal of this problem is to make all elements in a given integer array nums equal, through a series of reduction operations. In each operation, we find the largest element in the array, find the next largest element that is strictly smaller than the largest, and reduce the largest element to this next largest value. The task is to return the number of such operations needed to make all array elements equal.</description></item><item><title>2108. Find First Palindromic String in the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2108/</guid><description>LeetCode problem 2108
class Solution: def firstPalindrome(self, words: List[str]) -&amp;gt; str: return next((w for w in words if w == w[::-1]), &amp;#34;&amp;#34;)</description></item><item><title>2215. Find the Difference of Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</guid><description>LeetCode problem
Problem Statement Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:
answer[0] is a list of all distinct integers in nums1 which are not present in nums2. answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order.
Naive Solution A naive approach would be to iterate over each element of the first array and check whether it&amp;rsquo;s in the second array.</description></item><item><title>2251. Number of Flowers in Full Bloom</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</guid><description>LeetCode Problem 2251
Problem Statement In the given problem, we are presented with two arrays. The first, flowers, represents when each flower starts and stops being in full bloom. The second, people, indicates when each person arrives to see the flowers. Our task is to determine, for each person, how many flowers they will see in full bloom upon their arrival.
Naive Solution A straightforward approach might involve iterating over each person&amp;rsquo;s arrival time. For each time, we could iterate over the flowers list to count how many flowers are in full bloom.</description></item><item><title>2283. Check if Number Has Equal Digit Count and Digit Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2283/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2283/</guid><description>LeetCode problem 2283
class Solution: def digitCount(self, num: str) -&amp;gt; bool: cnt = Counter(num) return all(cnt[str(i)] == int(v) for i, v in enumerate(num))</description></item><item><title>2287. Rearrange Characters to Make Target String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2287/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2287/</guid><description>LeetCode problem 2287
class Solution: def rearrangeCharacters(self, s: str, target: str) -&amp;gt; int: cnt1 = Counter(s) cnt2 = Counter(target) return min(cnt1[c] // v for c, v in cnt2.items())</description></item><item><title>2293. Min Max Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2293/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2293/</guid><description>LeetCode problem 2293
class Solution: def minMaxGame(self, nums: List[int]) -&amp;gt; int: n = len(nums) while n &amp;gt; 1: n &amp;gt;&amp;gt;= 1 for i in range(n): a, b = nums[i &amp;lt;&amp;lt; 1], nums[i &amp;lt;&amp;lt; 1 | 1] nums[i] = min(a, b) if i % 2 == 0 else max(a, b) return nums[0]</description></item><item><title>2299. Strong Password Checker II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2299/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2299/</guid><description>LeetCode problem 2299
class Solution: def strongPasswordCheckerII(self, password: str) -&amp;gt; bool: if len(password) &amp;lt; 8: return False mask = 0 for i, c in enumerate(password): if i and c == password[i - 1]: return False if c.islower(): mask |= 1 elif c.isupper(): mask |= 2 elif c.isdigit(): mask |= 4 else: mask |= 8 return mask == 15</description></item><item><title>2303. Calculate Amount Paid in Taxes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2303/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2303/</guid><description>LeetCode problem 2303
class Solution: def calculateTax(self, brackets: List[List[int]], income: int) -&amp;gt; float: res = prev = 0 for upper, percent in brackets: res += max(0, min(income, upper) - prev) * percent prev = upper return res / 100</description></item><item><title>2309. Greatest English Letter in Upper and Lower Case</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2309/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2309/</guid><description>LeetCode problem 2309
class Solution: def greatestLetter(self, s: str) -&amp;gt; str: mask1 = mask2 = 0 for c in s: if c.islower(): mask1 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) else: mask2 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;A&amp;#34;)) mask = mask1 &amp;amp; mask2 return chr(mask.bit_length() - 1 + ord(&amp;#34;A&amp;#34;)) if mask else &amp;#34;&amp;#34;</description></item><item><title>2315. Count Asterisks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2315/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2315/</guid><description>LeetCode problem 2315
class Solution: def countAsterisks(self, s: str) -&amp;gt; int: res, ok = 0, 1 for c in s: if c == &amp;#34;*&amp;#34;: res += ok elif c == &amp;#34;|&amp;#34;: ok ^= 1 return res</description></item><item><title>2319. Check if Matrix Is X-Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2319/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2319/</guid><description>LeetCode problem 2319
class Solution: def checkXMatrix(self, grid: List[List[int]]) -&amp;gt; bool: for i, row in enumerate(grid): for j, v in enumerate(row): if i == j or i + j == len(grid) - 1: if v == 0: return False elif v: return False return True</description></item><item><title>2325. Decode the Message</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2325/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2325/</guid><description>LeetCode problem 2325
class Solution: def decodeMessage(self, key: str, message: str) -&amp;gt; str: d = {&amp;#34; &amp;#34;: &amp;#34; &amp;#34;} i = 0 for c in key: if c not in d: d[c] = ascii_lowercase[i] i += 1 return &amp;#34;&amp;#34;.join(d[c] for c in message)</description></item><item><title>2331. Evaluate Boolean Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2331/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2331/</guid><description>LeetCode problem 2331
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def evaluateTree(self, root: Optional[TreeNode]) -&amp;gt; bool: if root.left is None: return bool(root.val) l = self.evaluateTree(root.left) r = self.evaluateTree(root.right) return l or r if root.val == 2 else l and r</description></item><item><title>2335. Minimum Amount of Time to Fill Cups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2335/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2335/</guid><description>LeetCode problem 2335
class Solution: def fillCups(self, amount: List[int]) -&amp;gt; int: amount.sort() if amount[0] + amount[1] &amp;lt;= amount[2]: return amount[2] return (sum(amount) + 1) // 2</description></item><item><title>2341. Maximum Number of Pairs in Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2341/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2341/</guid><description>LeetCode problem 2341
class Solution: def numberOfPairs(self, nums: List[int]) -&amp;gt; List[int]: cnt = Counter(nums) s = sum(v // 2 for v in cnt.values()) return [s, len(nums) - s * 2]</description></item><item><title>2347. Best Poker Hand</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2347/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2347/</guid><description>LeetCode problem 2347
class Solution: def bestHand(self, ranks: List[int], suits: List[str]) -&amp;gt; str: # if len(set(suits)) == 1: if all(a == b for a, b in pairwise(suits)): return &amp;#39;Flush&amp;#39; cnt = Counter(ranks) if any(v &amp;gt;= 3 for v in cnt.values()): return &amp;#39;Three of a Kind&amp;#39; if any(v == 2 for v in cnt.values()): return &amp;#39;Pair&amp;#39; return &amp;#39;High Card&amp;#39;</description></item><item><title>2351. First Letter to Appear Twice</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2351/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2351/</guid><description>LeetCode problem 2351
class Solution: def repeatedCharacter(self, s: str) -&amp;gt; str: mask = 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if mask &amp;gt;&amp;gt; i &amp;amp; 1: return c mask |= 1 &amp;lt;&amp;lt; i</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode problem 2352
Problem Statement You are given a square grid of integers, specifically a 0-indexed n×n matrix named grid. The objective is to determine how many pairs of rows and columns in the grid are identical in terms of their content and order.
To elucidate, if row $r_i$ and column $c_j$ have the same integers in the exact same sequence, they are considered an &amp;ldquo;equal&amp;rdquo; pair. The challenge is to count all such pairs in the given matrix.</description></item><item><title>2353. Design a Food Rating System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2353/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2353/</guid><description>LeetCode problem 2353
from sortedcontainers import SortedSet class FoodRatings: def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]): self.mp = {} self.t = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1]))) for a, b, c in zip(foods, cuisines, ratings): self.mp[a] = (b, c) self.t[b].add((c, a)) def changeRating(self, food: str, newRating: int) -&amp;gt; None: b, c = self.mp[food] self.mp[food] = (b, newRating) self.t[b].remove((c, food)) self.t[b].add((newRating, food)) def highestRated(self, cuisine: str) -&amp;gt; str: return self.t[cuisine][0][1] # Your FoodRatings object will be instantiated and called as such: # obj = FoodRatings(foods, cuisines, ratings) # obj.</description></item><item><title>2357. Make Array Zero by Subtracting Equal Amounts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2357/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2357/</guid><description>LeetCode problem 2357
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: return len({x for x in nums if x})</description></item><item><title>2358. Maximum Number of Groups Entering a Competition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2358/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2358/</guid><description>LeetCode problem 2358
class Solution: def maximumGroups(self, grades: List[int]) -&amp;gt; int: n = len(grades) return bisect_right(range(n + 1), n * 2, key=lambda x: x * x + x) - 1</description></item><item><title>2359. Find Closest Node to Given Two Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2359/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2359/</guid><description>LeetCode problem 2359
class Solution: def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -&amp;gt; int: def f(i): dist = [inf] * n dist[i] = 0 q = deque([i]) while q: i = q.popleft() for j in g[i]: if dist[j] == inf: dist[j] = dist[i] + 1 q.append(j) return dist g = defaultdict(list) for i, j in enumerate(edges): if j != -1: g[i].append(j) n = len(edges) d1 = f(node1) d2 = f(node2) res, d = -1, inf for i, (a, b) in enumerate(zip(d1, d2)): if (t := max(a, b)) &amp;lt; d: d = t res = i return res</description></item><item><title>2363. Merge Similar Items</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2363/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2363/</guid><description>LeetCode problem 2363
class Solution: def mergeSimilarItems( self, items1: List[List[int]], items2: List[List[int]] ) -&amp;gt; List[List[int]]: cnt = Counter() for v, w in chain(items1, items2): cnt[v] += w return sorted(cnt.items())</description></item><item><title>2364. Count Number of Bad Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2364/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2364/</guid><description>LeetCode problem 2364
class Solution: def countBadPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter() res = 0 for i, x in enumerate(nums): res += i - cnt[i - x] cnt[i - x] += 1 return res</description></item><item><title>2365. Task Scheduler II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2365/</guid><description>LeetCode problem 2365
class Solution: def taskSchedulerII(self, tasks: List[int], space: int) -&amp;gt; int: day = defaultdict(int) res = 0 for task in tasks: res += 1 res = max(res, day[task]) day[task] = res + space + 1 return res</description></item><item><title>2367. Number of Arithmetic Triplets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2367/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2367/</guid><description>LeetCode problem 2367
class Solution: def arithmeticTriplets(self, nums: List[int], diff: int) -&amp;gt; int: vis = set(nums) return sum(x + diff in vis and x + diff * 2 in vis for x in nums)</description></item><item><title>2368. Reachable Nodes With Restrictions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2368/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2368/</guid><description>LeetCode problem 2368
class Solution: def reachableNodes( self, n: int, edges: List[List[int]], restricted: List[int] ) -&amp;gt; int: s = set(restricted) g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) q = deque([0]) vis = [False] * n for v in restricted: vis[v] = True res = 0 while q: i = q.popleft() res += 1 vis[i] = True for j in g[i]: if not vis[j]: q.append(j) return res</description></item><item><title>2369. Check if There is a Valid Partition For The Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2369/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2369/</guid><description>LeetCode problem 2369
class Solution: def validPartition(self, nums: List[int]) -&amp;gt; bool: n = len(nums) dp = [False] * (n + 1) dp[0] = True for i in range(2, n + 1): if nums[i - 1] == nums[i - 2]: dp[i] = dp[i] or dp[i - 2] if i &amp;gt; 2 and nums[i - 1] == nums[i - 2] == nums[i - 3]: dp[i] = dp[i] or dp[i - 3] if ( i &amp;gt; 2 and nums[i - 1] - nums[i - 2] == 1 and nums[i - 2] - nums[i - 3] == 1 ): dp[i] = dp[i] or dp[i - 3] return dp[-1]</description></item><item><title>2370. Longest Ideal Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2370/</guid><description>LeetCode problem 2370
class Solution: def longestIdealString(self, s: str, k: int) -&amp;gt; int: n = len(s) res = 1 dp = [1] * n d = {s[0]: 0} for i in range(1, n): a = ord(s[i]) for b in ascii_lowercase: if abs(a - ord(b)) &amp;gt; k: continue if b in d: dp[i] = max(dp[i], dp[d[b]] + 1) d[s[i]] = i return max(dp)</description></item><item><title>2373. Largest Local Values in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2373/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2373/</guid><description>LeetCode problem 2373
class Solution: def largestLocal(self, grid: List[List[int]]) -&amp;gt; List[List[int]]: n = len(grid) res = [[0] * (n - 2) for _ in range(n - 2)] for i in range(n - 2): for j in range(n - 2): res[i][j] = max( grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3) ) return res</description></item><item><title>2374. Node With Highest Edge Score</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2374/</guid><description>LeetCode problem 2374
class Solution: def edgeScore(self, edges: List[int]) -&amp;gt; int: cnt = Counter() for i, v in enumerate(edges): cnt[v] += i res = 0 for i in range(len(edges)): if cnt[res] &amp;lt; cnt[i]: res = i return res</description></item><item><title>2375. Construct Smallest Number From DI String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2375/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2375/</guid><description>LeetCode problem 2375
class Solution: def smallestNumber(self, pattern: str) -&amp;gt; str: def dfs(u): nonlocal res if res: return if u == len(pattern) + 1: res = &amp;#39;&amp;#39;.join(t) return for i in range(1, 10): if not vis[i]: if u and pattern[u - 1] == &amp;#39;I&amp;#39; and int(t[-1]) &amp;gt;= i: continue if u and pattern[u - 1] == &amp;#39;D&amp;#39; and int(t[-1]) &amp;lt;= i: continue vis[i] = True t.append(str(i)) dfs(u + 1) vis[i] = False t.pop() vis = [False] * 10 t = [] res = None dfs(0) return res</description></item><item><title>2378. Choose Edges to Maximize Score in a Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2378/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2378/</guid><description>LeetCode problem 2378
class Solution: def maxScore(self, edges: List[List[int]]) -&amp;gt; int: def dfs(i): a = b = t = 0 for j, w in g[i]: x, y = dfs(j) a += y b += y t = max(t, x - y + w) b += t return a, b g = defaultdict(list) for i, (p, w) in enumerate(edges[1:], 1): g[p].append((i, w)) return dfs(0)[1]</description></item><item><title>2379. Minimum Recolors to Get K Consecutive Black Blocks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2379/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2379/</guid><description>LeetCode problem 2379
class Solution: def minimumRecolors(self, blocks: str, k: int) -&amp;gt; int: res = cnt = blocks[:k].count(&amp;#39;W&amp;#39;) for i in range(k, len(blocks)): cnt += blocks[i] == &amp;#39;W&amp;#39; cnt -= blocks[i - k] == &amp;#39;W&amp;#39; res = min(res, cnt) return res</description></item><item><title>2380. Time Needed to Rearrange a Binary String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2380/</guid><description>LeetCode problem 2380
class Solution: def secondsToRemoveOccurrences(self, s: str) -&amp;gt; int: res = cnt = 0 for c in s: if c == &amp;#39;0&amp;#39;: cnt += 1 elif cnt: res = max(res + 1, cnt) return res</description></item><item><title>2381. Shifting Letters II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2381/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2381/</guid><description>LeetCode problem 2381
class Solution: def shiftingLetters(self, s: str, shifts: List[List[int]]) -&amp;gt; str: n = len(s) d = [0] * (n + 1) for i, j, v in shifts: if v == 0: v = -1 d[i] += v d[j + 1] -= v for i in range(1, n + 1): d[i] += d[i - 1] return &amp;#39;&amp;#39;.join( chr(ord(&amp;#39;a&amp;#39;) + (ord(s[i]) - ord(&amp;#39;a&amp;#39;) + d[i] + 26) % 26) for i in range(n) )</description></item><item><title>2383. Minimum Hours of Training to Win a Competition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2383/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2383/</guid><description>LeetCode problem 2383
class Solution: def minNumberOfHours( self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int], ) -&amp;gt; int: res = max(0, sum(energy) - initialEnergy + 1) for x in experience: if initialExperience &amp;lt;= x: res += x - initialExperience + 1 initialExperience = x + 1 initialExperience += x return res</description></item><item><title>2384. Largest Palindromic Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2384/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2384/</guid><description>LeetCode problem 2384
class Solution: def largestPalindromic(self, num: str) -&amp;gt; str: cnt = Counter(num) res = &amp;#39;&amp;#39; for i in range(9, -1, -1): v = str(i) if cnt[v] % 2: res = v cnt[v] -= 1 break for i in range(10): v = str(i) if cnt[v]: cnt[v] //= 2 s = cnt[v] * v res = s + res + s return res.strip(&amp;#39;0&amp;#39;) or &amp;#39;0&amp;#39;</description></item><item><title>2385. Amount of Time for Binary Tree to Be Infected</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2385/</guid><description>LeetCode problem 2385
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def amountOfTime(self, root: Optional[TreeNode], start: int) -&amp;gt; int: def dfs(root): if root is None: return if root.left: g[root.val].append(root.left.val) g[root.left.val].append(root.val) if root.right: g[root.val].append(root.right.val) g[root.right.val].append(root.val) dfs(root.left) dfs(root.right) def dfs2(i, fa): res = 0 for j in g[i]: if j != fa: res = max(res, 1 + dfs2(j, i)) return res g = defaultdict(list) dfs(root) return dfs2(start, -1)</description></item><item><title>2387. Median of a Row Wise Sorted Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2387/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2387/</guid><description>LeetCode problem 2387
class Solution: def matrixMedian(self, grid: List[List[int]]) -&amp;gt; int: def count(x): return sum(bisect_right(row, x) for row in grid) m, n = len(grid), len(grid[0]) target = (m * n + 1) &amp;gt;&amp;gt; 1 return bisect_left(range(10**6 + 1), target, key=count)</description></item><item><title>2389. Longest Subsequence With Limited Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2389/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2389/</guid><description>LeetCode problem 2389
class Solution: def answerQueries(self, nums: List[int], queries: List[int]) -&amp;gt; List[int]: nums.sort() m = len(queries) res = [0] * m idx = sorted(range(m), key=lambda i: queries[i]) s = j = 0 for i in idx: while j &amp;lt; len(nums) and s + nums[j] &amp;lt;= queries[i]: s += nums[j] j += 1 res[i] = j return res</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem 2390
class Solution: def removeStars(self, s: str) -&amp;gt; str: res = [] for c in s: if c == &amp;#39;*&amp;#39;: res.pop() else: res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2391. Minimum Amount of Time to Collect Garbage</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2391/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2391/</guid><description>LeetCode problem 2391
class Solution: def garbageCollection(self, garbage: List[str], travel: List[int]) -&amp;gt; int: def f(x: str) -&amp;gt; int: res = 0 st = 0 for i, s in enumerate(garbage): if t := s.count(x): res += t + st st = 0 if i &amp;lt; len(travel): st += travel[i] return res return f(&amp;#39;M&amp;#39;) + f(&amp;#39;P&amp;#39;) + f(&amp;#39;G&amp;#39;)</description></item><item><title>2393. Count Strictly Increasing Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2393/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2393/</guid><description>LeetCode problem 2393
class Solution: def countSubarrays(self, nums: List[int]) -&amp;gt; int: res = pre = cnt = 0 for x in nums: if pre &amp;lt; x: cnt += 1 else: cnt = 1 pre = x res += cnt return res</description></item><item><title>2395. Find Subarrays With Equal Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2395/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2395/</guid><description>LeetCode problem 2395
class Solution: def findSubarrays(self, nums: List[int]) -&amp;gt; bool: vis = set() for a, b in pairwise(nums): if (x := a + b) in vis: return True vis.add(x) return False</description></item><item><title>2396. Strictly Palindromic Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2396/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2396/</guid><description>LeetCode problem 2396
class Solution: def isStrictlyPalindromic(self, n: int) -&amp;gt; bool: return False</description></item><item><title>2397. Maximum Rows Covered by Columns</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2397/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2397/</guid><description>LeetCode problem 2397
class Solution: def maximumRows(self, matrix: List[List[int]], numSelect: int) -&amp;gt; int: rows = [] for row in matrix: mask = reduce(or_, (1 &amp;lt;&amp;lt; j for j, x in enumerate(row) if x), 0) rows.append(mask) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(matrix[0])): if mask.bit_count() != numSelect: continue t = sum((x &amp;amp; mask) == x for x in rows) res = max(res, t) return res</description></item><item><title>2399. Check Distances Between Same Letters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2399/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2399/</guid><description>LeetCode problem 2399
class Solution: def checkDistances(self, s: str, distance: List[int]) -&amp;gt; bool: d = defaultdict(int) for i, c in enumerate(s, 1): if d[c] and i - d[c] - 1 != distance[ord(c) - ord(&amp;#39;a&amp;#39;)]: return False d[c] = i return True</description></item><item><title>2400. Number of Ways to Reach a Position After Exactly k Steps</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2400/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2400/</guid><description>LeetCode problem 2400
class Solution: def numberOfWays(self, startPos: int, endPos: int, k: int) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if i &amp;gt; j or j &amp;lt; 0: return 0 if j == 0: return 1 if i == 0 else 0 return (dfs(i + 1, j - 1) + dfs(abs(i - 1), j - 1)) % mod mod = 10**9 + 7 return dfs(abs(startPos - endPos), k)</description></item><item><title>2401. Longest Nice Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2401/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2401/</guid><description>LeetCode problem 2401
class Solution: def longestNiceSubarray(self, nums: List[int]) -&amp;gt; int: res = j = mask = 0 for i, x in enumerate(nums): while mask &amp;amp; x: mask ^= nums[j] j += 1 res = max(res, i - j + 1) mask |= x return res</description></item><item><title>2404. Most Frequent Even Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2404/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2404/</guid><description>LeetCode problem 2404
class Solution: def mostFrequentEven(self, nums: List[int]) -&amp;gt; int: cnt = Counter(x for x in nums if x % 2 == 0) res, mx = -1, 0 for x, v in cnt.items(): if v &amp;gt; mx or (v == mx and res &amp;gt; x): res, mx = x, v return res</description></item><item><title>2405. Optimal Partition of String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2405/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2405/</guid><description>LeetCode problem 2405
class Solution: def partitionString(self, s: str) -&amp;gt; int: res, v = 1, 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if (v &amp;gt;&amp;gt; i) &amp;amp; 1: v = 0 res += 1 v |= 1 &amp;lt;&amp;lt; i return res</description></item><item><title>2406. Divide Intervals Into Minimum Number of Groups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2406/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2406/</guid><description>LeetCode problem 2406
class Solution: def minGroups(self, intervals: List[List[int]]) -&amp;gt; int: h = [] for a, b in sorted(intervals): if h and h[0] &amp;lt; a: heappop(h) heappush(h, b) return len(h)</description></item><item><title>2408. Design SQL</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2408/</guid><description>LeetCode problem 2408
class SQL: def __init__(self, names: List[str], columns: List[int]): self.tables = defaultdict(list) def insertRow(self, name: str, row: List[str]) -&amp;gt; None: self.tables[name].append(row) def deleteRow(self, name: str, rowId: int) -&amp;gt; None: pass def selectCell(self, name: str, rowId: int, columnId: int) -&amp;gt; str: return self.tables[name][rowId - 1][columnId - 1] # Your SQL object will be instantiated and called as such: # obj = SQL(names, columns) # obj.insertRow(name,row) # obj.deleteRow(name,rowId) # param_3 = obj.selectCell(name,rowId,columnId)</description></item><item><title>2409. Count Days Spent Together</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2409/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2409/</guid><description>LeetCode problem 2409
class Solution: def countDaysTogether( self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str ) -&amp;gt; int: a = max(arriveAlice, arriveBob) b = min(leaveAlice, leaveBob) days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) x = sum(days[: int(a[:2]) - 1]) + int(a[3:]) y = sum(days[: int(b[:2]) - 1]) + int(b[3:]) return max(y - x + 1, 0)</description></item><item><title>2410. Maximum Matching of Players With Trainers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2410/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2410/</guid><description>LeetCode problem 2410
class Solution: def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -&amp;gt; int: players.sort() trainers.sort() res = j = 0 for p in players: while j &amp;lt; len(trainers) and trainers[j] &amp;lt; p: j += 1 if j &amp;lt; len(trainers): res += 1 j += 1 return res</description></item><item><title>2411. Smallest Subarrays With Maximum Bitwise OR</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2411/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2411/</guid><description>LeetCode problem 2411
class Solution: def smallestSubarrays(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n f = [-1] * 32 for i in range(n - 1, -1, -1): t = 1 for j in range(32): if (nums[i] &amp;gt;&amp;gt; j) &amp;amp; 1: f[j] = i elif f[j] != -1: t = max(t, f[j] - i + 1) res[i] = t return res</description></item><item><title>2413. Smallest Even Multiple</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2413/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2413/</guid><description>LeetCode problem 2413
class Solution: def smallestEvenMultiple(self, n: int) -&amp;gt; int: return n if n % 2 == 0 else n * 2</description></item><item><title>2414. Length of the Longest Alphabetical Continuous Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2414/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2414/</guid><description>LeetCode problem 2414
class Solution: def longestContinuousSubstring(self, s: str) -&amp;gt; int: res = 0 i, j = 0, 1 while j &amp;lt; len(s): res = max(res, j - i) if ord(s[j]) - ord(s[j - 1]) != 1: i = j j += 1 res = max(res, j - i) return res</description></item><item><title>2415. Reverse Odd Levels of Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2415/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2415/</guid><description>LeetCode problem 2415
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def reverseOddLevels(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: q = deque([root]) i = 0 while q: if i &amp;amp; 1: l, r = 0, len(q) - 1 while l &amp;lt; r: q[l].val, q[r].val = q[r].val, q[l].val l, r = l + 1, r - 1 for _ in range(len(q)): node = q.</description></item><item><title>2417. Closest Fair Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2417/</guid><description>LeetCode problem 2417
class Solution: def closestFair(self, n: int) -&amp;gt; int: a = b = k = 0 t = n while t: if (t % 10) &amp;amp; 1: a += 1 else: b += 1 t //= 10 k += 1 if k &amp;amp; 1: x = 10**k y = int(&amp;#39;1&amp;#39; * (k &amp;gt;&amp;gt; 1) or &amp;#39;0&amp;#39;) return x + y if a == b: return n return self.closestFair(n + 1)</description></item><item><title>2418. Sort the People</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2418/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2418/</guid><description>LeetCode problem 2418
class Solution: def sortPeople(self, names: List[str], heights: List[int]) -&amp;gt; List[str]: return [name for _, name in sorted(zip(heights, names), reverse=True)]</description></item><item><title>2419. Longest Subarray With Maximum Bitwise AND</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2419/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2419/</guid><description>LeetCode problem 2419
class Solution: def longestSubarray(self, nums: List[int]) -&amp;gt; int: mx = max(nums) res = cnt = 0 for v in nums: if v == mx: cnt += 1 res = max(res, cnt) else: cnt = 0 return res</description></item><item><title>2420. Find All Good Indices</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2420/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2420/</guid><description>LeetCode problem 2420
class Solution: def goodIndices(self, nums: List[int], k: int) -&amp;gt; List[int]: n = len(nums) decr = [1] * (n + 1) incr = [1] * (n + 1) for i in range(2, n - 1): if nums[i - 1] &amp;lt;= nums[i - 2]: decr[i] = decr[i - 1] + 1 for i in range(n - 3, -1, -1): if nums[i + 1] &amp;lt;= nums[i + 2]: incr[i] = incr[i + 1] + 1 return [i for i in range(k, n - k) if decr[i] &amp;gt;= k and incr[i] &amp;gt;= k]</description></item><item><title>2422. Merge Operations to Turn Array Into a Palindrome</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2422/</guid><description>LeetCode problem 2422
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: i, j = 0, len(nums) - 1 a, b = nums[i], nums[j] res = 0 while i &amp;lt; j: if a &amp;lt; b: i += 1 a += nums[i] res += 1 elif b &amp;lt; a: j -= 1 b += nums[j] res += 1 else: i, j = i + 1, j - 1 a, b = nums[i], nums[j] return res</description></item><item><title>2423. Remove Letter To Equalize Frequency</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2423/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2423/</guid><description>LeetCode problem 2423
class Solution: def equalFrequency(self, word: str) -&amp;gt; bool: cnt = Counter(word) for c in cnt.keys(): cnt[c] -= 1 if len(set(v for v in cnt.values() if v)) == 1: return True cnt[c] += 1 return False</description></item><item><title>2424. Longest Uploaded Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2424/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2424/</guid><description>LeetCode problem 2424
class LUPrefix: def __init__(self, n: int): self.r = 0 self.s = set() def upload(self, video: int) -&amp;gt; None: self.s.add(video) while self.r + 1 in self.s: self.r += 1 def longest(self) -&amp;gt; int: return self.r # Your LUPrefix object will be instantiated and called as such: # obj = LUPrefix(n) # obj.upload(video) # param_2 = obj.longest()</description></item><item><title>2425. Bitwise XOR of All Pairings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2425/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2425/</guid><description>LeetCode problem 2425
class Solution: def xorAllNums(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: res = 0 if len(nums2) &amp;amp; 1: for v in nums1: res ^= v if len(nums1) &amp;amp; 1: for v in nums2: res ^= v return res</description></item><item><title>2427. Number of Common Factors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2427/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2427/</guid><description>LeetCode problem 2427
class Solution: def commonFactors(self, a: int, b: int) -&amp;gt; int: g = gcd(a, b) res, x = 0, 1 while x * x &amp;lt;= g: if g % x == 0: res += 1 res += x * x &amp;lt; g x += 1 return res</description></item><item><title>2428. Maximum Sum of an Hourglass</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2428/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2428/</guid><description>LeetCode problem 2428
class Solution: def maxSum(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) res = 0 for i in range(1, m - 1): for j in range(1, n - 1): s = -grid[i][j - 1] - grid[i][j + 1] s += sum( grid[x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) ) res = max(res, s) return res</description></item><item><title>2429. Minimize XOR</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2429/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2429/</guid><description>LeetCode problem 2429
class Solution: def minimizeXor(self, num1: int, num2: int) -&amp;gt; int: cnt1 = num1.bit_count() cnt2 = num2.bit_count() while cnt1 &amp;gt; cnt2: num1 &amp;amp;= num1 - 1 cnt1 -= 1 while cnt1 &amp;lt; cnt2: num1 |= num1 + 1 cnt1 += 1 return num1</description></item><item><title>2839. Check if Strings Can be Made Equal With Operations I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2839/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2839/</guid><description>LeetCode Problem
Problem Statement You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters. The objective is to find out if it&amp;rsquo;s possible to make the two strings equal by swapping certain pairs of characters.
Naive Solution A naive approach would be to try out all possible swap combinations. However, this can be very inefficient, especially when the strings have a large number of characters.
Hints &amp;amp; Tips Observe that the swapping condition is quite specific: j - i = 2.</description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2841/</guid><description>LeetCode Problem 2841
Problem Statement You are given an integer array nums and two positive integers m and k.
The task is to return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray is almost unique if it contains at least m pairwise distinct elements.
Naive Solution A naive solution would be to generate all the possible subarrays of length k and check each one to see if it is almost unique and what its sum is.</description></item><item><title>2971. Find Polygon With the Largest Perimeter</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2971/</guid><description>LeetCode problem 2971
class Solution: def largestPerimeter(self, nums: List[int]) -&amp;gt; int: nums.sort() s = list(accumulate(nums, initial=0)) res = -1 for k in range(3, len(nums) + 1): if s[k - 1] &amp;gt; nums[k - 1]: res = max(res, s[k]) return res</description></item><item><title>3016. Minimum Number of Pushes to Type Word II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3016/</guid><description>LeetCode problem 3016
class Solution: def minimumPushes(self, word: str) -&amp;gt; int: cnt = Counter(word) res = 0 for i, x in enumerate(sorted(cnt.values(), reverse=True)): res += (i // 8 + 1) * x return res</description></item><item><title>3031. Minimum Time to Revert Word to Initial State II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3031/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3031/</guid><description>LeetCode problem 3031
class Hashing: __slots__ = [&amp;#34;mod&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;p&amp;#34;] def __init__(self, s: str, base: int, mod: int): self.mod = mod self.h = [0] * (len(s) + 1) self.p = [1] * (len(s) + 1) for i in range(1, len(s) + 1): self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod self.p[i] = (self.p[i - 1] * base) % mod def query(self, l: int, r: int) -&amp;gt; int: return (self.h[r] - self.h[l - 1] * self.</description></item><item><title>3032</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3032/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3032/</guid><description>https://leetcode.com/problems/count-numbers-with-unique-digits-ii
class Solution: def numberCount(self, a: int, b: int) -&amp;gt; int: # Initialize the count of numbers with all unique digits unique_digit_count = 0 # Loop through each number in the range from a to b, inclusive for num in range(a, b + 1): # Convert the number to a string to examine its digits num_str = str(num) # Convert the string to a set of characters to remove duplicates unique_digits = set(num_str) # If the length of the set is equal to the length of the number string, # it means all digits are unique if len(unique_digits) == len(num_str): # Increment the count for each number with all unique digits unique_digit_count += 1 # Return the total count of unique digit numbers return unique_digit_count</description></item><item><title>Contests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/</guid><description/></item><item><title>Round #867/1822 (Div. 3)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/867-div-3-1822/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/867-div-3-1822/</guid><description>Contest problems A. TubeTube Feed Mushroom Filippov is having lunch and wants to watch a video on TubeTube. He has a specific amount of time for lunch, and he wants to make the best use of it by watching the most entertaining video that fits into his lunch break.
Given a list of videos, each with its duration and entertainment value, your task is to help Mushroom Filippov choose the best video to watch. He can only watch one video, and the video must not exceed his lunch break time.</description></item><item><title>Codeforces</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/</guid><description> Python template for contests Competitive Programming Helper (cph) | VSCode extension Competitive Programming | browser extension Codeforces solutions Links Python Visualize/Debug code online Python collections.Counter https://github.com/archishmanghos/DSA-Contests/ https://github.com/debochdilamo/Competative-Programming/tree/CodeForces-Solutions https://github.com/DilamoWondimu/Competative-programming/tree/main/CodeForces-Solutions https://github.com/hkirat/Algorithmic-Resources https://github.com/valentk777/Competitive-Programming/ Competitive Programming Library Codeforces rating</description></item></channel></rss>