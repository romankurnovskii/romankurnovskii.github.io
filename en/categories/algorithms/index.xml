<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/categories/algorithms/</link><description>Recent content in Algorithms on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2022 &lt;a href="https://romankurnovskii.com">Roman Kurnovskii&lt;/a> personal page</copyright><lastBuildDate>Mon, 09 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/categories/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Algorithms 101</title><link>https://romankurnovskii.com/en/docs/algorithms-101/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/</guid><description>Smart / OKR What is SMART and OKR
SMART Specific:
Goal: prepare for contests. Pass 50-&amp;gt;75-&amp;gt;100% of contest problems in time Improve python skills. Improve understanding of common algorithms and data structures. Measurable: How will we know that change has occurred?
solve top 100 questions that cover common algorithms and data structures. Achievable:
participate in LeetCode contest, solve 50%+ problems in time. Relevant: Is it possible to achieve this objective?
achievable with practice. improve skills in solving business problems more efficiently, quickly, understandable.</description></item><item><title>1. Two Sum</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/1-two-sum/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/1-two-sum/</guid><description>LeetCode problem
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Topics: array, hash table</description></item><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/13-roman-to-integer/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/13-roman-to-integer/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>14. Longest Common Prefix</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/14-longest-common-prefix/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/14-longest-common-prefix/</guid><description>LeetCode problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. First accepted Idea:
class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: strs.sort() l = strs[0] r = strs[-1] if l == r: return l res = &amp;quot;&amp;quot; for i in range(0, len(l)): if l[i] == r[i]: res += l[i] else: return res return res</description></item><item><title>Algorithm Patterns</title><link>https://romankurnovskii.com/en/docs/algorithms-101/algorithms/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/algorithms/</guid><description>Intro Big-O Cheat Sheet Binary Search Binary search template def find_target(nums, target): left = 0 right = len(nums) - 1 while left &amp;lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[mid] &amp;lt; target: left = mid + 1 else: right = mid - 1 return -1 Dynamic programming (DP) Breadth First Search (BFS) BFS on Tree:
def bfs(root): queue = deque([root]) while len(queue) &amp;gt; 0: node = queue.</description></item><item><title>Help functions</title><link>https://romankurnovskii.com/en/docs/algorithms-101/helpers/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/helpers/</guid><description>Create Linked List Definition for singly-linked list:
class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next values = [2, 4, 3] def createLinkedNode(values): head = ListNode(values[0]) # start node, head of the linkedlist current = head # current node in the linked list where we change/add next node for i in values[1:]: node = ListNode(i) current.next = node current = current.next # now current node is last created return head linled_list = createLinkedNode(values) Object structure:</description></item><item><title>20. Valid Parentheses</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/20-valid-parentheses/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/20-valid-parentheses/</guid><description>LeetCode problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true First accepted Idea:</description></item><item><title>21. Merge Two Sorted Lists</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/21-merge-two-sorted-lists/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/21-merge-two-sorted-lists/</guid><description>LeetCode problem
You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: list1 = [], list2 = [0] Output: [0] First accepted Idea:
Get smallest head. Loop and update its next.</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/26-remove-duplicates-from-sorted-array/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/26-remove-duplicates-from-sorted-array/</guid><description>LeetCode problem
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>66. Plus One</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/66-plus-one/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/66-plus-one/</guid><description>LeetCode problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Example 1:
Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.</description></item><item><title>69. Sqrt(x)</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/69-sqrtx/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/69-sqrtx/</guid><description>LeetCode problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2. Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/70-climbing-stairs/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/70-climbing-stairs/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>88. Merge Sorted Array</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/88-merge-sorted-array/</link><pubDate>Sun, 30 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/88-merge-sorted-array/</guid><description>LeetCode problem
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description></item><item><title>94. Binary Tree Inorder Traversal</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/94-binary-tree-inorder-traversal/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/94-binary-tree-inorder-traversal/</guid><description>##TODO
implement: create binary tree from list of values LeetCode problem
Given the root of a binary tree, return the inorder traversal of its nodes' values.
Example 1:
Input: root = [1,null,2,3] Output: [1,3,2] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Thoughts Don&amp;rsquo;t understand what needed. Why:
1-null-2-3 becomes 1-3-2 [1,2,5,7,8,9,10] becomes [7,2,8,1,9,5,10] In 1-null-2-3 1 becomes the first because we loop to its left node which is null, then come back and first value here is 1.</description></item><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/2-add-two-numbers/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/2-add-two-numbers/</guid><description>Before task: Create function for test data - code snippet You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807.</description></item><item><title>3. Longest Substring Without Repeating Characters</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/3-longest-substring-without-repeating-characters/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/3-longest-substring-without-repeating-characters/</guid><description>LeetCode problem
Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. First accepted Idea:
Loop through string Calculate max count of elements in substring If get double element, then go back until get this element and do step 2. Proceed the main loop class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: uniqs = set() len_max = 0 len_current = 0 idx = 0 for i in s: if i in uniqs: len_max = max(len_max, len_current) len_current = 1 uniqs = set(i) for j in reversed(s[:idx]): if j == i: break else: len_current += 1 uniqs.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/5-longest-palindromic-substring/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/5-longest-palindromic-substring/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/7-reverse-integer/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/7-reverse-integer/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/11-container-with-most-water.en./</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/11-container-with-most-water.en./</guid><description>LeetCode problem
You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.
Notice that you may not slant the container.
Example 1:
Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].</description></item><item><title>15. 3Sum</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/15-3sum/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/15-3sum/</guid><description>LeetCode problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/17-letter-combinations-of-a-phone-number/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/17-letter-combinations-of-a-phone-number/</guid><description>LeetCode problem
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] Example 2:
Input: digits = &amp;quot;&amp;quot; Output: [] First accepted class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] letters = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'] result = [''] for d in digits: d = int(d) tmp = [] for letter in letters[d]: for word in result: word += letter tmp.</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/19-remove-nth-node-from-end-of-list/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/19-remove-nth-node-from-end-of-list/</guid><description>LeetCode problem
Given the &amp;lsquo;head&amp;rsquo; of a linked list, remove the &amp;rsquo;nth&amp;rsquo; node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] First accepted Create Linked List
Idea:
Two pointers. Second pointer starts from nth position. Run while second pointer exist. First version:
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/22-generate-parentheses/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/22-generate-parentheses/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
class Solution: def generateParenthesis(self, n): ans = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: ans.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + '(') if l &amp;lt; r: dfs(l, r - 1, s + ')') dfs(n, n, '') return ans</description></item><item><title>28. Find the Index of the First Occurrence in a String</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/28-find-the-index-of-the-first-occurrence-in-a-string.en./</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/28-find-the-index-of-the-first-occurrence-in-a-string.en./</guid><description>LeetCode problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
Example 2:
Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/29-divide-two-integers/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/29-divide-two-integers/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/33-search-in-rotated-sorted-array/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/33-search-in-rotated-sorted-array/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/34-find-first-and-last-position-of-element-in-sorted-array.en-copy/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/34-find-first-and-last-position-of-element-in-sorted-array.en-copy/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]</description></item><item><title>36. Valid Sudoku</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/36-valid-sudoku/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/36-valid-sudoku/</guid><description>LeetCode problem
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/38-count-and-say/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/38-count-and-say/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit.</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/46-permutations/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/46-permutations/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: result_permutation = [] if len(nums) == 1: # base case return [nums[:]] for _ in nums: tmp_removed = nums.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/48-rotate-image/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/48-rotate-image/</guid><description>LeetCode problem
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;quot;&amp;quot;&amp;quot; Do not return anything, modify matrix in-place instead.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/49-group-anagrams/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/49-group-anagrams/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dd = {} for s in strs: s_sort = &amp;quot;&amp;quot;.</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>56. Merge Intervals</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/56/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/56/</guid><description>LeetCode problem
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:
Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Approach 1:
class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</description></item></channel></rss>