<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/categories/algorithms/</link><description>Recent content in Algorithms on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sat, 02 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/categories/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Two Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</guid><description>LeetCode problem
Problem Statement In this problem, you&amp;rsquo;re given an array of integers nums and an integer target. Your task is to find the indices of two numbers in the array that add up to the target. The input array is guaranteed to have exactly one solution, and you can&amp;rsquo;t use the same element twice. The indices can be returned in any order.
Naive Solution A naive solution would involve using two nested loops to iterate through each pair of elements in the array and check if their sum is equal to the target.</description></item><item><title>Algorithms 101</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/</guid><description>Smart / OKR What is SMART and OKR
SMART Specific:
Goal: prepare for contests. Pass 50-&amp;gt;75-&amp;gt;100% of contest problems in time Improve python skills. Improve understanding of common algorithms and data structures. Measurable: How will we know that change has occurred?
solve top 100 questions that cover common algorithms and data structures. Achievable:
participate in LeetCode contest, solve 50%+ problems in time. Relevant: Is it possible to achieve this objective?
achievable with practice. improve skills in solving business problems more efficiently, quickly, understandable.</description></item><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</guid><description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. First accepted Idea:
Loop through lists add each value to the list reverse list calculate sum create linked list from reversed sum class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def createLinkedNode(values): head = ListNode(values[0]) current = head for i in values[1:]: node = ListNode(i) current.</description></item><item><title>3. Longest Substring Without Repeating Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</guid><description>LeetCode problem
Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. First accepted Idea:
Loop through string Calculate max count of elements in substring If get double element, then go back until get this element and do step 2. Proceed the main loop class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: uniqs = set() len_max = 0 len_current = 0 idx = 0 for i in s: if i in uniqs: len_max = max(len_max, len_current) len_current = 1 uniqs = set(i) for j in reversed(s[:idx]): if j == i: break else: len_current += 1 uniqs.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:
Convert number to int Remove minus if exist (or convert module of number) reverse class Solution: def reverse(self, x: int) -&amp;gt; int: reversed_int = [] str_int = str(x) if x &amp;lt; 0: str_int = str_int[1:] for i in reversed(range(len(str_int))): reversed_int.</description></item><item><title>8. String to Integer (atoi)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</guid><description>LeetCode problem
// .js /** * @param {string} s * @return {number} */ var myAtoi = function(s) { let res = 0; let num = parseInt(s); if(num &amp;gt;= 2147483648){ res = 2147483647; } else if (num &amp;lt;= -2147483648){ res = -2147483648; } else if (isNaN(num)) { res = 0; } else { res = num; } return res; };</description></item><item><title>9. Palindrome Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</guid><description>LeetCode problem
Problem Statement Determine whether an integer is a palindrome without converting it to a string.
Naive Solution A straightforward solution might be to convert the integer to a string and check if it reads the same both ways. However, this challenge encourages solving it without such conversion.
Hints &amp;amp; Tips By reversing the number and comparing it to the original, you can determine if it&amp;rsquo;s a palindrome.
Approach Instead of converting the number to a string, we can reverse its digits using mathematical operations and then compare the reversed number to the original number.</description></item><item><title>1777A - Everybody Likes Good Arrays! - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</guid><description>1777A - Everybody Likes Good Arrays! (greedy, math, 800)
Statement You have an array of numbers, and you want to make it &amp;ldquo;good.&amp;rdquo; A good array is one where every pair of adjacent numbers has different parity (one is even, and the other is odd). You can do this by performing operations on pairs of adjacent numbers with the same parity (both even or both odd), and replacing them with their product. Logic Loop through the array Check the parity of the current element and the previous element If the parity is the same, perform the operation and increment the operation counter Repeat steps 2 and 3 until the end of the array Return the operation counter Solution def solve(n, ar): res = 0 i = 0 while i &amp;lt; len(ar) - 1: if ar[i] % 2 == ar[i + 1] % 2: ar[i] = ar[i] * ar[i + 1] del ar[i + 1] res += 1 else: i += 1 return res Optimized Solution Check how many times the parity changes in the given array.</description></item><item><title>1809A - Garland - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1809a/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1809a/</guid><description>1809A - Garland (implementation, 800)
Explanation If all the light bulbs have the same color, it is impossible to turn them all on, as you can&amp;rsquo;t perform the operation on the same color consecutively. In this case, print -1. If there are 3 light bulbs of the same color and one light bulb of a different color, it takes 6 operations to turn them all on: Turn on the different colored light bulb Turn on one of the other colored light bulbs Turn off the different colored light bulb Turn on the second light bulb of the same color Turn on the different colored light bulb Turn on the third light bulb of the same color In all other cases, it takes 4 operations to turn all the light bulbs on, as you can switch the light bulbs on in a sequence without violating the color restriction.</description></item><item><title>Plan</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/plan/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/plan/</guid><description>Stage 1: Implementation and Greedy 1809A - Garland (implementation, 800) 1807A - Plus or Minus (implementation, 800) 1807B - Grab the Candies (greedy, 800) 1807C - Find and Replace (greedy, implementation, strings, 800) 1798A - Showstopper (greedy, implementation, sortings, 800) 1799A - Recent Actions (data structures, greedy, implementation, math, 800) 1788A - One and Two (brute force, implementation, math, 800) 1778A - Flip Flop Sum (greedy, implementation, 800) 1772A - A+B? (implementation, 800) 1796B - Asterisk-Minor Template (implementation, strings, 1000) Stage 2: Combinatorics and Geometry 1777A - Everybody Likes Good Arrays!</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</guid><description>LeetCode problem 11
Problem Statement The problem involves an array of integers height, where each element represents the height of a line. These lines, along with the x-axis, form a series of containers. Your goal is to find the two lines that form the container with the greatest area.
Naive Solution The naive solution is to consider all pairs of lines and calculate the area of water each pair can contain. You would keep track of the maximum area encountered.</description></item><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>14. Longest Common Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</guid><description>LeetCode problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. First accepted Idea:
class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: strs.sort() l = strs[0] r = strs[-1] if l == r: return l res = &amp;#34;&amp;#34; for i in range(0, len(l)): if l[i] == r[i]: res += l[i] else: return res return res</description></item><item><title>15. 3Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</guid><description>LeetCode problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</guid><description>LeetCode problem
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] Example 2:
Input: digits = &amp;quot;&amp;quot; Output: [] First accepted class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] result = [&amp;#39;&amp;#39;] for d in digits: d = int(d) tmp = [] for letter in letters[d]: for word in result: word += letter tmp.</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem
Given the &amp;lsquo;head&amp;rsquo; of a linked list, remove the &amp;rsquo;nth&amp;rsquo; node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Idea:
Two pointers. Second pointer starts from nth position. Run while second pointer exist. First version:
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description></item><item><title>1787A - Exponential Equation - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</guid><description>1787A - Exponential Equation (constructive algorithms, math, 800)
Logic The equation is a mix of multiplication and exponential operations. Given the nature of exponential operations, $ùë•^ùë¶$ and $ùë¶^ùë•$ can grow very large very quickly as x and y increase.
We can try to simplify the equation.
If we can somehow set one of the variables x or y to 1, the equation simplifies.
This is because any number (except zero) raised to the power of 1 is the number itself, and any number raised to the power of 0 is 1.</description></item><item><title>1807A - Plus or Minus - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807a/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807a/</guid><description>1807A - Plus or Minus (implementation, 800)
Solution t = int(input()) for _ in range(t): a, b, c = map(int, input().split()) print(&amp;#39;+&amp;#39; if a + b == c else &amp;#39;-&amp;#39;)</description></item><item><title>Python template for contests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/cp-template/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/cp-template/</guid><description>Clean template ############################################# Libraries ###################################################### import bisect import sys import math import os import time from queue import PriorityQueue from io import BytesIO, IOBase from collections import defaultdict, Counter from bisect import bisect_right ############################################# Definitions ###################################################### INF = sys.maxsize BUFSIZE = 4096 ############################################# Inputs ###################################################### # def inp(): return sys.stdin.readline().rstrip(&amp;#34;\r\n&amp;#34;) # read line as string # def inp_int(): return int(inp()) # read input as integer. &amp;#39;1&amp;#39; -&amp;gt; 1 # def inp_int_list(): return list(map(int, inp().split())) # def inp_str_list(): return list(inp()) ############################################# Solution ###################################################### def solve(): n = list(map(int, input().</description></item><item><title>20. Valid Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</guid><description>LeetCode problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true First accepted Idea:</description></item><item><title>21. Merge Two Sorted Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</guid><description>LeetCode problem
You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: list1 = [], list2 = [0] Output: [0] First accepted Idea:
Get smallest head. Loop and update its next.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
class Solution: def generateParenthesis(self, n): ans = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: ans.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return ans</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</guid><description>LeetCode problem
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>28. Find the Index of the First Occurrence in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/28.en./</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/28.en./</guid><description>LeetCode problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
Example 2:
Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [‚àí231, 231 ‚àí 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.</description></item><item><title>1777B - Emordnilap - 900</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</guid><description>1777B - Emordnilap (combinatorics, greedy, math, 900)
Statement In this problem, we need to find the &amp;ldquo;beauty&amp;rdquo; of all permutations of a certain length n. The beauty of a permutation is defined as the number of inversions in an array that is created by combining the permutation and its reverse.
Logic The key insight is that every permutation of length n has the same beauty.
This is because the structure of the array created by concatenating a permutation with its reverse ensures that there will always be the same number of inversions, regardless of the order of the numbers in the original permutation.</description></item><item><title>1807B - Grab the Candies - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807b/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807b/</guid><description>1807B - Grab the Candies (greedy, 800)
Explanation Read the number of bags and the list of candies in the bags. Calculate the total number of candies with even and odd amounts separately. Compare the total amount of candies with even and odd amounts. If Mihai has strictly more candies than Bianca, output &amp;ldquo;YES&amp;rdquo;. Otherwise, output &amp;ldquo;NO&amp;rdquo;. Solution t = int(input()) for _ in range(t): n = int(input()) ar = list(map(int, input().split())) m = 0 b = 0 if n == 1: print(&amp;#39;YES&amp;#39; if ar[0] % 2 == 0 else &amp;#39;NO&amp;#39;) else: for x in ar: if x % 2 == 0: m += x else: b += x print(&amp;#39;YES&amp;#39; if m &amp;gt; b else &amp;#39;NO&amp;#39;)</description></item><item><title>Algorithms</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/</guid><description>Intro Big-O Cheat Sheet Sort Insertion sort sorts an array by continuously picking an element, starting from the second element, and inserting it in its correct position in the sorted part of the array to its left. It does this by shifting larger elements one position ahead of their current position, making room for the new element.
def insertion_sort(array): for i in range(1, len(array)): value = array[i] while i &amp;gt; 0 and array[i - 1] &amp;gt; value: array[i] = array[i - 1] i -= 1 array[i] = value return array Selection sort works by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first unsorted element.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]
Code Idea:</description></item><item><title>36. Valid Sudoku</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</guid><description>LeetCode problem
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</description></item><item><title>1773F - Football - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</guid><description>1773F - Football (constructive algorithms, 800)
Logic Solution def solve(): n = int(input()) # number of matches a = int(input()) # goals scored b = int(input()) # goals conceded if n == 1: if a == b: print(1) else: print(0) print(f&amp;#34;{a}:{b}&amp;#34;) return matches = [[0, 0] for _ in range(n + 1)] draw = 0 match = 1 while match &amp;lt;= n and a &amp;gt; 0: a -= 1 matches[match] = [1, 0] match += 1 if a &amp;gt; 0: matches[1] = [matches[1][0] + a, 0] if b &amp;gt; 0: if match == n + 1: matches[1][0] += 1 matches[n][0] -= 1 matches[n][1] = b else: while match &amp;lt;= n and b &amp;gt; 0: b -= 1 matches[match][1] += 1 match += 1 if b &amp;gt; 0: matches[n][1] += b for i in range(1, n + 1): if matches[i][0] == matches[i][1]: draw += 1 print(draw) for i in range(1, n + 1): print(f&amp;#34;{matches[i][0]}:{matches[i][1]}&amp;#34;) solve() Codeforces Editorial PDF</description></item><item><title>1807C - Find and Replace - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807c/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807c/</guid><description>1807C - Find and Replace (greedy, implementation, strings, 800)
Solution t = int(input()) for _ in range(t): n = int(input()) s = input() reserved_binaries = {} binary_values = [] for c in s: val = reserved_binaries.get(c, None) if not binary_values: binary_values.append(1) if val == binary_values[-1]: print(&amp;#39;NO&amp;#39;) break if not val: val = 1 if binary_values[-1] == 0 else 0 reserved_binaries[c] = val binary_values.append(val) else: print(&amp;#39;YES&amp;#39;)</description></item><item><title>01: Implementation &amp; Greedy</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/</guid><description>Implementation Implementation problems are typically straightforward and involve writing code to solve a problem based on the given description. There are no specific techniques for implementation problems, as they can vary widely.
However, the following tips can help you tackle these problems:
Read the problem statement carefully and make sure you understand the requirements. Break the problem down into smaller tasks and solve each task step by step. Write clear, modular code to make debugging easier. Test your solution with the given examples and edge cases.</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: result_permutation = [] if len(nums) == 1: # base case return [nums[:]] for _ in nums: tmp_removed = nums.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</guid><description>LeetCode problem
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify matrix in-place instead.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dd = {} for s in strs: s_sort = &amp;#34;&amp;#34;.</description></item><item><title>02: Combinatorics &amp; Geometry</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/</guid><description>Combinatorics Combinatorics is the study of counting, arranging, and selecting discrete objects. It deals with problems that involve combinations, permutations, and the principles of counting. Combinatorics is used in problems, especially involving optimization or enumeration.
Concepts Permutations A permutation is an arrangement of objects in a specific order. The number of possible permutations of n objects is n! (factorial of n).
Combinations A combination is a selection of objects without considering the order. The number of combinations of n objects taken r at a time is given by the binomial coefficient: $$C(n, r) = n!</description></item><item><title>1798A - Showstopper - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1798a/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1798a/</guid><description>1798A - Showstopper (greedy, implementation, sortings, 800)
Update a and b in a such way so in a always put the largest and in b smallest.
Solution def solve(a,b,n): a_max = a[0] for i in range(n): max_v = max(a[i], b[i]) min_v = min(a[i], b[i]) a[i] = max_v b[i] = min_v a_max = max(a_max, max_v) if a[-1] &amp;gt;= a_max and b[-1] &amp;gt;= max(b): return &amp;#39;Yes&amp;#39; return &amp;#39;No&amp;#39; t = int(input()) for _ in range(t): n = int(input()) a = list(map(int, input().</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive
class Solution: def myPow(self, x, n): if not n: return 1 if n &amp;lt; 0: return 1 / self.</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>56. Merge Intervals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</guid><description>LeetCode problem
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:
Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Approach 1:
class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort() res = [intervals[0]] for ir in range(1, len(intervals)): if intervals[ir][0] &amp;gt;= res[-1][0] and intervals[ir][0] &amp;lt;= res[-1][1]: # [1,3],[2,6] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) elif res[-1][0] &amp;gt;= intervals[ir][0] and res[-1][0] &amp;lt;= intervals[ir][1]: # [1,3],[0,4] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) else: res.</description></item><item><title>1799A - Recent Actions - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1799a/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1799a/</guid><description>1799A - Recent Actions (data structures, greedy, implementation, math, 800)
Explanation On Codeforces, the &amp;ldquo;Recent Actions&amp;rdquo; field shows the last n posts with recent actions. Initially, there are posts numbered 1 to n in the field, in order from top to bottom. There are also infinitely many posts not in the field, numbered with integers n+1, n+2, and so on.
When a recent action happens in post p:
If it is in the &amp;ldquo;Recent Actions&amp;rdquo; field, it moves from its position to the top position.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 10^9.</description></item><item><title>66. Plus One</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</guid><description>LeetCode problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Example 1:
Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.</description></item><item><title>69. Sqrt(x)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</guid><description>LeetCode problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2. Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>1788A - One and Two - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1788a/</link><pubDate>Tue, 28 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1788a/</guid><description>1788A - One and Two (brute force, implementation, math, 800)
This problem is about finding a specific index ùëò in a given sequence of integers $ùëé_1,ùëé_2,‚Ä¶,ùëé_ùëõ$, where each element is either 1 or 2. The goal is to determine whether there exists an integer ùëò such that the product of all elements from $ùëé_1$ to $ùëé_ùëò$ is equal to the product of all elements from $ùëé_ùëò+1$ to $ùëé_ùëõ$.
Because of product of 1 doesn&amp;rsquo;t change the result we can focus on 2.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>73. Set Matrix Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</guid><description>LeetCode problem
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Approach 1:
Idea:
LeetCode Submission
class Solution: def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None: rows = len(matrix) cols = len(matrix[0]) # 1. Check first row/column for zero&amp;#39;s first_row_has_zero = 0 in matrix[0] first_col_has_zero = 0 in list(zip(*matrix))[0] # 2.</description></item><item><title>75. Sort Colors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</guid><description>LeetCode problem
This problem is also known as the Dutch National Flag problem. One solution is to use three pointers to partition the array into three sections: red, white, and blue.
Here&amp;rsquo;s the algorithm:
Initialize three pointers: left, mid, and right. Initialize left to 0, mid to 0, and right to n-1, where n is the length of the input array. While mid is less than or equal to right: If nums[mid] is 0, swap nums[mid] with nums[left], increment mid and left.</description></item><item><title>78. Subsets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</guid><description>LeetCode problem
In this solution, we start with an empty list in the results array.
For each element in the nums array, we append that element to all of the subsets in the results array to create new subsets, and then add these new subsets to the results array.
By doing this for all elements in nums, we generate all possible subsets.
class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [[]] for i in nums: for j in range(len(res)): cur = [] cur.</description></item><item><title>1778A - Flip Flop Sum - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1778a/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1778a/</guid><description>1778A - Flip Flop Sum (greedy, implementation, 800)
There are three possible conditions:
-1 -1 - all negative. In this case sum -2 becomes sum 2. Plus 4. -1 1 - different, no sum change. 1 1 - all positive. 2 becomes -2. Diff is -4. Solution def solve(): n = int(input()) ar = list(map(int, input().split())) s = 0 # sum # three conditions: all 1, all -1, at least one -1 has_diff = False has2_positive = 0 has2_negative = 0 s += ar[0] for idx in range(1, n): if ar[idx] == ar[idx-1]: if ar[idx] == -1: has2_negative = 4 # -2 -&amp;gt; +2, diff 4 else: has2_positive = -4 # +2 =&amp;gt; +1, diff 1 else: has_diff = True s += ar[idx] if has2_negative: s += has2_negative elif has_diff: .</description></item><item><title>88. Merge Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</link><pubDate>Sun, 30 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</guid><description>LeetCode problem
First accepted class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify nums1 in-place instead. &amp;#34;&amp;#34;&amp;#34; i = len(nums1) - n for j in nums2: nums1[i] = j i += 1 nums1.sort()</description></item><item><title>1772A - A+B? - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1772a/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1772a/</guid><description>1772A - A+B? (implementation, 800)
Solution def solve(): a, b = input().split(&amp;#39;+&amp;#39;) res = int(a) + int(b) print(res) for _ in range(int(input())): solve()</description></item><item><title>94. Binary Tree Inorder Traversal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</guid><description>LeetCode problem
Given the root of a binary tree, return the inorder traversal of its nodes' values.
Example 1:
Input: root = [1,null,2,3] Output: [1,3,2] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Thoughts Don&amp;rsquo;t understand what needed. Why:
1-null-2-3 becomes 1-3-2 [1,2,5,7,8,9,10] becomes [7,2,8,1,9,5,10] In 1-null-2-3 1 becomes the first because we loop to its left node which is null, then come back and first value here is 1.</description></item><item><title>1796B - One and Two - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1796b/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1796b/</guid><description>Asterisk-Minor Template (implementation, strings, 1000)
If the first characters of both strings are the same, create a template that consists of the common character followed by an asterisk (e.g., a*). If the last characters of both strings are the same, create a template that consists of an asterisk followed by the common character (e.g., *b). If neither the first nor the last characters are the same, iterate through string a and check for any 2-character substring that also appears in string b.</description></item><item><title>131. Palindrome Partitioning</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to generate all possible partitions of the given string and then check if every substring in each partition is a palindrome.
However, this approach would be inefficient, as there would be an exponential number of partitions to check.
Approach:
Using Backtracking.
Logic:
Define a helper function, is_palindrome, to check if a given substring is a palindrome. Define the backtrack function to find all palindrome partitions recursively. This function will take the current position in the string and the current partition as input arguments.</description></item><item><title>134. Gas Station</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to try starting from each gas station and check if you can complete the circuit. For each gas station, calculate the remaining gas in the tank after traveling to the next station.
If the gas is not enough to travel to the next station, stop and try starting from the next gas station.
Approach:
In this problem, we can use a greedy algorithm
We can keep track of the total gas and total cost while iterating through the gas stations.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode problem
The problem asks to create a deep copy of a given linked list with a random pointer in each node. A deep copy means that the new linked list will have completely new nodes, and none of its pointers should point to the nodes in the original list. Both the next and random pointers of the new nodes should point to the new nodes in the copied list in the same order as the original list.</description></item><item><title>139. Word Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</guid><description>LeetCode problem
Approach:
Dynamic Programming.
Logic:
Using DP:
Iterate through each character of string s. Generate all possible substrings ending at the current index. Check if the substring is in wordDict: If it is, check if the index before the substring&amp;rsquo;s first index is marked as True (this indicates that the part of the string before the current substring can be segmented into words in wordDict). If it is, then mark the current index as True. Solution:
class Solution: def wordBreak(self, s, wordDict): n = len(s) dp = [False] * n for end in range(1, n + 1): # 1.</description></item><item><title>141. Linked List Cycle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</guid><description>LeetCode problem 141
Problem Statement The problem asks us to determine if a given linked list contains a cycle. A cycle in a linked list occurs when a node&amp;rsquo;s next pointer points back to a previous node in the list, causing an infinite loop.
Hints &amp;amp; Tips In this problem, you can take advantage of the Floyd&amp;rsquo;s &amp;ldquo;Tortoise and Hare&amp;rdquo; cycle detection algorithm. This algorithm allows you to detect a cycle in O(1) space and O(n) time complexity, where n is the number of nodes.</description></item><item><title>146. LRU Cache</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</guid><description>LeetCode problem
The operations we need to support are get and put which should both be done in O(1) time.
get(key) should return the value if the key exists in the cache, otherwise return -1. put(key, value) should update the value of the key if the key exists; otherwise, this method should insert the key-value pair into the cache. If the cache is full, this method should also evict the least recently used key-value pair. Approach Use Doubly Linked List or Python OrderedDict</description></item><item><title>148. Sort List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</guid><description>LeetCode problem
Naive Solution Traverse the linked list, adding each node&amp;rsquo;s value to a Python list sort that list create a new linked list from the sorted values return the head of this new list. This solution would have a time complexity of O(n log n) due to the sort operation and a space complexity of O(n) because of the extra list we&amp;rsquo;re creating.
class Solution: def sortList(self, head): values = [] node = head while node: values.append(node.val) node = node.</description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</guid><description>LeetCode problem
Problem Statement The problem is about reversing the order of words in a given string s. Each word in s is defined as a sequence of non-space characters and the words are separated by at least one space. You are expected to return a string with the words in reversed order and separated by a single space. It is important to note that s may contain leading or trailing spaces or multiple spaces between two words, but the returned string should not contain any extra spaces.</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>160. Intersection of Two Linked Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</link><pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</guid><description>LeetCode problem
Solution 1 Using hashmap.
# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode): nodes = set() cur = headA while cur: nodes.add(cur) cur = cur.next cur = headB while cur: if cur in nodes: return cur cur = cur.next return None Solution 2 Initialize two pointers, one for each head. Move each pointer to the next node in its list. If a pointer reaches the end of its list, move it to the start of the other list.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>171. Excel Sheet Column Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</guid><description>LeetCode problem
The column titles in an Excel sheet are designed similar to a base-26 number system. The columns start from &amp;lsquo;A&amp;rsquo; (which is 1) to &amp;lsquo;Z&amp;rsquo; (which is 26), then after &amp;lsquo;Z&amp;rsquo;, the column titles go to &amp;lsquo;AA&amp;rsquo; (which is 27), &amp;lsquo;AB&amp;rsquo; (28), and so on.
This problem is essentially asking us to convert a base-26 number (represented by uppercase English letters) to a decimal number.
That means that for each &amp;ldquo;new&amp;rdquo; index in columnTitle we already pass alphabet.</description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</guid><description>LeetCode problem
Problem Statement Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Naive Solution A simple, but inefficient, approach would be to rotate the array k times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations.</description></item><item><title>190. Reverse Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</guid><description>LeetCode problem
This task involves understanding how binary representation works. An unsigned integer is a 32-bit value, where each bit represents a power of 2, from 2^0 (the least significant bit) to 2^31 (the most significant bit).
Unsigned Integers (often called &amp;ldquo;uints&amp;rdquo;) are just like integers (whole numbers) but have the property that they don&amp;rsquo;t have a + or - sign associated with them. Thus they are always non-negative (zero or positive).
Naive Solution A naive solution to this problem could involve converting the number to a binary string, reversing the string, and then converting it back to an integer.</description></item><item><title>191. Number of 1 Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</guid><description>LeetCode problem
Problem Statement Given an integer value represented in binary format, we need to count the number of &amp;lsquo;1&amp;rsquo; bits in its binary representation.
Naive Solution The naive solution for this problem would be to convert the binary number into a string and then simply iterate over the string and count the number of &amp;lsquo;1&amp;rsquo;s. However, this solution is not optimal and is not taking advantage of the properties of binary numbers.
Algorithm The optimal solution for this problem involves using bitwise operation.</description></item><item><title>202. Happy Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</link><pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a number n. We have to determine whether this number is a &amp;ldquo;happy&amp;rdquo; number or not. A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.</description></item><item><title>234. Palindrome Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</guid><description>LeetCode problem
Problem Statement Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
Naive Solution A simple solution to this problem is to:
traverse the linked list storing the value of each node in an array. Then, we could compare the array with its reversed version.
If they match, the linked list is a palindrome. Otherwise, it is not.
This solution takes O(n) time (where n is the number of nodes in the list), as we need to traverse the list once.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</guid><description>LeetCode problem
Problem Statement The problem is to find a product of all elements in the given integer array nums, except for the i-th element, and return a new array with the results. You must design an algorithm that runs in O(n) time and doesn&amp;rsquo;t use the division operation. The challenge here is to solve this problem with O(1) extra space complexity.
Naive Solution A naive solution could be to calculate the product of all elements in the array, then iterate through the array and replace each element with the total product divided by the element.</description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</guid><description>LeetCode problem
Problem Statement The problem is asking to move all zeros in an integer array to the end of the array while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.
Naive Solution A naive solution could be to create a new list, iterate over the array, add non-zero elements to the new list and count zero elements. Then extend the new list with the same amount of zeros as counted.</description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</guid><description>LeetCode problem
Problem Statement The task is to determine if the given list of numbers contains an increasing subsequence of length three. This means we need to find three indices i, j, and k in the list such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k].
Naive Solution One possible naive solution is to use three nested loops to go through all possible triples in the list and check if they are increasing. But this solution is very inefficient, has a time complexity of O(n¬≥), and does not meet the follow-up constraints of the problem.</description></item><item><title>345. Reverse Vowels of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</guid><description>LeetCode problem
Problem Statement Given a string s, the task is to reverse only all the vowels in the string and return it. The vowels are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;, and they can appear in both lower and upper cases, more than once.
Naive Solution The naive approach to solve this problem would be to:
Initialize an empty string result. Traverse the given string s from the start to the end. If the current character is a vowel, find the next vowel in the string starting from the end, add it to result, and remove it from the string.</description></item><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</guid><description>LeetCode problem 392
Problem Statement Given two strings s and t, you need to determine if s is a subsequence of t. To be a subsequence, you can remove characters from t without reordering to form s.
Naive Solution The naive approach would be to generate all subsequences of string t and then check if string s is one of them. However, generating all subsequences of t can be computationally expensive especially when the length of t is large.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode problem
Problem Statement Given an encoded string, the task is to decode it to produce a string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.
Naive Solution A naive approach would be to repeatedly look for a pattern in the string where there is a number followed by square brackets. For each such pattern found, replace it with the string inside the square brackets repeated &amp;lsquo;k&amp;rsquo; times. This would work but might not be the most efficient solution, especially for nested brackets.</description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</guid><description>LeetCode problem
Problem Statement Given a list of characters, chars, you are required to compress the list using the following algorithm:
Start with an empty string, s. For each group of consecutive repeating characters in chars: If the group&amp;rsquo;s length is 1, append the character to s. Otherwise, append the character followed by the group&amp;rsquo;s length. The compressed string s should be stored back in the chars list. The length of the group that is 10 or longer will be split into multiple characters in chars.</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode problem 605
In this problem, we are given a flowerbed represented by an integer array flowerbed, where 0 represents an empty plot and 1 represents a plot with a flower.
We need to determine if we can plant n new flowers in the flowerbed without violating the rule that no two adjacent plots can have flowers.
Naive Solution To solve this problem, we can use a greedy approach. We iterate through the flowerbed and check each plot. If a plot is empty and its adjacent plots are also empty, we can plant a flower in that plot.</description></item><item><title>643. Maximum Average Subarray I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</guid><description>LeetCode problem
Problem Statement Given an integer array nums consisting of n elements and an integer k, find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. The result must be accurate up to a decimal point of 10^(-5).
Naive Solution A straightforward approach would be to calculate the average for every possible subarray of length k. For each starting point, sum the next k numbers and determine the average.</description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</guid><description>LeetCode problem
Problem Statement Given an array of integers nums, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.
Naive Solution A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode problem
Problem Statement Imagine a row of asteroids moving in space. Each asteroid has a size (given by its absolute value) and a direction it&amp;rsquo;s moving in (given by its sign: positive for right, negative for left). All asteroids move at the same speed. Your task is to determine the final state of the asteroids after all collisions have been resolved.
Two important points to note:
When two asteroids of different directions meet, the smaller one explodes. If they are of the same size, both explode.</description></item><item><title>Round #849/1791 (Div. 4)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/849-div-4-1791/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/849-div-4-1791/</guid><description>TODO G2 Contest date: 2023-02-03
Contest problems
Editorial
Template with function snippets
A. Codeforces Checking https://codeforces.com/contest/1791/problem/A
Solution:
def solve(letter): code = &amp;#34;codeforces&amp;#34; if letter in code: print(&amp;#34;YES&amp;#34;) else: print(&amp;#34;NO&amp;#34;) for _ in range(int(inp())): letter = inp() solve(letter) B. Following Directions https://codeforces.com/contest/1791/problem/B
geometry, implementation, *800
Solution:
def solve(n, s): x = 0 y = 0 for move in s: if move == &amp;#39;L&amp;#39;: x -= 1 elif move == &amp;#39;R&amp;#39;: x += 1 elif move == &amp;#39;U&amp;#39;: y += 1 elif move == &amp;#39;D&amp;#39;: y -= 1 if x == 1 and y == 1: print(&amp;#34;YES&amp;#34;) break else: print(&amp;#34;NO&amp;#34;) for _ in range(int(inp())): # attempts num = int(inp()) letter = inp() solve(num, letter) C.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</guid><description>LeetCode Problem 1004
Problem Statement Given a binary array nums and an integer k, the task is to return the maximum number of consecutive 1&amp;rsquo;s in the array, with the possibility to flip at most k 0&amp;rsquo;s.
Naive Solution A straight forward approach is to try flipping every combination of k zeros and checking for the longest sequence of 1&amp;rsquo;s. This would involve nested loops, with the outer loop iterating through the array and the inner loops flipping zeros and calculating sequences of 1&amp;rsquo;s.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode problem
Problem Statement The problem is about finding a greatest common divisor (GCD) of two strings. The term &amp;ldquo;GCD&amp;rdquo; might be familiar from mathematics, as the largest number that divides two numbers without leaving a remainder. Here, we extend the idea to strings: a string x is a GCD of strings str1 and str2 if x can be repeatedly appended to itself to obtain str1 and str2.
Naive Solution A naive approach would be to find all possible divisors of str1 and str2, and then find the largest common divisor.</description></item><item><title>1207. Unique Number of Occurrences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1207/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1207/</guid><description>LeetCode problem
Problem Statement Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
Naive Solution A naive approach would be to create a dictionary to store the count of each integer, then iterate over the dictionary and compare each count with the counts of other integers. This approach requires O(n^2) time complexity, where n is the length of the array. This is not efficient for large input sizes.</description></item><item><title>1431. Kids With the Greatest Number of Candies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1431/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1431/</guid><description>LeetCode problem
Problem Statement The problem requires us to find out which kids can potentially have the greatest number of candies if they are given all the extra candies. The information about the number of candies each kid has and the number of extra candies available is given.
Naive Solution A naive approach to this problem would be to iterate over the candies array for each kid and check if adding the extra candies to the kid&amp;rsquo;s current candies makes it equal to or greater than the maximum candies any kid has.</description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</guid><description>LeetCode Problem 1456
Problem Statement Given a string s and an integer k, the task is to return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.
Naive Solution The most straightforward solution to this problem is to take every possible substring of length k and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length k.</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1657. Determine if Two Strings Are Close</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</guid><description>LeetCode problem
Problem Statement Two strings are considered close if you can attain one from the other using two operations:
Swap any two existing characters. Transform every occurrence of one existing character into another existing character, and do the same with the other character. The challenge is to determine whether two given strings are close or not.
Naive Solution A naive approach might involve trying every possible combination of operations on the two strings until they match or until you&amp;rsquo;ve exhausted all possibilities.</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1732/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1732/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a biker who is going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal to 0.
We are also given an integer array gain of length n where gain[i] represents the net gain in altitude between points i and i + 1 for all 0 &amp;lt;= i &amp;lt; n. The net gain could be negative, indicating a decrease in altitude, or positive, indicating an increase in altitude.</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1768/</guid><description>LeetCode problem
Problem Statement The task is to merge two strings alternately, i.e., take one character from the first string, then one from the second, then again from the first, and so on. If one string finishes before the other, the remaining characters from the longer string are appended at the end.
Naive Solution A naive approach could involve maintaining two pointers, one for each string, and incrementally appending characters from each string to the result. Once we reach the end of one string, we append the rest of the other string to the result.</description></item><item><title>2215. Find the Difference of Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</guid><description>LeetCode problem
Problem Statement Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:
answer[0] is a list of all distinct integers in nums1 which are not present in nums2. answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order.
Naive Solution A naive approach would be to iterate over each element of the first array and check whether it&amp;rsquo;s in the second array.</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode problem
Problem Statement You are given a square grid of integers, specifically a 0-indexed n√ón matrix named grid. The objective is to determine how many pairs of rows and columns in the grid are identical in terms of their content and order.
To elucidate, if row $r_i$ and column $c_j$ have the same integers in the exact same sequence, they are considered an &amp;ldquo;equal&amp;rdquo; pair. The challenge is to count all such pairs in the given matrix.</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2839. Check if Strings Can be Made Equal With Operations I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2839/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2839/</guid><description>LeetCode Problem
Problem Statement You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters. The objective is to find out if it&amp;rsquo;s possible to make the two strings equal by swapping certain pairs of characters.
Naive Solution A naive approach would be to try out all possible swap combinations. However, this can be very inefficient, especially when the strings have a large number of characters.
Hints &amp;amp; Tips Observe that the swapping condition is quite specific: j - i = 2.</description></item><item><title>2840. Check if Strings Can be Made Equal With Operations II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</guid><description>LeetCode Problem 2840
Problem Statement You are given two strings s1 and s2, both of length n, consisting of lowercase English letters. You can apply certain operations to make them equal. The question is, is it possible?
Naive Solution A naive approach would be to try all possible swap operations and compare the two strings at each step, which would be highly inefficient.
Hints &amp;amp; Tips Observe that swapping can only occur at indices i and j where j - i is even.</description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</guid><description>LeetCode Problem 2841
Problem Statement You are given an integer array nums and two positive integers m and k.
The task is to return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray is almost unique if it contains at least m pairwise distinct elements.
Naive Solution A naive solution would be to generate all the possible subarrays of length k and check each one to see if it is almost unique and what its sum is.</description></item><item><title>2842. Count K-Subsequences of a String with Maximum Beauty</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2842/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2842/</guid><description>LeetCode problem
Problem Statement You are given a string s and an integer k. A k-subsequence is a subsequence of s, having length k, and all its characters are unique. The beauty of a k-subsequence is the sum of f(c) for every character c in the k-subsequence. Here, f(c) denotes the number of times the character c occurs in s.
The task is to find the number of k-subsequences whose beauty is maximum among all k-subsequences. Return the answer modulo $(10^9 + 7)$.</description></item><item><title>Contests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/</guid><description/></item><item><title>Round #867/1822 (Div. 3)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/867-div-3-1822/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/867-div-3-1822/</guid><description>Contest problems A. TubeTube Feed Mushroom Filippov is having lunch and wants to watch a video on TubeTube. He has a specific amount of time for lunch, and he wants to make the best use of it by watching the most entertaining video that fits into his lunch break.
Given a list of videos, each with its duration and entertainment value, your task is to help Mushroom Filippov choose the best video to watch. He can only watch one video, and the video must not exceed his lunch break time.</description></item><item><title>Codeforces</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/</guid><description> Python template for contests Competitive Programming Helper (cph) | VSCode extension Competitive Programming | browser extension Codeforces solutions Links Python Visualize/Debug code online Python collections.Counter https://github.com/archishmanghos/DSA-Contests/ https://github.com/debochdilamo/Competative-Programming/tree/CodeForces-Solutions https://github.com/DilamoWondimu/Competative-programming/tree/main/CodeForces-Solutions https://github.com/hkirat/Algorithmic-Resources https://github.com/valentk777/Competitive-Programming/ Competitive Programming Library Codeforces rating</description></item></channel></rss>