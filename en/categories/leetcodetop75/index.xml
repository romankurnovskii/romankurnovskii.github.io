<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCodeTop75 on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/categories/leetcodetop75/</link><description>Recent content in LeetCodeTop75 on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Tue, 01 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/categories/leetcodetop75/index.xml" rel="self" type="application/rss+xml"/><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>LeetCode Top 75</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode75/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode75/</guid><description>Array / String # Problem Difficulty 1 1768. Merge Strings Alternately Easy 2 1071. Greatest Common Divisor of Strings Easy 3 1431. Kids With the Greatest Number of Candies Easy 4 605. Can Place Flowers Easy 5 345. Reverse Vowels of a String Easy 6 151. Reverse Words in a String Medium 7 238. Product of Array Except Self Medium 8 Increasing Triplet Subsequence Medium 9 String Compression Medium Two Pointers # Problem Difficulty 10 283. Move Zeroes Easy 11 Is Subsequence Easy 12 11.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/238/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/238/</guid><description>LeetCode problem
Problem Statement The problem is to find a product of all elements in the given integer array nums, except for the i-th element, and return a new array with the results. You must design an algorithm that runs in O(n) time and doesn&amp;rsquo;t use the division operation. The challenge here is to solve this problem with O(1) extra space complexity.
Naive Solution A naive solution could be to calculate the product of all elements in the array, then iterate through the array and replace each element with the total product divided by the element.</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode problem
Problem Statement In the &amp;ldquo;Can Place Flowers&amp;rdquo; problem, we have a long flowerbed in which some of the plots are planted with flowers (represented by 1&amp;rsquo;s in an integer array), and some are not (represented by 0&amp;rsquo;s). We must determine whether we can plant a certain number of new flowers (denoted as &amp;rsquo;n&amp;rsquo;) in the flowerbed without violating the no-adjacent-flowers rule, i.e., flowers cannot be planted in adjacent plots.
Naive Solution A simple approach to this problem would be to go through each plot in the flowerbed and try to plant a flower if the plot is empty and its neighboring plots are also empty.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode problem
Problem Statement The problem is about finding a greatest common divisor (GCD) of two strings. The term &amp;ldquo;GCD&amp;rdquo; might be familiar from mathematics, as the largest number that divides two numbers without leaving a remainder. Here, we extend the idea to strings: a string x is a GCD of strings str1 and str2 if x can be repeatedly appended to itself to obtain str1 and str2.
Naive Solution A naive approach would be to find all possible divisors of str1 and str2, and then find the largest common divisor.</description></item><item><title>1431. Kids With the Greatest Number of Candies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1431/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1431/</guid><description>LeetCode problem
Problem Statement The problem requires us to find out which kids can potentially have the greatest number of candies if they are given all the extra candies. The information about the number of candies each kid has and the number of extra candies available is given.
Naive Solution A naive approach to this problem would be to iterate over the candies array for each kid and check if adding the extra candies to the kid&amp;rsquo;s current candies makes it equal to or greater than the maximum candies any kid has.</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1768/</guid><description>LeetCode problem
Problem Statement The task is to merge two strings alternately, i.e., take one character from the first string, then one from the second, then again from the first, and so on. If one string finishes before the other, the remaining characters from the longer string are appended at the end.
Naive Solution A naive approach could involve maintaining two pointers, one for each string, and incrementally appending characters from each string to the result. Once we reach the end of one string, we append the rest of the other string to the result.</description></item></channel></rss>