<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Roman Kurnovskii</title><link>https://romankurnovskii.com/en/</link><description>Recent content on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Wed, 21 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Two Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</guid><description>LeetCode problem
Problem Statement In this problem, you&amp;rsquo;re given an array of integers nums and an integer target. Your task is to find the indices of two numbers in the array that add up to the target. The input array is guaranteed to have exactly one solution, and you can&amp;rsquo;t use the same element twice. The indices can be returned in any order.
Naive Solution A naive solution would involve using two nested loops to iterate through each pair of elements in the array and check if their sum is equal to the target.</description></item><item><title>Create S3 Bucket</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/create-s3-bucket/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/create-s3-bucket/</guid><description>Creating an Amazon S3 Bucket Introduction You can create an Amazon S3 bucket using the AWS Management Console. As with many other AWS services, you can use the AWS API or CLI (command-line interface) as well.
In this lab step, you will create a new Amazon S3 bucket.
Instructions In the AWS Management Console search bar, enter¬†S3, and click the¬†S3¬†result under¬†Services: You will be placed in¬†the S3 console.
From the S3 console, click the¬†orange¬†Create Bucket¬†button: Enter a unique Bucket name on the Name and region screen of the wizard: Region: US West (Oregon) (This should be set for you.</description></item><item><title>Configuring a Static Website With S3 And CloudFront</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cloudfront/configuring-static-website-s3-and-cloudfront/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cloudfront/configuring-static-website-s3-and-cloudfront/</guid><description>Practice Lab link Creating an Amazon S3 Bucket for a Static Website 1. In the AWS Management Console search bar, enter¬†S3, and click the¬†S3¬†result under¬†Services:
You will be placed in¬†the Amazon S3 console.
2. To start creating a new Amazon S3 bucket, in the top-right, click¬†Create bucket:
The Amazon S3 bucket creation form will load.
3. Under General configuration, enter the following:
Bucket name: Enter calabs-bucket-&amp;lt;UniqueNumber&amp;gt;(Append a unique number to the end of calabs-bucket-) Region: Ensure US West (Oregon) us-west-2 is selected You have added a unique number to the bucket name because Amazon S3 bucket names must be unique regardless of the AWS region in which the bucket is created.</description></item><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</guid><description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. First accepted Idea:
Loop through lists add each value to the list reverse list calculate sum create linked list from reversed sum class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def createLinkedNode(values): head = ListNode(values[0]) current = head for i in values[1:]: node = ListNode(i) current.</description></item><item><title>Create a folder inside S3 Bucket</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/create-folder-s3/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/create-folder-s3/</guid><description>Creating a Folder inside an Amazon S3 Bucket Introduction The AWS S3¬†console allows you to create folders for grouping objects. This can be a very helpful organizational tool. However, in Amazon S3, buckets and objects are the primary resources. A folder simply becomes a prefix for object key names that are virtually archived into it.
Instructions Return to the Buckets menu by clicking here, and click on the¬†calabs-bucket¬†you created earlier. (Reminder: Your bucket name will¬†differ slightly.</description></item><item><title>3. Longest Substring Without Repeating Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</guid><description>LeetCode problem
Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. First accepted Idea:
Loop through string Calculate max count of elements in substring If get double element, then go back until get this element and do step 2. Proceed the main loop class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: uniqs = set() len_max = 0 len_current = 0 idx = 0 for i in s: if i in uniqs: len_max = max(len_max, len_current) len_current = 1 uniqs = set(i) for j in reversed(s[:idx]): if j == i: break else: len_current += 1 uniqs.</description></item><item><title>Upload a file to S3</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/upload-file-to-s3/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/upload-file-to-s3/</guid><description>Uploading a File to Amazon S3 Introduction When you upload a folder from your local system or another machine, Amazon S3 uploads all the files and subfolders from the specified local folder to your bucket. It then assigns a key value that is a combination of the uploaded file name and the folder name. In this lab step, you will upload a file to your bucket. The process is similar to uploading a single file, multiple files, or a folder with files in it.</description></item><item><title>Grant public access to S3 Object</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/grant-access-s3/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/grant-access-s3/</guid><description>Granting Public Access to an Amazon S3 Object Introduction All uploaded files are¬†private¬†by default and can only be viewed, edited, or downloaded by you.¬†In order to illustrate this point, complete the instructions below.
Note: The terms &amp;ldquo;file&amp;rdquo; and &amp;ldquo;object&amp;rdquo; are often used interchangeably when discussing Amazon S3. Technically, Amazon S3 is an object-store. It is not a block storage device and does not contain a file system as your local computer does. However, files such as images, movies, and sound clips are often uploaded from your file system to Amazon S3.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>Change metadata of S3 Object</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/how-to-change-metadata-s3/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/how-to-change-metadata-s3/</guid><description>Changing the Metadata of an Amazon S3 Object Introduction Each object in Amazon S3 has a set of key/value pairs representing its metadata. There are two types of metadata: &amp;ldquo;System metadata&amp;rdquo; (for example, Content-Type and Content-Length) and custom &amp;ldquo;User metadata&amp;rdquo;. User metadata is stored with the object and returned with it.
As an example, you might have your own taxonomy for various images, such as ‚Äúlogo‚Äù, ‚Äúscreenshot‚Äù, ‚Äúdiagram‚Äù, &amp;ldquo;flowchart&amp;rdquo; and so on.¬†In this lab step, you will change the Content-Type of your image to &amp;ldquo;text/plain&amp;rdquo;.</description></item><item><title>Delete S3 Bucket</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/delete-from-s3/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/s3/delete-from-s3/</guid><description>Deleting an Amazon S3 Bucket Introduction You can delete an Amazon S3 bucket using the S3 console. You will delete all objects within the bucket as well.
Instructions In the AWS Management Console search bar, enter¬†S3, and click the¬†S3¬†result under¬†Services: From the top level of the S3 console, notice the Delete¬†button is not actionable.
2.¬†Check the name of your bucket to select it:
With the bucket selected, click Empty: The Empty bucket form page will load.</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:
Convert number to int Remove minus if exist (or convert module of number) reverse class Solution: def reverse(self, x: int) -&amp;gt; int: reversed_int = [] str_int = str(x) if x &amp;lt; 0: str_int = str_int[1:] for i in reversed(range(len(str_int))): reversed_int.</description></item><item><title>8. String to Integer (atoi)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</guid><description>LeetCode problem
// .js /** * @param {string} s * @return {number} */ var myAtoi = function(s) { let res = 0; let num = parseInt(s); if(num &amp;gt;= 2147483648){ res = 2147483647; } else if (num &amp;lt;= -2147483648){ res = -2147483648; } else if (isNaN(num)) { res = 0; } else { res = num; } return res; };</description></item><item><title>9. Palindrome Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</guid><description>LeetCode problem 9. Palindrome Number
Problem Statement Determine whether an integer is a palindrome without converting it to a string.
Naive Solution A straightforward solution might be to convert the integer to a string and check if it reads the same both ways. However, this challenge encourages solving it without such conversion.
Hints &amp;amp; Tips By reversing the number and comparing it to the original, you can determine if it&amp;rsquo;s a palindrome.
Approach Instead of converting the number to a string, we can reverse its digits using mathematical operations and then compare the reversed number to the original number.</description></item><item><title>1777A - Everybody Likes Good Arrays! - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</guid><description>1777A - Everybody Likes Good Arrays! (greedy, math, 800)
Statement You have an array of numbers, and you want to make it &amp;ldquo;good.&amp;rdquo; A good array is one where every pair of adjacent numbers has different parity (one is even, and the other is odd). You can do this by performing operations on pairs of adjacent numbers with the same parity (both even or both odd), and replacing them with their product. Logic Loop through the array Check the parity of the current element and the previous element If the parity is the same, perform the operation and increment the operation counter Repeat steps 2 and 3 until the end of the array Return the operation counter Solution def solve(n, ar): res = 0 i = 0 while i &amp;lt; len(ar) - 1: if ar[i] % 2 == ar[i + 1] % 2: ar[i] = ar[i] * ar[i + 1] del ar[i + 1] res += 1 else: i += 1 return res Optimized Solution Check how many times the parity changes in the given array.</description></item><item><title>1809A - Garland - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1809a/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1809a/</guid><description>1809A - Garland (implementation, 800)
Explanation If all the light bulbs have the same color, it is impossible to turn them all on, as you can&amp;rsquo;t perform the operation on the same color consecutively. In this case, print -1. If there are 3 light bulbs of the same color and one light bulb of a different color, it takes 6 operations to turn them all on: Turn on the different colored light bulb Turn on one of the other colored light bulbs Turn off the different colored light bulb Turn on the second light bulb of the same color Turn on the different colored light bulb Turn on the third light bulb of the same color In all other cases, it takes 4 operations to turn all the light bulbs on, as you can switch the light bulbs on in a sequence without violating the color restriction.</description></item><item><title>Plan</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/plan/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/plan/</guid><description>Stage 1: Implementation and Greedy 1809A - Garland (implementation, 800) 1807A - Plus or Minus (implementation, 800) 1807B - Grab the Candies (greedy, 800) 1807C - Find and Replace (greedy, implementation, strings, 800) 1798A - Showstopper (greedy, implementation, sortings, 800) 1799A - Recent Actions (data structures, greedy, implementation, math, 800) 1788A - One and Two (brute force, implementation, math, 800) 1778A - Flip Flop Sum (greedy, implementation, 800) 1772A - A+B? (implementation, 800) 1796B - Asterisk-Minor Template (implementation, strings, 1000) Stage 2: Combinatorics and Geometry 1777A - Everybody Likes Good Arrays!</description></item><item><title>Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/data-structures/binary-tree/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/data-structures/binary-tree/</guid><description>1. What is a Binary Tree?
A binary tree is a data structure in which each node has at most two children, which are referred to as the left child and the right child.
2. Representing a Binary Tree in Python
To represent a binary tree in Python, we can create a class called Node to represent each node in the tree. Each node will have a value and references to its left and right children.
If a node doesn&amp;rsquo;t have a left or right child, the reference will be set to None.</description></item><item><title>Segment Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/data-structures/segment-tree/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/data-structures/segment-tree/</guid><description>A Segment Tree is a data structure used for efficiently processing queries over intervals or ranges. It is commonly used for solving problems that involve finding information about a set of elements and their sub-intervals.
Since a Segment Tree is a binary tree, a simple linear array can be used to represent the Segment Tree. Before building the Segment Tree, one must figure what needs to be stored in the Segment Tree&amp;rsquo;s node?.
Each leaf node represents a single element, and each internal node represents the union of its children&amp;rsquo;s ranges.</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</guid><description>LeetCode problem 11
Problem Statement The problem involves an array of integers height, where each element represents the height of a line. These lines, along with the x-axis, form a series of containers. Your goal is to find the two lines that form the container with the greatest area.
Naive Solution The naive solution is to consider all pairs of lines and calculate the area of water each pair can contain. You would keep track of the maximum area encountered.</description></item><item><title>12. Integer to Roman</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/12/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/12/</guid><description>LeetCode problem 12
class Solution: def intToRoman(self, num: int) -&amp;gt; str: cs = (&amp;#39;M&amp;#39;, &amp;#39;CM&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;CD&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;XC&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;XL&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;IX&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;IV&amp;#39;, &amp;#39;I&amp;#39;) vs = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) res = [] for c, v in zip(cs, vs): while num &amp;gt;= v: num -= v res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>14. Longest Common Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</guid><description>LeetCode problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. First accepted Idea:
class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: strs.sort() l = strs[0] r = strs[-1] if l == r: return l res = &amp;#34;&amp;#34; for i in range(0, len(l)): if l[i] == r[i]: res += l[i] else: return res return res</description></item><item><title>15. 3Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</guid><description>LeetCode problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description></item><item><title>Plan</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/plan/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/plan/</guid><description>Q1 # Problem Difficulty Topics 1 1. Two Sum Easy Array, Hash Table 2 13. Roman to Integer Easy Hash Table, Math, String 3 14. Longest Common Prefix Easy String 4 20. Valid Parentheses Easy String, Stack 5 21. Merge Two Sorted Lists Easy Linked List, Recursion 6 26. Remove Duplicates from Sorted Array Easy Array, Two pointers 7 66. Plus One Easy Array, Math 8 69. Sqrt(x) Easy Math, Binary Search, 9 70. Climbing Stairs Easy Math, Dynamic Programming, Memoization 10 88.</description></item><item><title>LeetCode Top 75</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode75/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode75/</guid><description>Array / String # Problem Difficulty Slides/Video 1 1768. Merge Strings Alternately Easy ‚úÖ ‚úÖ 2 1071. Greatest Common Divisor of Strings Easy ‚úÖ ‚úÖ 3 1431. Kids With the Greatest Number of Candies Easy ‚úÖ ‚úÖ 4 605. Can Place Flowers Easy 5 345. Reverse Vowels of a String Easy 6 151. Reverse Words in a String Medium ‚úÖ 7 238. Product of Array Except Self Medium 8 334. Increasing Triplet Subsequence Medium 9 443. String Compression Medium Two Pointers # Problem Difficulty 10 283.</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</guid><description>LeetCode problem
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] Example 2:
Input: digits = &amp;quot;&amp;quot; Output: [] First accepted class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] result = [&amp;#39;&amp;#39;] for d in digits: d = int(d) tmp = [] for letter in letters[d]: for word in result: word += letter tmp.</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem
Given the &amp;lsquo;head&amp;rsquo; of a linked list, remove the &amp;rsquo;nth&amp;rsquo; node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Idea:
Two pointers. Second pointer starts from nth position. Run while second pointer exist. First version:
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description></item><item><title>1787A - Exponential Equation - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</guid><description>1787A - Exponential Equation (constructive algorithms, math, 800)
Logic The equation is a mix of multiplication and exponential operations. Given the nature of exponential operations, $ùë•^ùë¶$ and $ùë¶^ùë•$ can grow very large very quickly as x and y increase.
We can try to simplify the equation.
If we can somehow set one of the variables x or y to 1, the equation simplifies.
This is because any number (except zero) raised to the power of 1 is the number itself, and any number raised to the power of 0 is 1.</description></item><item><title>1807A - Plus or Minus - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807a/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807a/</guid><description>1807A - Plus or Minus (implementation, 800)
Solution t = int(input()) for _ in range(t): a, b, c = map(int, input().split()) print(&amp;#39;+&amp;#39; if a + b == c else &amp;#39;-&amp;#39;)</description></item><item><title>Python template for contests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/cp-template/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/cp-template/</guid><description>Clean template ############################################# Libraries ###################################################### import bisect import sys import math import os import time from queue import PriorityQueue from io import BytesIO, IOBase from collections import defaultdict, Counter from bisect import bisect_right ############################################# Definitions ###################################################### INF = sys.maxsize BUFSIZE = 4096 ############################################# Inputs ###################################################### # def inp(): return sys.stdin.readline().rstrip(&amp;#34;\r\n&amp;#34;) # read line as string # def inp_int(): return int(inp()) # read input as integer. &amp;#39;1&amp;#39; -&amp;gt; 1 # def inp_int_list(): return list(map(int, inp().split())) # def inp_str_list(): return list(inp()) ############################################# Solution ###################################################### def solve(): n = list(map(int, input().</description></item><item><title>20. Valid Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</guid><description>LeetCode problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true First accepted Idea:</description></item><item><title>21. Merge Two Sorted Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</guid><description>LeetCode problem
You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: list1 = [], list2 = [0] Output: [0] First accepted Idea:
Get smallest head. Loop and update its next.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
class Solution: def generateParenthesis(self, n): res = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: res.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return res</description></item><item><title>24. Swap Nodes in Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/24/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/24/</guid><description>LeetCode problem 24
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def swapPairs(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) pre, cur = dummy, head while cur and cur.next: t = cur.next cur.next = t.next t.next = cur pre.next = t pre, cur = cur, cur.next return dummy.next</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</guid><description>LeetCode problem
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>28. Find the Index of the First Occurrence in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/28/</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/28/</guid><description>LeetCode problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
Example 2:
Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [‚àí231, 231 ‚àí 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.</description></item><item><title>1777B - Emordnilap - 900</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</guid><description>1777B - Emordnilap (combinatorics, greedy, math, 900)
Statement In this problem, we need to find the &amp;ldquo;beauty&amp;rdquo; of all permutations of a certain length n. The beauty of a permutation is defined as the number of inversions in an array that is created by combining the permutation and its reverse.
Logic The key insight is that every permutation of length n has the same beauty.
This is because the structure of the array created by concatenating a permutation with its reverse ensures that there will always be the same number of inversions, regardless of the order of the numbers in the original permutation.</description></item><item><title>1807B - Grab the Candies - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807b/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807b/</guid><description>1807B - Grab the Candies (greedy, 800)
Explanation Read the number of bags and the list of candies in the bags. Calculate the total number of candies with even and odd amounts separately. Compare the total amount of candies with even and odd amounts. If Mihai has strictly more candies than Bianca, output &amp;ldquo;YES&amp;rdquo;. Otherwise, output &amp;ldquo;NO&amp;rdquo;. Solution t = int(input()) for _ in range(t): n = int(input()) ar = list(map(int, input().split())) m = 0 b = 0 if n == 1: print(&amp;#39;YES&amp;#39; if ar[0] % 2 == 0 else &amp;#39;NO&amp;#39;) else: for x in ar: if x % 2 == 0: m += x else: b += x print(&amp;#39;YES&amp;#39; if m &amp;gt; b else &amp;#39;NO&amp;#39;)</description></item><item><title>Algorithms</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/</guid><description>Intro Big-O Cheat Sheet Sort Insertion sort sorts an array by continuously picking an element, starting from the second element, and inserting it in its correct position in the sorted part of the array to its left. It does this by shifting larger elements one position ahead of their current position, making room for the new element.
def insertion_sort(array): for i in range(1, len(array)): value = array[i] while i &amp;gt; 0 and array[i - 1] &amp;gt; value: array[i] = array[i - 1] i -= 1 array[i] = value return array Selection sort works by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first unsorted element.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]
Code Idea:</description></item><item><title>36. Valid Sudoku</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</guid><description>LeetCode problem
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</description></item><item><title>1773F - Football - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</guid><description>1773F - Football (constructive algorithms, 800)
Logic Solution def solve(): n = int(input()) # number of matches a = int(input()) # goals scored b = int(input()) # goals conceded if n == 1: if a == b: print(1) else: print(0) print(f&amp;#34;{a}:{b}&amp;#34;) return matches = [[0, 0] for _ in range(n + 1)] draw = 0 match = 1 while match &amp;lt;= n and a &amp;gt; 0: a -= 1 matches[match] = [1, 0] match += 1 if a &amp;gt; 0: matches[1] = [matches[1][0] + a, 0] if b &amp;gt; 0: if match == n + 1: matches[1][0] += 1 matches[n][0] -= 1 matches[n][1] = b else: while match &amp;lt;= n and b &amp;gt; 0: b -= 1 matches[match][1] += 1 match += 1 if b &amp;gt; 0: matches[n][1] += b for i in range(1, n + 1): if matches[i][0] == matches[i][1]: draw += 1 print(draw) for i in range(1, n + 1): print(f&amp;#34;{matches[i][0]}:{matches[i][1]}&amp;#34;) solve() Codeforces Editorial PDF</description></item><item><title>1807C - Find and Replace - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807c/</link><pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1807c/</guid><description>1807C - Find and Replace (greedy, implementation, strings, 800)
Solution t = int(input()) for _ in range(t): n = int(input()) s = input() reserved_binaries = {} binary_values = [] for c in s: val = reserved_binaries.get(c, None) if not binary_values: binary_values.append(1) if val == binary_values[-1]: print(&amp;#39;NO&amp;#39;) break if not val: val = 1 if binary_values[-1] == 0 else 0 reserved_binaries[c] = val binary_values.append(val) else: print(&amp;#39;YES&amp;#39;)</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: result_permutation = [] if len(nums) == 1: # base case return [nums[:]] for _ in nums: tmp_removed = nums.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</guid><description>LeetCode problem
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify matrix in-place instead.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dd = {} for s in strs: s_sort = &amp;#34;&amp;#34;.</description></item><item><title>1798A - Showstopper - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1798a/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1798a/</guid><description>1798A - Showstopper (greedy, implementation, sortings, 800)
Update a and b in a such way so in a always put the largest and in b smallest.
Solution def solve(a,b,n): a_max = a[0] for i in range(n): max_v = max(a[i], b[i]) min_v = min(a[i], b[i]) a[i] = max_v b[i] = min_v a_max = max(a_max, max_v) if a[-1] &amp;gt;= a_max and b[-1] &amp;gt;= max(b): return &amp;#39;Yes&amp;#39; return &amp;#39;No&amp;#39; t = int(input()) for _ in range(t): n = int(input()) a = list(map(int, input().</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive
class Solution: def myPow(self, x, n): if not n: return 1 if n &amp;lt; 0: return 1 / self.</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>56. Merge Intervals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</guid><description>LeetCode problem
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:
Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Approach 1:
class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort() res = [intervals[0]] for ir in range(1, len(intervals)): if intervals[ir][0] &amp;gt;= res[-1][0] and intervals[ir][0] &amp;lt;= res[-1][1]: # [1,3],[2,6] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) elif res[-1][0] &amp;gt;= intervals[ir][0] and res[-1][0] &amp;lt;= intervals[ir][1]: # [1,3],[0,4] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) else: res.</description></item><item><title>1799A - Recent Actions - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1799a/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1799a/</guid><description>1799A - Recent Actions (data structures, greedy, implementation, math, 800)
Explanation On Codeforces, the &amp;ldquo;Recent Actions&amp;rdquo; field shows the last n posts with recent actions. Initially, there are posts numbered 1 to n in the field, in order from top to bottom. There are also infinitely many posts not in the field, numbered with integers n+1, n+2, and so on.
When a recent action happens in post p:
If it is in the &amp;ldquo;Recent Actions&amp;rdquo; field, it moves from its position to the top position.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 10^9.</description></item><item><title>66. Plus One</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</guid><description>LeetCode problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Example 1:
Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.</description></item><item><title>69. Sqrt(x)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</guid><description>LeetCode problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2. Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>1788A - One and Two - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1788a/</link><pubDate>Tue, 28 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1788a/</guid><description>1788A - One and Two (brute force, implementation, math, 800)
This problem is about finding a specific index ùëò in a given sequence of integers $ùëé_1,ùëé_2,‚Ä¶,ùëé_ùëõ$, where each element is either 1 or 2. The goal is to determine whether there exists an integer ùëò such that the product of all elements from $ùëé_1$ to $ùëé_ùëò$ is equal to the product of all elements from $ùëé_ùëò+1$ to $ùëé_ùëõ$.
Because of product of 1 doesn&amp;rsquo;t change the result we can focus on 2.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>73. Set Matrix Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</guid><description>LeetCode problem
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Approach 1:
Idea:
LeetCode Submission
class Solution: def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None: rows = len(matrix) cols = len(matrix[0]) # 1. Check first row/column for zero&amp;#39;s first_row_has_zero = 0 in matrix[0] first_col_has_zero = 0 in list(zip(*matrix))[0] # 2.</description></item><item><title>75. Sort Colors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</guid><description>LeetCode problem
This problem is also known as the Dutch National Flag problem. One solution is to use three pointers to partition the array into three sections: red, white, and blue.
Here&amp;rsquo;s the algorithm:
Initialize three pointers: left, mid, and right. Initialize left to 0, mid to 0, and right to n-1, where n is the length of the input array. While mid is less than or equal to right: If nums[mid] is 0, swap nums[mid] with nums[left], increment mid and left.</description></item><item><title>78. Subsets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</guid><description>LeetCode problem
In this solution, we start with an empty list in the results array.
For each element in the nums array, we append that element to all of the subsets in the results array to create new subsets, and then add these new subsets to the results array.
By doing this for all elements in nums, we generate all possible subsets.
class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [[]] for i in nums: for j in range(len(res)): cur = [] cur.</description></item><item><title>1778A - Flip Flop Sum - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1778a/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1778a/</guid><description>1778A - Flip Flop Sum (greedy, implementation, 800)
There are three possible conditions:
-1 -1 - all negative. In this case sum -2 becomes sum 2. Plus 4. -1 1 - different, no sum change. 1 1 - all positive. 2 becomes -2. Diff is -4. Solution def solve(): n = int(input()) ar = list(map(int, input().split())) s = 0 # sum # three conditions: all 1, all -1, at least one -1 has_diff = False has2_positive = 0 has2_negative = 0 s += ar[0] for idx in range(1, n): if ar[idx] == ar[idx-1]: if ar[idx] == -1: has2_negative = 4 # -2 -&amp;gt; +2, diff 4 else: has2_positive = -4 # +2 =&amp;gt; +1, diff 1 else: has_diff = True s += ar[idx] if has2_negative: s += has2_negative elif has_diff: .</description></item><item><title>88. Merge Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</link><pubDate>Sun, 30 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</guid><description>LeetCode problem
First accepted class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify nums1 in-place instead. &amp;#34;&amp;#34;&amp;#34; i = len(nums1) - n for j in nums2: nums1[i] = j i += 1 nums1.sort()</description></item><item><title>1772A - A+B? - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1772a/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1772a/</guid><description>1772A - A+B? (implementation, 800)
Solution def solve(): a, b = input().split(&amp;#39;+&amp;#39;) res = int(a) + int(b) print(res) for _ in range(int(input())): solve()</description></item><item><title>94. Binary Tree Inorder Traversal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</guid><description>LeetCode problem
Given the root of a binary tree, return the inorder traversal of its nodes' values.
Example 1:
Input: root = [1,null,2,3] Output: [1,3,2] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Thoughts Don&amp;rsquo;t understand what needed. Why:
1-null-2-3 becomes 1-3-2 [1,2,5,7,8,9,10] becomes [7,2,8,1,9,5,10] In 1-null-2-3 1 becomes the first because we loop to its left node which is null, then come back and first value here is 1.</description></item><item><title>1796B - One and Two - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1796b/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/01-implementation-and-greedy/1796b/</guid><description>Asterisk-Minor Template (implementation, strings, 1000)
If the first characters of both strings are the same, create a template that consists of the common character followed by an asterisk (e.g., a*). If the last characters of both strings are the same, create a template that consists of an asterisk followed by the common character (e.g., *b). If neither the first nor the last characters are the same, iterate through string a and check for any 2-character substring that also appears in string b.</description></item><item><title>Short description from article</title><link>https://romankurnovskii.com/en/tracks/disser/utils/text_2_short/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/disser/utils/text_2_short/</guid><description> Create</description></item><item><title>IAM</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/iam/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/iam/</guid><description>About IAM - AWS Identity and Access Management
AWS IAM AWS IAM User Guide AWS Identity and Access Management (IAM) allows to securely control user access to AWS services and resources.
Designed for organizations with multiple users or systems that use AWS products such as Amazon EC2, Amazon RDS, and AWS Management Console.
With IAM, you can centrally manage users, security credentials such as access keys, and permissions that control user access to AWS resources.
There are three ways IAM authenticates a principal:</description></item><item><title>116. Populating Next Right Pointers in Each Node</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/116/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/116/</guid><description>LeetCode problem
from collections import deque class Solution: def connect(self, root: &amp;#39;Optional[Node]&amp;#39;) -&amp;gt; &amp;#39;Optional[Node]&amp;#39;: if not root: return root queue = deque([root]) while queue: level_size = len(queue) for i in range(level_size): node = queue.popleft() if i &amp;lt; level_size - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root LeetCode Editorial:
Editorial</description></item><item><title>122. Best Time to Buy and Sell Stock II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/122/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/122/</guid><description>LeetCode problem
To solve this problem, we can use a greedy approach.
The idea is to keep adding the profit whenever the price on the next day is higher than the price on the current day.
This way, we will maximize profit.
class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = 0 for i in range(1, len(prices)): if prices[i] &amp;gt; prices[i - 1]: profit += prices[i] - prices[i - 1] return profit LeetCode Editorial:
Editorial</description></item><item><title>128. Longest Consecutive Sequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/128/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/128/</guid><description>LeetCode problem
Save all numbers in set to make it possible to get number at O(1). For each element look for the current+1 element if exists. class Solution: def longestConsecutive(self, nums: List[int]) -&amp;gt; int: res = 0 nset = set(nums) for x in nset: if x - 1 not in nset: # prevent double calculations _max = 1 cur = x while cur + 1 in nset: _max += 1 cur += 1 res = max(_max, res) return res</description></item><item><title>130. Surrounded Regions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/130/</link><pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/130/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to iterate through each cell in the grid, and for each O, check if it is surrounded by X&amp;rsquo;s in all four directions (up, down, left, and right). If so, flip it to X. However, this method has a high time complexity and does not take advantage of any properties of the problem.
Approach: The more efficient solution is to perform a Depth-First Search (DFS) starting from the border O&amp;rsquo;s.</description></item><item><title>131. Palindrome Partitioning</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to generate all possible partitions of the given string and then check if every substring in each partition is a palindrome.
However, this approach would be inefficient, as there would be an exponential number of partitions to check.
Approach:
Using Backtracking.
Logic:
Define a helper function, is_palindrome, to check if a given substring is a palindrome. Define the backtrack function to find all palindrome partitions recursively. This function will take the current position in the string and the current partition as input arguments.</description></item><item><title>134. Gas Station</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to try starting from each gas station and check if you can complete the circuit. For each gas station, calculate the remaining gas in the tank after traveling to the next station.
If the gas is not enough to travel to the next station, stop and try starting from the next gas station.
Approach:
In this problem, we can use a greedy algorithm
We can keep track of the total gas and total cost while iterating through the gas stations.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode problem
The problem asks to create a deep copy of a given linked list with a random pointer in each node. A deep copy means that the new linked list will have completely new nodes, and none of its pointers should point to the nodes in the original list. Both the next and random pointers of the new nodes should point to the new nodes in the copied list in the same order as the original list.</description></item><item><title>139. Word Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</guid><description>LeetCode problem
Approach:
Dynamic Programming.
Logic:
Using DP:
Iterate through each character of string s. Generate all possible substrings ending at the current index. Check if the substring is in wordDict: If it is, check if the index before the substring&amp;rsquo;s first index is marked as True (this indicates that the part of the string before the current substring can be segmented into words in wordDict). If it is, then mark the current index as True. Solution:
class Solution: def wordBreak(self, s, wordDict): n = len(s) dp = [False] * n for end in range(1, n + 1): # 1.</description></item><item><title>141. Linked List Cycle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</guid><description>LeetCode problem 141
Problem Statement The problem asks us to determine if a given linked list contains a cycle. A cycle in a linked list occurs when a node&amp;rsquo;s next pointer points back to a previous node in the list, causing an infinite loop.
Hints &amp;amp; Tips In this problem, you can take advantage of the Floyd&amp;rsquo;s &amp;ldquo;Tortoise and Hare&amp;rdquo; cycle detection algorithm. This algorithm allows you to detect a cycle in O(1) space and O(n) time complexity, where n is the number of nodes.</description></item><item><title>146. LRU Cache</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</guid><description>LeetCode problem
The operations we need to support are get and put which should both be done in O(1) time.
get(key) should return the value if the key exists in the cache, otherwise return -1. put(key, value) should update the value of the key if the key exists; otherwise, this method should insert the key-value pair into the cache. If the cache is full, this method should also evict the least recently used key-value pair. Approach Use Doubly Linked List or Python OrderedDict</description></item><item><title>148. Sort List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</guid><description>LeetCode problem
Naive Solution Traverse the linked list, adding each node&amp;rsquo;s value to a Python list sort that list create a new linked list from the sorted values return the head of this new list. This solution would have a time complexity of O(n log n) due to the sort operation and a space complexity of O(n) because of the extra list we&amp;rsquo;re creating.
class Solution: def sortList(self, head): values = [] node = head while node: values.append(node.val) node = node.</description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</guid><description>LeetCode –∑–∞–¥–∞—á–∞ 151
–ó–∞–¥–∞—á–∞ –ù–∞ –≤—Ö–æ–¥ –ø–æ–¥–∞–µ—Ç—Å—è —Å—Ç—Ä–æ–∫–∞ s. –ù–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–≤ –≤ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ. –°–ª–æ–≤–∞ –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –∫–∞–∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–∏–º–≤–æ–ª–æ–≤ –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤. –°–ª–æ–≤–∞ –≤ s —Ä–∞–∑–¥–µ–ª–µ–Ω—ã —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∏–º –ø—Ä–æ–±–µ–ª–æ–º. –ù—É–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å —Å—Ç—Ä–æ–∫—É, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å–ª–æ–≤–∞ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω—ã –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–µ –æ–¥–Ω–∏–º –ø—Ä–æ–±–µ–ª–æ–º.
–í–∞–∂–Ω–æ: —Å—Ç—Ä–æ–∫–∞ s –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–∞—á–∞–ª—å–Ω—ã–µ –∏–ª–∏ –∫–æ–Ω–µ—á–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏–ª–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –º–µ–∂–¥—É –¥–≤—É–º—è —Å–ª–æ–≤–∞–º–∏. –í –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–π —Å—Ç—Ä–æ–∫–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –ø—Ä–æ–±–µ–ª, —Ä–∞–∑–¥–µ–ª—è—é—â–∏–π —Å–ª–æ–≤–∞. –õ–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –Ω–µ –≤–∫–ª—é—á–∞–µ–º.
–ü–æ–¥—Ö–æ–¥ –î–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ –º—ã –º–æ–∂–µ–º —Ä–∞–∑–¥–µ–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É –Ω–∞ —Å–ª–æ–≤–∞, –∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä–æ–±–µ–ª –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è, –∞ –∑–∞—Ç–µ–º –ø—Ä–æ—Å—Ç–æ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –∏—Ö –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>160. Intersection of Two Linked Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</link><pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</guid><description>LeetCode problem
Solution 1 Using hashmap.
# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode): nodes = set() cur = headA while cur: nodes.add(cur) cur = cur.next cur = headB while cur: if cur in nodes: return cur cur = cur.next return None Solution 2 Initialize two pointers, one for each head. Move each pointer to the next node in its list. If a pointer reaches the end of its list, move it to the start of the other list.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem 166
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>171. Excel Sheet Column Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</guid><description>LeetCode problem
The column titles in an Excel sheet are designed similar to a base-26 number system. The columns start from &amp;lsquo;A&amp;rsquo; (which is 1) to &amp;lsquo;Z&amp;rsquo; (which is 26), then after &amp;lsquo;Z&amp;rsquo;, the column titles go to &amp;lsquo;AA&amp;rsquo; (which is 27), &amp;lsquo;AB&amp;rsquo; (28), and so on.
This problem is essentially asking us to convert a base-26 number (represented by uppercase English letters) to a decimal number.
That means that for each &amp;ldquo;new&amp;rdquo; index in columnTitle we already pass alphabet.</description></item><item><title>172. Factorial Trailing Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/172/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/172/</guid><description>LeetCode problem 172
class Solution: def trailingZeroes(self, n: int) -&amp;gt; int: res = 0 while n: n //= 5 res += n return res</description></item><item><title>173. Binary Search Tree Iterator</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/173/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/173/</guid><description>LeetCode problem 173
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] while root: self.stack.append(root) root = root.left def next(self) -&amp;gt; int: cur = self.stack.pop() node = cur.right while node: self.stack.append(node) node = node.left return cur.val def hasNext(self) -&amp;gt; bool: return len(self.stack) &amp;gt; 0 # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.</description></item><item><title>176. Second Highest Salary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/176/</guid><description>LeetCode problem 176
Drop any duplicate salary values to avoid counting duplicates as separate salary ranks Sort the unique salaries in descending order and get the second highest salary If the second highest salary doesn&amp;rsquo;t exist (e.g., there are fewer than two unique salaries), return None Create a DataFrame with the second highest salary import pandas as pd def second_highest_salary(employee: pd.DataFrame) -&amp;gt; pd.DataFrame: unique_salaries = employee[&amp;#34;salary&amp;#34;].drop_duplicates() second_highest = ( unique_salaries.nlargest(2).iloc[-1] if len(unique_salaries) &amp;gt;= 2 else None ) if second_highest is None: return pd.</description></item><item><title>177. Nth Highest Salary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/177/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/177/</guid><description>LeetCode problem 177
import pandas as pd def nth_highest_salary(employee: pd.DataFrame, N: int) -&amp;gt; pd.DataFrame: unique_salaries = employee.salary.unique() if len(unique_salaries) &amp;lt; N: return pd.DataFrame([np.NaN], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;]) salary = sorted(unique_salaries, reverse=True)[N - 1] return pd.DataFrame([salary], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;])</description></item><item><title>178. Rank Scores</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/178/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/178/</guid><description>LeetCode problem 178
import pandas as pd def order_scores(scores: pd.DataFrame) -&amp;gt; pd.DataFrame: # Use the rank method to assign ranks to the scores in descending order with no gaps scores[&amp;#34;rank&amp;#34;] = scores[&amp;#34;score&amp;#34;].rank(method=&amp;#34;dense&amp;#34;, ascending=False) # Drop id column &amp;amp; Sort the DataFrame by score in descending order result_df = scores.drop(&amp;#34;id&amp;#34;, axis=1).sort_values(by=&amp;#34;score&amp;#34;, ascending=False) return result_df</description></item><item><title>179. Largest Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/179/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/179/</guid><description>LeetCode problem 179
class Solution: def largestNumber(self, nums: List[int]) -&amp;gt; str: nums = [str(v) for v in nums] nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b &amp;lt; b + a else -1)) return &amp;#34;0&amp;#34; if nums[0] == &amp;#34;0&amp;#34; else &amp;#34;&amp;#34;.join(nums)</description></item><item><title>180. Consecutive Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/180/</guid><description>LeetCode problem 180
import pandas as pd def consecutive_numbers(logs: pd.DataFrame) -&amp;gt; pd.DataFrame: all_the_same = lambda lst: lst.nunique() == 1 logs[&amp;#34;is_consecutive&amp;#34;] = ( logs[&amp;#34;num&amp;#34;].rolling(window=3, center=True, min_periods=3).apply(all_the_same) ) return ( logs.query(&amp;#34;is_consecutive == 1.0&amp;#34;)[[&amp;#34;num&amp;#34;]] .drop_duplicates() .rename(columns={&amp;#34;num&amp;#34;: &amp;#34;ConsecutiveNums&amp;#34;}) )</description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</guid><description>LeetCode problem
Problem Statement Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Naive Solution A simple, but inefficient, approach would be to rotate the array k times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations.</description></item><item><title>190. Reverse Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</guid><description>LeetCode problem
This task involves understanding how binary representation works. An unsigned integer is a 32-bit value, where each bit represents a power of 2, from 2^0 (the least significant bit) to 2^31 (the most significant bit).
Unsigned Integers (often called &amp;ldquo;uints&amp;rdquo;) are just like integers (whole numbers) but have the property that they don&amp;rsquo;t have a + or - sign associated with them. Thus they are always non-negative (zero or positive).
Naive Solution A naive solution to this problem could involve converting the number to a binary string, reversing the string, and then converting it back to an integer.</description></item><item><title>191. Number of 1 Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</guid><description>LeetCode problem
Problem Statement Given an integer value represented in binary format, we need to count the number of &amp;lsquo;1&amp;rsquo; bits in its binary representation.
Naive Solution The naive solution for this problem would be to convert the binary number into a string and then simply iterate over the string and count the number of &amp;lsquo;1&amp;rsquo;s. However, this solution is not optimal and is not taking advantage of the properties of binary numbers.
Algorithm The optimal solution for this problem involves using bitwise operation.</description></item><item><title>EC2</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/ec2/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/ec2/</guid><description>About AWS EC2 AWS EC2 User Guide Amazon Elastic Compute Cloud (EC2) - one of the most popular AWS services.
Allows:
to run different types of cloud instances and pay-per-use models. to control computing resources at the operating system level working in an Amazon computing environment. Digest EC2 &amp;amp; EBS EC2 (Elastic Compute Cloud) Instance EBS (Elastic Block Store) - Persistent storage volume AMI (Amazon Machine Image) - Packages OS and additional installations in a reusable template Instance and Instance Types: General Purpose (t-type and m-type), Compute Optimized(c-type), GPU Graphics, GPU Compute, Memory Optimized(r, √ó and z-type), and Storage Optimized(d, h and i-type) Purchasing Options: On Demand, Reserved, Scheduled, Spot, Dedicated Instance and Dedicated Host Spot: Partial hours are not billed if terminated by AWS EC2 Secure login information for your instances using key pairs Placement group: Cluster and Spread For root:</description></item><item><title>201. Bitwise AND of Numbers Range</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/201/</link><pubDate>Wed, 21 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/201/</guid><description>LeetCode problem 201
Focus on the leftmost bits of left and right. The result&amp;rsquo;s bits are only set if left and right share the same leftmost bits up to a point.
Idea The core idea is to find the common prefix of the binary representations of left and right. The bitwise AND of any two numbers is only affected by the common prefix because any difference in the subsequent bits will result in zeros when ANDed.
Approach Track the Shifts: Initialize a variable to track the number of shifts needed to find the common prefix.</description></item><item><title>202. Happy Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</link><pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a number n. We have to determine whether this number is a &amp;ldquo;happy&amp;rdquo; number or not. A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.</description></item><item><title>206. Reverse Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/206/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/206/</guid><description>LeetCode problem 206
Problem Statement Reverse a given singly linked list and return its head. A singly linked list is a data structure consisting of nodes, where each node has a value and a reference to the next node in the sequence.
Naive Solution A naive approach could be to traverse the entire linked list once to read all its elements into an array. Then, we could reverse the array and construct a new linked list from it. This would work, but it takes up additional space for the array.</description></item><item><title>229. Majority Element II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/229/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/229/</guid><description>LeetCode problem 229
Problem Statement Given an integer array of size n, find all elements that appear more than ‚åä n/3 ‚åã times.
Naive Solution The immediate solution would involve using a hashmap or dictionary to track the occurrence of each number in the array. After which, we can iterate over the dictionary to find numbers whose occurrences are greater than n/3.
Hints &amp;amp; Tips There can be at most one or two majority elements which appear more than n/3 times in the array.</description></item><item><title>231. Power of Two</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/231/</link><pubDate>Mon, 19 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/231/</guid><description>LeetCode problem 231
class Solution: def isPowerOfTwo(self, n: int) -&amp;gt; bool: return n &amp;gt; 0 and n == n &amp;amp; (-n) class Solution: def isPowerOfTwo(self, n: int) -&amp;gt; bool: if n &amp;lt; 0: return False return bin(n).count(&amp;#39;1&amp;#39;) == 1</description></item><item><title>234. Palindrome Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</guid><description>LeetCode problem
Problem Statement Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
Naive Solution A simple solution to this problem is to:
traverse the linked list storing the value of each node in an array. Then, we could compare the array with its reversed version.
If they match, the linked list is a palindrome. Otherwise, it is not.
This solution takes O(n) time (where n is the number of nodes in the list), as we need to traverse the list once.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</guid><description>LeetCode problem
Problem Statement The problem is to find a product of all elements in the given integer array nums, except for the i-th element, and return a new array with the results. You must design an algorithm that runs in O(n) time and doesn&amp;rsquo;t use the division operation. The challenge here is to solve this problem with O(1) extra space complexity.
Naive Solution A naive solution could be to calculate the product of all elements in the array, then iterate through the array and replace each element with the total product divided by the element.</description></item><item><title>268. Missing Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/268/</link><pubDate>Mon, 19 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/268/</guid><description>LeetCode problem 268
Hint Consider using mathematical formulas to find the sum of a sequence and compare it with the sum of the array elements.
Idea The idea is based on the formula for the sum of the first n natural numbers: sum = n * (n + 1) / 2. We can calculate the expected sum of numbers from 0 to n and subtract the actual sum of the array elements from it. The difference will be the missing number.</description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</guid><description>LeetCode problem
Problem Statement The problem is asking to move all zeros in an integer array to the end of the array while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.
Naive Solution A naive solution could be to create a new list, iterate over the array, add non-zero elements to the new list and count zero elements. Then extend the new list with the same amount of zeros as counted.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode problem 287
Problem Statement Given an array of integers nums containing n + 1 integers where each integer is within the range [1, n], you need to find and return the only duplicate number present in nums.
The key constraints:
You shouldn&amp;rsquo;t modify the array nums. You should only use constant extra space. Naive Solution One possible naive solution would be to use a nested loop to compare each element with every other element in the array. This approach, however, is not efficient and has a time complexity of O(n^2), which doesn&amp;rsquo;t scale well with large inputs.</description></item><item><title>Elastic Beanstalk</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/elasticbeanstalk/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/elasticbeanstalk/</guid><description>About AWS Elastic Beanstalk AWS Elastic Beanstalk is an easy-to-use service for deploying and scaling web applications and services developed with Java, .NET, PHP, Node.js, Python, Ruby, Go, and Docker on familiar servers such as Apache, Nginx, Passenger, and IIS.
Deploying new application versions to existing resources in AWS Elastic Beanstalk happens much faster (typically under a minute) and once again is¬†mostly dependent on the size of the new application version.
Digest When you want to use new run time capabilities with elastic bean stalk, it is better to use blue-green deployment Security group will not be removed when removing the stack with elastic bean stalk For long running tasks - Use Elastic Beanstalk worker environment to process the tasks asynchronously Launch configuration is used for modifying instance type, key pair, elastic block storage and other settings that can be configured only when launching the instance Rolling with Additional Batch and Immutable both involve provisioning new servers to ensure capacity is not reduced.</description></item><item><title>332. Reconstruct Itinerary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</guid><description>LeetCode problem
Problem Statement Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from &amp;ldquo;JFK&amp;rdquo;, thus, the itinerary must begin with &amp;ldquo;JFK&amp;rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
Naive Solution One naive solution would be to use backtracking and try all possible combinations of tickets to form a valid itinerary.</description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</guid><description>LeetCode problem
Problem Statement The task is to determine if the given list of numbers contains an increasing subsequence of length three. This means we need to find three indices i, j, and k in the list such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k].
Naive Solution One possible naive solution is to use three nested loops to go through all possible triples in the list and check if they are increasing. But this solution is very inefficient, has a time complexity of O(n¬≥), and does not meet the follow-up constraints of the problem.</description></item><item><title>343. Integer Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/343/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/343/</guid><description>LeetCode problem 343
Problem Statement Given a positive integer n, our task is to divide it into the sum of k positive integers, where $k \geq 2$, in such a way that the product of these integers is maximized. Our goal is to determine the maximum possible product.
Naive Solution A straightforward or naive way to solve this would be to consider all potential combinations to divide the number n and calculate the product for each division. This method, while comprehensive, would be inefficient and impractical for larger values of n.</description></item><item><title>345. Reverse Vowels of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</guid><description>LeetCode problem
Problem Statement Given a string s, the task is to reverse only all the vowels in the string and return it. The vowels are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;, and they can appear in both lower and upper cases, more than once.
Naive Solution The naive approach to solve this problem would be to:
Initialize an empty string result. Traverse the given string s from the start to the end. If the current character is a vowel, find the next vowel in the string starting from the end, add it to result, and remove it from the string.</description></item><item><title>389. Find the Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/389/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/389/</guid><description>LeetCode problem 389
Problem Statement Given two strings s and t, the string t is generated by shuffling the characters of s and adding one additional character at a random position. The task is to identify and return that extra character.
Naive Solution A naive solution would involve comparing the characters in both strings one by one to detect the extra character in t. This method is not efficient as it could take a linear amount of time for strings of considerable lengths.</description></item><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</guid><description>LeetCode problem 392
Problem Statement Given two strings s and t, you need to determine if s is a subsequence of t. To be a subsequence, you can remove characters from t without reordering to form s.
Naive Solution The naive approach would be to generate all subsequences of string t and then check if string s is one of them. However, generating all subsequences of t can be computationally expensive especially when the length of t is large.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode problem
Problem Statement Given an encoded string, the task is to decode it to produce a string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.
Naive Solution A naive approach would be to repeatedly look for a pattern in the string where there is a number followed by square brackets. For each such pattern found, replace it with the string inside the square brackets repeated &amp;lsquo;k&amp;rsquo; times. This would work but might not be the most efficient solution, especially for nested brackets.</description></item><item><title>Lambda</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/lambda/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/lambda/</guid><description>About AWS Lambda AWS Lambda¬†User Guide AWS Lambda is a serverless computing service that runs program code in response to certain events and is responsible for automatically allocating the necessary computing resources.
AWS Lambda automatically runs program code in response to various events, such as HTTP requests through Amazon API Gateway, changing objects in Amazon Simple Storage Service garbage cans (Amazon S3), updating tables in Amazon DynamoDB or changing states in AWS Step Functions.
Supports for Java, Go, PowerShell, Node.</description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</guid><description>LeetCode problem
Problem Statement Given a list of characters, chars, you are required to compress the list using the following algorithm:
Start with an empty string, s. For each group of consecutive repeating characters in chars: If the group&amp;rsquo;s length is 1, append the character to s. Otherwise, append the character followed by the group&amp;rsquo;s length. The compressed string s should be stored back in the chars list. The length of the group that is 10 or longer will be split into multiple characters in chars.</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode problem 605
In this problem, we are given a flowerbed represented by an integer array flowerbed, where 0 represents an empty plot and 1 represents a plot with a flower.
We need to determine if we can plant n new flowers in the flowerbed without violating the rule that no two adjacent plots can have flowers.
Naive Solution To solve this problem, we can use a greedy approach. We iterate through the flowerbed and check each plot. If a plot is empty and its adjacent plots are also empty, we can plant a flower in that plot.</description></item><item><title>643. Maximum Average Subarray I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</guid><description>LeetCode problem
Problem Statement Given an integer array nums consisting of n elements and an integer k, find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. The result must be accurate up to a decimal point of 10^(-5).
Naive Solution A straightforward approach would be to calculate the average for every possible subarray of length k. For each starting point, sum the next k numbers and determine the average.</description></item><item><title>ElastiCache</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/elasticache/</link><pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/elasticache/</guid><description>About Documentation User Guide Amazon Elasticache is a fully managed Redis or Memcached in-memory data store.
It&amp;rsquo;s great for use cases like two-tier web applications where the most frequently accesses data is stored in ElastiCache so response time is optimal.
You can use ElastiCache for caching, which accelerates application and database performance, or as a primary data store for use cases that don&amp;rsquo;t require durability like session stores, gaming leaderboards, streaming, and analytics.
Compatible with Redis and Memcached</description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</guid><description>LeetCode problem
Problem Statement Given an array of integers nums, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.
Naive Solution A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode problem 725
Problem Statement The problem asks you to divide a given singly linked list into k different parts such that the sizes of these parts are as nearly equal as possible. The parts should appear in the same order as in the original list, and earlier parts should not be smaller than later parts.
Naive Solution A naive approach would involve counting the length of the list and then traversing the list multiple times to create each part.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode problem
Problem Statement Imagine a row of asteroids moving in space. Each asteroid has a size (given by its absolute value) and a direction it&amp;rsquo;s moving in (given by its sign: positive for right, negative for left). All asteroids move at the same speed. Your task is to determine the final state of the asteroids after all collisions have been resolved.
Two important points to note:
When two asteroids of different directions meet, the smaller one explodes. If they are of the same size, both explode.</description></item><item><title>777. Swap Adjacent in LR String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/777/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/777/</guid><description>LeetCode problem 777
class Solution: def canTransform(self, start: str, end: str) -&amp;gt; bool: n = len(start) i = j = 0 while 1: while i &amp;lt; n and start[i] == &amp;#39;X&amp;#39;: i += 1 while j &amp;lt; n and end[j] == &amp;#39;X&amp;#39;: j += 1 if i &amp;gt;= n and j &amp;gt;= n: return True if i &amp;gt;= n or j &amp;gt;= n or start[i] != end[j]: return False if start[i] == &amp;#39;L&amp;#39; and i &amp;lt; j: return False if start[i] == &amp;#39;R&amp;#39; and i &amp;gt; j: return False i, j = i + 1, j + 1</description></item><item><title>779. K-th Symbol in Grammar</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/779/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/779/</guid><description>LeetCode problem 779
class Solution: def kthGrammar(self, n: int, k: int) -&amp;gt; int: return (k - 1).bit_count() &amp;amp; 1</description></item><item><title>781. Rabbits in Forest</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/781/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/781/</guid><description>LeetCode problem 781
class Solution: def numRabbits(self, answers: List[int]) -&amp;gt; int: counter = Counter(answers) return sum([math.ceil(v / (k + 1)) * (k + 1) for k, v in counter.items()])</description></item><item><title>784. Letter Case Permutation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/784/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/784/</guid><description>LeetCode problem 784
class Solution: def letterCasePermutation(self, s: str) -&amp;gt; List[str]: res = [] n = sum(c.isalpha() for c in s) for i in range(1 &amp;lt;&amp;lt; n): j, t = 0, [] for c in s: if c.isalpha(): c = c.lower() if (i &amp;gt;&amp;gt; j) &amp;amp; 1 else c.upper() j += 1 t.append(c) res.append(&amp;#39;&amp;#39;.join(t)) return res</description></item><item><title>785. Is Graph Bipartite</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/785/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/785/</guid><description>LeetCode problem 785
class Solution: def isBipartite(self, graph: List[List[int]]) -&amp;gt; bool: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(len(graph))) for u, g in enumerate(graph): for v in g: if find(u) == find(v): return False p[find(v)] = find(g[0]) return True</description></item><item><title>786. K-th Smallest Prime Fraction</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/786/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/786/</guid><description>LeetCode problem 786
class Solution: def kthSmallestPrimeFraction(self, arr: List[int], k: int) -&amp;gt; List[int]: h = [(1 / y, 0, j + 1) for j, y in enumerate(arr[1:])] heapify(h) for _ in range(k - 1): _, i, j = heappop(h) if i + 1 &amp;lt; j: heappush(h, (arr[i + 1] / arr[j], i + 1, j)) return [arr[h[0][1]], arr[h[0][2]]]</description></item><item><title>787. Cheapest Flights Within K Stops</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/787/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/787/</guid><description>LeetCode problem 787
class Solution: def findCheapestPrice( self, n: int, flights: List[List[int]], src: int, dst: int, k: int ) -&amp;gt; int: @cache def dfs(u, k): if u == dst: return 0 if k &amp;lt;= 0: return inf k -= 1 res = inf for v, p in g[u]: res = min(res, dfs(v, k) + p) return res g = defaultdict(list) for u, v, p in flights: g[u].append((v, p)) res = dfs(src, k + 1) return -1 if res &amp;gt;= inf else res</description></item><item><title>788. Rotated Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/788/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/788/</guid><description>LeetCode problem 788
class Solution: def rotatedDigits(self, n: int) -&amp;gt; int: @cache def dfs(pos, ok, limit): if pos &amp;lt;= 0: return ok up = a[pos] if limit else 9 res = 0 for i in range(up + 1): if i in (0, 1, 8): res += dfs(pos - 1, ok, limit and i == up) if i in (2, 5, 6, 9): res += dfs(pos - 1, 1, limit and i == up) return res a = [0] * 6 l = 1 while n: a[l] = n % 10 n //= 10 l += 1 return dfs(l, 0, True)</description></item><item><title>789. Escape The Ghosts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/789/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/789/</guid><description>LeetCode problem 789
class Solution: def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -&amp;gt; bool: tx, ty = target return all(abs(tx - x) + abs(ty - y) &amp;gt; abs(tx) + abs(ty) for x, y in ghosts)</description></item><item><title>790. Domino and Tromino Tiling</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/790/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/790/</guid><description>LeetCode problem 790
class Solution: def numTilings(self, n: int) -&amp;gt; int: f = [1, 0, 0, 0] mod = 10**9 + 7 for i in range(1, n + 1): g = [0] * 4 g[0] = (f[0] + f[1] + f[2] + f[3]) % mod g[1] = (f[2] + f[3]) % mod g[2] = (f[1] + f[3]) % mod g[3] = f[0] f = g return f[0]</description></item><item><title>791. Custom Sort String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/791/</guid><description>LeetCode problem 791
class Solution: def customSortString(self, order: str, s: str) -&amp;gt; str: cnt = Counter(s) res = [] for c in order: res.append(c * cnt[c]) cnt[c] = 0 for c, v in cnt.items(): res.append(c * v) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>792. Number of Matching Subsequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/792/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/792/</guid><description>LeetCode problem 792
class Solution: def numMatchingSubseq(self, s: str, words: List[str]) -&amp;gt; int: def check(w): i = -1 for c in w: j = bisect_right(d[c], i) if j == len(d[c]): return False i = d[c][j] return True d = defaultdict(list) for i, c in enumerate(s): d[c].append(i) return sum(check(w) for w in words)</description></item><item><title>794. Valid Tic-Tac-Toe State</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/794/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/794/</guid><description>LeetCode problem 794
class Solution: def validTicTacToe(self, board: List[str]) -&amp;gt; bool: def win(x): for i in range(3): if all(board[i][j] == x for j in range(3)): return True if all(board[j][i] == x for j in range(3)): return True if all(board[i][i] == x for i in range(3)): return True return all(board[i][2 - i] == x for i in range(3)) x = sum(board[i][j] == &amp;#39;X&amp;#39; for i in range(3) for j in range(3)) o = sum(board[i][j] == &amp;#39;O&amp;#39; for i in range(3) for j in range(3)) if x !</description></item><item><title>795. Number of Subarrays with Bounded Maximum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/795/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/795/</guid><description>LeetCode problem 795
class Solution: def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -&amp;gt; int: n = len(nums) l, r = [-1] * n, [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;lt;= v: stk.pop() if stk: l[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: r[i] = stk[-1] stk.append(i) return sum( (i - l[i]) * (r[i] - i) for i, v in enumerate(nums) if left &amp;lt;= v &amp;lt;= right )</description></item><item><title>797. All Paths From Source to Target</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/797/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/797/</guid><description>LeetCode problem 797
class Solution: def allPathsSourceTarget(self, graph: List[List[int]]) -&amp;gt; List[List[int]]: def dfs(t): if t[-1] == len(graph) - 1: res.append(t[:]) return for v in graph[t[-1]]: t.append(v) dfs(t) t.pop() res = [] dfs([0]) return res</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</guid><description>LeetCode problem 799
class Solution: def champagneTower(self, poured: int, query_row: int, query_glass: int) -&amp;gt; float: f = [poured] for i in range(1, query_row + 1): g = [0] * (i + 1) for j, v in enumerate(f): if v &amp;gt; 1: half = (v - 1) / 2 g[j] += half g[j + 1] += half f = g return min(1, f[query_glass])</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/799/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/799/</guid><description>LeetCode problem 799
Problem Statement You are tasked with modeling a champagne tower. Glasses are stacked in a pyramid, with each row having one more glass than the previous. When champagne is poured into the top glass and it overflows, the overflowed champagne is split equally between the two glasses below. The objective is to determine how full a specified glass will be after pouring a given amount of champagne.
Naive Solution One could imagine a simulation, where we pour champagne into the top glass and then, glass-by-glass, simulate the overflow until we reach the desired glass.</description></item><item><title>RDS</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/rds/</link><pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/rds/</guid><description>About Relational Database Service Managed DB service that uses SQL as query language Amazon Relational Database Service (Amazon RDS) is a collection of managed services that makes it simple to set up, operate, and scale databases in the cloud.
Documentation User Guide Supports engines:
Amazon Aurora with MySQL compatibility: 5432 Amazon Aurora with PostgreSQL compatibility: 5432 MySQL: 3306 MariaDB: 3306 PostgreSQL: 5432 Oracle: 1521 SQL Server: 1433 Engine modes:
Used in CreateDBCluster
global parallelquery serverless multimaster Backups Backups are enabled by default in RDS Automated backups</description></item><item><title>802. Find Eventual Safe States</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/802/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/802/</guid><description>LeetCode problem 802
class Solution: def eventualSafeNodes(self, graph: List[List[int]]) -&amp;gt; List[int]: def dfs(i): if color[i]: return color[i] == 2 color[i] = 1 for j in graph[i]: if not dfs(j): return False color[i] = 2 return True n = len(graph) color = [0] * n return [i for i in range(n) if dfs(i)]</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>Round #849/1791 (Div. 4)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/849-div-4-1791/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/849-div-4-1791/</guid><description>TODO G2 Contest date: 2023-02-03
Contest problems
Editorial
Template with function snippets
A. Codeforces Checking https://codeforces.com/contest/1791/problem/A
Solution:
def solve(letter): code = &amp;#34;codeforces&amp;#34; if letter in code: print(&amp;#34;YES&amp;#34;) else: print(&amp;#34;NO&amp;#34;) for _ in range(int(inp())): letter = inp() solve(letter) B. Following Directions https://codeforces.com/contest/1791/problem/B
geometry, implementation, *800
Solution:
def solve(n, s): x = 0 y = 0 for move in s: if move == &amp;#39;L&amp;#39;: x -= 1 elif move == &amp;#39;R&amp;#39;: x += 1 elif move == &amp;#39;U&amp;#39;: y += 1 elif move == &amp;#39;D&amp;#39;: y -= 1 if x == 1 and y == 1: print(&amp;#34;YES&amp;#34;) break else: print(&amp;#34;NO&amp;#34;) for _ in range(int(inp())): # attempts num = int(inp()) letter = inp() solve(num, letter) C.</description></item><item><title>880. Decoded String at Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/880/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/880/</guid><description>LeetCode problem 880
Problem Statement Given an encoded string s, the encoded string is transformed into a tape based on the following criteria:
When a letter is encountered, it&amp;rsquo;s written on the tape. When a digit d is encountered, the current content of the tape is repeated d - 1 more times. You are required to find and return the kth letter (1-indexed) on the decoded tape.
Naive Solution A straightforward solution would involve constructing the entire decoded tape and then simply accessing the kth character.</description></item><item><title>API Gateway</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/api-gateway/</link><pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/api-gateway/</guid><description>About Documentation User Guide API Gateway provides the opportunity to create and expand your own REST and WebSocket APIs at any size.
API endpoints can be cached to accommodate for frequent similar requests.
Use Cases Build a network for micros¬≠ervices archit¬≠ectures.
Amazon CloudWatch metrics - Collects near-real-time metrics Examples: 4XXError (client-side errors), 5XXError(server-side errors), CacheHitCount Amazon CloudWatch Logs - Debug issues related to request execution AWS CloudTrail - Record of actions taken by a user, role, or an AWS service in API Gateway AWS X-Ray - Trace your request across different AWS Services Digests Concepts REST API, HTTP API, WebSocket API</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1004/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1004/</guid><description>LeetCode Problem 1004
Problem Statement Given a binary array nums and an integer k, the task is to return the maximum number of consecutive 1&amp;rsquo;s in the array, with the possibility to flip at most k 0&amp;rsquo;s.
Naive Solution A straight forward approach is to try flipping every combination of k zeros and checking for the longest sequence of 1&amp;rsquo;s. This would involve nested loops, with the outer loop iterating through the array and the inner loops flipping zeros and calculating sequences of 1&amp;rsquo;s.</description></item><item><title>1048. Longest String Chain</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</guid><description>LeetCode problem 1048
Problem Statement You are given an array of words where each word consists of lowercase English letters. Your task is to determine the longest string chain you can form given this list. A word A can be a predecessor of word B if by adding exactly one letter to A (at any position), B is formed. The objective is to find the longest sequence where each word is a predecessor of the next.
Naive Solution The straightforward brute-force way would be to try all possible combinations of word chains.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode problem
Problem Statement The problem is about finding a greatest common divisor (GCD) of two strings. The term &amp;ldquo;GCD&amp;rdquo; might be familiar from mathematics, as the largest number that divides two numbers without leaving a remainder. Here, we extend the idea to strings: a string x is a GCD of strings str1 and str2 if x can be repeatedly appended to itself to obtain str1 and str2.
Naive Solution A naive approach would be to find all possible divisors of str1 and str2, and then find the largest common divisor.</description></item><item><title>1101. The Earliest Moment When Everyone Become Friends</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1101/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1101/</guid><description>LeetCode problem 1101
class UnionFind: __slots__ = (&amp;#39;p&amp;#39;, &amp;#39;size&amp;#39;) def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x: int) -&amp;gt; int: if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a: int, b: int) -&amp;gt; bool: pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def earliestAcq(self, logs: List[List[int]], n: int) -&amp;gt; int: uf = UnionFind(n) for t, x, y in sorted(logs): if uf.</description></item><item><title>1102. Path With Maximum Minimum Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1102/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1102/</guid><description>LeetCode problem 1102
class UnionFind: __slots__ = (&amp;#34;p&amp;#34;, &amp;#34;size&amp;#34;) def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x: int) -&amp;gt; int: if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a: int, b: int) -&amp;gt; bool: pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def maximumMinimumPath(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) uf = UnionFind(m * n) q = [(v, i, j) for i, row in enumerate(grid) for j, v in enumerate(row)] q.</description></item><item><title>1104. Path In Zigzag Labelled Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1104/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1104/</guid><description>LeetCode problem 1104
class Solution: def pathInZigZagTree(self, label: int) -&amp;gt; List[int]: x = i = 1 while (x &amp;lt;&amp;lt; 1) &amp;lt;= label: x &amp;lt;&amp;lt;= 1 i += 1 res = [0] * i while i: res[i - 1] = label label = ((1 &amp;lt;&amp;lt; (i - 1)) + (1 &amp;lt;&amp;lt; i) - 1 - label) &amp;gt;&amp;gt; 1 i -= 1 return res</description></item><item><title>1105. Filling Bookcase Shelves</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1105/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1105/</guid><description>LeetCode problem 1105
class Solution: def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -&amp;gt; int: n = len(books) f = [0] * (n + 1) for i, (w, h) in enumerate(books, 1): f[i] = f[i - 1] + h for j in range(i - 1, 0, -1): w += books[j - 1][0] if w &amp;gt; shelfWidth: break h = max(h, books[j - 1][1]) f[i] = min(f[i], f[j - 1] + h) return f[n]</description></item><item><title>1109. Corporate Flight Bookings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1109/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1109/</guid><description>LeetCode problem 1109
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) def update(self, x, delta): while x &amp;lt;= self.n: self.c[x] += delta x += x &amp;amp; -x def query(self, x): s = 0 while x: s += self.c[x] x -= x &amp;amp; -x return s class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -&amp;gt; List[int]: tree = BinaryIndexedTree(n) for first, last, seats in bookings: tree.update(first, seats) tree.update(last + 1, -seats) return [tree.</description></item><item><title>1110. Delete Nodes And Return Forest</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1110/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1110/</guid><description>LeetCode problem 1110
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def delNodes( self, root: Optional[TreeNode], to_delete: List[int] ) -&amp;gt; List[TreeNode]: def dfs(root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: if root is None: return None root.left, root.right = dfs(root.left), dfs(root.right) if root.val not in s: return root if root.left: res.append(root.left) if root.right: res.append(root.right) return None s = set(to_delete) res = [] if dfs(root): res.</description></item><item><title>1111. Maximum Nesting Depth of Two Valid Parentheses Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1111/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1111/</guid><description>LeetCode problem 1111
class Solution: def maxDepthAfterSplit(self, seq: str) -&amp;gt; List[int]: res = [0] * len(seq) x = 0 for i, c in enumerate(seq): if c == &amp;#34;(&amp;#34;: res[i] = x &amp;amp; 1 x += 1 else: x -= 1 res[i] = x &amp;amp; 1 return res</description></item><item><title>1115. Print FooBar Alternately</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1115/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1115/</guid><description>LeetCode problem 1115
from threading import Semaphore class FooBar: def __init__(self, n): self.n = n self.f = Semaphore(1) self.b = Semaphore(0) def foo(self, printFoo: &amp;#34;Callable[[], None]&amp;#34;) -&amp;gt; None: for _ in range(self.n): self.f.acquire() # printFoo() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line. printFoo() self.b.release() def bar(self, printBar: &amp;#34;Callable[[], None]&amp;#34;) -&amp;gt; None: for _ in range(self.n): self.b.acquire() # printBar() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line. printBar() self.f.release()</description></item><item><title>1116. Print Zero Even Odd</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1116/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1116/</guid><description>LeetCode problem 1116
from threading import Semaphore class ZeroEvenOdd: def __init__(self, n): self.n = n self.z = Semaphore(1) self.e = Semaphore(0) self.o = Semaphore(0) # printNumber(x) outputs &amp;#34;x&amp;#34;, where x is an integer. def zero(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(self.n): self.z.acquire() printNumber(0) if i % 2 == 0: self.o.release() else: self.e.release() def even(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(2, self.n + 1, 2): self.e.acquire() printNumber(i) self.z.release() def odd(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(1, self.</description></item><item><title>1120. Maximum Average Subtree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1120/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1120/</guid><description>LeetCode problem 1120
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maximumAverageSubtree(self, root: Optional[TreeNode]) -&amp;gt; float: def dfs(root): if root is None: return 0, 0 ls, ln = dfs(root.left) rs, rn = dfs(root.right) s = root.val + ls + rs n = 1 + ln + rn nonlocal res res = max(res, s / n) return s, n res = 0 dfs(root) return res</description></item><item><title>1123. Lowest Common Ancestor of Deepest Leaves</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1123/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1123/</guid><description>LeetCode problem 1123
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def lcaDeepestLeaves(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: def dfs(root): if root is None: return None, 0 l, d1 = dfs(root.left) r, d2 = dfs(root.right) if d1 &amp;gt; d2: return l, d1 + 1 if d1 &amp;lt; d2: return r, d2 + 1 return root, d1 + 1 return dfs(root)[0]</description></item><item><title>1207. Unique Number of Occurrences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1207/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1207/</guid><description>LeetCode problem
Problem Statement Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
Naive Solution A naive approach would be to create a dictionary to store the count of each integer, then iterate over the dictionary and compare each count with the counts of other integers. This approach requires O(n^2) time complexity, where n is the length of the array. This is not efficient for large input sizes.</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1359/</guid><description>LeetCode problem 1359
Problem Statement You&amp;rsquo;re tasked with finding all valid sequences of pickup and delivery events for n orders such that for every order, the delivery always comes after its respective pickup. Because the answer can be immense, you&amp;rsquo;re to return the result modulo (10^9 + 7).
Naive Solution A straightforward approach might be to generate all potential permutations of pickup and delivery actions and then exclude the unsuitable ones. However, this method would be exceedingly inefficient and would not scale for larger n values.</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1372/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1372/</guid><description>LeetCode problem 1372
Problem Statement Given the root of a binary tree, the task is to find the longest ZigZag path contained in that tree. A ZigZag path is defined by a sequence starting at any node and switching between left and right directions at each subsequent step.
Naive Solution A simplistic approach would be to kick off from every node and emulate the ZigZag movement until it&amp;rsquo;s no longer feasible, all the while updating the longest path encountered.</description></item><item><title>1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1420/</link><pubDate>Thu, 21 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1420/</guid><description>LeetCode Problem 1420
Problem Statement In this problem, we have three integers, n, m, and k. We need to construct an array arr having the following properties:
It consists of exactly n integers. Each integer in the array is between 1 and m inclusive. After executing a certain algorithm on arr, we get a value known as search_cost. Our goal is to ensure search_cost is equal to k. The main challenge is determining how many ways we can construct such an array arr.</description></item><item><title>1431. Kids With the Greatest Number of Candies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1431/</link><pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1431/</guid><description>LeetCode problem 1431. Kids With the Greatest Number of Candies
Problem Statement Imagine you&amp;rsquo;re in a classroom with a bunch of kids, and each kid has a certain number of candies. You, being super generous, have some extra candies to give away. Now, you&amp;rsquo;re wondering, if you give all these extra candies to one kid at a time, will that kid end up having the most candies in the class? And you want to check this for every kid in the class.</description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</guid><description>LeetCode Problem 1456
Problem Statement Given a string s and an integer k, the task is to return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.
Naive Solution The most straightforward solution to this problem is to take every possible substring of length k and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length k.</description></item><item><title>1481. Least Number of Unique Integers after K Removals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1481/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1481/</guid><description>LeetCode problem 1481
class Solution: def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -&amp;gt; int: counter = Counter(arr) for i, v in enumerate(sorted(counter.values())): k -= v if k &amp;lt; 0: return len(counter) - i return 0</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1642. Furthest Building You Can Reach</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1642/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1642/</guid><description>LeetCode problem 1642
class Solution: def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -&amp;gt; int: h = [] for i, a in enumerate(heights[:-1]): b = heights[i + 1] d = b - a if d &amp;gt; 0: heappush(h, d) if len(h) &amp;gt; ladders: bricks -= heappop(h) if bricks &amp;lt; 0: return i return len(heights) - 1</description></item><item><title>1657. Determine if Two Strings Are Close</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</guid><description>LeetCode problem
Problem Statement Two strings are considered close if you can attain one from the other using two operations:
Swap any two existing characters. Transform every occurrence of one existing character into another existing character, and do the same with the other character. The challenge is to determine whether two given strings are close or not.
Naive Solution A naive approach might involve trying every possible combination of operations on the two strings until they match or until you&amp;rsquo;ve exhausted all possibilities.</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1658/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1658/</guid><description>LeetCode problem 1658
Problem Statement You have an integer array nums and another integer x. In a single operation, you can either remove the leftmost or the rightmost element from the array nums and decrement x by the value of the removed element. The question is: What is the minimum number of operations required to reduce x to exactly zero? If it&amp;rsquo;s not feasible, the answer should be -1.
Naive Solution The naive approach would be to explore every possible combination of removing elements from the start or the end, recursively.</description></item><item><title>1688. Count of Matches in Tournament</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1688/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1688/</guid><description>LeetCode problem 1688
class Solution: def numberOfMatches(self, n: int) -&amp;gt; int: return n - 1</description></item><item><title>1694. Reformat Phone Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1694/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1694/</guid><description>LeetCode problem 1694
class Solution: def reformatNumber(self, number: str) -&amp;gt; str: number = number.replace(&amp;#34;-&amp;#34;, &amp;#34;&amp;#34;).replace(&amp;#34; &amp;#34;, &amp;#34;&amp;#34;) n = len(number) res = [number[i * 3 : i * 3 + 3] for i in range(n // 3)] if n % 3 == 1: res[-1] = res[-1][:2] res.append(number[-2:]) elif n % 3 == 2: res.append(number[-2:]) return &amp;#34;-&amp;#34;.join(res)</description></item><item><title>1700. Number of Students Unable to Eat Lunch</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1700/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1700/</guid><description>LeetCode problem 1700
class Solution: def countStudents(self, students: List[int], sandwiches: List[int]) -&amp;gt; int: counter = Counter(students) for v in sandwiches: if counter[v] == 0: return counter[v ^ 1] counter[v] -= 1 return 0</description></item><item><title>CodeDeploy</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codedeploy/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codedeploy/</guid><description>About CodeDeploy is a fully managed deployment service that automates software deploy¬≠ments to a variety of compute services such as EC2, Fargate, Lambda, &amp;amp; on-pre¬≠mises servers
Documentation User Guide CodeDeploy can also deploy a serverless Lambda function.
CodeDeploy can be connected to CodePipeline and use artifacts from there.
Platforms Need to choose the compute platform:
EC2/On-premises. AWS Lambda. Amazon ECS. AppSpec File The application specification file (AppSpec file) is a YAML-formatted, or JSON-formatted file used by CodeDeploy to manage a deployment.</description></item><item><title>1704. Determine if String Halves Are Alike</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1704/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1704/</guid><description>LeetCode problem 1704
class Solution: def halvesAreAlike(self, s: str) -&amp;gt; bool: vowels = set(&amp;#39;aeiouAEIOU&amp;#39;) a, b = s[: len(s) &amp;gt;&amp;gt; 1], s[len(s) &amp;gt;&amp;gt; 1 :] res = sum(c in vowels for c in a) == sum(c in vowels for c in b) return return</description></item><item><title>1708. Largest Subarray Length K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1708/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1708/</guid><description>LeetCode problem 1708
class Solution: def largestSubarray(self, nums: List[int], k: int) -&amp;gt; List[int]: i = nums.index(max(nums[: len(nums) - k + 1])) return nums[i : i + k]</description></item><item><title>1710. Maximum Units on a Truck</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1710/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1710/</guid><description>LeetCode problem 1710
class Solution: def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -&amp;gt; int: cnt = [0] * 1001 for a, b in boxTypes: cnt[b] += a res = 0 for b in range(1000, 0, -1): a = cnt[b] if a: res += b * min(truckSize, a) truckSize -= a if truckSize &amp;lt;= 0: break return res</description></item><item><title>1716. Calculate Money in Leetcode Bank</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1716/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1716/</guid><description>LeetCode problem 1716
class Solution: def totalMoney(self, n: int) -&amp;gt; int: a, b = divmod(n, 7) return (28 + 28 + 7 * (a - 1)) * a // 2 + (a * 2 + b + 1) * b // 2</description></item><item><title>1720. Decode XORed Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1720/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1720/</guid><description>LeetCode problem 1720
class Solution: def decode(self, encoded: List[int], first: int) -&amp;gt; List[int]: res = [first] for e in encoded: res.append(res[-1] ^ e) return res</description></item><item><title>1725. Number Of Rectangles That Can Form The Largest Square</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1725/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1725/</guid><description>LeetCode problem 1725
class Solution: def countGoodRectangles(self, rectangles: List[List[int]]) -&amp;gt; int: res = mx = 0 for l, w in rectangles: x = min(l, w) if mx &amp;lt; x: res = 1 mx = x elif mx == x: res += 1 return res</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1732/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1732/</guid><description>LeetCode problem 1732
class Solution: def largestAltitude(self, gain: List[int]) -&amp;gt; int: res = h = 0 for v in gain: h += v res = max(res, h) return res</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1732/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1732/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a biker who is going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal to 0.
We are also given an integer array gain of length n where gain[i] represents the net gain in altitude between points i and i + 1 for all 0 &amp;lt;= i &amp;lt; n. The net gain could be negative, indicating a decrease in altitude, or positive, indicating an increase in altitude.</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1768/</guid><description>LeetCode problem
Problem Statement The task is to merge two strings alternately, i.e., take one character from the first string, then one from the second, then again from the first, and so on. If one string finishes before the other, the remaining characters from the longer string are appended at the end.
Naive Solution A naive approach could involve maintaining two pointers, one for each string, and incrementally appending characters from each string to the result. Once we reach the end of one string, we append the rest of the other string to the result.</description></item><item><title>CodeBuild</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codebuild/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codebuild/</guid><description>About CodeBuild is a fully managed service that assembles source code, runs unit tests, &amp;amp; also generates artefacts ready to deploy.
Documentation User Guide CodeBuild is a code creation service that also produces code artefacts upon request.
CodeBuild is an alternative to other build tools such as Jenkins.
CodeBuild is integrated with KMS for encryption of build artifacts, IAM for build permissions, VPC for network security, and CloudTrail for logging API calls.
CodeBuild is a fully managed build service to compile source code, run unit tests and produce artifacts that are ready for deployment.</description></item><item><title>1887. Reduction Operations to Make the Array Elements Equal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1887/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1887/</guid><description>LeetCode Problem 1887
Problem Statement The goal of this problem is to make all elements in a given integer array nums equal, through a series of reduction operations. In each operation, we find the largest element in the array, find the next largest element that is strictly smaller than the largest, and reduce the largest element to this next largest value. The task is to return the number of such operations needed to make all array elements equal.</description></item><item><title>CodePipeline</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codepipeline/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codepipeline/</guid><description>About AWS CodePipeline is a fully managed continuous delivery service that helps you automate your release pipelines for fast and reliable application and infrastructure updates.
Documentation User Guide CodePipeline automates the build, test, and deploy phases of your release process every time there is a code change, based on the release model you define.
You can easily integrate AWS CodePipeline with third-party services such as GitHub or with your own custom plugin. With AWS CodePipeline, you only pay for what you use.</description></item><item><title>2108. Find First Palindromic String in the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2108/</guid><description>LeetCode problem 2108
class Solution: def firstPalindrome(self, words: List[str]) -&amp;gt; str: return next((w for w in words if w == w[::-1]), &amp;#34;&amp;#34;)</description></item><item><title>CodeArtifact</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codeartifact/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codeartifact/</guid><description>About AWS CodeArtifact is a fully managed artifact repository service that makes it easy for organizations of any size to securely store, publish, and share software packages used in their software development process.
Documentation User Guide CodeAr¬≠tifact is a secure storage, publishing, and sharing of software code packages used in a development process organisation&amp;rsquo;s software development. CodeAr¬≠tifact makes it easy for small organisations to store, publish, and share software packages.
CodeArtifact can be configured to automatically fetch software packages and dependencies from public artifact repositories.</description></item><item><title>2215. Find the Difference of Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</guid><description>LeetCode problem
Problem Statement Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:
answer[0] is a list of all distinct integers in nums1 which are not present in nums2. answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order.
Naive Solution A naive approach would be to iterate over each element of the first array and check whether it&amp;rsquo;s in the second array.</description></item><item><title>2251. Number of Flowers in Full Bloom</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</guid><description>LeetCode Problem 2251
Problem Statement In the given problem, we are presented with two arrays. The first, flowers, represents when each flower starts and stops being in full bloom. The second, people, indicates when each person arrives to see the flowers. Our task is to determine, for each person, how many flowers they will see in full bloom upon their arrival.
Naive Solution A straightforward approach might involve iterating over each person&amp;rsquo;s arrival time. For each time, we could iterate over the flowers list to count how many flowers are in full bloom.</description></item><item><title>2283. Check if Number Has Equal Digit Count and Digit Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2283/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2283/</guid><description>LeetCode problem 2283
class Solution: def digitCount(self, num: str) -&amp;gt; bool: cnt = Counter(num) return all(cnt[str(i)] == int(v) for i, v in enumerate(num))</description></item><item><title>2287. Rearrange Characters to Make Target String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2287/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2287/</guid><description>LeetCode problem 2287
class Solution: def rearrangeCharacters(self, s: str, target: str) -&amp;gt; int: cnt1 = Counter(s) cnt2 = Counter(target) return min(cnt1[c] // v for c, v in cnt2.items())</description></item><item><title>2293. Min Max Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2293/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2293/</guid><description>LeetCode problem 2293
class Solution: def minMaxGame(self, nums: List[int]) -&amp;gt; int: n = len(nums) while n &amp;gt; 1: n &amp;gt;&amp;gt;= 1 for i in range(n): a, b = nums[i &amp;lt;&amp;lt; 1], nums[i &amp;lt;&amp;lt; 1 | 1] nums[i] = min(a, b) if i % 2 == 0 else max(a, b) return nums[0]</description></item><item><title>2299. Strong Password Checker II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2299/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2299/</guid><description>LeetCode problem 2299
class Solution: def strongPasswordCheckerII(self, password: str) -&amp;gt; bool: if len(password) &amp;lt; 8: return False mask = 0 for i, c in enumerate(password): if i and c == password[i - 1]: return False if c.islower(): mask |= 1 elif c.isupper(): mask |= 2 elif c.isdigit(): mask |= 4 else: mask |= 8 return mask == 15</description></item><item><title>X-Ray</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/xray/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/xray/</guid><description>About AWS X-Ray helps developers analyze and debug production, distributed applications, such as those built using a microservices architecture.
Documentation User Guide X-Ray allows software engineers to view the state of a system at a glance, identify potential bottlenecks, and make informed operational decisions to improve performance and reliability. X-Ray inspects application code using a combination of machine and customer-provided data to identify potential bottlenecks and analyze performance and performance trends for each test scenario.
Terminology AWS X-Ray receives data from services as segments.</description></item><item><title>2303. Calculate Amount Paid in Taxes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2303/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2303/</guid><description>LeetCode problem 2303
class Solution: def calculateTax(self, brackets: List[List[int]], income: int) -&amp;gt; float: res = prev = 0 for upper, percent in brackets: res += max(0, min(income, upper) - prev) * percent prev = upper return res / 100</description></item><item><title>2309. Greatest English Letter in Upper and Lower Case</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2309/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2309/</guid><description>LeetCode problem 2309
class Solution: def greatestLetter(self, s: str) -&amp;gt; str: mask1 = mask2 = 0 for c in s: if c.islower(): mask1 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) else: mask2 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;A&amp;#34;)) mask = mask1 &amp;amp; mask2 return chr(mask.bit_length() - 1 + ord(&amp;#34;A&amp;#34;)) if mask else &amp;#34;&amp;#34;</description></item><item><title>2315. Count Asterisks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2315/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2315/</guid><description>LeetCode problem 2315
class Solution: def countAsterisks(self, s: str) -&amp;gt; int: res, ok = 0, 1 for c in s: if c == &amp;#34;*&amp;#34;: res += ok elif c == &amp;#34;|&amp;#34;: ok ^= 1 return res</description></item><item><title>2319. Check if Matrix Is X-Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2319/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2319/</guid><description>LeetCode problem 2319
class Solution: def checkXMatrix(self, grid: List[List[int]]) -&amp;gt; bool: for i, row in enumerate(grid): for j, v in enumerate(row): if i == j or i + j == len(grid) - 1: if v == 0: return False elif v: return False return True</description></item><item><title>2325. Decode the Message</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2325/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2325/</guid><description>LeetCode problem 2325
class Solution: def decodeMessage(self, key: str, message: str) -&amp;gt; str: d = {&amp;#34; &amp;#34;: &amp;#34; &amp;#34;} i = 0 for c in key: if c not in d: d[c] = ascii_lowercase[i] i += 1 return &amp;#34;&amp;#34;.join(d[c] for c in message)</description></item><item><title>2331. Evaluate Boolean Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2331/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2331/</guid><description>LeetCode problem 2331
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def evaluateTree(self, root: Optional[TreeNode]) -&amp;gt; bool: if root.left is None: return bool(root.val) l = self.evaluateTree(root.left) r = self.evaluateTree(root.right) return l or r if root.val == 2 else l and r</description></item><item><title>2335. Minimum Amount of Time to Fill Cups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2335/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2335/</guid><description>LeetCode problem 2335
class Solution: def fillCups(self, amount: List[int]) -&amp;gt; int: amount.sort() if amount[0] + amount[1] &amp;lt;= amount[2]: return amount[2] return (sum(amount) + 1) // 2</description></item><item><title>2341. Maximum Number of Pairs in Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2341/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2341/</guid><description>LeetCode problem 2341
class Solution: def numberOfPairs(self, nums: List[int]) -&amp;gt; List[int]: cnt = Counter(nums) s = sum(v // 2 for v in cnt.values()) return [s, len(nums) - s * 2]</description></item><item><title>2347. Best Poker Hand</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2347/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2347/</guid><description>LeetCode problem 2347
class Solution: def bestHand(self, ranks: List[int], suits: List[str]) -&amp;gt; str: # if len(set(suits)) == 1: if all(a == b for a, b in pairwise(suits)): return &amp;#39;Flush&amp;#39; cnt = Counter(ranks) if any(v &amp;gt;= 3 for v in cnt.values()): return &amp;#39;Three of a Kind&amp;#39; if any(v == 2 for v in cnt.values()): return &amp;#39;Pair&amp;#39; return &amp;#39;High Card&amp;#39;</description></item><item><title>2351. First Letter to Appear Twice</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2351/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2351/</guid><description>LeetCode problem 2351
class Solution: def repeatedCharacter(self, s: str) -&amp;gt; str: mask = 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if mask &amp;gt;&amp;gt; i &amp;amp; 1: return c mask |= 1 &amp;lt;&amp;lt; i</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode problem 2352
Problem Statement You are given a square grid of integers, specifically a 0-indexed n√ón matrix named grid. The objective is to determine how many pairs of rows and columns in the grid are identical in terms of their content and order.
To elucidate, if row $r_i$ and column $c_j$ have the same integers in the exact same sequence, they are considered an &amp;ldquo;equal&amp;rdquo; pair. The challenge is to count all such pairs in the given matrix.</description></item><item><title>2353. Design a Food Rating System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2353/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2353/</guid><description>LeetCode problem 2353
from sortedcontainers import SortedSet class FoodRatings: def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]): self.mp = {} self.t = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1]))) for a, b, c in zip(foods, cuisines, ratings): self.mp[a] = (b, c) self.t[b].add((c, a)) def changeRating(self, food: str, newRating: int) -&amp;gt; None: b, c = self.mp[food] self.mp[food] = (b, newRating) self.t[b].remove((c, food)) self.t[b].add((newRating, food)) def highestRated(self, cuisine: str) -&amp;gt; str: return self.t[cuisine][0][1] # Your FoodRatings object will be instantiated and called as such: # obj = FoodRatings(foods, cuisines, ratings) # obj.</description></item><item><title>2357. Make Array Zero by Subtracting Equal Amounts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2357/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2357/</guid><description>LeetCode problem 2357
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: return len({x for x in nums if x})</description></item><item><title>2358. Maximum Number of Groups Entering a Competition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2358/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2358/</guid><description>LeetCode problem 2358
class Solution: def maximumGroups(self, grades: List[int]) -&amp;gt; int: n = len(grades) return bisect_right(range(n + 1), n * 2, key=lambda x: x * x + x) - 1</description></item><item><title>2359. Find Closest Node to Given Two Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2359/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2359/</guid><description>LeetCode problem 2359
class Solution: def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -&amp;gt; int: def f(i): dist = [inf] * n dist[i] = 0 q = deque([i]) while q: i = q.popleft() for j in g[i]: if dist[j] == inf: dist[j] = dist[i] + 1 q.append(j) return dist g = defaultdict(list) for i, j in enumerate(edges): if j != -1: g[i].append(j) n = len(edges) d1 = f(node1) d2 = f(node2) res, d = -1, inf for i, (a, b) in enumerate(zip(d1, d2)): if (t := max(a, b)) &amp;lt; d: d = t res = i return res</description></item><item><title>2363. Merge Similar Items</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2363/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2363/</guid><description>LeetCode problem 2363
class Solution: def mergeSimilarItems( self, items1: List[List[int]], items2: List[List[int]] ) -&amp;gt; List[List[int]]: cnt = Counter() for v, w in chain(items1, items2): cnt[v] += w return sorted(cnt.items())</description></item><item><title>2364. Count Number of Bad Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2364/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2364/</guid><description>LeetCode problem 2364
class Solution: def countBadPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter() res = 0 for i, x in enumerate(nums): res += i - cnt[i - x] cnt[i - x] += 1 return res</description></item><item><title>2365. Task Scheduler II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2365/</guid><description>LeetCode problem 2365
class Solution: def taskSchedulerII(self, tasks: List[int], space: int) -&amp;gt; int: day = defaultdict(int) res = 0 for task in tasks: res += 1 res = max(res, day[task]) day[task] = res + space + 1 return res</description></item><item><title>2367. Number of Arithmetic Triplets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2367/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2367/</guid><description>LeetCode problem 2367
class Solution: def arithmeticTriplets(self, nums: List[int], diff: int) -&amp;gt; int: vis = set(nums) return sum(x + diff in vis and x + diff * 2 in vis for x in nums)</description></item><item><title>2368. Reachable Nodes With Restrictions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2368/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2368/</guid><description>LeetCode problem 2368
class Solution: def reachableNodes( self, n: int, edges: List[List[int]], restricted: List[int] ) -&amp;gt; int: s = set(restricted) g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) q = deque([0]) vis = [False] * n for v in restricted: vis[v] = True res = 0 while q: i = q.popleft() res += 1 vis[i] = True for j in g[i]: if not vis[j]: q.append(j) return res</description></item><item><title>2369. Check if There is a Valid Partition For The Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2369/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2369/</guid><description>LeetCode problem 2369
class Solution: def validPartition(self, nums: List[int]) -&amp;gt; bool: n = len(nums) dp = [False] * (n + 1) dp[0] = True for i in range(2, n + 1): if nums[i - 1] == nums[i - 2]: dp[i] = dp[i] or dp[i - 2] if i &amp;gt; 2 and nums[i - 1] == nums[i - 2] == nums[i - 3]: dp[i] = dp[i] or dp[i - 3] if ( i &amp;gt; 2 and nums[i - 1] - nums[i - 2] == 1 and nums[i - 2] - nums[i - 3] == 1 ): dp[i] = dp[i] or dp[i - 3] return dp[-1]</description></item><item><title>2370. Longest Ideal Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2370/</guid><description>LeetCode problem 2370
class Solution: def longestIdealString(self, s: str, k: int) -&amp;gt; int: n = len(s) res = 1 dp = [1] * n d = {s[0]: 0} for i in range(1, n): a = ord(s[i]) for b in ascii_lowercase: if abs(a - ord(b)) &amp;gt; k: continue if b in d: dp[i] = max(dp[i], dp[d[b]] + 1) d[s[i]] = i return max(dp)</description></item><item><title>2373. Largest Local Values in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2373/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2373/</guid><description>LeetCode problem 2373
class Solution: def largestLocal(self, grid: List[List[int]]) -&amp;gt; List[List[int]]: n = len(grid) res = [[0] * (n - 2) for _ in range(n - 2)] for i in range(n - 2): for j in range(n - 2): res[i][j] = max( grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3) ) return res</description></item><item><title>2374. Node With Highest Edge Score</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2374/</guid><description>LeetCode problem 2374
class Solution: def edgeScore(self, edges: List[int]) -&amp;gt; int: cnt = Counter() for i, v in enumerate(edges): cnt[v] += i res = 0 for i in range(len(edges)): if cnt[res] &amp;lt; cnt[i]: res = i return res</description></item><item><title>2375. Construct Smallest Number From DI String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2375/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2375/</guid><description>LeetCode problem 2375
class Solution: def smallestNumber(self, pattern: str) -&amp;gt; str: def dfs(u): nonlocal res if res: return if u == len(pattern) + 1: res = &amp;#39;&amp;#39;.join(t) return for i in range(1, 10): if not vis[i]: if u and pattern[u - 1] == &amp;#39;I&amp;#39; and int(t[-1]) &amp;gt;= i: continue if u and pattern[u - 1] == &amp;#39;D&amp;#39; and int(t[-1]) &amp;lt;= i: continue vis[i] = True t.append(str(i)) dfs(u + 1) vis[i] = False t.pop() vis = [False] * 10 t = [] res = None dfs(0) return res</description></item><item><title>2378. Choose Edges to Maximize Score in a Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2378/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2378/</guid><description>LeetCode problem 2378
class Solution: def maxScore(self, edges: List[List[int]]) -&amp;gt; int: def dfs(i): a = b = t = 0 for j, w in g[i]: x, y = dfs(j) a += y b += y t = max(t, x - y + w) b += t return a, b g = defaultdict(list) for i, (p, w) in enumerate(edges[1:], 1): g[p].append((i, w)) return dfs(0)[1]</description></item><item><title>2379. Minimum Recolors to Get K Consecutive Black Blocks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2379/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2379/</guid><description>LeetCode problem 2379
class Solution: def minimumRecolors(self, blocks: str, k: int) -&amp;gt; int: res = cnt = blocks[:k].count(&amp;#39;W&amp;#39;) for i in range(k, len(blocks)): cnt += blocks[i] == &amp;#39;W&amp;#39; cnt -= blocks[i - k] == &amp;#39;W&amp;#39; res = min(res, cnt) return res</description></item><item><title>2380. Time Needed to Rearrange a Binary String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2380/</guid><description>LeetCode problem 2380
class Solution: def secondsToRemoveOccurrences(self, s: str) -&amp;gt; int: res = cnt = 0 for c in s: if c == &amp;#39;0&amp;#39;: cnt += 1 elif cnt: res = max(res + 1, cnt) return res</description></item><item><title>2381. Shifting Letters II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2381/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2381/</guid><description>LeetCode problem 2381
class Solution: def shiftingLetters(self, s: str, shifts: List[List[int]]) -&amp;gt; str: n = len(s) d = [0] * (n + 1) for i, j, v in shifts: if v == 0: v = -1 d[i] += v d[j + 1] -= v for i in range(1, n + 1): d[i] += d[i - 1] return &amp;#39;&amp;#39;.join( chr(ord(&amp;#39;a&amp;#39;) + (ord(s[i]) - ord(&amp;#39;a&amp;#39;) + d[i] + 26) % 26) for i in range(n) )</description></item><item><title>2383. Minimum Hours of Training to Win a Competition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2383/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2383/</guid><description>LeetCode problem 2383
class Solution: def minNumberOfHours( self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int], ) -&amp;gt; int: res = max(0, sum(energy) - initialEnergy + 1) for x in experience: if initialExperience &amp;lt;= x: res += x - initialExperience + 1 initialExperience = x + 1 initialExperience += x return res</description></item><item><title>2384. Largest Palindromic Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2384/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2384/</guid><description>LeetCode problem 2384
class Solution: def largestPalindromic(self, num: str) -&amp;gt; str: cnt = Counter(num) res = &amp;#39;&amp;#39; for i in range(9, -1, -1): v = str(i) if cnt[v] % 2: res = v cnt[v] -= 1 break for i in range(10): v = str(i) if cnt[v]: cnt[v] //= 2 s = cnt[v] * v res = s + res + s return res.strip(&amp;#39;0&amp;#39;) or &amp;#39;0&amp;#39;</description></item><item><title>2385. Amount of Time for Binary Tree to Be Infected</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2385/</guid><description>LeetCode problem 2385
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def amountOfTime(self, root: Optional[TreeNode], start: int) -&amp;gt; int: def dfs(root): if root is None: return if root.left: g[root.val].append(root.left.val) g[root.left.val].append(root.val) if root.right: g[root.val].append(root.right.val) g[root.right.val].append(root.val) dfs(root.left) dfs(root.right) def dfs2(i, fa): res = 0 for j in g[i]: if j != fa: res = max(res, 1 + dfs2(j, i)) return res g = defaultdict(list) dfs(root) return dfs2(start, -1)</description></item><item><title>2387. Median of a Row Wise Sorted Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2387/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2387/</guid><description>LeetCode problem 2387
class Solution: def matrixMedian(self, grid: List[List[int]]) -&amp;gt; int: def count(x): return sum(bisect_right(row, x) for row in grid) m, n = len(grid), len(grid[0]) target = (m * n + 1) &amp;gt;&amp;gt; 1 return bisect_left(range(10**6 + 1), target, key=count)</description></item><item><title>2389. Longest Subsequence With Limited Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2389/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2389/</guid><description>LeetCode problem 2389
class Solution: def answerQueries(self, nums: List[int], queries: List[int]) -&amp;gt; List[int]: nums.sort() m = len(queries) res = [0] * m idx = sorted(range(m), key=lambda i: queries[i]) s = j = 0 for i in idx: while j &amp;lt; len(nums) and s + nums[j] &amp;lt;= queries[i]: s += nums[j] j += 1 res[i] = j return res</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem 2390
class Solution: def removeStars(self, s: str) -&amp;gt; str: res = [] for c in s: if c == &amp;#39;*&amp;#39;: res.pop() else: res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2391. Minimum Amount of Time to Collect Garbage</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2391/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2391/</guid><description>LeetCode problem 2391
class Solution: def garbageCollection(self, garbage: List[str], travel: List[int]) -&amp;gt; int: def f(x: str) -&amp;gt; int: res = 0 st = 0 for i, s in enumerate(garbage): if t := s.count(x): res += t + st st = 0 if i &amp;lt; len(travel): st += travel[i] return res return f(&amp;#39;M&amp;#39;) + f(&amp;#39;P&amp;#39;) + f(&amp;#39;G&amp;#39;)</description></item><item><title>2393. Count Strictly Increasing Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2393/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2393/</guid><description>LeetCode problem 2393
class Solution: def countSubarrays(self, nums: List[int]) -&amp;gt; int: res = pre = cnt = 0 for x in nums: if pre &amp;lt; x: cnt += 1 else: cnt = 1 pre = x res += cnt return res</description></item><item><title>2395. Find Subarrays With Equal Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2395/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2395/</guid><description>LeetCode problem 2395
class Solution: def findSubarrays(self, nums: List[int]) -&amp;gt; bool: vis = set() for a, b in pairwise(nums): if (x := a + b) in vis: return True vis.add(x) return False</description></item><item><title>2396. Strictly Palindromic Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2396/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2396/</guid><description>LeetCode problem 2396
class Solution: def isStrictlyPalindromic(self, n: int) -&amp;gt; bool: return False</description></item><item><title>2397. Maximum Rows Covered by Columns</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2397/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2397/</guid><description>LeetCode problem 2397
class Solution: def maximumRows(self, matrix: List[List[int]], numSelect: int) -&amp;gt; int: rows = [] for row in matrix: mask = reduce(or_, (1 &amp;lt;&amp;lt; j for j, x in enumerate(row) if x), 0) rows.append(mask) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(matrix[0])): if mask.bit_count() != numSelect: continue t = sum((x &amp;amp; mask) == x for x in rows) res = max(res, t) return res</description></item><item><title>2399. Check Distances Between Same Letters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2399/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2399/</guid><description>LeetCode problem 2399
class Solution: def checkDistances(self, s: str, distance: List[int]) -&amp;gt; bool: d = defaultdict(int) for i, c in enumerate(s, 1): if d[c] and i - d[c] - 1 != distance[ord(c) - ord(&amp;#39;a&amp;#39;)]: return False d[c] = i return True</description></item><item><title>2400. Number of Ways to Reach a Position After Exactly k Steps</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2400/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2400/</guid><description>LeetCode problem 2400
class Solution: def numberOfWays(self, startPos: int, endPos: int, k: int) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if i &amp;gt; j or j &amp;lt; 0: return 0 if j == 0: return 1 if i == 0 else 0 return (dfs(i + 1, j - 1) + dfs(abs(i - 1), j - 1)) % mod mod = 10**9 + 7 return dfs(abs(startPos - endPos), k)</description></item><item><title>Fault Injection Simulator</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/fis/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/fis/</guid><description>About AWS Fault Injection Simulator (FIS) is a fully managed service for running fault injection experiments on AWS that makes it easier to improve an application‚Äôs performance, observability, and resiliency.
Documentation User Guide Price Current price
With AWS FIS, you pay only for what you use. There are no upfront costs or minimum fees. You are charged based on the duration that an action is active. The AWS FIS price is $0.10 per action-minute.
Terminology and Concepts Everything starts with an experiment template.</description></item><item><title>2401. Longest Nice Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2401/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2401/</guid><description>LeetCode problem 2401
class Solution: def longestNiceSubarray(self, nums: List[int]) -&amp;gt; int: res = j = mask = 0 for i, x in enumerate(nums): while mask &amp;amp; x: mask ^= nums[j] j += 1 res = max(res, i - j + 1) mask |= x return res</description></item><item><title>2402. Meeting Rooms III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2402/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2402/</guid><description>LeetCode problem 2402
Given n rooms and a list of meetings with start and end times, allocate each meeting to an unused room with the lowest number. If all rooms are in use, meetings are delayed until a room is available, maintaining their original duration. Meetings are prioritized by their original start times. The task is to return the room number that hosts the most meetings. If multiple rooms host the same maximum number of meetings, return the room with the lowest number.</description></item><item><title>2404. Most Frequent Even Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2404/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2404/</guid><description>LeetCode problem 2404
class Solution: def mostFrequentEven(self, nums: List[int]) -&amp;gt; int: cnt = Counter(x for x in nums if x % 2 == 0) res, mx = -1, 0 for x, v in cnt.items(): if v &amp;gt; mx or (v == mx and res &amp;gt; x): res, mx = x, v return res</description></item><item><title>2405. Optimal Partition of String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2405/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2405/</guid><description>LeetCode problem 2405
class Solution: def partitionString(self, s: str) -&amp;gt; int: res, v = 1, 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if (v &amp;gt;&amp;gt; i) &amp;amp; 1: v = 0 res += 1 v |= 1 &amp;lt;&amp;lt; i return res</description></item><item><title>2406. Divide Intervals Into Minimum Number of Groups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2406/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2406/</guid><description>LeetCode problem 2406
class Solution: def minGroups(self, intervals: List[List[int]]) -&amp;gt; int: h = [] for a, b in sorted(intervals): if h and h[0] &amp;lt; a: heappop(h) heappush(h, b) return len(h)</description></item><item><title>2408. Design SQL</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2408/</guid><description>LeetCode problem 2408
class SQL: def __init__(self, names: List[str], columns: List[int]): self.tables = defaultdict(list) def insertRow(self, name: str, row: List[str]) -&amp;gt; None: self.tables[name].append(row) def deleteRow(self, name: str, rowId: int) -&amp;gt; None: pass def selectCell(self, name: str, rowId: int, columnId: int) -&amp;gt; str: return self.tables[name][rowId - 1][columnId - 1] # Your SQL object will be instantiated and called as such: # obj = SQL(names, columns) # obj.insertRow(name,row) # obj.deleteRow(name,rowId) # param_3 = obj.selectCell(name,rowId,columnId)</description></item><item><title>2409. Count Days Spent Together</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2409/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2409/</guid><description>LeetCode problem 2409
class Solution: def countDaysTogether( self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str ) -&amp;gt; int: a = max(arriveAlice, arriveBob) b = min(leaveAlice, leaveBob) days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) x = sum(days[: int(a[:2]) - 1]) + int(a[3:]) y = sum(days[: int(b[:2]) - 1]) + int(b[3:]) return max(y - x + 1, 0)</description></item><item><title>2410. Maximum Matching of Players With Trainers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2410/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2410/</guid><description>LeetCode problem 2410
class Solution: def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -&amp;gt; int: players.sort() trainers.sort() res = j = 0 for p in players: while j &amp;lt; len(trainers) and trainers[j] &amp;lt; p: j += 1 if j &amp;lt; len(trainers): res += 1 j += 1 return res</description></item><item><title>2411. Smallest Subarrays With Maximum Bitwise OR</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2411/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2411/</guid><description>LeetCode problem 2411
class Solution: def smallestSubarrays(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n f = [-1] * 32 for i in range(n - 1, -1, -1): t = 1 for j in range(32): if (nums[i] &amp;gt;&amp;gt; j) &amp;amp; 1: f[j] = i elif f[j] != -1: t = max(t, f[j] - i + 1) res[i] = t return res</description></item><item><title>2413. Smallest Even Multiple</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2413/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2413/</guid><description>LeetCode problem 2413
class Solution: def smallestEvenMultiple(self, n: int) -&amp;gt; int: return n if n % 2 == 0 else n * 2</description></item><item><title>2414. Length of the Longest Alphabetical Continuous Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2414/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2414/</guid><description>LeetCode problem 2414
class Solution: def longestContinuousSubstring(self, s: str) -&amp;gt; int: res = 0 i, j = 0, 1 while j &amp;lt; len(s): res = max(res, j - i) if ord(s[j]) - ord(s[j - 1]) != 1: i = j j += 1 res = max(res, j - i) return res</description></item><item><title>2415. Reverse Odd Levels of Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2415/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2415/</guid><description>LeetCode problem 2415
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def reverseOddLevels(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: q = deque([root]) i = 0 while q: if i &amp;amp; 1: l, r = 0, len(q) - 1 while l &amp;lt; r: q[l].val, q[r].val = q[r].val, q[l].val l, r = l + 1, r - 1 for _ in range(len(q)): node = q.</description></item><item><title>2417. Closest Fair Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2417/</guid><description>LeetCode problem 2417
class Solution: def closestFair(self, n: int) -&amp;gt; int: a = b = k = 0 t = n while t: if (t % 10) &amp;amp; 1: a += 1 else: b += 1 t //= 10 k += 1 if k &amp;amp; 1: x = 10**k y = int(&amp;#39;1&amp;#39; * (k &amp;gt;&amp;gt; 1) or &amp;#39;0&amp;#39;) return x + y if a == b: return n return self.closestFair(n + 1)</description></item><item><title>2418. Sort the People</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2418/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2418/</guid><description>LeetCode problem 2418
class Solution: def sortPeople(self, names: List[str], heights: List[int]) -&amp;gt; List[str]: return [name for _, name in sorted(zip(heights, names), reverse=True)]</description></item><item><title>2419. Longest Subarray With Maximum Bitwise AND</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2419/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2419/</guid><description>LeetCode problem 2419
class Solution: def longestSubarray(self, nums: List[int]) -&amp;gt; int: mx = max(nums) res = cnt = 0 for v in nums: if v == mx: cnt += 1 res = max(res, cnt) else: cnt = 0 return res</description></item><item><title>2420. Find All Good Indices</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2420/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2420/</guid><description>LeetCode problem 2420
class Solution: def goodIndices(self, nums: List[int], k: int) -&amp;gt; List[int]: n = len(nums) decr = [1] * (n + 1) incr = [1] * (n + 1) for i in range(2, n - 1): if nums[i - 1] &amp;lt;= nums[i - 2]: decr[i] = decr[i - 1] + 1 for i in range(n - 3, -1, -1): if nums[i + 1] &amp;lt;= nums[i + 2]: incr[i] = incr[i + 1] + 1 return [i for i in range(k, n - k) if decr[i] &amp;gt;= k and incr[i] &amp;gt;= k]</description></item><item><title>2422. Merge Operations to Turn Array Into a Palindrome</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2422/</guid><description>LeetCode problem 2422
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: i, j = 0, len(nums) - 1 a, b = nums[i], nums[j] res = 0 while i &amp;lt; j: if a &amp;lt; b: i += 1 a += nums[i] res += 1 elif b &amp;lt; a: j -= 1 b += nums[j] res += 1 else: i, j = i + 1, j - 1 a, b = nums[i], nums[j] return res</description></item><item><title>2423. Remove Letter To Equalize Frequency</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2423/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2423/</guid><description>LeetCode problem 2423
class Solution: def equalFrequency(self, word: str) -&amp;gt; bool: cnt = Counter(word) for c in cnt.keys(): cnt[c] -= 1 if len(set(v for v in cnt.values() if v)) == 1: return True cnt[c] += 1 return False</description></item><item><title>2424. Longest Uploaded Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2424/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2424/</guid><description>LeetCode problem 2424
class LUPrefix: def __init__(self, n: int): self.r = 0 self.s = set() def upload(self, video: int) -&amp;gt; None: self.s.add(video) while self.r + 1 in self.s: self.r += 1 def longest(self) -&amp;gt; int: return self.r # Your LUPrefix object will be instantiated and called as such: # obj = LUPrefix(n) # obj.upload(video) # param_2 = obj.longest()</description></item><item><title>2425. Bitwise XOR of All Pairings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2425/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2425/</guid><description>LeetCode problem 2425
class Solution: def xorAllNums(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: res = 0 if len(nums2) &amp;amp; 1: for v in nums1: res ^= v if len(nums1) &amp;amp; 1: for v in nums2: res ^= v return res</description></item><item><title>2427. Number of Common Factors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2427/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2427/</guid><description>LeetCode problem 2427
class Solution: def commonFactors(self, a: int, b: int) -&amp;gt; int: g = gcd(a, b) res, x = 0, 1 while x * x &amp;lt;= g: if g % x == 0: res += 1 res += x * x &amp;lt; g x += 1 return res</description></item><item><title>2428. Maximum Sum of an Hourglass</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2428/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2428/</guid><description>LeetCode problem 2428
class Solution: def maxSum(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) res = 0 for i in range(1, m - 1): for j in range(1, n - 1): s = -grid[i][j - 1] - grid[i][j + 1] s += sum( grid[x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) ) res = max(res, s) return res</description></item><item><title>2429. Minimize XOR</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2429/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2429/</guid><description>LeetCode problem 2429
class Solution: def minimizeXor(self, num1: int, num2: int) -&amp;gt; int: cnt1 = num1.bit_count() cnt2 = num2.bit_count() while cnt1 &amp;gt; cnt2: num1 &amp;amp;= num1 - 1 cnt1 -= 1 while cnt1 &amp;lt; cnt2: num1 |= num1 + 1 cnt1 += 1 return num1</description></item><item><title>Elastic Container Registry</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/ecr/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/ecr/</guid><description>About Amazon Elastic Container Registry (Amazon ECR) - Fully managed container registry offering high-performance hosting, so you can reliably deploy application images and artifacts anywhere
Documentation User Guide Hosted private Docker registry
Alternatives Docker Hub JFrog Artifactory Azure Container Registry Harbor Google Container Registry Red Hat Quay JFrog Container Registry Price Current price
Use Cases Store, encrypt, and manage container images
Manage software vulnerabilities Streamline your deployment workloads Manage image lifecycle policies Type: Containers
Same type services: Elastic Container Service (ECS), Elastic Container Registry (ECR), Elastic Kubernetes Service (EKS), Fargate</description></item><item><title>Elastic Container Service</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/ecs/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/ecs/</guid><description>About Documentation User Guide Highly secure, reliable, &amp;amp; scalable way to run contai¬≠ners
Alternatives Google Container Engine (GKE) Azure Container Service IBM Bluemix Container Service Jelastic Multi-Cloud PaaS Terminology Amazon ECS Term Definition Cluster Logical Grouping of EC2 Instances Container Instance EC2 instance running the ECS agent Task Definition Blueprint that describes how a docker container should launch Task A running container using settings in a Task Definition Service Defines long running tasks ‚Äì can control task count with Auto Scaling and attach an ELB Digest Microservices are built in multiple programming languages Containers simplify deployment of microservices: Step 1 : Create a self contained Docker image Application Runtime (JDK or Python), Application code and Dependencies Step 2 : Run it as a container any where Local machine OR Corporate data center OR Cloud Use On-Demand instances or Spot instances Launch type: EC2 or Fargate Data volumes attached to containers Deployment type: Rolling update Blue/green deployment (powered by AWS CodeDeploy) Task Placement Strategies: binpack - Leave least amount of unused CPU or memory.</description></item><item><title>Fargate</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/fargate/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/fargate/</guid><description>About Serverless version of ECS.
Serverless compute for contai¬≠ners.
AWS Fargate is a serverless, pay-as-you-go compute engine that lets you focus on building applications without managing servers.
Deploy and manage your applications, not infrastructure. Fargate removes the operational overhead of scaling, patching, securing, and managing servers.
Compatible with both Amazon Elastic Container Service (ECS) and Amazon Elastic Kubernetes Service (EKS).
Documentation User Guide Alternatives Google Kubernetes Engine (GKE) Red Hat OpenShift Container Platform Azure Kubernetes Service (AKS) Rancher Azure Container Instances Cloud Foundry Oracle Cloud Infrastructure Container Engine for Kubernetes Price Current price</description></item><item><title>Elastic Kubernetes Service</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/eks/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/eks/</guid><description>About Kubernetes (K8) Docker Container/Cluster management
Run highly secure, reliable, and scalable containers
Documentation User Guide Alternatives Red Hat OpenShift Container Platform Azure Kubernetes Service (AKS) Rancher Google Kubernetes Engine (GKE) Oracle Cloud Infrastructure Container Engine for Kubernetes Mirantis Kubernetes Engine (formerly Docker Enterprise) Kubernetes Cloud Foundry Price Current price
Use Cases Build and run web applications Deploy across hybrid environments Model machine learning (ML) workflows ECS vs EKS Amazon provides the Elastic Container Service for Kubernetes (Amazon EKS) which can be used to deploy, manage, and scale containerized applications using Kubernetes on AWS.</description></item><item><title>2839. Check if Strings Can be Made Equal With Operations I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2839/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2839/</guid><description>LeetCode Problem
Problem Statement You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters. The objective is to find out if it&amp;rsquo;s possible to make the two strings equal by swapping certain pairs of characters.
Naive Solution A naive approach would be to try out all possible swap combinations. However, this can be very inefficient, especially when the strings have a large number of characters.
Hints &amp;amp; Tips Observe that the swapping condition is quite specific: j - i = 2.</description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2841/</guid><description>LeetCode Problem 2841
Problem Statement You are given an integer array nums and two positive integers m and k.
The task is to return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray is almost unique if it contains at least m pairwise distinct elements.
Naive Solution A naive solution would be to generate all the possible subarrays of length k and check each one to see if it is almost unique and what its sum is.</description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2844/</guid><description>LeetCode problem 2844
Problem Statement You are given a 0-indexed string num representing a non-negative integer. In one operation, you can pick any digit of num and delete it. Note that if you delete all the digits of num, num becomes 0.
Return the minimum number of operations required to make num special. An integer x is considered special if it is divisible by 25.
Naive Solution A naive approach to solving this problem might involve recursively generating all possible substrings of the input string, checking each one for divisibility by 25.</description></item><item><title>2849. Determine if a Cell Is Reachable at a Given Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2849/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2849/</guid><description>LeetCode problem 2849
Problem Statement You are given starting coordinates (sx, sy) and final coordinates (fx, fy) on a 2D infinite grid. Starting from the initial position, you can move to any of the 8 adjacent cells in one second. The challenge is to determine if you can reach the final cell (fx, fy) in exactly t seconds.
Naive Solution A naive approach would be to use a recursive function to navigate the grid from the starting point (sx, sy) and attempt to reach the target (fx, fy) in t seconds.</description></item><item><title>Cognito</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cognito/</link><pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cognito/</guid><description>About Amazon Cognito - Simple and Secure User Sign-Up, Sign-In, and Access Control
Documentation User Guide Amazon Cognito lets you add user sign-up, sign-in, and access control to your web and mobile apps quickly and easily. Amazon Cognito scales to millions of users and supports sign-in with social identity providers, such as Apple, Facebook, Google, and Amazon, and enterprise identity providers via SAML 2.0 and OpenID Connect.
Users can sign in directly with a user name and password, or through a third party such as Facebook, Amazon, or Google.</description></item><item><title>2971. Find Polygon With the Largest Perimeter</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2971/</guid><description>LeetCode problem 2971
class Solution: def largestPerimeter(self, nums: List[int]) -&amp;gt; int: nums.sort() s = list(accumulate(nums, initial=0)) res = -1 for k in range(3, len(nums) + 1): if s[k - 1] &amp;gt; nums[k - 1]: res = max(res, s[k]) return res</description></item><item><title>Route 53</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/route53/</link><pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/route53/</guid><description>About Amazon Route 53 is a highly available and scalable Domain Name System (DNS) web service. Route 53 connects user requests to internet applications running on AWS or on-premises.
Documentation User Guide A highly available and scalable Domain Name System (DNS) web service used for domain registration, DNS routing, and health checking.
Can create and manage your public DNS records.
What is the difference between Route 53 and DNS?
Your DNS is the service that translates your domain name into an IP address.</description></item><item><title>3016. Minimum Number of Pushes to Type Word II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3016/</guid><description>LeetCode problem 3016
class Solution: def minimumPushes(self, word: str) -&amp;gt; int: cnt = Counter(word) res = 0 for i, x in enumerate(sorted(cnt.values(), reverse=True)): res += (i // 8 + 1) * x return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3029/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3029/</guid><description>https://leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-i/description/
class Solution: def minimumTimeToInitialState(self, word: str, k: int) -&amp;gt; int: n = len(word) # Calculate the length of the word # Iterate through the word in steps of k for i in range(k, n, k): # Check if the suffix starting from i matches the prefix up to n-i if word[i:] == word[:-i]: # If they match, the word can return to the initial state in i/k steps return i // k # If no matching prefix and suffix are found, # return the ceiling division of n by k return (n + k - 1) // k Length Calculation: First, calculate the length of word to know the range we&amp;rsquo;re working with.</description></item><item><title>3030. Find the Grid of Region Average</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3030/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3030/</guid><description>LeetCode problem 3030
class Solution: def isRegion(self, image, x, y, threshold): for i in range(x, x + 3): for j in range(y, y + 3): if i &amp;gt; x and abs(image[i][j] - image[i-1][j]) &amp;gt; threshold: return False if j &amp;gt; y and abs(image[i][j] - image[i][j-1]) &amp;gt; threshold: return False return True def calculateRegionAverage(self, image, x, y): total = sum(image[i][j] for i in range(x, x + 3) for j in range(y, y + 3)) return total // 9 def resultGrid(self, image, threshold): n, m = len(image), len(image[0]) result = [[image[i][j] for j in range(m)] for i in range(n)] for i in range(n - 2): for j in range(m - 2): if self.</description></item><item><title>3031. Minimum Time to Revert Word to Initial State II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3031/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3031/</guid><description>LeetCode problem 3031
class Hashing: __slots__ = [&amp;#34;mod&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;p&amp;#34;] def __init__(self, s: str, base: int, mod: int): self.mod = mod self.h = [0] * (len(s) + 1) self.p = [1] * (len(s) + 1) for i in range(1, len(s) + 1): self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod self.p[i] = (self.p[i - 1] * base) % mod def query(self, l: int, r: int) -&amp;gt; int: return (self.h[r] - self.h[l - 1] * self.</description></item><item><title>3032</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3032/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3032/</guid><description>https://leetcode.com/problems/count-numbers-with-unique-digits-ii
class Solution: def numberCount(self, a: int, b: int) -&amp;gt; int: # Initialize the count of numbers with all unique digits unique_digit_count = 0 # Loop through each number in the range from a to b, inclusive for num in range(a, b + 1): # Convert the number to a string to examine its digits num_str = str(num) # Convert the string to a set of characters to remove duplicates unique_digits = set(num_str) # If the length of the set is equal to the length of the number string, # it means all digits are unique if len(unique_digits) == len(num_str): # Increment the count for each number with all unique digits unique_digit_count += 1 # Return the total count of unique digit numbers return unique_digit_count</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3033/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3033/</guid><description>class Solution: def modifiedMatrix(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: rows = len(matrix) cols = len(matrix[0]) for j in range(rows): max_val = max(matrix[i][j] for i in range(cols)) for i in range(cols): if matrix[i][j] == -1: matrix[i][j] = max_val return matrix</description></item><item><title>3045. Count Prefix and Suffix Pairs II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3045/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3045/</guid><description>LeetCode problem 3045
Hint To solve this problem efficiently, consider using a Trie (prefix tree) to store each word in a way that allows checking for prefixes and suffixes simultaneously.
Idea The key idea is to leverage a Trie data structure, but with a twist: instead of only considering prefixes (as is typical with tries), we also account for suffixes simultaneously. This dual consideration allows us to efficiently count valid prefix-suffix pairs among the words.
Approach Trie Construction: Build a Trie where each node represents a pair of characters (prefix_char, suffix_char) from a word and its reversed counterpart.</description></item><item><title>EventBridge</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/eventbridge/</link><pubDate>Sun, 25 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/eventbridge/</guid><description>About EventB¬≠ridge is a serverless event bus that makes it easy to connect applic¬≠ations together using data from apps, integrated SaaS apps, &amp;amp; AWS services.
Documentation User Guide EventB¬≠ridge is a low-cost alternative to building a new backend infrastructure for every new app. With Serverless EventB¬≠ridge, you can connect your existing apps with a few lines of code. You don‚Äôt have to build a new backend for every new app you want to connect to.
You can use existing infrastructure as a provider of event data, and connect your apps using Serverless EventB¬≠ridge.</description></item><item><title>Step Functions</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/step-functions/</link><pubDate>Tue, 27 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/step-functions/</guid><description>About AWS Step Functions is a low-code, visual workflow service that developers use to build distributed applications, automate IT and business processes, and build data and machine learning pipelines using AWS services.
Documentation User Guide Step Functions is a serverless function orches¬≠trator that makes it easy to sequence Lambda functions &amp;amp; multiple AWS services into busine¬≠ss-¬≠cri¬≠tical applic¬≠ations.
Alternatives AWS lambda Airflow Google Cloud Workflows Microsoft Flow Price Pay only for what you use
Current price
Free Tier: 4,000 state transitions per month</description></item><item><title>Questions</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/questions/</link><pubDate>Thu, 08 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/questions/</guid><description>On this page you can find 50 random questions.
To get prepared for exam you can use cloud-exam-prepare.com
Q1 - Q10 Q1 You are developing an API in Amazon API Gateway that several mobile applications will use to interface with a back end service in AWS being written by another developer. You can use a(n)____ integration for your API methods to develop and test your client applications before the other developer has completed work on the back end.</description></item><item><title>nmap - cheatsheet</title><link>https://romankurnovskii.com/en/posts/linux/nmap-cheatsheet/</link><pubDate>Sat, 30 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/linux/nmap-cheatsheet/</guid><description>Scanning Options Nmap Option Description 10.10.10.0/24 Target network range. -sn Disables port scanning. -Pn Disables ICMP Echo Requests -n Disables DNS Resolution. -PE Performs the ping scan by using ICMP Echo Requests against the target. --packet-trace Shows all packets sent and received. --reason Displays the reason for a specific result. --disable-arp-ping Disables ARP Ping Requests. --top-ports=&amp;lt;num&amp;gt; Scans the specified top ports that have been defined as most frequent. -p- Scan all ports. -p22-110 Scan all ports between 22 and 110.</description></item><item><title>Monitoring</title><link>https://romankurnovskii.com/en/posts/linux/debian-setup/</link><pubDate>Fri, 29 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/linux/debian-setup/</guid><description>Auditing Packages dpkg --verify or
dpkg -V # dpkg -V ??5?????? /lib/systemd/system/ssh.service ??5?????? c /etc/libvirt/qemu/networks/default.xml &amp;lsquo;ssh.service&amp;rsquo;: reports a change to SSH&amp;rsquo;s service file that the administrator made to the packaged file instead of using an appropriate /etc/systemd/system/ssh.service override &amp;lsquo;c&amp;rsquo; letter: legitimately modified Monitoring Files AIDE apt install aide aideinit # first db init aideinit creates a cron job in etc/cron.daily/aide
DB: /var/lib/aide/aide.db
When changes are detected, AIDE records them in log files /var/log/aide/*.log
logcheck Monitors log files every hour by default and sends unusual log messages in emails to the administrator for further analysis</description></item><item><title>Wireless access point with hostapd on Debian</title><link>https://romankurnovskii.com/en/posts/linux/wireless-access-point/</link><pubDate>Fri, 29 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/linux/wireless-access-point/</guid><description>hostapd is a user space daemon for access point and authentication servers. It implements IEEE 802.11 access point management, IEEE 802.1X/WPA/WPA2/EAP Authenticators and RADIUS authentication server. The current version supports Linux (Host AP, mac80211-based drivers) and FreeBSD (net80211). Configure network traffic routing and Network Address Translation (NAT) using iptables.
Configure the system to forward packets from one network interface to another, applying NAT to the packets going out of the eth0 interface.
Network configuration where the system is intended to function as a router or gateway between two networks (e.</description></item><item><title>How to disable IPv6 on Debian/Kali Linux</title><link>https://romankurnovskii.com/en/posts/linux/howto-disable-ipv6-on-debian/</link><pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/linux/howto-disable-ipv6-on-debian/</guid><description>TL;DR git clone https://github.com/romankurnovskii/kali-shortcuts.git cd kali-shortcuts chmod +x disable_ipv6.sh sudo ./disable_ipv6.sh Edit sysctl Configuration In the terminal, type sudo vi /etc/sysctl.conf and press Enter. This opens the sysctl.conf file in the text editor with root privileges. Add IPv6 Disable Lines At the end of the file, add the following lines: net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 These lines will disable IPv6 on all network interfaces, including the loopback interface.
Save and Exit Save /etc/sysctl.conf and exit text editor Apply Changes To apply the changes without rebooting, run `sudo sysctl -p`` in the terminal.</description></item><item><title>Certificates</title><link>https://romankurnovskii.com/en/posts/certificates/</link><pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/certificates/</guid><description/></item><item><title>Telegram bot with Google Apps Script (GAS)</title><link>https://romankurnovskii.com/en/posts/howto-setup-telegram-bot-and-google-apps-script/</link><pubDate>Mon, 11 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-setup-telegram-bot-and-google-apps-script/</guid><description>1. Set Up the Telegram Bot Use the BotFather on Telegram to create a new bot. Get your HTTP API token. 2. Google Apps Script Code Google Apps Script for a Telegram bot:
var TOKEN = &amp;#39;YOUR_TELEGRAM_BOT_TOKEN&amp;#39;; var WEBHOOK_URL = &amp;#39;YOUR_WEB_APP_URL&amp;#39;; // web app URL of your GAS deployment. var USERS_SPREAD_SHEET_NAME=&amp;#39;usersAnswers&amp;#39; var COLUMN_STEP_1 = &amp;#39;E&amp;#39; var COLUMN_STEP_2 = &amp;#39;F&amp;#39; var COLUMN_DATE = &amp;#39;A&amp;#39; function setWebhook() { // run after every deploy and updated WEBHOOK_URL var url = &amp;#39;https://api.telegram.org/bot&amp;#39; + TOKEN + &amp;#39;/setWebhook?</description></item><item><title>Subscription</title><link>https://romankurnovskii.com/en/p/subscribe/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/p/subscribe/</guid><description> LeetCode solutions RU] - Email LeetCode solutions EN - Email</description></item><item><title>Interactive vs. Non-Interactive Users in Linux</title><link>https://romankurnovskii.com/en/posts/linux-interactive-non-interactive-users/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/linux-interactive-non-interactive-users/</guid><description>Characteristics In a Linux environment, users can be broadly categorized as &amp;ldquo;interactive&amp;rdquo; and &amp;ldquo;non-interactive&amp;rdquo;. These distinctions stem from how these user accounts interact (or don&amp;rsquo;t interact) with the system.
Definition Interactive Users: These are users who interact directly with the system, usually through a shell. When you log into a computer using SSH or a terminal, you&amp;rsquo;re operating as an interactive user. Non-Interactive Users: These users are designed to perform specific tasks without direct human intervention. Examples include system accounts running services like apache or mysql.</description></item><item><title>Average True Range (ATR) - Volatility Indicator</title><link>https://romankurnovskii.com/en/posts/trading-indicators/atr/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/trading-indicators/atr/</guid><description>About The Average True Range (ATR) is a technical analysis indicator that measures market volatility by decomposing the entire range of an asset price for that period. It was developed by J. Welles Wilder Jr. and introduced in his book &amp;ldquo;New Concepts in Technical Trading Systems&amp;rdquo; in 1978.
Calculating Formula ATR is calculated based on the true range (TR), which is the maximum of the following:
Current High less the current Low Absolute value of (Current High less the previous Close) Absolute value of (Current Low less the previous Close) The ATR is then the moving average over a given period of the TR.</description></item><item><title>EMA - Exponential Moving Average</title><link>https://romankurnovskii.com/en/posts/trading-indicators/ema/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/trading-indicators/ema/</guid><description>About Unlike the SMA, the EMA gives more weight to recent data, making it quicker to respond to price changes.
Calculating Formula EMA = (Close - Previous EMA) * Multiplier + Previous EMA
Where:
Close: the closing price for a given period (Price today/now). Here close prices is for example N: the period of the EMA. Multiplier: 2 / (N + 1) Previous EMA is the EMA of the previous period. The EMA for the first period is just the Close price.</description></item><item><title>Setup subdomains on VPS CentOS</title><link>https://romankurnovskii.com/en/posts/vps-docker-subdomains-setup/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/vps-docker-subdomains-setup/</guid><description>TLDR Code sources
Create Projects Creating three example projects:
node.js express server that returns json on request another node.js express server static html page Place projects data in dir &amp;lsquo;projects&amp;rsquo;.
Structure:
‚îî‚îÄ‚îÄ project ‚îú‚îÄ‚îÄ Dockerfile ‚îú‚îÄ‚îÄ nginx.conf ‚îú‚îÄ‚îÄ projects | ‚îú‚îÄ‚îÄ 1 | | ‚îú‚îÄ‚îÄ app.js | | ‚îî‚îÄ‚îÄ package.json | ‚îú‚îÄ‚îÄ 2 | | ‚îú‚îÄ‚îÄ app.js | | ‚îî‚îÄ‚îÄ package.json | ‚îî‚îÄ‚îÄ 3 | ‚îî‚îÄ‚îÄ index.html ‚îî‚îÄ‚îÄ start.sh Nginx setup Server needs to &amp;ldquo;understand&amp;rdquo; the initial subdomain and where to forward.</description></item><item><title>Stochastic Oscillator - Momentum Indicator</title><link>https://romankurnovskii.com/en/posts/trading-indicators/stochastic_oscillator/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/trading-indicators/stochastic_oscillator/</guid><description>About The Stochastic Oscillator is a momentum indicator that shows the location of the close relative to the high-low range over a set number of periods. It was developed by George Lane in the 1950s.
Calculating Formula The Stochastic Oscillator is calculated using the following formula:
%K = 100[(C - L14) / (H14 - L14)] where:
C = the most recent closing price L14 = the lowest price traded of the 14 previous trading sessions H14 = the highest price traded during the same 14-day period %K = the current value of the stochastic indicator The &amp;ldquo;%D&amp;rdquo; line is then a 3-day simple moving average of %K.</description></item><item><title>Bollinger Bands - Volatility and Price Level Indicator</title><link>https://romankurnovskii.com/en/posts/trading-indicators/bollinger_bands/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/trading-indicators/bollinger_bands/</guid><description>About Bollinger Bands is a technical indicator developed by John Bollinger in the 1980s. It provides a relative definition of high and low prices of a market instrument by creating a band of two standard deviations from a simple moving average (SMA).
Calculating Formula Bollinger Bands consist of three lines:
Middle Line: 20-day simple moving average (SMA) Upper Band: 20-day SMA + (2 * 20-day standard deviation of price) Lower Band: 20-day SMA - (2 * 20-day standard deviation of price) The standard deviation measures how spread out the prices or returns of an asset are on average.</description></item><item><title>JavaScript: convert array of objects to dictionary</title><link>https://romankurnovskii.com/en/posts/js-convert-array-to-dict/</link><pubDate>Mon, 19 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/js-convert-array-to-dict/</guid><description>type ObjectWithKeyName = { [key: string]: any; }; // transform array of objects to dict // use object provided keyName as a key of dict // expected for each object in array this keyName value is unique const transformArrayToDict = (objects: ObjectWithKeyName[], keyName: string) =&amp;gt; { const res: ObjectWithKeyName = {}; objects.forEach((obj) =&amp;gt; { res[obj[keyName]] = obj; }); return res; };</description></item><item><title>How to Render Jupyter Notebooks in Hugo with a Custom Shortcode</title><link>https://romankurnovskii.com/en/posts/howto-render-notebook-in-hugo/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-render-notebook-in-hugo/</guid><description>Jupyter notebooks are a fantastic tool for data scientists and programmers, allowing you to write code, visualize results, and write documentation all in one place. Hugo is a powerful and flexible static site generator that&amp;rsquo;s great for blogging and building websites. But what if you want to share your Jupyter notebooks on your Hugo website?
This step-by-step guide will walk you through how to render Jupyter notebooks in Hugo using a custom shortcode and automate the process using GitHub Actions.</description></item><item><title>How to Create Interactive Financial Charts using Tkinter and Plotly</title><link>https://romankurnovskii.com/en/posts/howto-tkinter-interactive-plotly-chart/</link><pubDate>Fri, 16 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-tkinter-interactive-plotly-chart/</guid><description>How to Create Interactive Financial Charts using Tkinter and Plotly Data visualization is an integral part of data analysis. Python, with its strong set of libraries, has emerged as a go-to language for data visualization. In this tutorial, we will create an application that generates and displays interactive financial charts using Tkinter and Plotly.
Prerequisites Before we get started, ensure you have the following installed on your machine:
Python 3.6 or newer Dash, Plotly&amp;rsquo;s Python framework for building analytical web applications.</description></item><item><title>MACD - Moving Average Convergence Divergence</title><link>https://romankurnovskii.com/en/posts/trading-indicators/macd/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/trading-indicators/macd/</guid><description>About The Moving Average Convergence Divergence (MACD) is a versatile trading indicator used in various forms of trading, including high-frequency trading (HFT).
MACD is a trend-following momentum indicator that shows the relationship between two moving averages of a security‚Äôs price.
Calculating Formula The MACD is calculated by subtracting the 26-period Exponential Moving Average (EMA) from the 12-period EMA. A 9-day EMA of the MACD, called the &amp;ldquo;signal line&amp;rdquo;, is then plotted on top of the MACD, functioning as a trigger for buy and sell signals.</description></item><item><title>RSI - Relative Strength Index</title><link>https://romankurnovskii.com/en/posts/trading-indicators/rsi/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/trading-indicators/rsi/</guid><description>About The Relative Strength Index (RSI) is a momentum oscillator that measures the speed and change of price movements. Developed by J. Welles Wilder, the RSI is a very popular indicator that is used primarily to identify overbought and oversold conditions in a market.
Calculating The RSI is calculated using the following steps:
Calculate the average gain and the average loss over the specified period (usually 14 periods). Compute the relative strength (RS) which is the ratio of average gain to average loss.</description></item><item><title>SMA - Simple Moving Average</title><link>https://romankurnovskii.com/en/posts/trading-indicators/sma/</link><pubDate>Tue, 13 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/trading-indicators/sma/</guid><description>About The Simple Moving Average (SMA) is a technical indicator that calculates the average price over a specific number of periods, and it moves along as new data is added, making it a &amp;ldquo;moving average&amp;rdquo;.
Calculating Formula SMA = (Sum of price data for the last N periods) / N
For example, a 5-period SMA would sum up the last 5 closing prices and divide it by 5 to find the average. It is called a &amp;lsquo;moving&amp;rsquo; average because as new prices become available, the oldest prices are dropped and the average recalculates.</description></item><item><title>Linters &amp; Formatters Setup for Python, Groovy, JavaScript in VSCode</title><link>https://romankurnovskii.com/en/posts/python-groovy-lint-format-setup/</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/python-groovy-lint-format-setup/</guid><description>–í —ç—Ç–æ–π —Å—Ç–∞—Ç—å–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å
Black –∏ Flake8 –¥–ª—è Python, CodeNarc –¥–ª—è Groovy ESLint –∏ Prettier –¥–ª—è JavaScript –≤ —Å—Ä–µ–¥–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ VSCode. Python –î–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Python —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Black –∏ Flake8 –≤–∞–º –ø–æ–Ω–∞–¥–æ–±—è—Ç—Å—è —Ñ–∞–π–ª—ã –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: pyproject.toml–¥–ª—è Black –∏ .flake8 –¥–ª—è Flake8.
Black - —ç—Ç–æ —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä –∫–æ–¥–∞ –¥–ª—è Python, –∫–æ—Ç–æ—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≤–µ—Å—å —Ñ–∞–π–ª –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Å—Ç—Ä–æ–≥–∏–º –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞ PEP 8. Black —É–ø—Ä–æ—â–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å —Ä–µ—Ü–µ–Ω–∑–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–¥–∞, —Å–æ–∑–¥–∞–≤–∞—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ä–∞–∑–ª–∏—á–∏—è –º–µ–∂–¥—É –≤–µ—Ä—Å–∏—è–º–∏ –∫–æ–¥–∞.
Flake8 - –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞—à –∫–æ–¥ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–µ–∫–æ—Ç–æ—Ä—ã–º –∫–æ–Ω–≤–µ–Ω—Ü–∏—è–º —Å—Ç–∏–ª—è PEP 8, –æ–±—ä–µ–¥–∏–Ω—è—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –¥—Ä—É–≥–∏—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤, –≤–∫–ª—é—á–∞—è PyFlakes (–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏), pycodestyle (–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ—à–∏–±–∫–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è) –∏ —Å–∫—Ä–∏–ø—Ç McCabe –æ—Ç Ned Batchelder (–ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∫–æ–¥–∞).</description></item><item><title>Python docstring templates</title><link>https://romankurnovskii.com/en/posts/python-docstring-templates/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/python-docstring-templates/</guid><description>Template def function_name(param1: Type1, param2: Type2, ...) -&amp;gt; ReturnType: &amp;#34;&amp;#34;&amp;#34;Brief description of the function. More detailed explanation of the function if necessary. This can span multiple lines as needed. Args: param1 (Type1): Description of param1. param2 (Type2): Description of param2. ... Returns: ReturnType: Description of the return value. Raises: ExceptionType: Explanation of the conditions under which this exception is raised. Example: &amp;gt;&amp;gt;&amp;gt; function_name(param1_value, param2_value) Expected output &amp;#34;&amp;#34;&amp;#34; ... Example With Type Hints def add_numbers(num1: int, num2: int = 5) -&amp;gt; int: &amp;#34;&amp;#34;&amp;#34;Adds two numbers together.</description></item><item><title>AI Midjourney generated</title><link>https://romankurnovskii.com/en/photos/midjourney/</link><pubDate>Sun, 14 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/photos/midjourney/</guid><description> colorful abstract splashes floating around forming the loose shape of a gato, in the style of realistic anamorphic art, digital art wonders, flickr, bold yet graceful, colorful explosions, vivid realism, colorful curves colorful abstract splashes floating around forming the loose shape of a tree, in the style of realistic anamorphic art, digital art wonders, flickr, bold yet graceful, colorful explosions, vivid realism, colorful curves colorful abstract splashes floating around forming the loose shape of a rose, in the style of realistic anamorphic art, digital art wonders, flickr, bold yet graceful, colorful explosions, vivid realism, colorful curves colorful abstract splashes floating around forming the loose shape of a protea, in the style of realistic anamorphic art, digital art wonders, flickr, bold yet graceful, colorful explosions, vivid realism, colorful curves</description></item><item><title>Difference between Tries and Trees?</title><link>https://romankurnovskii.com/en/posts/tree-vs-trie-data-structures/</link><pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/tree-vs-trie-data-structures/</guid><description>Despite their similar names, these structures serve different purposes, and understanding their differences is crucial to utilizing them effectively.
Tree A tree data structure is a collection of entities, called nodes, connected by edges.
Each node contains a value, and a list of references to its child nodes. The first node of the tree is called the root. If we visualize it, a tree data structure resembles an inverted tree, with the root at the top and the leaves (nodes without children) at the bottom.</description></item><item><title>How to publish JavaScript package to npm registry</title><link>https://romankurnovskii.com/en/posts/howto-publish-js-npm-project/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-publish-js-npm-project/</guid><description>In this post, we&amp;rsquo;ll dive deeper into the process of creating, structuring, and publishing a JavaScript package to the npm registry. We&amp;rsquo;ll use the repository https://github.com/romankurnovskii/npm-js-package-template as a reference for this guide.
TLDR Open template: https://github.com/romankurnovskii/npm-js-package-template Click Use this template Create repo from this template. git clone new repo update code src/index.ts, src/bin.ts How to check if bin script works from terminal:
npm link &amp;amp;&amp;amp; npm link mypackage mypackage Publish:
npm run prepublishOnly npm publish Folder Structure Let&amp;rsquo;s go through the folder structure of the repository:</description></item><item><title>Enhancing Trading Bot with Abstraction and Async Management</title><link>https://romankurnovskii.com/en/stories/004-trading-bot-refactor-orders/</link><pubDate>Tue, 02 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/stories/004-trading-bot-refactor-orders/</guid><description>Abstraction Today worked on refining some abstraction level in framework. The main objective of today&amp;rsquo;s work was to enhance the abstraction in the classes and improve the overall code structure.
The goal was to make the code more adaptable and easier to maintain.
For example, instead of having Binance hardcoded in the from_binance_order method, now use the Exchanges enum, which makes the code more versatile and ready for additional exchanges in the future.
def from_binance_order(binance_order: BinanceOrder): exchange = Exchanges.</description></item><item><title>Round #867/1822 (Div. 3)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/867-div-3-1822/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/contests/867-div-3-1822/</guid><description>Contest problems A. TubeTube Feed Mushroom Filippov is having lunch and wants to watch a video on TubeTube. He has a specific amount of time for lunch, and he wants to make the best use of it by watching the most entertaining video that fits into his lunch break.
Given a list of videos, each with its duration and entertainment value, your task is to help Mushroom Filippov choose the best video to watch. He can only watch one video, and the video must not exceed his lunch break time.</description></item><item><title>Creating a GUI for a Trading Bot</title><link>https://romankurnovskii.com/en/stories/003-trading-bot-gui-init-tkinter/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/stories/003-trading-bot-gui-init-tkinter/</guid><description>The journey towards creating a light trading bot framework begins with a simple, intuitive graphical user interface (GUI). For this venture, I have chosen to rely on Python&amp;rsquo;s built-in Tkinter library to provide the fundamental building blocks for my GUI.
Embracing Simplicity The initial goal is to keep the GUI as straightforward as possible, focusing on the core functionalities required for a trading bot. The main elements incorporated are:
Start/Stop Buttons: These allow the user to control the operation of the bot.</description></item><item><title>Setup OpenVPN Server on AWS EC2 Ubuntu</title><link>https://romankurnovskii.com/en/stories/002-openvpn-aws-ec2-setup/</link><pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/stories/002-openvpn-aws-ec2-setup/</guid><description>Today, I embarked on a journey to create an accessible, affordable, and easy-to-use VPN solution that anyone can set up on their devices using AWS.
Finding a reasonably priced solution was critical. I opted for Amazon&amp;rsquo;s t3a.nano ARM Ubuntu image, which costs ~$0.0047/hour ~ $3.8/month.
Various Amazon EC2 instances and their prices are listed on Amazon&amp;rsquo;s On-Demand Pricing page.
Here is the list of all Ubuntu AMI images to identify the appropriate image for the project. The selected image combined with the CloudFormation template, which was inspired by the AWS CloudFormation General Reference, provides a seamless and consistent user experience.</description></item><item><title>Visualize Algorithms - Rediscovering Backtracking</title><link>https://romankurnovskii.com/en/stories/001-rediscovering-backtracking-algo/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/stories/001-rediscovering-backtracking-algo/</guid><description>Today, I tackled a LeetCode programming problem that pushed me to rediscover a forgotten concept and devise a creative solution to share my learning experience with others.
The problem centered around a backtracking algorithm. Although I had previously explored this topic, I couldn&amp;rsquo;t quite remember the exact steps and logic involved. Determined to refresh my memory, I set out not only to solve the problem but also to find a way to make it easier for myself and others to visualize and comprehend the algorithm in the future.</description></item><item><title>How to Create a React-Electron Application From Scratch</title><link>https://romankurnovskii.com/en/posts/howto-create-react-electron-app-ts/</link><pubDate>Sat, 22 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-create-react-electron-app-ts/</guid><description>In this step-by-step tutorial, we&amp;rsquo;ll create a simple React-Electron application from scratch. Electron is a framework that allows you to build cross-platform desktop applications using web technologies such as HTML, CSS, and JavaScript. React is a popular JavaScript library for building user interfaces.
I use this clean template as a boilerplate for my projects.
TLDR Go to repo electron-react-template click Use this template to create a new repo and start coding. Prerequisites Before starting this tutorial, make sure you have the following tools installed on your system:</description></item><item><title>AI generated</title><link>https://romankurnovskii.com/en/photos/ai/</link><pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/photos/ai/</guid><description/></item><item><title>How to upload an opensource application to SourceForge</title><link>https://romankurnovskii.com/en/posts/how-to-upload-app-to-sourceforge/</link><pubDate>Thu, 16 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/how-to-upload-app-to-sourceforge/</guid><description>Step 1: Create a SourceForge account Go to the SourceForge website at https://sourceforge.net/ Click on the &amp;ldquo;Join&amp;rdquo; button in the top-right corner. Fill in the required fields, such as username, email, and password, then click &amp;ldquo;Register&amp;rdquo; You&amp;rsquo;ll receive a confirmation email from SourceForge. Click on the link provided to confirm your account. Step 2: Start a new project Log in to your SourceForge account. Click on the &amp;ldquo;Create&amp;rdquo; button in the top-right corner of the page. Select &amp;ldquo;Create Your Project Now&amp;rdquo; from the dropdown menu.</description></item><item><title>BrewMate</title><link>https://romankurnovskii.com/en/apps/brewmate/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/apps/brewmate/</guid><description>BrewMate is a macOS GUI application that makes it easy to search for, install, and uninstall Homebrew casks. You can also see the top downloaded casks for the last month.
Install Download the latest DMG file from the releases page or from sourceforge.net Double-click the DMG file to open it. Drag the BrewMate app to your Applications folder. Launch BrewMate from your Applications folder. or
brew install romankurnovskii/cask/brewmate --cask or
brew tap romankurnovskii/cask brew update brew install brewmate --cask FAQ Is this app free?</description></item><item><title>How to publish typescript package to npm registry</title><link>https://romankurnovskii.com/en/posts/howto-publish-ts-npm-project/</link><pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-publish-ts-npm-project/</guid><description> Open template: https://github.com/romankurnovskii/npm-typescript-package-template Click Use this template Create repo from this template. git clone new repo update code src/index.ts, src/bin.ts How to check if bin script works from terminal:
npm link &amp;amp;&amp;amp; npm link mypackage mypackage Publish:
npm run prepublishOnly npm publish</description></item><item><title>How to add copy code button on HUGO highligh code block</title><link>https://romankurnovskii.com/en/posts/hugo-add-copy-button-on-highlight-block/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/hugo-add-copy-button-on-highlight-block/</guid><description>function addCopyButtonToCodeBlocks() { // Get all code blocks with a class of &amp;#34;language-*&amp;#34; const codeBlocks = document.querySelectorAll(&amp;#39;code[class^=&amp;#34;language-&amp;#34;]&amp;#39;); // For each code block, add a copy button inside the block codeBlocks.forEach(codeBlock =&amp;gt; { // Create the copy button element const copyButton = document.createElement(&amp;#39;button&amp;#39;); copyButton.classList.add(&amp;#39;copy-code-button&amp;#39;); copyButton.innerHTML = &amp;#39;&amp;lt;i class=&amp;#34;far fa-copy&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;#39;; // Add a click event listener to the copy button copyButton.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; { // Copy the code inside the code block to the clipboard const codeToCopy = codeBlock.innerText; navigator.clipboard.writeText(codeToCopy); // Update the copy button text to indicate that the code has been copied copyButton.</description></item><item><title>Bash Special Variables $! $0 $? $$</title><link>https://romankurnovskii.com/en/posts/bash-variables/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/bash-variables/</guid><description>$0 - The Name of the Script $0 represents the name of the Bash script as it was called.
If you execute a script with bash myscript.sh, then within myscript.sh, $0 will be myscript.sh.
$1, $2, $3, &amp;hellip; - Positional Parameters These variables correspond to the arguments passed to the script. $1 is the first argument, $2 is the second, and so on.
In the command bash myscript.sh arg1 arg2, $1 equals arg1, and $2 equals arg2.
$! - PID of the Last Background Process This holds the process ID of the most recent background process.</description></item><item><title>Bash code snippets</title><link>https://romankurnovskii.com/en/posts/bash-snippets/</link><pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/bash-snippets/</guid><description>Rename all files in current directory / Remove prefix #!/bin/bash REMOVE_PREFIX=$1 files=(*) for file in &amp;#34;${files[@]}&amp;#34; do if [[ $file == *&amp;#34;${REMOVE_PREFIX}&amp;#34;* ]]; then # Remove everything before and including the &amp;#34;‚Ññ&amp;#34; symbol new_file=${file##*&amp;#34;${REMOVE_PREFIX}&amp;#34;} mv &amp;#34;$file&amp;#34; &amp;#34;$new_file&amp;#34; echo &amp;#34;Renamed $file to $new_file&amp;#34; fi done $ ./rename_files.sh abc renamed file abc123.txt -&amp;gt; 123.txt Add substring to filename #!/bin/bash DIR=&amp;#34;/path/to/folder&amp;#34; cd &amp;#34;$DIR&amp;#34; # Rename all .png files and add &amp;#34;.ru&amp;#34; before .png for file in *.png; do base=$(basename &amp;#34;$file&amp;#34; .png) mv &amp;#34;$file&amp;#34; &amp;#34;${base}.</description></item><item><title>Git snippets</title><link>https://romankurnovskii.com/en/posts/git-snippets/</link><pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/git-snippets/</guid><description>Commits More info about commits style
Github Actions Submodules Sync name: &amp;#39;Submodules Sync&amp;#39; on: schedule: - cron: &amp;#34;0 * * * *&amp;#34; jobs: sync: runs-on: ubuntu-latest steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 with: submodules: true - name: Pull &amp;amp; update submodules recursively run: | git pull --recurse-submodules git submodule update --remote --recursive - name: Commit &amp;amp; push changes run: | git config --global user.name &amp;#39;Git bot&amp;#39; git config --global user.</description></item><item><title>Links</title><link>https://romankurnovskii.com/en/p/links/</link><pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/p/links/</guid><description>AI The curated list of AI tools for marketing Discover the newest AIs for any given task Create 1,000 AI art images a day for free openai examples openai answers from file AI-powered video summaries Chrome extension Free AI-generated Stock Images of People Soft/Architecture Block Diagram Maker Theme for Docs - MkDocs Media Fast and simple way to visualize your story - free 1 Storyboard and 10 Frames Video from Screenshot Other Create and sell your own personalized books and journals Books nice covers Comments on site https://github.</description></item><item><title>Code style notes</title><link>https://romankurnovskii.com/en/posts/code-style/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/code-style/</guid><description>Release notes example Changed
feat(exports): export mergeConfig #5151 Fixed
fix(CancelledError): include config #4922 fix(general): removing multiple/trailing/leading whitespace #5022 fix(headers): decompression for responses without Content-Length header #5306 fix(webWorker): exception to sending form data in web worker #5139 Refactors
refactor(types): AxiosProgressEvent.event type to any #5308 refactor(types): add missing types for static AxiosError.from method #4956 Chores
chore(docs): remove README link to non-existent upgrade guide #5307 chore(docs): typo in issue template name #5159 Common used
build: Changes that affect the build system or external dependencies (e.</description></item><item><title>Python bitwise operators</title><link>https://romankurnovskii.com/en/posts/python-bitwise-operators/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/python-bitwise-operators/</guid><description>&amp;laquo; Left Shift Moves the bits of its first operand to the left by the number of places specified in its second operand.
Formula: $a &amp;laquo; n = a * 2^n$
Shifting a single bit to the left by one place doubles its value. Shifting to two places to the left by one place quadruple its value. &amp;gt;&amp;gt;&amp;gt; 100 &amp;lt;&amp;lt; 1 200 &amp;gt;&amp;gt;&amp;gt; 100 &amp;lt;&amp;lt; 2 400 &amp;gt;&amp;gt;&amp;gt; 100 &amp;lt;&amp;lt; 3 800 &amp;raquo; Right Shift The rightmost bits always get dropped.</description></item><item><title>Support me</title><link>https://romankurnovskii.com/en/p/supportme/</link><pubDate>Sun, 23 Oct 2022 07:38:00 +0300</pubDate><guid>https://romankurnovskii.com/en/p/supportme/</guid><description> https://www.buymeacoffee.com/romankurnovskii https://rom.gumroad.com/ https://www.patreon.com/user?u=79828420</description></item><item><title>chart</title><link>https://romankurnovskii.com/en/posts/hugo-shortcode-examples/chart/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/hugo-shortcode-examples/chart/</guid><description>Display Chart.js diagrams/blocks
Sources</description></item><item><title>img</title><link>https://romankurnovskii.com/en/posts/hugo-shortcode-examples/img/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/hugo-shortcode-examples/img/</guid><description>My image float right, tall Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry&amp;rsquo;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</description></item><item><title>Cloud exam Quizz</title><link>https://romankurnovskii.com/en/apps/cloud-exam-quizz/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/apps/cloud-exam-quizz/</guid><description>Goal: Check if you are ready to pass the Cloud exam
The application calculates progress after each answered question. Ability to answer at least one question and get a comment at the same time. No need to pass all questions before. It is convenient to spend 20 min a day Works from web/tablet/mobile Link: https://www.cloud-exam-prepare.com</description></item><item><title>Deposit Interactive Brokers from Israel Discount bank</title><link>https://romankurnovskii.com/en/posts/interactivebrokers-deposit/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/interactivebrokers-deposit/</guid><description>Web Create IB notification Login to https://www.interactivebrokers.co.uk/portal/#/ Click Deposit Click Use a new deposit method if no one exist Bank Wire -&amp;gt; Get instructions Account Number: Bank account number
Next you get Bank Wire Instructions These data you need to make a payment from Discount bank
Send money from Discount bank Login start.telebank.co.il Click: ◊ë◊ô◊¶◊ï◊¢ ◊î◊¢◊ë◊®◊î
Fill the form
Click ◊î◊û◊©◊ö and proceed</description></item><item><title>JavaScript code snippets</title><link>https://romankurnovskii.com/en/posts/js-snippets/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/js-snippets/</guid><description>Web / Browser get base URL const getBaseURL = url =&amp;gt; url.replace(/[?#].*$/, &amp;#39;&amp;#39;); getBaseURL(&amp;#39;http://url.com/page?name=Adam&amp;amp;surname=Smith&amp;#39;); // &amp;#39;http://url.com/page&amp;#39; const url = new URL(&amp;#34;https://example.com/login?user=someguy&amp;amp;page=news&amp;#34;); url.origin // &amp;#34;https://example.com&amp;#34; url.host // &amp;#34;example.com&amp;#34; url.protocol // &amp;#34;https:&amp;#34; url.pathname // &amp;#34;/login&amp;#34; url.searchParams.get(&amp;#39;user&amp;#39;) // &amp;#34;someuser&amp;#34; get URL parameters as object const getURLParameters = url =&amp;gt; (url.match(/([^?=&amp;amp;]+)(=([^&amp;amp;]*))/g) || []).reduce( (a, v) =&amp;gt; ( (a[v.slice(0, v.indexOf(&amp;#39;=&amp;#39;))] = v.slice(v.indexOf(&amp;#39;=&amp;#39;) + 1)), a ), {} ); getURLParameters(&amp;#39;google.com&amp;#39;); // {} getURLParameters(&amp;#39;http://url.com/page?name=Adam&amp;amp;surname=Smith&amp;#39;); // {name: &amp;#39;Adam&amp;#39;, surname: &amp;#39;Smith&amp;#39;} // One line Object.fromEntries(&amp;#39;http://url.com/page?name=Adam&amp;amp;surname=Smith&amp;#39;.split(&amp;#39;?&amp;#39;)[1].split(&amp;#39;&amp;amp;&amp;#39;).map(x=&amp;gt;x.split(&amp;#39;=&amp;#39;))) if DOC element contains another element const elementContains = (parent, child) =&amp;gt; parent !</description></item><item><title>Serverless: Flask+API Gateway+Lambda+MongoDB</title><link>https://romankurnovskii.com/en/posts/serverless-flask-lambda-api-gateway-mongodb/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/serverless-flask-lambda-api-gateway-mongodb/</guid><description>&amp;ldquo;mongodb&amp;rdquo; free tier vs &amp;ldquo;documentdb&amp;rdquo;
Project structure - src - app.py - mongo.py - .env - requirements.txt - serverless.yml Sources
Add AIM user Setup specific user for serverless deployment
username: serverless-deployer
aws aim documentation Set policy Create:
ServerLessDeployerPolicyGroup ServerLessDeployerPolicy Policy:
{ &amp;#34;Statement&amp;#34;: [ { &amp;#34;Action&amp;#34;: [ &amp;#34;apigateway:*&amp;#34;, &amp;#34;cloudformation:CancelUpdateStack&amp;#34;, &amp;#34;cloudformation:ContinueUpdateRollback&amp;#34;, &amp;#34;cloudformation:CreateChangeSet&amp;#34;, &amp;#34;cloudformation:CreateStack&amp;#34;, &amp;#34;cloudformation:CreateUploadBucket&amp;#34;, &amp;#34;cloudformation:DeleteStack&amp;#34;, &amp;#34;cloudformation:Describe*&amp;#34;, &amp;#34;cloudformation:EstimateTemplateCost&amp;#34;, &amp;#34;cloudformation:ExecuteChangeSet&amp;#34;, &amp;#34;cloudformation:Get*&amp;#34;, &amp;#34;cloudformation:List*&amp;#34;, &amp;#34;cloudformation:UpdateStack&amp;#34;, &amp;#34;cloudformation:UpdateTerminationProtection&amp;#34;, &amp;#34;cloudformation:ValidateTemplate&amp;#34;, &amp;#34;dynamodb:CreateTable&amp;#34;, &amp;#34;dynamodb:DeleteTable&amp;#34;, &amp;#34;dynamodb:DescribeTable&amp;#34;, &amp;#34;dynamodb:DescribeTimeToLive&amp;#34;, &amp;#34;dynamodb:UpdateTimeToLive&amp;#34;, &amp;#34;ec2:AttachInternetGateway&amp;#34;, &amp;#34;ec2:AuthorizeSecurityGroupIngress&amp;#34;, &amp;#34;ec2:CreateInternetGateway&amp;#34;, &amp;#34;ec2:CreateNetworkAcl&amp;#34;, &amp;#34;ec2:CreateNetworkAclEntry&amp;#34;, &amp;#34;ec2:CreateRouteTable&amp;#34;, &amp;#34;ec2:CreateSecurityGroup&amp;#34;, &amp;#34;ec2:CreateSubnet&amp;#34;, &amp;#34;ec2:CreateTags&amp;#34;, &amp;#34;ec2:CreateVpc&amp;#34;, &amp;#34;ec2:DeleteInternetGateway&amp;#34;, &amp;#34;ec2:DeleteNetworkAcl&amp;#34;, &amp;#34;ec2:DeleteNetworkAclEntry&amp;#34;, &amp;#34;ec2:DeleteRouteTable&amp;#34;, &amp;#34;ec2:DeleteSecurityGroup&amp;#34;, &amp;#34;ec2:DeleteSubnet&amp;#34;, &amp;#34;ec2:DeleteVpc&amp;#34;, &amp;#34;ec2:Describe*&amp;#34;, &amp;#34;ec2:DetachInternetGateway&amp;#34;, &amp;#34;ec2:ModifyVpcAttribute&amp;#34;, &amp;#34;events:DeleteRule&amp;#34;, &amp;#34;events:DescribeRule&amp;#34;, &amp;#34;events:ListRuleNamesByTarget&amp;#34;, &amp;#34;events:ListRules&amp;#34;, &amp;#34;events:ListTargetsByRule&amp;#34;, &amp;#34;events:PutRule&amp;#34;, &amp;#34;events:PutTargets&amp;#34;, &amp;#34;events:RemoveTargets&amp;#34;, &amp;#34;iam:AttachRolePolicy&amp;#34;, &amp;#34;iam:CreateRole&amp;#34;, &amp;#34;iam:DeleteRole&amp;#34;, &amp;#34;iam:DeleteRolePolicy&amp;#34;, &amp;#34;iam:DetachRolePolicy&amp;#34;, &amp;#34;iam:GetRole&amp;#34;, &amp;#34;iam:PassRole&amp;#34;, &amp;#34;iam:PutRolePolicy&amp;#34;, &amp;#34;iot:CreateTopicRule&amp;#34;, &amp;#34;iot:DeleteTopicRule&amp;#34;, &amp;#34;iot:DisableTopicRule&amp;#34;, &amp;#34;iot:EnableTopicRule&amp;#34;, &amp;#34;iot:ReplaceTopicRule&amp;#34;, &amp;#34;kinesis:CreateStream&amp;#34;, &amp;#34;kinesis:DeleteStream&amp;#34;, &amp;#34;kinesis:DescribeStream&amp;#34;, &amp;#34;lambda:*&amp;#34;, &amp;#34;logs:CreateLogDelivery&amp;#34;, &amp;#34;logs:CreateLogGroup&amp;#34;, &amp;#34;logs:DeleteLogGroup&amp;#34;, &amp;#34;logs:DescribeLogGroups&amp;#34;, &amp;#34;logs:DescribeLogStreams&amp;#34;, &amp;#34;logs:FilterLogEvents&amp;#34;, &amp;#34;logs:GetLogEvents&amp;#34;, &amp;#34;logs:PutSubscriptionFilter&amp;#34;, &amp;#34;s3:CreateBucket&amp;#34;, &amp;#34;s3:DeleteBucket&amp;#34;, &amp;#34;s3:DeleteBucketPolicy&amp;#34;, &amp;#34;s3:DeleteObject&amp;#34;, &amp;#34;s3:DeleteObjectVersion&amp;#34;, &amp;#34;s3:GetObject&amp;#34;, &amp;#34;s3:GetObjectVersion&amp;#34;, &amp;#34;s3:ListAllMyBuckets&amp;#34;, &amp;#34;s3:ListBucket&amp;#34;, &amp;#34;s3:PutBucketNotification&amp;#34;, &amp;#34;s3:PutBucketPolicy&amp;#34;, &amp;#34;s3:PutBucketTagging&amp;#34;, &amp;#34;s3:PutBucketWebsite&amp;#34;, &amp;#34;s3:PutEncryptionConfiguration&amp;#34;, &amp;#34;s3:PutObject&amp;#34;, &amp;#34;sns:CreateTopic&amp;#34;, &amp;#34;sns:DeleteTopic&amp;#34;, &amp;#34;sns:GetSubscriptionAttributes&amp;#34;, &amp;#34;sns:GetTopicAttributes&amp;#34;, &amp;#34;sns:ListSubscriptions&amp;#34;, &amp;#34;sns:ListSubscriptionsByTopic&amp;#34;, &amp;#34;sns:ListTopics&amp;#34;, &amp;#34;sns:SetSubscriptionAttributes&amp;#34;, &amp;#34;sns:SetTopicAttributes&amp;#34;, &amp;#34;sns:Subscribe&amp;#34;, &amp;#34;sns:Unsubscribe&amp;#34;, &amp;#34;states:CreateStateMachine&amp;#34;, &amp;#34;states:DeleteStateMachine&amp;#34; ], &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ], &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34; } Create user copy the¬†API Key &amp;amp;¬†Secret</description></item><item><title>cognito-token-observer</title><link>https://romankurnovskii.com/en/apps/npm/cognito-token-observer/</link><pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/apps/npm/cognito-token-observer/</guid><description/></item><item><title>hugo-lunr-ml</title><link>https://romankurnovskii.com/en/apps/npm/hugo-lunr-ml/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/apps/npm/hugo-lunr-ml/</guid><description/></item><item><title>Add search to Hugo multilingual static site with Lunr</title><link>https://romankurnovskii.com/en/posts/hugo-add-search-lunr-popup/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/hugo-add-search-lunr-popup/</guid><description>Initial I had the need to implement search functionality on my site. Content on is in different languages.
The goal is to impelemnt search for all pages and separate search results for each and every language.
How it works Hugo generates the search index. In this case it means that we get json file with every static page on the site.
To make search works we need to create index. lunr.js takes care of it.
Client send query -&amp;gt; our script &amp;ldquo;tries to find&amp;rdquo; in the index</description></item><item><title>Hugo resize a picture on click</title><link>https://romankurnovskii.com/en/posts/hugo-add-image-zoomin/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/hugo-add-image-zoomin/</guid><description>Introduction Hugo by default uses parsing of markdown files. This means that we get the html code as it is written in markdown.
In order to understand which images we can enhance, we add a separate tag/key/id to those images
Tools To implement the functionality, we need to:
Write/connect a script/handler that will perform the zoomin effect on the images we need Add the necessary metadata to the images, so the script can find them zoomin script To add the ability to zoom on click, we will use the medium-zoom package.</description></item><item><title>Automating Code Reviews with Amazon CodeGuru</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codeguru/automating-code-reviews-amazon-codeguru/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codeguru/automating-code-reviews-amazon-codeguru/</guid><description>Lab Automating Code Reviews with Amazon CodeGuru Associating Amazon CodeGuru with a CodeCommit Repository 1. Navigate to the¬†Amazon CodeCommit console.
2. Click¬†java-web-app:
3. Notice that at the moment, only a README file has been committed to the master branch. Next, you&amp;rsquo;ll associate CodeGuru with this repository, so that CodeGuru can begin to analyze the code therein.
4. Go to the¬†CodeGuru dashboard.
5. Click¬†Associate Repository and run analysis:
6. Select¬†AWS CodeCommit as the provider, choose¬†java-web-app¬†from the repository dropdown, enter _master_into Source branch¬†and click¬†Associate:</description></item><item><title>Build A Log Aggregation System in AWS</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/opensearch-service/build-log-aggregation-system/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/opensearch-service/build-log-aggregation-system/</guid><description>Lab Monitor Like a DevOps Pro: Build A Log Aggregation System in AWS Navigating to Your Cloud&amp;rsquo;s Lambda Function 1. In the AWS Management Console search bar, enter¬†Cloud Formation, and click the¬†CloudFormation¬†result under¬†Services:
This will bring you to the CloudFormation Stacks¬†table.
There will be one stack named cloudacademylabs¬†in the table with a¬†Status of¬†CREATE_COMPLETE.
Note: If the stack hasn&amp;rsquo;t reached the Statusof¬†CREATE_COMPLETE, try refreshing the page after a minute. It only takes a minute for the stack to fully create.</description></item><item><title>Create Classic Load Balancer</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/elasticloadbalancing/create-amazon-load-balancing/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/elasticloadbalancing/create-amazon-load-balancing/</guid><description>Practice Creating Classic Load Balancer Planning the Classic Load Balancer When you connected to the AWS account provided in the former step, you had¬†a few things that were already deployed. This is the current infrastructure that was already deployed for you:
You already have a VPC with some subnets¬†and 2 EC2 instances running inside the VPC in different Availability Zones. Both instances are inside the same Security Group called , which¬†is allowing HTTP access from port 80 to anywhere (0.</description></item><item><title>Develop and Deploy an Application with AWS CodeStar</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codestar/develop-and-deploy-app-with-codestar/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codestar/develop-and-deploy-app-with-codestar/</guid><description>Lab Develop and Deploy an Application with AWS CodeStar Creating an AWS CodeStar Project 1.¬†In the AWS Management Console search bar, enter CodeStar, and click the¬†CodeStar¬†result under¬†Services:
2. On the welcome page, click¬†Create¬†project.
Take a moment to see all of the different templates available in AWS CodeStar.
3.¬†Check the following boxes on the left filter bar to narrow down the listed templates:
AWS services: EC2 Application category:¬†Web application Programming languages:¬†Node.</description></item><item><title>Encrypting S3 Objects Using SSE-KMS</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/kms/encrypting-s3-objects-using-sse-kms/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/kms/encrypting-s3-objects-using-sse-kms/</guid><description>Lab Encrypting S3 Objects Using SSE-KMS Creating a Customer Master Key (CMK) 1. In the AWS Management Console search bar, enter¬†KMS, and click the¬†KMS¬†result under¬†Services:
2. Select Customer managed****keys in the left pane of the KMS console.
Warning: Cloud Academy cleans up the lab environment for you after a lab is completed or terminated. As a precaution, AWS prevents keys from being deleted immediately. Rather, they are queued for deletion, and an expiration period is set (of 7-30 days).</description></item><item><title>Fan-Out Orders using Amazon SNS and SQS</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/sqs/fan-out-orders-with-sns-sqs/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/sqs/fan-out-orders-with-sns-sqs/</guid><description>Lab Fan-Out Orders using Amazon SNS and SQS Creating an Amazon SNS Topic and Amazon SQS Queues Here&amp;rsquo;s a diagram of what you will build and configure in this lab step:
In the search bar at the top, enter SNS and under Services, click the Simple Notification Service result: In the Create topic card on the right, in the Topic name textbox, enter new-orders and click Next step: The Create topic form will load.
By default, the Type of topic selected will be Standard.</description></item><item><title>Initializing Amazon EC2 Instances with AWS CloudFormation Init</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cloudformation/initializing-ec2-with-cloudformation/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cloudformation/initializing-ec2-with-cloudformation/</guid><description>Lab Initializing Amazon EC2 Instances with AWS CloudFormation Init Establishing Desired EC2 Instance State with AWS CloudFormation Init 1.¬†In the AWS Console search bar, search for¬†cloudformation¬†and¬†click the¬†CloudFormation¬†result under¬†Services:
2. Click the¬†Create stack¬†dropdown menu and select¬†With new resources:
3. In the¬†Create stack¬†form, in the Specify template¬†section, ensure¬†Amazon S3 URLis selected for the¬†Template source.
4.¬†Paste in the following URL in the¬†Amazon S3 URL¬†field:</description></item><item><title>Introduction to CloudWatch</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cloudwatch/introduction-to-cloudwatch/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/cloudwatch/introduction-to-cloudwatch/</guid><description>Lab Introduction to CloudWatch Explore CloudWatch 1. AWS has done an excellent job defining CloudWatch key concepts. Read the abbreviated¬†excerpt from their official documentation below to obtain an understanding of Metrics, Namespaces¬†and Alarms:
Metrics
A metric is the fundamental concept in CloudWatch and represents a time-ordered set of data points. These data points can be either your custom metrics or metrics from other services in AWS. You or AWS products publish metric data points into CloudWatch and you retrieve statistics about those data points as an ordered set of time-series data.</description></item><item><title>Introduction to CodeCommit</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codecommit/introduction-codecommit/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/codecommit/introduction-codecommit/</guid><description>Lab https://cloudacademy.com/lab/introduction-codecommit/
Create a repository 1. In the AWS Management Console search bar, enter¬†CodeCommit, and click the CodeCommit¬†result under¬†Services:
2. Click Create repository:
3. In the Create repository¬†form enter the following values accepting the defaults for values not specified:
Repository name:¬†lab-repository You can leave the¬†Description¬†field empty for this lab. Usually this field would contain a short¬†description of the purpose of the repository. Attaching meaningful descriptions to repositories makes managing large numbers of repositories easier.</description></item><item><title>Process Amazon SNS Notifications with AWS Lambda</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/sns/aws-lambda-sns-notifications/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/sns/aws-lambda-sns-notifications/</guid><description>Lab Process Amazon SNS Notifications with AWS Lambda Creating an Amazon SNS Topic 1.¬†In the AWS Management Console search bar, enter¬†SNS, and click the¬†Simple Notification Service¬†result under¬†Services:
In the left-hand side menu, click¬†Topics: If you can&amp;rsquo;t see the left-hand menu, to expand it, click the following:
Click¬†Create topic: In the¬†Create topic¬†form, ensure to have selected the Standard type, and enter the following values accepting the defaults for values not specified: Name:¬†lab-topic You can leave the¬†Display name¬†field empty for this Lab.</description></item><item><title>Sessionizing Clickstream Data with Amazon Kinesis Data Analytics</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/kinesis/sessionizing-clickstream-data-kinesis-data-analytics/</link><pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/kinesis/sessionizing-clickstream-data-kinesis-data-analytics/</guid><description>Lab Sessionizing Clickstream Data with Amazon Kinesis Data Analytics Creating an Amazon Kinesis Data Analytics Application 1.¬†In the AWS Management Console search bar, enter¬†Kinesis, and click the¬†Kinesis¬†result under¬†Services:
You will be taken to the Amazon Kinesis dashboard.
In this lab, a Kinesis Data Stream has been pre-created for you. Under¬†Data Streams¬†you will see Total data streams¬†is one:
2. In the left-hand menu, click Analytics applications and under that click SQL applications:</description></item><item><title>Israel - Haifa - Bahai Gardens</title><link>https://romankurnovskii.com/en/photos/22-07-02-israel-haifa-bahai-gardens/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/photos/22-07-02-israel-haifa-bahai-gardens/</guid><description>Google maps Route</description></item><item><title>Introduction to DynamoDB</title><link>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/dynamodb/introduction-dynamodb/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/aws-certified-developer-associate/dynamodb/introduction-dynamodb/</guid><description>Lab
Creating a DynamoDB Table with a Partition Key 1. From the AWS Management Console, in the search bar at the top, enter¬†DynamoDB, and under¬†Services, click the¬†DynamoDB¬†result:
The Amazon DynamoDB product overview page will load.
2. To start creating a new DyanmoDB table, on the right-hand side, click¬†Create table:
3. In the¬†Table details¬†section, enter the following:
Table Name: Partition Key: Enter¬†Name¬†and ensure type is 4. In the¬†Settings¬†section, select¬†Customize settings:</description></item><item><title>Python Cheat Sheet</title><link>https://romankurnovskii.com/en/posts/python-snippets/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/python-snippets/</guid><description>def sum_of_digits(n): sum = 0 while n: sum += n % 10 n //= 10 return sum # Single line comments start with a number symbol. &amp;#34;&amp;#34;&amp;#34; Multiline strings can be written using three &amp;#34;s, and are often used as documentation. &amp;#34;&amp;#34;&amp;#34; #################################################### ## 1. Primitive Datatypes and Operators #################################################### # You have numbers 3 # =&amp;gt; 3 # Math is what you would expect 1 + 1 # =&amp;gt; 2 8 - 1 # =&amp;gt; 7 10 * 2 # =&amp;gt; 20 35 / 5 # =&amp;gt; 7.</description></item><item><title>How to Download and Install Linux RHEL 9 for Free</title><link>https://romankurnovskii.com/en/posts/howto-install-rhel-9-free/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-install-rhel-9-free/</guid><description>Red Hat Enterprise Linux 9 (RHEL 9), codenamed Plow, has gone public (GA). Red Hat announced it on May 18, 2022. It replaced the beta version, which had been in existence since November 3, 2021.
RHEL 9 is the first few releases in the Red Hat family. It is the first major release since IBM acquired Red Hat in July 2019, and the first major release since abandoning the CentOS project in favor of CentOS Stream, which is now RHEL&amp;rsquo;s predecessor.</description></item><item><title>Top Docker Commands</title><link>https://romankurnovskii.com/en/posts/docker-commands/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/docker-commands/</guid><description>most popular docker images ## lists the images docker pull imagename ## Pull an image or a repository from a registry docker ps -a ## See a list of all containers, even the ones not running docker build -t imagename . ## Create image using this directory's Dockerfile docker run -p 4000:80 imagename ## Run &amp;quot;imagename&amp;quot; mapping port 4000 to 80 docker rmi ## removes the image docker rm ## removes the container docker stop ## stops the container docker volume ls ## lists the volumes docker kill ## kills the container docker logs ## see logs docker inspect ## shows all the info of a container docker docker cp ## Copy files/folders between a container and the local filesystem docker pull imagename ## Pull an image or a repository from a registry docker build -t imagename .</description></item><item><title>Tar command Cheat Sheet</title><link>https://romankurnovskii.com/en/posts/cheat-sheet-command-tar/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/cheat-sheet-command-tar/</guid><description>Common options z compress with gzip c create an archive u append files which are newer than the corresponding copy ibn the archive f filename of the archive v verbose, display what is inflated or deflated a unlike of z, determine compression based on file extension Create tar named archive.tar containing directory tar cf archive.tar /path/files Concatenate files into a single tar tar -cf archive.tar /path/files Extract the contents from archive.tar tar xf archive.tar Create a gzip compressed tar file name archive.</description></item><item><title>How to rename files in Python</title><link>https://romankurnovskii.com/en/posts/howto-rename-files-in-python/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-rename-files-in-python/</guid><description>Learn different ways to rename files in Python using the os and pathlib modules.
os.rename Rename files with os
You can use
os.rename(old_name, new_name) For example we can combine it with os.path.splitext() to get the base name and file extension, and then combine it to a new name:
import os for file in os.listdir(): name, ext = os.path.splitext(file) new_name = f&amp;#34;{name}_new{ext}&amp;#34; os.rename(file, new_name) pathlib Rename files with pathlib
The same could be achieved with the pathlib module and</description></item><item><title>How to create a deep clone of an object in JavaScript</title><link>https://romankurnovskii.com/en/posts/howto-create-deepclone-js/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/howto-create-deepclone-js/</guid><description>We can use recursion. Use Object.assign() and an empty object ({}) to create a shallow clone of the original. Use Object.keys() and Array.prototype.forEach() to determine which key-value pairs need to be deep cloned.
const deepClone = obj =&amp;gt; { let clone = Object.assign({}, obj); Object.keys(clone).forEach( key =&amp;gt; (clone[key] = typeof obj[key] === &amp;#39;object&amp;#39; ? deepClone(obj[key]) : obj[key]) ); return Array.isArray(obj) &amp;amp;&amp;amp; obj.length ? (clone.length = obj.length) &amp;amp;&amp;amp; Array.from(clone) : Array.isArray(obj) ? Array.from(obj) : clone; }; const a = { foo: &amp;#39;bar&amp;#39;, obj: { a: 1, b: 2 } }; const b = deepClone(a); // a !</description></item><item><title>Mac Setup 2022</title><link>https://romankurnovskii.com/en/posts/mac-setup-development/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/mac-setup-development/</guid><description>MacBook Pro Specification 13-inch Apple M1 Pro M1 2020 16 GB RAM 512 GB SSD QWERTY = English/Hebrew macOS Monterey (Update always) Homebrew Install Homebrew as package manager for macOS:
## paste in terminal and follow the instructions /bin/bash -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;#34; Update everything in Homebrew to recent version:
brew update Add additional source for casks:
brew tap homebrew/cask-versions Install GUI applications (read more about these in GUI Applications):
brew install --cask \ appcleaner \ all-in-one-messenger \ anaconda \ brewmate \ deepl \ discord \ disk-inventory-x \ docker \ figma \ google-chrome \ google-drive \ grammarly \ iterm2 \ itsycal \ macx-youtube-downloader \ mongodb-compass \ notion \ obs \ postman \ rectangle \ sublime-text \ syncthing \ telegram \ tor-browser \ transmission \ utm \ viber \ visual-studio-code \ vlc \ yandex-disk \ zoom Install terminal applications (read more about these in Terminal Applications):</description></item><item><title>Markdown Cheat Sheet</title><link>https://romankurnovskii.com/en/posts/markdown-syntax/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/markdown-syntax/</guid><description>&lt;p>This article offers an example of the basic Markdown syntax that can be used and also shows whether the basic elements of HTML are decorated with CSS.&lt;/p></description></item><item><title>Some code snippets</title><link>https://romankurnovskii.com/en/posts/other-snippets/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/other-snippets/</guid><description>pandoc mardown -&amp;gt; pdf Create pdf file from .md in multiple folders
prepare:
brew install basictex # search for cyrillic fonts fc-list | grep –∫\ brew tap homebrew/cask-fonts brew install --cask font-m-plus brew tap homebrew/cask-fonts brew install --cask font-m-plus brew install --cask font-m-plus-1 brew install --cask font-m-plus-1-code ```sh pandoc --pdf-engine xelatex \ --variable mainfont=&amp;#34;M+ 1p&amp;#34; --variable sansfont=&amp;#34;M+ 1p&amp;#34; --variable monofont=&amp;#34;M+ 1m&amp;#34; \ -V geometry:&amp;#34;top=1cm, bottom=2cm, left=1cm, right=1cm&amp;#34; \ --file-scope \ --highlight-style=tango \ -s \ --toc-depth=1 \ --variable=toc-title:&amp;#34; &amp;#34; \ --top-level-division=chapter \ --standalone \ --self-contained \ --from=markdown \ $(find .</description></item><item><title>IT courses 2020</title><link>https://romankurnovskii.com/en/posts/diploma/</link><pubDate>Fri, 01 Jan 2021 15:31:25 +0200</pubDate><guid>https://romankurnovskii.com/en/posts/diploma/</guid><description>&lt;p>Interim metrics still in process&lt;/p>
&lt;p>For 2020:&lt;/p>
&lt;ul>
&lt;li>Time spent studying/practicing: ~5500 hours&lt;/li>
&lt;/ul></description></item><item><title/><link>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/apm-server/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/apm-server/readme/</guid><description>APM Server extension The APM Server receives data from APM agents and transforms them into Elasticsearch documents that can be visualised in Kibana.
Usage To include APM Server in the stack, run Docker Compose from the root of the repository with an additional command line argument referencing the apm-server-compose.yml file:
docker-compose -f docker-compose.yml -f extensions/apm-server/apm-server-compose.yml up Meanwhile, you can navigate to the APM application in Kibana and follow the setup instructions to get started.
Connecting an agent to APM Server The most basic configuration to send traces to APM server is to specify the SERVICE_NAME and SERVICE_URL.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/curator/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/curator/readme/</guid><description>Curator Elasticsearch Curator helps you curate or manage your indices.
Usage If you want to include the Curator extension, run Docker Compose from the root of the repository with an additional command line argument referencing the curator-compose.yml file:
docker-compose -f docker-compose.yml -f extensions/curator/curator-compose.yml up This sample setup demonstrates how to run curator every minute using cron.
All configuration files are available in the config/ directory.
Documentation Curator Reference</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/enterprise-search/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/enterprise-search/readme/</guid><description>Enterprise Search extension Elastic Enterprise Search is a suite of products for search applications backed by the Elastic Stack.
Requirements 2 GB of free RAM, on top of the resources required by the other stack components and extensions. Enterprise Search exposes the TCP port 3002 for its Web UI and API.
Usage Generate an encryption key Enterprise Search requires one or more encryption keys to be configured before the initial startup. Failing to do so prevents the server from starting.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/filebeat/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/filebeat/readme/</guid><description>Filebeat Filebeat is a lightweight shipper for forwarding and centralizing log data. Installed as an agent on your servers, Filebeat monitors the log files or locations that you specify, collects log events, and forwards them either to Elasticsearch or Logstash for indexing.
Usage To include Filebeat in the stack, run Docker Compose from the root of the repository with an additional command line argument referencing the filebeat-compose.yml file:
docker-compose -f docker-compose.yml -f extensions/filebeat/filebeat-compose.yml up Configuring Filebeat The Filebeat configuration is stored in config/filebeat.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/logspout/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/logspout/readme/</guid><description>Logspout extension Logspout collects all Docker logs using the Docker logs API, and forwards them to Logstash without any additional configuration.
Usage If you want to include the Logspout extension, run Docker Compose from the root of the repository with an additional command line argument referencing the logspout-compose.yml file:
docker-compose -f docker-compose.yml -f extensions/logspout/logspout-compose.yml up In your Logstash pipeline configuration, enable the udp input and set the input codec to json:
input { udp { port =&amp;gt; 5000 codec =&amp;gt; json } } Documentation https://github.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/metricbeat/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/metricbeat/readme/</guid><description>Metricbeat Metricbeat is a lightweight shipper that you can install on your servers to periodically collect metrics from the operating system and from services running on the server. Metricbeat takes the metrics and statistics that it collects and ships them to the output that you specify, such as Elasticsearch or Logstash.
Usage To include Metricbeat in the stack, run Docker Compose from the root of the repository with an additional command line argument referencing the metricbeat-compose.yml file:
docker-compose -f docker-compose.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/90daysofdevops/monitoring/elastic-stack/extensions/readme/</guid><description>Extensions Third-party extensions that enable extra integrations with the Elastic stack.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2808/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2808/</guid><description>class Solution: def minimumSeconds(self, nums: List[int]) -&amp;gt; int: d = defaultdict(list) for i, x in enumerate(nums): d[x].append(i) res = inf n = len(nums) for idx in d.values(): t = idx[0] + n - idx[-1] for i, j in pairwise(idx): t = max(t, j - i) res = min(res, t // 2) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2818/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2818/</guid><description>def primeFactors(n): i = 2 res = set() while i * i &amp;lt;= n: while n % i == 0: res.add(i) n //= i i += 1 if n &amp;gt; 1: res.add(n) return len(res) class Solution: def maximumScore(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 arr = [(i, primeFactors(x), x) for i, x in enumerate(nums)] n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, f, x in arr: while stk and stk[-1][0] &amp;lt; f: stk.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2826/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2826/</guid><description>class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: f = [0] * 3 for x in nums: g = [0] * 3 if x == 1: g[0] = f[0] g[1] = min(f[:2]) + 1 g[2] = min(f) + 1 elif x == 2: g[0] = f[0] + 1 g[1] = min(f[:2]) g[2] = min(f) + 1 else: g[0] = f[0] + 1 g[1] = min(f[:2]) + 1 g[2] = min(f) f = g return min(f)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2827/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2827/</guid><description>class Solution: def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -&amp;gt; int: @cache def dfs(pos: int, mod: int, diff: int, lead: int, limit: int) -&amp;gt; int: if pos &amp;gt;= len(s): return mod == 0 and diff == 10 up = int(s[pos]) if limit else 9 res = 0 for i in range(up + 1): if i == 0 and lead: res += dfs(pos + 1, mod, diff, 1, limit and i == up) else: nxt = diff + (1 if i % 2 == 1 else -1) res += dfs(pos + 1, (mod * 10 + i) % k, nxt, 0, limit and i == up) return res s = str(high) a = dfs(0, 0, 10, 1, 1) dfs.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2846/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2846/</guid><description>class Solution: def minOperationsQueries( self, n: int, edges: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: m = n.bit_length() g = [[] for _ in range(n)] f = [[0] * m for _ in range(n)] p = [0] * n cnt = [None] * n depth = [0] * n for u, v, w in edges: g[u].append((v, w - 1)) g[v].append((u, w - 1)) cnt[0] = [0] * 26 q = deque([0]) while q: i = q.popleft() f[i][0] = p[i] for j in range(1, m): f[i][j] = f[f[i][j - 1]][j - 1] for j, w in g[i]: if j !</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2851/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2851/</guid><description>&amp;#34;&amp;#34;&amp;#34; DP, Z-algorithm, Fast mod. Approach How to represent a string? Each operation is just a rotation. Each result string can be represented by an integer from 0 to n - 1. Namely, it&amp;#39;s just the new index of s[0]. How to find the integer(s) that can represent string t? Create a new string s + t + t (length = 3 * n). Use Z-algorithm (or KMP), for each n &amp;lt;= index &amp;lt; 2 * n, calculate the maximum prefix length that each substring starts from index can match, if the length &amp;gt;= n, then (index - n) is a valid integer representation.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2852/</guid><description>class Solution: def sumRemoteness(self, grid: List[List[int]]) -&amp;gt; int: def dfs(i: int, j: int) -&amp;gt; (int, int): s, t = grid[i][j], 1 grid[i][j] = 0 for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; n and 0 &amp;lt;= y &amp;lt; n and grid[x][y] &amp;gt; 0: s1, t1 = dfs(x, y) s, t = s + s1, t + t1 return s, t n = len(grid) dirs = (-1, 0, 1, 0, -1) cnt = sum(x &amp;gt; 0 for row in grid for x in row) res = 0 for i, row in enumerate(grid): for j, x in enumerate(row): if x &amp;gt; 0: s, t = dfs(i, j) res += (cnt - t) * s return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2865/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2865/</guid><description>class Solution: def maximumSumOfHeights(self, maxHeights: List[int]) -&amp;gt; int: n = len(maxHeights) stk = [] left = [-1] * n for i, x in enumerate(maxHeights): while stk and maxHeights[stk[-1]] &amp;gt; x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] right = [n] * n for i in range(n - 1, -1, -1): x = maxHeights[i] while stk and maxHeights[stk[-1]] &amp;gt;= x: stk.pop() if stk: right[i] = stk[-1] stk.append(i) f = [0] * n for i, x in enumerate(maxHeights): if i and x &amp;gt;= maxHeights[i - 1]: f[i] = f[i - 1] + x else: j = left[i] f[i] = x * (i - j) + (f[j] if j !</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2874/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2874/</guid><description>class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2879/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2879/</guid><description>import pandas as pd def selectFirstRows(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: return employees.head(3)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2884/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2884/</guid><description>import pandas as pd def modifySalaryColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;salary&amp;#39;] *= 2 return employees</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2894/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2894/</guid><description>class Solution: def differenceOfSums(self, n: int, m: int) -&amp;gt; int: return sum(i if i % m else -i for i in range(1, n + 1))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2897/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2897/</guid><description>class Solution: def maxSum(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 cnt = [0] * 31 for x in nums: for i in range(31): if x &amp;gt;&amp;gt; i &amp;amp; 1: cnt[i] += 1 res = 0 for _ in range(k): x = 0 for i in range(31): if cnt[i]: x |= 1 &amp;lt;&amp;lt; i cnt[i] -= 1 res = (res + x * x) % mod return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2573/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2573/</guid><description>class Solution: def findTheString(self, lcp: List[List[int]]) -&amp;gt; str: n = len(lcp) s = [&amp;#34;&amp;#34;] * n i = 0 for c in ascii_lowercase: while i &amp;lt; n and s[i]: i += 1 if i == n: break for j in range(i, n): if lcp[i][j]: s[j] = c if &amp;#34;&amp;#34; in s: return &amp;#34;&amp;#34; for i in range(n - 1, -1, -1): for j in range(n - 1, -1, -1): if s[i] == s[j]: if i == n - 1 or j == n - 1: if lcp[i][j] !</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2576/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2576/</guid><description>class Solution: def maxNumOfMarkedIndices(self, nums: List[int]) -&amp;gt; int: nums.sort() n = len(nums) i, j = 0, (n + 1) // 2 res = 0 while j &amp;lt; n: while j &amp;lt; n and nums[i] * 2 &amp;gt; nums[j]: j += 1 if j &amp;lt; n: res += 2 i, j = i + 1, j + 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2579/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2579/</guid><description>class Solution: def coloredCells(self, n: int) -&amp;gt; int: return 2 * n * (n - 1) + 1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2581/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2581/</guid><description>class Solution: def rootCount( self, edges: List[List[int]], guesses: List[List[int]], k: int ) -&amp;gt; int: def dfs1(i, fa): nonlocal cnt for j in g[i]: if j != fa: cnt += gs[(i, j)] dfs1(j, i) def dfs2(i, fa): nonlocal res, cnt res += cnt &amp;gt;= k for j in g[i]: if j != fa: cnt -= gs[(i, j)] cnt += gs[(j, i)] dfs2(j, i) cnt -= gs[(j, i)] cnt += gs[(i, j)] g = defaultdict(list) for a, b in edges: g[a].</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2582/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2582/</guid><description>class Solution: def passThePillow(self, n: int, time: int) -&amp;gt; int: k, mod = divmod(time, n - 1) return n - mod if k &amp;amp; 1 else mod + 1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2584/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2584/</guid><description>class Solution: def findValidSplit(self, nums: List[int]) -&amp;gt; int: first = {} n = len(nums) last = list(range(n)) for i, x in enumerate(nums): j = 2 while j &amp;lt;= x // j: if x % j == 0: if j in first: last[first[j]] = i else: first[j] = i while x % j == 0: x //= j j += 1 if x &amp;gt; 1: if x in first: last[first[x]] = i else: first[x] = i mx = last[0] for i, x in enumerate(last): if mx &amp;lt; i: return mx mx = max(mx, x) return -1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2586/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2586/</guid><description>class Solution: def vowelStrings(self, words: List[str], left: int, right: int) -&amp;gt; int: return sum( w[0] in &amp;#39;aeiou&amp;#39; and w[-1] in &amp;#39;aeiou&amp;#39; for w in words[left : right + 1] )</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2587/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2587/</guid><description>class Solution: def maxScore(self, nums: List[int]) -&amp;gt; int: nums.sort(reverse=True) s = 0 for i, x in enumerate(nums): s += x if s &amp;lt;= 0: return i return len(nums)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2590/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2590/</guid><description>from sortedcontainers import SortedList class TodoList: def __init__(self): self.i = 1 self.tasks = defaultdict(SortedList) def addTask( self, userId: int, taskDescription: str, dueDate: int, tags: List[str] ) -&amp;gt; int: taskId = self.i self.i += 1 self.tasks[userId].add([dueDate, taskDescription, set(tags), taskId, False]) return taskId def getAllTasks(self, userId: int) -&amp;gt; List[str]: return [x[1] for x in self.tasks[userId] if not x[4]] def getTasksForTag(self, userId: int, tag: str) -&amp;gt; List[str]: return [x[1] for x in self.tasks[userId] if not x[4] and tag in x[2]] def completeTask(self, userId: int, taskId: int) -&amp;gt; None: for task in self.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2591/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2591/</guid><description>class Solution: def distMoney(self, money: int, children: int) -&amp;gt; int: if money &amp;lt; children: return -1 if money &amp;gt; 8 * children: return children - 1 if money == 8 * children - 4: return children - 2 # money-8x &amp;gt;= children-x, x &amp;lt;= (money-children)/7 return (money - children) // 7</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2593/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2593/</guid><description>class Solution: def findScore(self, nums: List[int]) -&amp;gt; int: n = len(nums) vis = [False] * (n + 2) idx = sorted(range(n), key=lambda i: (nums[i], i)) res = 0 for i in idx: if not vis[i + 1]: res += nums[i] vis[i] = vis[i + 2] = True return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2595/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2595/</guid><description>class Solution: def evenOddBit(self, n: int) -&amp;gt; List[int]: mask = 0x5555 even = (n &amp;amp; mask).bit_count() odd = (n &amp;amp; ~mask).bit_count() return [even, odd]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2599/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2599/</guid><description>class Solution: def makePrefSumNonNegative(self, nums: List[int]) -&amp;gt; int: h = [] res = s = 0 for x in nums: s += x if x &amp;lt; 0: heappush(h, x) while s &amp;lt; 0: s -= heappop(h) res += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2600/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2600/</guid><description>class Solution: def kItemsWithMaximumSum( self, numOnes: int, numZeros: int, numNegOnes: int, k: int ) -&amp;gt; int: if numOnes &amp;gt;= k: return k if numZeros &amp;gt;= k - numOnes: return numOnes return numOnes - (k - numOnes - numZeros)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2603/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2603/</guid><description>class Solution: def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -&amp;gt; int: g = defaultdict(set) for a, b in edges: g[a].add(b) g[b].add(a) n = len(coins) q = deque(i for i in range(n) if len(g[i]) == 1 and coins[i] == 0) while q: i = q.popleft() for j in g[i]: g[j].remove(i) if coins[j] == 0 and len(g[j]) == 1: q.append(j) g[i].clear() for k in range(2): q = [i for i in range(n) if len(g[i]) == 1] for i in q: for j in g[i]: g[j].</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2604/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2604/</guid><description>class Solution: def minimumTime(self, hens: List[int], grains: List[int]) -&amp;gt; int: def check(t): j = 0 for x in hens: if j == m: return True y = grains[j] if y &amp;lt;= x: d = x - y if d &amp;gt; t: return False while j &amp;lt; m and grains[j] &amp;lt;= x: j += 1 while j &amp;lt; m and min(d, grains[j] - x) + grains[j] - y &amp;lt;= t: j += 1 else: while j &amp;lt; m and grains[j] - x &amp;lt;= t: j += 1 return j == m hens.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2606/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2606/</guid><description>class Solution: def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -&amp;gt; int: d = {c: v for c, v in zip(chars, vals)} res = f = 0 for c in s: v = d.get(c, ord(c) - ord(&amp;#39;a&amp;#39;) + 1) f = max(f, 0) + v res = max(res, f) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2607/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2607/</guid><description>class Solution: def makeSubKSumEqual(self, arr: List[int], k: int) -&amp;gt; int: n = len(arr) g = gcd(n, k) res = 0 for i in range(g): t = sorted(arr[i:n:g]) mid = t[len(t) &amp;gt;&amp;gt; 1] res += sum(abs(x - mid) for x in t) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2609/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2609/</guid><description>class Solution: def findTheLongestBalancedSubstring(self, s: str) -&amp;gt; int: res = zero = one = 0 for c in s: if c == &amp;#39;0&amp;#39;: if one: zero = one = 0 zero += 1 else: one += 1 res = max(res, 2 * min(one, zero)) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2612/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2612/</guid><description>from sortedcontainers import SortedSet class Solution: def minReverseOperations( self, n: int, p: int, banned: List[int], k: int ) -&amp;gt; List[int]: res = [-1] * n res[p] = 0 ts = [SortedSet() for _ in range(2)] for i in range(n): ts[i % 2].add(i) ts[p % 2].remove(p) for i in banned: ts[i % 2].remove(i) ts[0].add(n) ts[1].add(n) q = deque([p]) while q: i = q.popleft() mi = max(i - k + 1, k - i - 1) mx = min(i + k - 1, n * 2 - k - i - 1) s = ts[mi % 2] j = s.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2615/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2615/</guid><description>class Solution: def distance(self, nums: List[int]) -&amp;gt; List[int]: d = defaultdict(list) for i, x in enumerate(nums): d[x].append(i) res = [0] * len(nums) for idx in d.values(): left, right = 0, sum(idx) - len(idx) * idx[0] for i in range(len(idx)): res[idx[i]] = left + right if i + 1 &amp;lt; len(idx): left += (idx[i + 1] - idx[i]) * (i + 1) right -= (idx[i + 1] - idx[i]) * (len(idx) - i - 1) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2616/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2616/</guid><description>class Solution: def minimizeMax(self, nums: List[int], p: int) -&amp;gt; int: def check(diff: int) -&amp;gt; bool: cnt = i = 0 while i &amp;lt; len(nums) - 1: if nums[i + 1] - nums[i] &amp;lt;= diff: cnt += 1 i += 2 else: i += 1 return cnt &amp;gt;= p nums.sort() return bisect_left(range(nums[-1] - nums[0] + 1), True, key=check)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2638/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2638/</guid><description>class Solution: def countTheNumOfKFreeSubsets(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() g = defaultdict(list) for x in nums: g[x % k].append(x) res = 1 for arr in g.values(): m = len(arr) f = [0] * (m + 1) f[0] = 1 f[1] = 2 for i in range(2, m + 1): if arr[i - 1] - arr[i - 2] == k: f[i] = f[i - 1] + f[i - 2] else: f[i] = f[i - 1] * 2 res *= f[m] return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2640/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2640/</guid><description>class Solution: def findPrefixScore(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [0] * n mx = 0 for i, x in enumerate(nums): mx = max(mx, x) res[i] = x + mx + (0 if i == 0 else res[i - 1]) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2641/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2641/</guid><description># Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def replaceValueInTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: root.val = 0 q = [root] while q: t = [] s = 0 for node in q: if node.left: t.append(node.left) s += node.left.val if node.right: t.append(node.right) s += node.right.val for node in q: sub = (node.left.val if node.left else 0) + ( node.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2644/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2644/</guid><description>class Solution: def maxDivScore(self, nums: List[int], divisors: List[int]) -&amp;gt; int: res, mx = divisors[0], 0 for div in divisors: cnt = sum(x % div == 0 for x in nums) if mx &amp;lt; cnt: mx, res = cnt, div elif mx == cnt and res &amp;gt; div: res = div return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2646/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2646/</guid><description>class Solution: def minimumTotalPrice( self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]] ) -&amp;gt; int: def dfs(i: int, fa: int, k: int) -&amp;gt; bool: cnt[i] += 1 if i == k: return True ok = any(j != fa and dfs(j, i, k) for j in g[i]) if not ok: cnt[i] -= 1 return ok def dfs2(i: int, fa: int) -&amp;gt; (int, int): a = cnt[i] * price[i] b = a // 2 for j in g[i]: if j !</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2651/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2651/</guid><description>class Solution: def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -&amp;gt; int: return (arrivalTime + delayedTime) % 24</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2653/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2653/</guid><description>class Solution: def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -&amp;gt; List[int]: def f(x: int) -&amp;gt; int: s = 0 for i in range(50): s += cnt[i] if s &amp;gt;= x: return i - 50 return 0 cnt = [0] * 101 for v in nums[:k]: cnt[v + 50] += 1 res = [f(x)] for i in range(k, len(nums)): cnt[nums[i] + 50] += 1 cnt[nums[i - k] + 50] -= 1 res.append(f(x)) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2655/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2655/</guid><description>class Solution: def findMaximalUncoveredRanges( self, n: int, ranges: List[List[int]] ) -&amp;gt; List[List[int]]: ranges.sort() last = -1 res = [] for l, r in ranges: if last + 1 &amp;lt; l: res.append([last + 1, l - 1]) last = max(last, r) if last + 1 &amp;lt; n: res.append([last + 1, n - 1]) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2656/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2656/</guid><description>class Solution: def maximizeSum(self, nums: List[int], k: int) -&amp;gt; int: x = max(nums) return k * x + k * (k - 1) // 2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2661/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2661/</guid><description>class Solution: def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) idx = {} for i in range(m): for j in range(n): idx[mat[i][j]] = (i, j) row = [0] * m col = [0] * n for k in range(len(arr)): i, j = idx[arr[k]] row[i] += 1 col[j] += 1 if row[i] == n or col[j] == m: return k</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2662/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2662/</guid><description>class Solution: def minimumCost( self, start: List[int], target: List[int], specialRoads: List[List[int]] ) -&amp;gt; int: def dist(x1: int, y1: int, x2: int, y2: int) -&amp;gt; int: return abs(x1 - x2) + abs(y1 - y2) q = [(0, start[0], start[1])] vis = set() res = inf while q: d, x, y = heappop(q) if (x, y) in vis: continue vis.add((x, y)) res = min(res, d + dist(x, y, *target)) for x1, y1, x2, y2, cost in specialRoads: heappush(q, (d + dist(x, y, x1, y1) + cost, x2, y2)) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2664/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2664/</guid><description>class Solution: def tourOfKnight(self, m: int, n: int, r: int, c: int) -&amp;gt; List[List[int]]: def dfs(i: int, j: int): nonlocal ok if g[i][j] == m * n - 1: ok = True return for a, b in pairwise((-2, -1, 2, 1, -2, 1, 2, -1, -2)): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and g[x][y] == -1: g[x][y] = g[i][j] + 1 dfs(x, y) if ok: return g[x][y] = -1 g = [[-1] * n for _ in range(m)] g[r][c] = 0 ok = False dfs(r, c) return g</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2670/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2670/</guid><description>class Solution: def distinctDifferenceArray(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) suf = [0] * (n + 1) s = set() for i in range(n - 1, -1, -1): s.add(nums[i]) suf[i] = len(s) s.clear() res = [0] * n for i, x in enumerate(nums): s.add(x) res[i] = len(s) - suf[i + 1] return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2672/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2672/</guid><description>class Solution: def colorTheArray(self, n: int, queries: List[List[int]]) -&amp;gt; List[int]: nums = [0] * n res = [0] * len(queries) x = 0 for k, (i, c) in enumerate(queries): if i &amp;gt; 0 and nums[i] and nums[i - 1] == nums[i]: x -= 1 if i &amp;lt; n - 1 and nums[i] and nums[i + 1] == nums[i]: x -= 1 if i &amp;gt; 0 and nums[i - 1] == c: x += 1 if i &amp;lt; n - 1 and nums[i + 1] == c: x += 1 res[k] = x nums[i] = c return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2673/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2673/</guid><description>class Solution: def minIncrements(self, n: int, cost: List[int]) -&amp;gt; int: def dfs(i: int) -&amp;gt; int: if (i &amp;lt;&amp;lt; 1) &amp;gt; n: return cost[i - 1] l, r = dfs(i &amp;lt;&amp;lt; 1), dfs(i &amp;lt;&amp;lt; 1 | 1) nonlocal res res += max(l, r) - min(l, r) return cost[i - 1] + max(l, r) res = 0 dfs(1) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2674/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2674/</guid><description># Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def splitCircularLinkedList( self, list: Optional[ListNode] ) -&amp;gt; List[Optional[ListNode]]: a = b = list while b.next != list and b.next.next != list: a = a.next b = b.next.next if b.next != list: b = b.next list2 = a.next b.next = list2 a.next = list return [list, list2]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2680/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2680/</guid><description>class Solution: def maximumOr(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) suf = [0] * (n + 1) for i in range(n - 1, -1, -1): suf[i] = suf[i + 1] | nums[i] res = pre = 0 for i, x in enumerate(nums): res = max(res, pre | (x &amp;lt;&amp;lt; k) | suf[i + 1]) pre |= x return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2683/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2683/</guid><description>class Solution: def doesValidArrayExist(self, derived: List[int]) -&amp;gt; bool: return reduce(xor, derived) == 0</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2685/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2685/</guid><description>class Solution: def countCompleteComponents(self, n: int, edges: List[List[int]]) -&amp;gt; int: def dfs(i: int) -&amp;gt; (int, int): vis[i] = True x, y = 1, len(g[i]) for j in g[i]: if not vis[j]: a, b = dfs(j) x += a y += b return x, y g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) vis = [False] * n res = 0 for i in range(n): if not vis[i]: a, b = dfs(i) res += a * (a - 1) == b return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2696/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2696/</guid><description>class Solution: def minLength(self, s: str) -&amp;gt; int: stk = [&amp;#34;&amp;#34;] for c in s: if (c == &amp;#34;B&amp;#34; and stk[-1] == &amp;#34;A&amp;#34;) or (c == &amp;#34;D&amp;#34; and stk[-1] == &amp;#34;C&amp;#34;): stk.pop() else: stk.append(c) return len(stk) - 1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2699/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2699/</guid><description>class Solution: def modifiedGraphEdges( self, n: int, edges: List[List[int]], source: int, destination: int, target: int ) -&amp;gt; List[List[int]]: def dijkstra(edges: List[List[int]]) -&amp;gt; int: g = [[inf] * n for _ in range(n)] for a, b, w in edges: if w == -1: continue g[a][b] = g[b][a] = w dist = [inf] * n dist[source] = 0 vis = [False] * n for _ in range(n): k = -1 for j in range(n): if not vis[j] and (k == -1 or dist[k] &amp;gt; dist[j]): k = j vis[k] = True for j in range(n): dist[j] = min(dist[j], dist[k] + g[k][j]) return dist[destination] inf = 2 * 10**9 d = dijkstra(edges) if d &amp;lt; target: return [] ok = d == target for e in edges: if e[2] &amp;gt; 0: continue if ok: e[2] = inf continue e[2] = 1 d = dijkstra(edges) if d &amp;lt;= target: ok = True e[2] += target - d return edges if ok else []</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2702/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2702/</guid><description>class Solution: def minOperations(self, nums: List[int], x: int, y: int) -&amp;gt; int: def check(t: int) -&amp;gt; bool: cnt = 0 for v in nums: if v &amp;gt; t * y: cnt += ceil((v - t * y) / (x - y)) return cnt &amp;lt;= t l, r = 0, max(nums) while l &amp;lt; r: mid = (l + r) &amp;gt;&amp;gt; 1 if check(mid): r = mid else: l = mid + 1 return l</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2706/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2706/</guid><description>class Solution: def buyChoco(self, prices: List[int], money: int) -&amp;gt; int: a = b = inf for x in prices: if x &amp;lt; a: a, b = x, a elif x &amp;lt; b: b = x cost = a + b return money if money &amp;lt; cost else money - cost</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2709/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2709/</guid><description>class UnionFind: def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a, b): pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True mx = 100010 p = defaultdict(list) for x in range(1, mx + 1): v = x i = 2 while i &amp;lt;= v // i: if v % i == 0: p[x].</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2710/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2710/</guid><description>class Solution: def removeTrailingZeros(self, num: str) -&amp;gt; str: return num.rstrip(&amp;#34;0&amp;#34;)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2712/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2712/</guid><description>class Solution: def minimumCost(self, s: str) -&amp;gt; int: res, n = 0, len(s) for i in range(1, n): if s[i] != s[i - 1]: res += min(i, n - i) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2713/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2713/</guid><description>class Solution: def maxIncreasingCells(self, mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) g = defaultdict(list) for i in range(m): for j in range(n): g[mat[i][j]].append((i, j)) rowMax = [0] * m colMax = [0] * n res = 0 for _, pos in sorted(g.items()): mx = [] for i, j in pos: mx.append(1 + max(rowMax[i], colMax[j])) res = max(res, mx[-1]) for k, (i, j) in enumerate(pos): rowMax[i] = max(rowMax[i], mx[k]) colMax[j] = max(colMax[j], mx[k]) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2716/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2716/</guid><description>class Solution: def minimizedStringLength(self, s: str) -&amp;gt; int: return len(set(s))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2718/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2718/</guid><description>class Solution: def matrixSumQueries(self, n: int, queries: List[List[int]]) -&amp;gt; int: row = set() col = set() res = 0 for t, i, v in queries[::-1]: if t == 0: if i not in row: res += v * (n - len(col)) row.add(i) else: if i not in col: res += v * (n - len(row)) col.add(i) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2728/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2728/</guid><description># Definition for a street. # class Street: # def openDoor(self): # pass # def closeDoor(self): # pass # def isDoorOpen(self): # pass # def moveRight(self): # pass # def moveLeft(self): # pass class Solution: def houseCount(self, street: Optional[&amp;#34;Street&amp;#34;], k: int) -&amp;gt; int: for _ in range(k): street.openDoor() street.moveLeft() res = 0 while street.isDoorOpen(): street.closeDoor() street.moveLeft() res += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2730/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2730/</guid><description>class Solution: def longestSemiRepetitiveSubstring(self, s: str) -&amp;gt; int: n = len(s) res = cnt = j = 0 for i in range(n): if i and s[i] == s[i - 1]: cnt += 1 while cnt &amp;gt; 1: if s[j] == s[j + 1]: cnt -= 1 j += 1 res = max(res, i - j + 1) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2731/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2731/</guid><description>class Solution: def sumDistance(self, nums: List[int], s: str, d: int) -&amp;gt; int: mod = 10**9 + 7 for i, c in enumerate(s): nums[i] += d if c == &amp;#34;R&amp;#34; else -d nums.sort() res = s = 0 for i, x in enumerate(nums): res += i * x - s s += x return res % mod</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2735/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2735/</guid><description>class Solution: def minCost(self, nums: List[int], x: int) -&amp;gt; int: n = len(nums) f = [[0] * n for _ in range(n)] for i, v in enumerate(nums): f[i][0] = v for j in range(1, n): f[i][j] = min(f[i][j - 1], nums[(i - j) % n]) return min(sum(f[i][j] for i in range(n)) + x * j for j in range(n))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2736/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2736/</guid><description>class BinaryIndexedTree: __slots__ = [&amp;#34;n&amp;#34;, &amp;#34;c&amp;#34;] def __init__(self, n: int): self.n = n self.c = [-1] * (n + 1) def update(self, x: int, v: int): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], v) x += x &amp;amp; -x def query(self, x: int) -&amp;gt; int: mx = -1 while x: mx = max(mx, self.c[x]) x -= x &amp;amp; -x return mx class Solution: def maximumSumQueries( self, nums1: List[int], nums2: List[int], queries: List[List[int]] ) -&amp;gt; List[int]: nums = sorted(zip(nums1, nums2), key=lambda x: -x[0]) nums2.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2740/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2740/</guid><description>class Solution: def findValueOfPartition(self, nums: List[int]) -&amp;gt; int: nums.sort() return min(b - a for a, b in pairwise(nums))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2742/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2742/</guid><description>class Solution: def paintWalls(self, cost: List[int], time: List[int]) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if n - i &amp;lt;= j: return 0 if i &amp;gt;= n: return inf return min(dfs(i + 1, j + time[i]) + cost[i], dfs(i + 1, j - 1)) n = len(cost) return dfs(0, 0)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2743/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2743/</guid><description>class Solution: def numberOfSpecialSubstrings(self, s: str) -&amp;gt; int: cnt = Counter() res = j = 0 for i, c in enumerate(s): cnt[c] += 1 while cnt[c] &amp;gt; 1: cnt[s[j]] -= 1 j += 1 res += i - j + 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2745/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2745/</guid><description>class Solution: def longestString(self, x: int, y: int, z: int) -&amp;gt; int: if x &amp;lt; y: return (x * 2 + z + 1) * 2 if x &amp;gt; y: return (y * 2 + z + 1) * 2 return (x + y + z) * 2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2749/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2749/</guid><description>class Solution: def makeTheIntegerZero(self, num1: int, num2: int) -&amp;gt; int: for k in count(1): x = num1 - k * num2 if x &amp;lt; 0: break if x.bit_count() &amp;lt;= k &amp;lt;= x: return k return -1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2750/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2750/</guid><description>class Solution: def numberOfGoodSubarraySplits(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 res, j = 1, -1 for i, x in enumerate(nums): if x == 0: continue if j &amp;gt; -1: res = res * (i - j) % mod j = i return 0 if j == -1 else res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2753/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2753/</guid><description># Definition for a street. # class Street: # def closeDoor(self): # pass # def isDoorOpen(self): # pass # def moveRight(self): # pass class Solution: def houseCount(self, street: Optional[&amp;#34;Street&amp;#34;], k: int) -&amp;gt; int: while not street.isDoorOpen(): street.moveRight() for i in range(1, k + 1): street.moveRight() if street.isDoorOpen(): res = i street.closeDoor() return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2760/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2760/</guid><description>class Solution: def longestAlternatingSubarray(self, nums: List[int], threshold: int) -&amp;gt; int: res, l, n = 0, 0, len(nums) while l &amp;lt; n: if nums[l] % 2 == 0 and nums[l] &amp;lt;= threshold: r = l + 1 while r &amp;lt; n and nums[r] % 2 != nums[r - 1] % 2 and nums[r] &amp;lt;= threshold: r += 1 res = max(res, r - l) l = r else: l += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2762/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2762/</guid><description>from sortedcontainers import SortedList class Solution: def continuousSubarrays(self, nums: List[int]) -&amp;gt; int: res = i = 0 sl = SortedList() for x in nums: sl.add(x) while sl[-1] - sl[0] &amp;gt; 2: sl.remove(nums[i]) i += 1 res += len(sl) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2764/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2764/</guid><description>class Solution: def isPreorder(self, nodes: List[List[int]]) -&amp;gt; bool: def dfs(i: int) -&amp;gt; int: nonlocal k if i != nodes[k][0]: return False k += 1 return all(dfs(j) for j in g[i]) g = defaultdict(list) for i, p in nodes: g[p].append(i) k = 0 return dfs(nodes[0][0]) and k == len(nodes)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2766/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2766/</guid><description>class Solution: def relocateMarbles( self, nums: List[int], moveFrom: List[int], moveTo: List[int] ) -&amp;gt; List[int]: pos = set(nums) for f, t in zip(moveFrom, moveTo): pos.remove(f) pos.add(t) return sorted(pos)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2770/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2770/</guid><description>class Solution: def maximumJumps(self, nums: List[int], target: int) -&amp;gt; int: @cache def dfs(i: int) -&amp;gt; int: if i == n - 1: return 0 res = -inf for j in range(i + 1, n): if abs(nums[i] - nums[j]) &amp;lt;= target: res = max(res, 1 + dfs(j)) return res n = len(nums) res = dfs(0) return -1 if res &amp;lt; 0 else res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2771/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2771/</guid><description>class Solution: def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) f = g = 1 res = 1 for i in range(1, n): ff = gg = 1 if nums1[i] &amp;gt;= nums1[i - 1]: ff = max(ff, f + 1) if nums1[i] &amp;gt;= nums2[i - 1]: ff = max(ff, g + 1) if nums2[i] &amp;gt;= nums1[i - 1]: gg = max(gg, f + 1) if nums2[i] &amp;gt;= nums2[i - 1]: gg = max(gg, g + 1) f, g = ff, gg res = max(res, f, g) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2835/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2835/</guid><description>class Solution: def minOperations(self, nums: List[int], target: int) -&amp;gt; int: s = sum(nums) if s &amp;lt; target: return -1 cnt = [0] * 32 for x in nums: for i in range(32): if x &amp;gt;&amp;gt; i &amp;amp; 1: cnt[i] += 1 i = j = 0 res = 0 while 1: while i &amp;lt; 32 and (target &amp;gt;&amp;gt; i &amp;amp; 1) == 0: i += 1 if i == 32: break while j &amp;lt; i: cnt[j + 1] += cnt[j] // 2 cnt[j] %= 2 j += 1 while cnt[j] == 0: cnt[j] = 1 j += 1 res += j - i cnt[j] -= 1 j = i i += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2838/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2838/</guid><description>class Solution: def maximumCoins( self, heroes: List[int], monsters: List[int], coins: List[int] ) -&amp;gt; List[int]: m = len(monsters) idx = sorted(range(m), key=lambda i: monsters[i]) s = list(accumulate((coins[i] for i in idx), initial=0)) res = [] for h in heroes: i = bisect_right(idx, h, key=lambda i: monsters[i]) res.append(s[i]) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</guid><description>class Solution: def checkStrings(self, s1: str, s2: str) -&amp;gt; bool: return sorted(s1[::2]) == sorted(s2[::2]) and sorted(s1[1::2]) == sorted( s2[1::2] )</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2842/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2842/</guid><description>class Solution: def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -&amp;gt; int: f = Counter(s) if len(f) &amp;lt; k: return 0 mod = 10**9 + 7 vs = sorted(f.values(), reverse=True) val = vs[k - 1] x = vs.count(val) res = 1 for v in vs: if v == val: break k -= 1 res = res * v % mod res = res * comb(x, k) * pow(val, k, mod) % mod return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2845/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2845/</guid><description>class Solution: def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -&amp;gt; int: arr = [int(x % modulo == k) for x in nums] cnt = Counter() cnt[0] = 1 res = s = 0 for x in arr: s += x res += cnt[(s - k) % modulo] cnt[s % modulo] += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2848/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2848/</guid><description>class Solution: def numberOfPoints(self, nums: List[List[int]]) -&amp;gt; int: d = [0] * 110 for a, b in nums: d[a] += 1 d[b + 1] -= 1 return sum(s &amp;gt; 0 for s in accumulate(d))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2850/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2850/</guid><description>class Solution: def minimumMoves(self, grid: List[List[int]]) -&amp;gt; int: def cal(a: tuple, b: tuple) -&amp;gt; int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) left, right = [], [] for i in range(3): for j in range(3): if grid[i][j] == 0: left.append((i, j)) else: for _ in range(grid[i][j] - 1): right.append((i, j)) n = len(left) f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): k = i.bit_count() for j in range(n): if i &amp;gt;&amp;gt; j &amp;amp; 1: f[i] = min(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + cal(left[k - 1], right[j])) return f[-1]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2855/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2855/</guid><description>class Solution: def minimumRightShifts(self, nums: List[int]) -&amp;gt; int: n = len(nums) i = 1 while i &amp;lt; n and nums[i - 1] &amp;lt; nums[i]: i += 1 k = i + 1 while k &amp;lt; n and nums[k - 1] &amp;lt; nums[k] &amp;lt; nums[0]: k += 1 return -1 if k &amp;lt; n else n - i</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2856/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2856/</guid><description>class Solution: def minLengthAfterRemovals(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) pq = [-x for x in cnt.values()] heapify(pq) res = len(nums) while len(pq) &amp;gt; 1: x, y = -heappop(pq), -heappop(pq) x -= 1 y -= 1 if x &amp;gt; 0: heappush(pq, -x) if y &amp;gt; 0: heappush(pq, -y) res -= 2 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2858/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2858/</guid><description>class Solution: def minEdgeReversals(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: res = [0] * n g = [[] for _ in range(n)] for x, y in edges: g[x].append((y, 1)) g[y].append((x, -1)) def dfs(i: int, fa: int): for j, k in g[i]: if j != fa: res[0] += int(k &amp;lt; 0) dfs(j, i) dfs(0, -1) def dfs2(i: int, fa: int): for j, k in g[i]: if j != fa: res[j] = res[i] + k dfs2(j, i) dfs2(0, -1) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2867/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2867/</guid><description>class Solution: def countPaths(self, n: int, edges: List[List[int]]) -&amp;gt; int: def mul(x, y): return x * y def dfs(x, f, con, prime, r): v = [1 - prime[x], prime[x]] for y in con[x]: if y == f: continue p = dfs(y, x, con, prime, r) r[0] += mul(p[0], v[1]) + mul(p[1], v[0]) if prime[x]: v[1] += p[0] else: v[0] += p[0] v[1] += p[1] return v prime = [True] * (n + 1) prime[1] = False all_primes = [] for i in range(2, n + 1): if prime[i]: all_primes.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2868/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2868/</guid><description>class Solution: def canAliceWin(self, a: List[str], b: List[str]) -&amp;gt; bool: i, j, k = 1, 0, 1 w = a[0] while 1: if k: if j == len(b): return True if (b[j][0] == w[0] and b[j] &amp;gt; w) or ord(b[j][0]) - ord(w[0]) == 1: w = b[j] k ^= 1 j += 1 else: if i == len(a): return False if (a[i][0] == w[0] and a[i] &amp;gt; w) or ord(a[i][0]) - ord(w[0]) == 1: w = a[i] k ^= 1 i += 1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2869/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2869/</guid><description>class Solution: def minOperations(self, nums: List[int], k: int) -&amp;gt; int: is_added = [False] * k count = 0 n = len(nums) for i in range(n - 1, -1, -1): if nums[i] &amp;gt; k or is_added[nums[i] - 1]: continue is_added[nums[i] - 1] = True count += 1 if count == k: return n - i</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2871/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2871/</guid><description>class Solution: def maxSubarrays(self, nums: List[int]) -&amp;gt; int: score, res = -1, 1 for num in nums: score &amp;amp;= num if score == 0: score = -1 res += 1 return 1 if res == 1 else res - 1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2872/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2872/</guid><description>class Solution: def maxKDivisibleComponents( self, n: int, edges: List[List[int]], values: List[int], k: int ) -&amp;gt; int: def dfs(i: int, fa: int) -&amp;gt; int: s = values[i] for j in g[i]: if j != fa: s += dfs(j, i) nonlocal res res += s % k == 0 return s g = [[] for _ in range(n)] for a, b in edges: g[a].append(b) g[b].append(a) res = 0 dfs(0, -1) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2873/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2873/</guid><description>class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2877/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2877/</guid><description>import pandas as pd def createDataframe(student_data: List[List[int]]) -&amp;gt; pd.DataFrame: return pd.DataFrame(student_data, columns=[&amp;#39;student_id&amp;#39;, &amp;#39;age&amp;#39;])</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2878/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2878/</guid><description>import pandas as pd def getDataframeSize(players: pd.DataFrame) -&amp;gt; List[int]: return list(players.shape)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2880/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2880/</guid><description>import pandas as pd def selectData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;student_id&amp;#39;] == 101][[&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;]]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2882/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2882/</guid><description>import pandas as pd def dropDuplicateEmails(customers: pd.DataFrame) -&amp;gt; pd.DataFrame: return customers.drop_duplicates(subset=[&amp;#39;email&amp;#39;])</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2883/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2883/</guid><description>import pandas as pd def dropMissingData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;name&amp;#39;].notnull()]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2885/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2885/</guid><description>import pandas as pd def renameColumns(students: pd.DataFrame) -&amp;gt; pd.DataFrame: students.rename( columns={ &amp;#39;id&amp;#39;: &amp;#39;student_id&amp;#39;, &amp;#39;first&amp;#39;: &amp;#39;first_name&amp;#39;, &amp;#39;last&amp;#39;: &amp;#39;last_name&amp;#39;, &amp;#39;age&amp;#39;: &amp;#39;age_in_years&amp;#39;, }, inplace=True, ) return students</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2887/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2887/</guid><description>import pandas as pd def fillMissingValues(products: pd.DataFrame) -&amp;gt; pd.DataFrame: products[&amp;#39;quantity&amp;#39;] = products[&amp;#39;quantity&amp;#39;].fillna(0) return products</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2888/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2888/</guid><description>import pandas as pd def concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.concat([df1, df2], ignore_index=True)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2889/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2889/</guid><description>import pandas as pd def pivotTable(weather: pd.DataFrame) -&amp;gt; pd.DataFrame: return weather.pivot(index=&amp;#39;month&amp;#39;, columns=&amp;#39;city&amp;#39;, values=&amp;#39;temperature&amp;#39;)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2890/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2890/</guid><description>import pandas as pd def meltTable(report: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.melt(report, id_vars=[&amp;#39;product&amp;#39;], var_name=&amp;#39;quarter&amp;#39;, value_name=&amp;#39;sales&amp;#39;)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2891/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2891/</guid><description>import pandas as pd def findHeavyAnimals(animals: pd.DataFrame) -&amp;gt; pd.DataFrame: return animals[animals[&amp;#39;weight&amp;#39;] &amp;gt; 100].sort_values(&amp;#39;weight&amp;#39;, ascending=False)[ [&amp;#39;name&amp;#39;] ]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2898/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2898/</guid><description>class Solution: def maxScore(self, prices: List[int]) -&amp;gt; int: cnt = Counter() for i, x in enumerate(prices): cnt[x - i] += x return max(cnt.values())</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2903/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2903/</guid><description>class Solution: def findIndices( self, nums: List[int], indexDifference: int, valueDifference: int ) -&amp;gt; List[int]: mi = mx = 0 for i in range(indexDifference, len(nums)): j = i - indexDifference if nums[j] &amp;lt; nums[mi]: mi = j if nums[j] &amp;gt; nums[mx]: mx = j if nums[i] - nums[mi] &amp;gt;= valueDifference: return [mi, i] if nums[mx] - nums[i] &amp;gt;= valueDifference: return [mx, i] return [-1, -1]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2904/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2904/</guid><description>class Solution: def shortestBeautifulSubstring(self, s: str, k: int) -&amp;gt; str: i = j = cnt = 0 n = len(s) res = &amp;#34;&amp;#34; while j &amp;lt; n: cnt += s[j] == &amp;#34;1&amp;#34; while cnt &amp;gt; k or (i &amp;lt; j and s[i] == &amp;#34;0&amp;#34;): cnt -= s[i] == &amp;#34;1&amp;#34; i += 1 j += 1 if cnt == k and ( not res or j - i &amp;lt; len(res) or (j - i == len(res) and s[i:j] &amp;lt; res) ): res = s[i:j] return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2908/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2908/</guid><description>class Solution: def minimumSum(self, nums: List[int]) -&amp;gt; int: n = len(nums) right = [inf] * (n + 1) for i in range(n - 1, -1, -1): right[i] = min(right[i + 1], nums[i]) res = left = inf for i, x in enumerate(nums): if left &amp;lt; x and right[i + 1] &amp;lt; x: res = min(res, left + x + right[i + 1]) left = min(left, x) return -1 if res == inf else res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2912/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2912/</guid><description>class Solution: def numberOfWays( self, n: int, m: int, k: int, source: List[int], dest: List[int] ) -&amp;gt; int: mod = 10**9 + 7 f = [1, 0, 0, 0] for _ in range(k): g = [0] * 4 g[0] = ((n - 1) * f[1] + (m - 1) * f[2]) % mod g[1] = (f[0] + (n - 2) * f[1] + (m - 1) * f[3]) % mod g[2] = (f[0] + (m - 2) * f[2] + (n - 1) * f[3]) % mod g[3] = (f[1] + f[2] + (n - 2) * f[3] + (m - 2) * f[3]) % mod f = g if source[0] == dest[0]: return f[0] if source[1] == dest[1] else f[2] return f[1] if source[1] == dest[1] else f[3]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2914/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2914/</guid><description>class Solution: def minChanges(self, s: str) -&amp;gt; int: return sum(s[i] != s[i - 1] for i in range(1, len(s), 2))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2915/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2915/</guid><description>class Solution: def lengthOfLongestSubsequence(self, nums: List[int], target: int) -&amp;gt; int: f = [0] + [-inf] * target for x in nums: for j in range(target, x - 1, -1): f[j] = max(f[j], f[j - x] + 1) return -1 if f[-1] &amp;lt;= 0 else f[-1]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2918/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2918/</guid><description>class Solution: def minSum(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: s1 = sum(nums1) + nums1.count(0) s2 = sum(nums2) + nums2.count(0) if s1 &amp;gt; s2: return self.minSum(nums2, nums1) if s1 == s2: return s1 return -1 if nums1.count(0) == 0 else s2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2920/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2920/</guid><description>class Solution: def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -&amp;gt; int: @cache def dfs(i: int, fa: int, j: int) -&amp;gt; int: a = (coins[i] &amp;gt;&amp;gt; j) - k b = coins[i] &amp;gt;&amp;gt; (j + 1) for c in g[i]: if c != fa: a += dfs(c, i, j) if j &amp;lt; 14: b += dfs(c, i, j + 1) return max(a, b) n = len(coins) g = [[] for _ in range(n)] for a, b in edges: g[a].</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2933/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2933/</guid><description>class Solution: def findHighAccessEmployees(self, access_times: List[List[str]]) -&amp;gt; List[str]: d = defaultdict(list) for name, t in access_times: d[name].append(int(t[:2]) * 60 + int(t[2:])) res = [] for name, ts in d.items(): ts.sort() if any(ts[i] - ts[i - 2] &amp;lt; 60 for i in range(2, len(ts))): res.append(name) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2934/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2934/</guid><description>class Solution: def minOperations(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: def f(x: int, y: int) -&amp;gt; int: cnt = 0 for a, b in zip(nums1[:-1], nums2[:-1]): if a &amp;lt;= x and b &amp;lt;= y: continue if not (a &amp;lt;= y and b &amp;lt;= x): return -1 cnt += 1 return cnt a, b = f(nums1[-1], nums2[-1]), f(nums2[-1], nums1[-1]) return -1 if a + b == -2 else min(a, b + 1)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2944/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2944/</guid><description>class Solution: def minimumCoins(self, prices: List[int]) -&amp;gt; int: n = len(prices) q = deque() for i in range(n, 0, -1): while q and q[0] &amp;gt; i * 2 + 1: q.popleft() if i &amp;lt;= (n - 1) // 2: prices[i - 1] += prices[q[0] - 1] while q and prices[q[-1] - 1] &amp;gt;= prices[i - 1]: q.pop() q.append(i) return prices[0]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2953/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2953/</guid><description>class Solution: def countCompleteSubstrings(self, word: str, k: int) -&amp;gt; int: def f(s: str) -&amp;gt; int: m = len(s) res = 0 for i in range(1, 27): l = i * k if l &amp;gt; m: break cnt = Counter(s[:l]) freq = Counter(cnt.values()) res += freq[k] == i for j in range(l, m): freq[cnt[s[j]]] -= 1 cnt[s[j]] += 1 freq[cnt[s[j]]] += 1 freq[cnt[s[j - l]]] -= 1 cnt[s[j - l]] -= 1 freq[cnt[s[j - l]]] += 1 res += freq[k] == i return res n = len(word) res = i = 0 while i &amp;lt; n: j = i + 1 while j &amp;lt; n and abs(ord(word[j]) - ord(word[j - 1])) &amp;lt;= 2: j += 1 res += f(word[i:j]) i = j return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2954/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2954/</guid><description>mod = 10**9 + 7 mx = 10**5 fac = [1] * (mx + 1) for i in range(2, mx + 1): fac[i] = fac[i - 1] * i % mod class Solution: def numberOfSequence(self, n: int, sick: List[int]) -&amp;gt; int: nums = [b - a - 1 for a, b in pairwise([-1] + sick + [n])] res = 1 s = sum(nums) res = fac[s] for x in nums: if x: res = res * pow(fac[x], mod - 2, mod) % mod for x in nums[1:-1]: if x &amp;gt; 1: res = res * pow(2, x - 1, mod) % mod return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2979/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2979/</guid><description>class Solution: def mostExpensiveItem(self, primeOne: int, primeTwo: int) -&amp;gt; int: return primeOne * primeTwo - primeOne - primeTwo</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3000/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3000/</guid><description>class Solution: def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -&amp;gt; int: res = mx = 0 for l, w in dimensions: t = l**2 + w**2 if mx &amp;lt; t: mx = t res = l * w elif mx == t: res = max(res, l * w) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3002/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3002/</guid><description>class Solution: def maximumSetSize(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: s1 = set(nums1) s2 = set(nums2) n = len(nums1) a = min(len(s1 - s2), n // 2) b = min(len(s2 - s1), n // 2) return min(a + b + len(s1 &amp;amp; s2), n)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3018/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3018/</guid><description>class Solution: def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -&amp;gt; int: n = len(nums) f = [[0] * n for _ in range(n)] m = len(queries) for i in range(n): for j in range(n - 1, i - 1, -1): if i: f[i][j] = max( f[i][j], f[i - 1][j] + (nums[i - 1] &amp;gt;= queries[f[i - 1][j]]) ) if j + 1 &amp;lt; n: f[i][j] = max( f[i][j], f[i][j + 1] + (nums[j + 1] &amp;gt;= queries[f[i][j + 1]]) ) if f[i][j] == m: return m return max(f[i][i] + (nums[i] &amp;gt;= queries[f[i][i]]) for i in range(n))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3026/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3026/</guid><description>class Solution: def maximumSubarraySum(self, nums: List[int], k: int) -&amp;gt; int: res = -inf p = {nums[0]: 0} s, n = 0, len(nums) for i, x in enumerate(nums): s += x if x - k in p: res = max(res, s - p[x - k]) if x + k in p: res = max(res, s - p[x + k]) if i + 1 &amp;lt; n and (nums[i + 1] not in p or p[nums[i + 1]] &amp;gt; s): p[nums[i + 1]] = s return 0 if res == -inf else res</description></item><item><title>AWS Amplify - project setup with Github</title><link>https://romankurnovskii.com/en/posts/cloud-exam-quizz/amplify-setup-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/cloud-exam-quizz/amplify-setup-project/</guid><description>Preface For Amplify project I use eu-west region github repo has to be ready private or public New project goto https://eu-west-1.console.aws.amazon.com/amplify/home?region=eu-west-1#/
New app ‚Üí Host web app ‚Üí Github
Add access to github repo Select repository Come back to Amplify and try again to choose repo Click Next
Update amplify.yml for node.js project
version: 1 frontend: phases: preBuild: commands: - yarn install build: commands: - yarn run build artifacts: baseDirectory: build files: - &amp;#39;**/*&amp;#39; cache: paths: - node_modules/**/* Next ‚Üí Save and deploy Amplify starts to build project and generates project url.</description></item><item><title>AWS Amplify - Set custom domain</title><link>https://romankurnovskii.com/en/posts/cloud-exam-quizz/amplify-custom-domain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/cloud-exam-quizz/amplify-custom-domain/</guid><description>You can use any custom domain with Amplify and no need register it with AWS Route53.
I am adding domain at the setup app stage. Another way is from console.
Click Domain management. or
Add domain Write domain name -&amp;gt; Configure domain -&amp;gt; Save Nest starts SSL configuration process. Amplify provides with DNS data that you need to write in the domain register account. Once SSL creation starts you can get domain data
Action -&amp;gt; View DNS records</description></item><item><title>Docs</title><link>https://romankurnovskii.com/en/tracks/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/archive/</guid><description>This page contains an archive of all posts.</description></item><item><title>Posts Archive</title><link>https://romankurnovskii.com/en/posts/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/archive/</guid><description>This page contains an archive of all posts.</description></item><item><title>Set Up Proxy on Amazon EC2 Ubuntu</title><link>https://romankurnovskii.com/en/posts/setup-proxy-server-ec2-ubuntu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/posts/setup-proxy-server-ec2-ubuntu/</guid><description>1. Setting up the EC2 Instance Launch an EC2 Instance Choose an Ubuntu Server image. Select an appropriate instance type. Configure instance details, storage, and security group. Ensure your security group allows inbound traffic on the ports you plan to use for your proxy (typically port 3128 for Squid). Review and launch the instance. Create and download a key pair for SSH access. (optional, can connect through AWS console later) 2. Connect to Your Instance Use SSH client with the instance&amp;rsquo;s public DNS/IP and the key pair:</description></item></channel></rss>