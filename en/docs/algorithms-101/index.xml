<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms 101 on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/docs/algorithms-101/</link><description>Recent content in Algorithms 101 on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2022 &lt;a href="https://romankurnovskii.com">Roman Kurnovskii&lt;/a> personal page</copyright><lastBuildDate>Sat, 15 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/docs/algorithms-101/index.xml" rel="self" type="application/rss+xml"/><item><title>Plan</title><link>https://romankurnovskii.com/en/docs/algorithms-101/plan/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/plan/</guid><description>Q1 # Problem Difficulty Topics 1 1. Two Sum Easy Array, Hash Table 2 13. Roman to Integer Easy Hash Table, Math, String 3 14. Longest Common Prefix Easy String 4 20. Valid Parentheses Easy String, Stack 5 21. Merge Two Sorted Lists Easy Linked List, Recursion 6 26. Remove Duplicates from Sorted Array Easy Array, Two pointers 7 66. Plus One Easy Array, Math 8 69. Sqrt(x) Easy Math, Binary Search, 9 70. Climbing Stairs Easy Math, Dynamic Programming, Memoization 10 88.</description></item><item><title>Tools</title><link>https://romankurnovskii.com/en/docs/algorithms-101/leetcode-tools/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/leetcode-tools/</guid><description/></item><item><title>Algorithm Patterns</title><link>https://romankurnovskii.com/en/docs/algorithms-101/algorithms/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/algorithms/</guid><description>Intro Big-O Cheat Sheet Binary Search Binary search template def find_target(nums, target): left = 0 right = len(nums) - 1 while left &amp;lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[mid] &amp;lt; target: left = mid + 1 else: right = mid - 1 return -1 Dynamic programming (DP) Breadth First Search (BFS) BFS on Tree:
def bfs(root): queue = deque([root]) while len(queue) &amp;gt; 0: node = queue.</description></item><item><title>Help functions</title><link>https://romankurnovskii.com/en/docs/algorithms-101/helpers/</link><pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/helpers/</guid><description>Create Linked List Definition for singly-linked list:
class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next values = [2, 4, 3] def createLinkedNode(values): head = ListNode(values[0]) # start node, head of the linkedlist current = head # current node in the linked list where we change/add next node for i in values[1:]: node = ListNode(i) current.next = node current = current.next # now current node is last created return head linled_list = createLinkedNode(values) Object structure:</description></item></channel></rss>