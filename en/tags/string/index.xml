<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/string/</link><description>Recent content in String on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 &lt;a href="https://romankurnovskii.com">Roman Kurnovskii&lt;/a> personal page</copyright><lastBuildDate>Wed, 21 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/string/index.xml" rel="self" type="application/rss+xml"/><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/13-roman-to-integer/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/13-roman-to-integer/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>14. Longest Common Prefix</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/14-longest-common-prefix/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/14-longest-common-prefix/</guid><description>LeetCode problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. First accepted Idea:
1class Solution: 2 def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: 3 strs.sort() 4 l = strs[0] 5 r = strs[-1] 6 if l == r: 7 return l 8 res = &amp;#34;&amp;#34; 9 for i in range(0, len(l)): 10 if l[i] == r[i]: 11 res += l[i] 12 else: 13 return res 14 return res</description></item><item><title>20. Valid Parentheses</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/20-valid-parentheses/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/20-valid-parentheses/</guid><description>LeetCode problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true First accepted Idea:</description></item><item><title>3. Longest Substring Without Repeating Characters</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/3-longest-substring-without-repeating-characters/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/3-longest-substring-without-repeating-characters/</guid><description>LeetCode problem
Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. First accepted Idea:
Loop through string Calculate max count of elements in substring If get double element, then go back until get this element and do step 2. Proceed the main loop 1class Solution: 2 def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: 3 uniqs = set() 4 len_max = 0 5 len_current = 0 6 idx = 0 7 for i in s: 8 if i in uniqs: 9 len_max = max(len_max, len_current) 10 len_current = 1 11 uniqs = set(i) 12 for j in reversed(s[:idx]): 13 if j == i: 14 break 15 else: 16 len_current += 1 17 uniqs.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/5-longest-palindromic-substring/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/5-longest-palindromic-substring/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/17-letter-combinations-of-a-phone-number/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/17-letter-combinations-of-a-phone-number/</guid><description>LeetCode problem
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] Example 2:
Input: digits = &amp;quot;&amp;quot; Output: [] First accepted 1class Solution: 2 def letterCombinations(self, digits: str) -&amp;gt; List[str]: 3 if not digits: 4 return [] 5 6 letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, 7 &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, 8 &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] 9 10 result = [&amp;#39;&amp;#39;] 11 12 for d in digits: 13 d = int(d) 14 tmp = [] 15 for letter in letters[d]: 16 for word in result: 17 word += letter 18 tmp.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/22-generate-parentheses/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/22-generate-parentheses/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
1class Solution: 2 def generateParenthesis(self, n): 3 ans = [] 4 5 def dfs(l: int, r: int, s: str) -&amp;gt; None: 6 if l == 0 and r == 0: 7 ans.append(s) 8 if l &amp;gt; 0: 9 dfs(l - 1, r, s + &amp;#39;(&amp;#39;) 10 if l &amp;lt; r: 11 dfs(l, r - 1, s + &amp;#39;)&amp;#39;) 12 13 dfs(n, n, &amp;#39;&amp;#39;) 14 return ans</description></item><item><title>28. Find the Index of the First Occurrence in a String</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/28-find-the-index-of-the-first-occurrence-in-a-string.en./</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/28-find-the-index-of-the-first-occurrence-in-a-string.en./</guid><description>LeetCode problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
Example 2:
Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/38-count-and-say/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/38-count-and-say/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/49-group-anagrams/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/49-group-anagrams/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
1class Solution: 2 def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: 3 dd = {} 4 for s in strs: 5 s_sort = &amp;#34;&amp;#34;.</description></item></channel></rss>