<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bit Manipulation on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/bit-manipulation/</link><description>Recent content in Bit Manipulation on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2022 &lt;a href="https://romankurnovskii.com">Roman Kurnovskii&lt;/a> personal page</copyright><lastBuildDate>Fri, 25 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/bit-manipulation/index.xml" rel="self" type="application/rss+xml"/><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/29-divide-two-integers/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/29-divide-two-integers/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/33-search-in-rotated-sorted-array/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/33-search-in-rotated-sorted-array/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/34-find-first-and-last-position-of-element-in-sorted-array.en-copy/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/34-find-first-and-last-position-of-element-in-sorted-array.en-copy/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]</description></item></channel></rss>