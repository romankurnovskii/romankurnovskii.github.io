<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Medium on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/medium/</link><description>Recent content in Medium on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Tue, 12 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list">LeetCode problem 19&lt;/a>&lt;/p>
&lt;p>Given the &amp;lsquo;head&amp;rsquo; of a linked list, remove the &amp;rsquo;nth&amp;rsquo; node from the end of the list and return its head.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"
id="zoom-default"
alt="LeetCode 19. Remove Nth Node From End of List"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;pre>&lt;code>Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre>&lt;code>Input: head = [1], n = 1
Output: []
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Idea:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Two pointers.&lt;/li>
&lt;li>Second pointer starts from &lt;code>nth&lt;/code> position.&lt;/li>
&lt;li>Run while second pointer exist.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Definition for singly-linked list.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class ListNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, next=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.next = next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">removeNthFromEnd&lt;/span>(self, head, n: &lt;span style="color:#007020">int&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> p2&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic"># fast&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> p2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic"># in case: head=[1], n=1 -&amp;gt; return []&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> p2&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> p1&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> p2&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> p1&lt;span style="color:#666">.&lt;/span>next&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Definition for singly-linked list.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class ListNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, next=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.next = next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">removeNthFromEnd&lt;/span>(self, head: Optional[ListNode], n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> Optional[ListNode]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> head&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes &lt;span style="color:#666">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> cur:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[i] &lt;span style="color:#666">=&lt;/span> cur
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#666">=&lt;/span> cur&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> i &lt;span style="color:#666">-&lt;/span> n &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#666">=&lt;/span> nodes[i &lt;span style="color:#666">-&lt;/span> n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> cur&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> cur&lt;span style="color:#666">.&lt;/span>next&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>92. Reverse Linked List II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/92/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/92/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reverse-linked-list-ii/">LeetCode задача 92&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан односвязный список и два целых числа &lt;code>left&lt;/code> и &lt;code>right&lt;/code>, где &lt;code>left &amp;lt;= right&lt;/code>. Задача заключается в том, чтобы перевернуть узлы списка с позиции &lt;code>left&lt;/code> до &lt;code>right&lt;/code>&lt;/p>
&lt;p>Т.е. если список 1-2-3-4-5-6-7-8-9, left=2, right=7, то итоговый список будет 1-&lt;strong>7-6-5-4-3-2&lt;/strong>-8-9.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения задачи удобно использовать два указателя: один для сохранения начальной позиции участка, который нужно перевернуть, и второй для выполнения самого разворота.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Основная идея решения заключается в использовании двух указателей: одного для начала подсписка, который нужно перевернуть, и второго для его конца. После этого, можно перевернуть этот подсписок &amp;ldquo;на лету&amp;rdquo;, обновляя ссылки между узлами.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;p>Основная логика разворота заключается в следующих действиях:&lt;/p>
&lt;ol>
&lt;li>Определяем узел &lt;code>next&lt;/code> как следующий узел от current.&lt;/li>
&lt;li>Обновляем указатель &lt;code>current.next&lt;/code>, чтобы он указывал на узел после узла &lt;code>next&lt;/code>.&lt;/li>
&lt;li>Обновляем указатель &lt;code>next.next&lt;/code>, чтобы он указывал на узел, на который указывает &lt;code>prev.next&lt;/code>.&lt;/li>
&lt;li>Обновляем указатель &lt;code>prev.next&lt;/code>, чтобы он указывал на узел &lt;code>next&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>&lt;p class="md__image">
&lt;img
src="https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/assets/92.jpg"
id="zoom-default"
alt="LeetCode problem 166"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Definition for singly-linked list.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class ListNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, next=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.next = next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reverseBetween&lt;/span>(self, head, left, right):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Создаем новый узел&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">reversed&lt;/span> &lt;span style="color:#666">=&lt;/span> ListNode(&lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">reversed&lt;/span>&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">reversed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Пройдем до узла, предшествующего левой границе&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(left &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> prev&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current &lt;span style="color:#666">=&lt;/span> prev&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(right&lt;span style="color:#666">-&lt;/span>left):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, current = 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># rule: &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 1. next should look to current (prev.next)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># for this need to switch links in proper order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 2. current.next should look to next.next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 3. prev.next should look to next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 4. next.next (3) should look to current (prev.next)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># prev.next instead of current because of avoid cycle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># define next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">next&lt;/span> &lt;span style="color:#666">=&lt;/span> current&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic">#1 (3-&amp;gt;4), need 2&amp;lt;-3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># switch links&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span>&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic">#2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">next&lt;/span>&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> prev&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic">#4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">#3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">reversed&lt;/span>&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-product-subarray">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>In this problem, we&amp;rsquo;re given an integer array &lt;code>nums&lt;/code>, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one. However, this would have a time complexity of O(n²), as there are n*(n+1)/2 subarrays of an array, where n is the length of the array.&lt;/p>
&lt;p>This would be inefficient and time-consuming for large inputs.&lt;/p>
&lt;h2 id="dynamic-programming">Dynamic Programming&lt;/h2>
&lt;p>We can solve this problem efficiently using Dynamic Programming.&lt;/p>
&lt;p>The idea is to keep track of the maximum and minimum product ending at each position (as the array can contain negative numbers, and a negative number can become maximum when multiplied by another negative number).&lt;/p>
&lt;p>We initialize two variables, &lt;code>max_prod&lt;/code> and &lt;code>min_prod&lt;/code>, to &lt;code>nums[0]&lt;/code>. Then for each number in the array (from the second number to the end), we calculate &lt;code>max_prod&lt;/code> and &lt;code>min_prod&lt;/code> using the formulas:&lt;/p>
&lt;pre>&lt;code>max_prod = max(nums[i], max_prod * nums[i], min_prod * nums[i])
min_prod = min(nums[i], max_prod * nums[i], min_prod * nums[i])
&lt;/code>&lt;/pre>
&lt;p>We also keep track of &lt;code>res&lt;/code>, which stores the maximum product of a subarray as a result.&lt;/p>
&lt;p>If &lt;code>max_prod&lt;/code> is greater than &lt;code>res&lt;/code>, we update &lt;code>res&lt;/code>.&lt;/p>
&lt;p>Finally, &lt;code>res&lt;/code> will hold the maximum product of a subarray.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize &lt;code>max_prod&lt;/code>, &lt;code>min_prod&lt;/code>, and &lt;code>res&lt;/code> to &lt;code>nums[0]&lt;/code>.&lt;/li>
&lt;li>For each number in the array (from the second number to the end):
&lt;ul>
&lt;li>Update &lt;code>max_prod&lt;/code> and &lt;code>min_prod&lt;/code>.&lt;/li>
&lt;li>Update &lt;code>res&lt;/code> if &lt;code>max_prod&lt;/code> is greater.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Return &lt;code>res&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="python-solution">Python Solution&lt;/h2>
&lt;p>Here is a Python solution following the described approach:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxProduct&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> nums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_prod &lt;span style="color:#666">=&lt;/span> min_prod &lt;span style="color:#666">=&lt;/span> res &lt;span style="color:#666">=&lt;/span> nums[&lt;span style="color:#40a070">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> num &lt;span style="color:#007020;font-weight:bold">in&lt;/span> nums[&lt;span style="color:#40a070">1&lt;/span>:]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_max &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(num, max_prod &lt;span style="color:#666">*&lt;/span> num, min_prod &lt;span style="color:#666">*&lt;/span> num)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_prod &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">min&lt;/span>(num, max_prod &lt;span style="color:#666">*&lt;/span> num, min_prod &lt;span style="color:#666">*&lt;/span> num)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_prod &lt;span style="color:#666">=&lt;/span> new_max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(res, max_prod)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> res
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/fraction-to-recurring-decimal/">LeetCode problem 166&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.&lt;/p>
&lt;p>This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.&lt;/p>
&lt;p>For example, if we have a fraction 1/3, the decimal representation would be 0.3333&amp;hellip;. In this problem, we need to represent it as &amp;ldquo;0.(3)&amp;rdquo;.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive solution could involve simple division - you divide the numerator by the denominator and convert it to a string. However, this wouldn&amp;rsquo;t account for recurring decimals, and it would only be correct for fractions that result in a finite decimal.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;span class="caption-wrapper">
&lt;img class="caption" style="float: right; width: ; height: 250px; margin: 0px 10px 10px 0px;" src="../../assets/long-division.png" title="" alt="">
&lt;span class="caption-text">&lt;/span>
&lt;/span>
&lt;p>A better approach to solve this problem involves using the &lt;strong>long division method&lt;/strong> and a hash map to keep track of remainders. If the same remainder appears again, it means we have found a repeating sequence.&lt;/p>
&lt;p>In long division, we divide the numerator by the denominator, find the remainder, and then add a zero to the remainder and repeat the process.&lt;/p>
&lt;p>While doing this, if we encounter the same remainder that we have seen before, it means the sequence will start to repeat from here.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../../assets/166.jpg"
id="zoom-default"
alt="LeetCode problem 166"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>First, handle the simple case where &lt;code>numerator&lt;/code> is divisible by &lt;code>denominator&lt;/code>.&lt;/li>
&lt;li>If the division isn&amp;rsquo;t exact, proceed with the long division method.&lt;/li>
&lt;li>Keep dividing the &lt;code>numerator&lt;/code> by the &lt;code>denominator&lt;/code> and track the remainder.&lt;/li>
&lt;li>Store the remainder and its corresponding index in the decimal part of the result in a dictionary.&lt;/li>
&lt;li>If the remainder repeats, stop the division and enclose the repeating part in parentheses.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">fractionToDecimal&lt;/span>(self, numerator: &lt;span style="color:#007020">int&lt;/span>, denominator: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> numerator &lt;span style="color:#666">%&lt;/span> denominator &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">str&lt;/span>(numerator &lt;span style="color:#666">//&lt;/span> denominator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> integer &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">str&lt;/span>(&lt;span style="color:#007020">abs&lt;/span>(numerator) &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(numerator) &lt;span style="color:#666">%&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder_dict &lt;span style="color:#666">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> remainder &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> remainder &lt;span style="color:#007020;font-weight:bold">in&lt;/span> remainder_dict:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal&lt;span style="color:#666">.&lt;/span>insert(remainder_dict[remainder], &lt;span style="color:#4070a0">&amp;#34;(&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#4070a0">&amp;#34;)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># future index of starting repeating part , i.e. 1.12(345)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder_dict[remainder] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(decimal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">*=&lt;/span> &lt;span style="color:#40a070">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#007020">str&lt;/span>(remainder &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">%=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> integer &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#34;.&amp;#34;&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">.&lt;/span>join(decimal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (numerator &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>) &lt;span style="color:#666">^&lt;/span> (denominator &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Check if the result should be negative&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;-&amp;#34;&lt;/span> &lt;span style="color:#666">+&lt;/span> res
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> res
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When doing the division, we are always considering the absolute value of the numerator and denominator. The remainder and the index at which it appears are stored in a dictionary. Whenever a remainder repeats, it means we have found a repeating sequence and the division process is stopped. The repeating part is then enclosed in parentheses.&lt;/p>
&lt;p>Also, note the line if &lt;code>(numerator &amp;lt; 0) ^ (denominator &amp;lt; 0)&lt;/code>:. This is checking if the result should be negative. If either, but not both, of the numerator and denominator are negative, the result should also be negative. Here &lt;code>^&lt;/code> is the bitwise XOR operator in Python, which returns True if exactly one of the conditions is True.&lt;/p>
&lt;p>After doing all this, if the numerator was negative, we add a negative sign to the front of our result. Otherwise, the result is returned as is.&lt;/p>
&lt;video width="100%" controls>
&lt;source src="../../assets/166.mp4" type="video/mp4">
Your browser does not support the video tag.
&lt;/video>
&lt;figcaption>LeetCode 166 Solution&lt;/figcaption></description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/rotate-array/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an integer array &lt;code>nums&lt;/code>, rotate the array to the right by &lt;code>k&lt;/code> steps, where &lt;code>k&lt;/code> is non-negative.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A simple, but inefficient, approach would be to rotate the array &lt;code>k&lt;/code> times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations. This is not an optimal solution, especially when we have a large &lt;code>k&lt;/code> or a large array.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>An efficient solution can be found by using array reversal. Here&amp;rsquo;s the plan:&lt;/p>
&lt;ol>
&lt;li>Reverse the entire array.&lt;/li>
&lt;li>Reverse the first &lt;code>k&lt;/code> elements.&lt;/li>
&lt;li>Reverse the remaining &lt;code>n-k&lt;/code> elements.&lt;/li>
&lt;/ol>
&lt;p>This method allows us to achieve the desired output in O(n) time and O(1) space complexity.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;p>Let&amp;rsquo;s break down the steps using an example: &lt;code>nums = [1,2,3,4,5,6,7], k = 3&lt;/code>.&lt;/p>
&lt;ol>
&lt;li>Reverse the entire array: &lt;code>nums = [7,6,5,4,3,2,1]&lt;/code>.&lt;/li>
&lt;li>Reverse the first &lt;code>k&lt;/code> elements: &lt;code>nums = [5,6,7,4,3,2,1]&lt;/code>.&lt;/li>
&lt;li>Reverse the remaining &lt;code>n-k&lt;/code> elements: &lt;code>nums = [5,6,7,1,2,3,4]&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>As you can see, we get the expected output &lt;code>[5,6,7,1,2,3,4]&lt;/code>.&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>Here is the Python code that implements the aforementioned logic:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">rotate&lt;/span>(self, nums, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reverse&lt;/span>(start, end):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> start &lt;span style="color:#666">&amp;lt;&lt;/span> end:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums[start], nums[end] &lt;span style="color:#666">=&lt;/span> nums[end], nums[start]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#666">=&lt;/span> k &lt;span style="color:#666">%&lt;/span> n &lt;span style="color:#60a0b0;font-style:italic"># in case k &amp;gt; len(nums)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reverse(nums, &lt;span style="color:#40a070">0&lt;/span>, n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reverse(nums, &lt;span style="color:#40a070">0&lt;/span>, k &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reverse(nums, k, n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>210. Course Schedule II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/210/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/210/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/course-schedule-ii/">LeetCode задача 210&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Вам дано ( n ) курсов для изучения, пронумерованных от ( 0 ) до ( n-1 ), и массив ( prerequisites ), где ( prerequisites[i] = [a, b] ) означает, что для изучения курса ( a ) предварительно необходимо пройти курс ( b ).&lt;/p>
&lt;p>Напишите функцию для нахождения порядка, в котором можно пройти курсы. Если это невозможно, верните пустой массив.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Топологическая сортировка может быть использована для решения этой задачи.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>Создадим граф, представляющий предварительные требования для каждого курса.&lt;/li>
&lt;li>Применим топологическую сортировку для нахождения порядка курсов.&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем граф и массив для хранения входящих степеней всех вершин (курсов).&lt;/li>
&lt;li>Заполним граф и массив входящих степеней, используя массив ( prerequisites ).&lt;/li>
&lt;li>Используем алгоритм топологической сортировки для нахождения порядка курсов.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> deque, defaultdict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findOrder&lt;/span>(numCourses, prerequisites):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Создаем граф и массив для хранения входящих степеней&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph &lt;span style="color:#666">=&lt;/span> defaultdict(&lt;span style="color:#007020">list&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> indegree &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">*&lt;/span> numCourses
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Заполняем граф и массив входящих степеней&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> course, prereq &lt;span style="color:#007020;font-weight:bold">in&lt;/span> prerequisites:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[prereq]&lt;span style="color:#666">.&lt;/span>append(course)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> indegree[course] &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализация очереди для вершин с нулевой входящей степенью&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue &lt;span style="color:#666">=&lt;/span> deque([i &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(numCourses) &lt;span style="color:#007020;font-weight:bold">if&lt;/span> indegree[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Топологическая сортировка&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> queue:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prereq &lt;span style="color:#666">=&lt;/span> queue&lt;span style="color:#666">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order&lt;span style="color:#666">.&lt;/span>append(prereq)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> course &lt;span style="color:#007020;font-weight:bold">in&lt;/span> graph[prereq]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> indegree[course] &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> indegree[course] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue&lt;span style="color:#666">.&lt;/span>append(course)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> order &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">len&lt;/span>(order) &lt;span style="color:#666">==&lt;/span> numCourses &lt;span style="color:#007020;font-weight:bold">else&lt;/span> []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>215. Kth Largest Element in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/215/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/215/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">LeetCode задача 215&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Найти k-тый по величине элемент в неотсортированном массиве. Примечание: это k-тый по величине элемент в отсортированном порядке, а не k-тый различный элемент.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;ol>
&lt;li>Можно отсортировать массив и просто взять k-тый элемент с конца.&lt;/li>
&lt;li>Для более эффективного решения можно использовать алгоритм быстрой выборки.&lt;/li>
&lt;/ol>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>В самом простом случае мы можем отсортировать массив и взять k-тый элемент с конца.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Сортируем массив.&lt;/li>
&lt;li>Возвращаем k-тый элемент с конца.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findKthLargest&lt;/span>(nums, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#666">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> nums[&lt;span style="color:#666">-&lt;/span>k]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/236/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/236/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode задача 236&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Найдите наименьшего общего предка (LCA) двух заданных узлов в бинарном дереве.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Используйте метод обхода в глубину (DFS) для решения этой задачи.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Обход в глубину (DFS)&lt;/strong>: Используйте рекурсивный метод для обхода дерева.&lt;/li>
&lt;li>&lt;strong>Поиск узлов&lt;/strong>: При обходе дерева ищите заданные узлы p и q.&lt;/li>
&lt;li>&lt;strong>Возврат значения&lt;/strong>: Если найден один из узлов, верните его как потенциального предка.&lt;/li>
&lt;li>&lt;strong>Сравнение результатов&lt;/strong>: Если оба поддерева возвращают узлы, текущий узел является LCA.&lt;/li>
&lt;li>&lt;strong>Пропуск пустых узлов&lt;/strong>: Если узел пуст, верните &lt;code>None&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Запустите рекурсивный DFS, начиная с корня дерева.&lt;/li>
&lt;li>В каждой итерации рекурсии:
&lt;ul>
&lt;li>Проверьте, является ли текущий узел одним из искомых (p или q).&lt;/li>
&lt;li>Произведите обход левого и правого поддеревьев.&lt;/li>
&lt;li>Если оба поддерева возвращают не-&lt;code>None&lt;/code> значения, текущий узел является LCA.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">TreeNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, left&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>, right&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>left &lt;span style="color:#666">=&lt;/span> left
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>right &lt;span style="color:#666">=&lt;/span> right
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">lowestCommonAncestor&lt;/span>(root: TreeNode, p: TreeNode, q: TreeNode) &lt;span style="color:#666">-&amp;gt;&lt;/span> TreeNode:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если текущий узел является одним из искомых, вернуть его&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> root&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">==&lt;/span> p&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#007020;font-weight:bold">or&lt;/span> root&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">==&lt;/span> q&lt;span style="color:#666">.&lt;/span>val:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Обход левого и правого поддеревьев&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">=&lt;/span> lowestCommonAncestor(root&lt;span style="color:#666">.&lt;/span>left, p, q)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right &lt;span style="color:#666">=&lt;/span> lowestCommonAncestor(root&lt;span style="color:#666">.&lt;/span>right, p, q)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если оба поддерева возвращают узлы, текущий узел является LCA&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> left &lt;span style="color:#007020;font-weight:bold">and&lt;/span> right:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> left &lt;span style="color:#007020;font-weight:bold">or&lt;/span> right
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>237. Delete Node in a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/237/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/237/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">LeetCode задача 237&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Написать функцию для удаления узла (за исключением хвостового) в односвязном списке, дан только доступ к этому узлу.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;ol>
&lt;li>Обычно, для удаления узла из односвязного списка, нам нужен доступ к предыдущему узлу. В этом случае, у нас такого доступа нет. Как это обойти?&lt;/li>
&lt;/ol>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Поскольку доступа к предыдущему узлу нет, мы не можем просто &amp;ldquo;вырезать&amp;rdquo; текущий узел. Однако мы можем переписать значение текущего узла значением следующего узла и затем удалить следующий узел.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Перезаписываем значение текущего узла значением следующего узла.&lt;/li>
&lt;li>Удаляем следующий узел.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ListNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#007020">next&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">deleteNode&lt;/span>(node):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> node&lt;span style="color:#666">.&lt;/span>next&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#60a0b0;font-style:italic"># Перезаписываем значение узла значением следующего узла&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> node&lt;span style="color:#666">.&lt;/span>next&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic"># Удаляем следующий узел&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/240/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/240/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">LeetCode задача 240&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Вам дана двумерная матрица размера m x n, представляющая прямоугольник, и целое число &lt;code>target&lt;/code>. Отсортированные строки матрицы по неубыванию с лева направо и столбцы отсортированы по неубыванию сверху вниз.&lt;/p>
&lt;p>Найдите элемент &lt;code>target&lt;/code> в матрице. Верните &lt;code>True&lt;/code>, если элемент &lt;code>target&lt;/code> есть в матрице, и &lt;code>False&lt;/code>, если его нет.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Попробуйте использовать двоичный поиск для каждого ряда.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Самый простой подход - использовать двоичный поиск для каждого ряда. Хотя это не самый эффективный метод, он достаточно прост для понимания.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Пройдитесь по каждому ряду в матрице.&lt;/li>
&lt;li>В каждом ряду используйте двоичный поиск для поиска &lt;code>target&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">bisect&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> bisect_left
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">searchMatrix&lt;/span>(matrix, target):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> row &lt;span style="color:#007020;font-weight:bold">in&lt;/span> matrix:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#666">=&lt;/span> bisect_left(row, target)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> pos &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(row) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> row[pos] &lt;span style="color:#666">==&lt;/span> target:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/251/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/251/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/flatten-2d-vector/">LeetCode задача 251&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дизайн и реализация итератора для 2D вектора. Итератор должен быть инициализирован 2D вектором (&lt;code>vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code>) и должен поддерживать следующие операции:&lt;/p>
&lt;ul>
&lt;li>&lt;code>next()&lt;/code>: Возвращает следующий элемент из 2D вектора. Если нет больше элементов, возвращает 0.&lt;/li>
&lt;li>&lt;code>hasNext()&lt;/code>: Возвращает &lt;code>True&lt;/code>, если в 2D векторе есть следующий элемент, и &lt;code>False&lt;/code> в противном случае.&lt;/li>
&lt;/ul>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Мы можем использовать две переменные: одну для текущего индекса строки и одну для текущего индекса столбца, чтобы навигироваться по 2D вектору.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем переменные &lt;code>row&lt;/code> и &lt;code>col&lt;/code> в конструкторе.&lt;/li>
&lt;li>В методе &lt;code>next()&lt;/code>, возвращаем элемент в текущем &lt;code>row&lt;/code> и &lt;code>col&lt;/code>, и двигаем индексы на следующий доступный элемент.&lt;/li>
&lt;li>В методе &lt;code>hasNext()&lt;/code>, проверяем, есть ли следующий доступный элемент в 2D векторе.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Vector2D&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, vec: &lt;span style="color:#007020">list&lt;/span>[&lt;span style="color:#007020">list&lt;/span>[&lt;span style="color:#007020">int&lt;/span>]]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>vec &lt;span style="color:#666">=&lt;/span> vec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>row &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>col &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">next&lt;/span>(self) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>_advance_to_next()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>vec[self&lt;span style="color:#666">.&lt;/span>row][self&lt;span style="color:#666">.&lt;/span>col]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>col &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">hasNext&lt;/span>(self) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>_advance_to_next()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>row &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(self&lt;span style="color:#666">.&lt;/span>vec)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">_advance_to_next&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> self&lt;span style="color:#666">.&lt;/span>row &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(self&lt;span style="color:#666">.&lt;/span>vec) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> self&lt;span style="color:#666">.&lt;/span>col &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#007020">len&lt;/span>(self&lt;span style="color:#666">.&lt;/span>vec[self&lt;span style="color:#666">.&lt;/span>row]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>row &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>col &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/277/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/find-the-celebrity/">LeetCode задача 277&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?&lt;/p>
&lt;p>Имплементируйте функцию &lt;code>int findCelebrity(n)&lt;/code>, которая вернет знаменитость если она есть, иначе вернёт -1.&lt;/p>
&lt;p>Вам дана функция &lt;code>bool knows(a, b)&lt;/code>, которая скажет вам, знает ли &lt;code>a&lt;/code> человека &lt;code>b&lt;/code>.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем переменную &lt;code>candidate&lt;/code> значением 0.&lt;/li>
&lt;li>Используем один проход для выявления кандидата. Если &lt;code>knows(candidate, i)&lt;/code> возвращает &lt;code>True&lt;/code>, переключаем &lt;code>candidate&lt;/code> на &lt;code>i&lt;/code>.&lt;/li>
&lt;li>Второй проход для проверки, является ли &lt;code>candidate&lt;/code> знаменитостью.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findCelebrity&lt;/span>(self, n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidate &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">#1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> knows(candidate, i):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidate &lt;span style="color:#666">=&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n): &lt;span style="color:#60a0b0;font-style:italic">#3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> i &lt;span style="color:#666">!=&lt;/span> candidate &lt;span style="color:#007020;font-weight:bold">and&lt;/span> (knows(candidate, i) &lt;span style="color:#007020;font-weight:bold">or&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> knows(i, candidate)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> candidate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>300. Longest Increasing Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/300/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/300/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/longest-increasing-subsequence/">LeetCode задача 300&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан массив чисел, ваша задача — найти длину наибольшей возрастающей подпоследовательности.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения этой задачи вы можете использовать динамическое программирование.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Инициализация&lt;/strong>: Инициализируйте массив, который будет хранить длины наибольших возрастающих подпоследовательностей для каждого элемента массива.&lt;/li>
&lt;li>&lt;strong>Обход массива&lt;/strong>: Обойдите массив, и для каждого элемента обновите массив длин наибольших возрастающих подпоследовательностей.&lt;/li>
&lt;li>&lt;strong>Максимум&lt;/strong>: По окончании обхода найдите максимальное значение в массиве длин.&lt;/li>
&lt;/ol>
&lt;p>Простейший способ решения — это использовать двойной цикл для обхода массива и поиска наибольшей возрастающей подпоследовательности для каждого элемента. Это не самый эффективный способ, но его легко понять.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Создать массив &lt;code>dp&lt;/code> той же длины, что и исходный массив, и заполнить его единицами.&lt;/li>
&lt;li>Для каждого элемента &lt;code>nums[i]&lt;/code> обойти все предыдущие элементы &lt;code>nums[j]&lt;/code> и, если &lt;code>nums[i] &amp;gt; nums[j]&lt;/code>, обновить &lt;code>dp[i]&lt;/code> как &lt;code>max(dp[i], dp[j] + 1)&lt;/code>.&lt;/li>
&lt;li>Найти и вернуть максимальное значение в массиве &lt;code>dp&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">lengthOfLIS&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> nums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums) &lt;span style="color:#60a0b0;font-style:italic"># массив для хранения длин LIS для каждого элемента&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> j &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(i):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[i] &lt;span style="color:#666">&amp;gt;&lt;/span> nums[j]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[i] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(dp[i], dp[j] &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># обновление длины LIS для элемента nums[i]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">max&lt;/span>(dp)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом решении используется двойной цикл для обхода массива и обновления массива dp, который хранит длину наибольшей возрастающей подпоследовательности для каждого элемента. По окончании обхода находим и возвращаем максимальное значение в массиве dp.&lt;/p></description></item><item><title>328. Odd Even Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/328/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/328/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/odd-even-linked-list/">LeetCode задача 328&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан односвязный список и задача переставить его узлы таким образом, чтобы все узлы с нечетными индексами шли перед всеми узлами с четными индексами.&lt;/p>
&lt;h2 id="вариант-решения-1">Вариант решения 1&lt;/h2>
&lt;p>Рассмотрим вариант решения более простой для понимания и реализации.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Использовать два связных списка.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Во время прохода по связному списку указатель для чётных узлов добавлять связанный список с четными, то же самое делать с нечетными.&lt;/p>
&lt;p>В конце прохода список с четными узлами добавить в конец списка с нечетными узлами.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Объявляем 2 пустых связных списка (&lt;code>even_head&lt;/code>, &lt;code>odd_head&lt;/code>)&lt;/li>
&lt;li>Объявляем два указателя на каждый список (&lt;code>even&lt;/code>,`odd). Данные указатели будут перемещаться по своим спискам.&lt;/li>
&lt;li>Проходим по списку &lt;code>head&lt;/code>:
&lt;ol>
&lt;li>если текущий указатель - четный, добавляем его в &lt;code>even_head&lt;/code> (обновляем значение указателя списка).&lt;/li>
&lt;li>Переставляем указатель на следующий. &lt;code>even = even.next&lt;/code>&lt;/li>
&lt;li>Шаги 1-2 для нечетного указателя соответсвенно.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Переходим к следующему указателю в &lt;code>head&lt;/code>.&lt;/li>
&lt;li>Соединяем два списка. Список с четные указателями становится следующим после списка с нечетными указателями.
&lt;ol>
&lt;li>Так как четные указатели должны стоять в самом конце нового списка, то обновляем &lt;code>even.next = None&lt;/code>, потому что после него ничего не должно идти.&lt;/li>
&lt;li>Добавляем &lt;code>even_head&lt;/code> к списку &lt;code>odd_head&lt;/code> в конец.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Возвращаем &lt;code>odd_head&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">oddEvenList&lt;/span>(self, head: Optional[ListNode]) &lt;span style="color:#666">-&amp;gt;&lt;/span> Optional[ListNode]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd_head &lt;span style="color:#666">=&lt;/span> ListNode(&lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_head &lt;span style="color:#666">=&lt;/span> ListNode(&lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd &lt;span style="color:#666">=&lt;/span> odd_head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even &lt;span style="color:#666">=&lt;/span> even_head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is_odd &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> head:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> is_odd:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd &lt;span style="color:#666">=&lt;/span> odd&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even &lt;span style="color:#666">=&lt;/span> even&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head &lt;span style="color:#666">=&lt;/span> head&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is_odd &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> is_odd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># самый последний узел&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> even_head&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic"># head в конец списка&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> odd_head&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="вариант-решения-2">Вариант решения 2&lt;/h2>
&lt;h2 id="подсказки-1">Подсказки&lt;/h2>
&lt;p>Использовать указатели. Четный указатель будет головным для четных, нечетный для нечетных. Четный и нечетный по мере прохождения можно менять местами.&lt;/p>
&lt;h2 id="подход-1">Подход&lt;/h2>
&lt;p>Абстрактная идея:&lt;/p>
&lt;ul>
&lt;li>превратить список &lt;code>head&lt;/code> в список из &lt;strong>нечетных&lt;/strong> по счету узлов.&lt;/li>
&lt;li>превратить список &lt;code>even_head&lt;/code> из списка &lt;code>head&lt;/code> с содержанием только &lt;strong>четных&lt;/strong> узлов&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&lt;strong>Инициализация указателей&lt;/strong>: Инициализируем указатели для нечетных и четных узлов, а также сохраняем начальный четный узел, который будет использован после того, как пройдем весь список.&lt;/li>
&lt;li>&lt;strong>Перестановка узлов&lt;/strong>: Проходим по списку, &lt;mark>меняя местами нечетные и четные узлы&lt;/mark>.
&lt;ol>
&lt;li>Обновляем &lt;code>next&lt;/code> для нечетного путем взятия &lt;code>next&lt;/code> у четного: &lt;code>odd.next = even.next&lt;/code>&lt;/li>
&lt;li>Перемещаем указатель для нечетного вперед: &lt;code>odd = odd.next&lt;/code>&lt;/li>
&lt;li>1 и 2 шаги проделываем для четного указателя. 💡 четный указатель обновляет ссылки с &lt;em>обновленного&lt;/em> четного указателя.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>Соединение списков&lt;/strong>: После того как все узлы переставлены, последний нечетный узел должен указывать на первый четный узел.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Пример для &lt;code>1,2,3,4,5&lt;/code>:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Инициализация указателей:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Указатель &lt;code>odd&lt;/code> указывает на узел с значением 1. состояние списка: &lt;code>1-2-3-4-5&lt;/code>&lt;/li>
&lt;li>Указатель &lt;code>even&lt;/code> указывает на узел с значением 2. состояние списка: &lt;code>2-3-4-5&lt;/code>&lt;/li>
&lt;li>Указатель &lt;code>even_head&lt;/code> указывает на узел с значением 2. состояние списка: &lt;code>2-3-4-5&lt;/code>&lt;/li>
&lt;/ul>
&lt;span class="caption-wrapper">
&lt;img class="caption" style="float: right; width: ; height: 555px; margin: 0px 10px 10px 0px;" src="#ZgotmplZ" title="" alt="">
&lt;span class="caption-text">&lt;/span>
&lt;/span>
&lt;ol start="2">
&lt;li>Первый проход:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>odd.next&lt;/code> будет указывать на узел, следующий за &lt;code>even&lt;/code>: 1-2 =&amp;gt; 1-3, &lt;code>odd.next = 3&lt;/code>.&lt;/li>
&lt;li>Обновляем &lt;code>odd&lt;/code> на &lt;code>odd.next&lt;/code>. &lt;code>odd = 3&lt;/code>, &lt;code>odd.next = 4&lt;/code>.&lt;/li>
&lt;li>&lt;code>even.next&lt;/code> будет указывать на узел, следующий за новым &lt;code>odd&lt;/code>: 2-3 =&amp;gt; 2-&amp;gt;4, &lt;code>even.next = 4&lt;/code>.&lt;/li>
&lt;li>Перемещаем &lt;code>even&lt;/code> на &lt;code>even.next&lt;/code>&lt;/li>
&lt;li>Текущее состояние списков &lt;code>head&lt;/code>: &lt;code>1-3-4-5&lt;/code>, &lt;code>even_head&lt;/code>: &lt;code>2-4-5&lt;/code>&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>Второй проход:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>odd.next&lt;/code> будет указывать на узел, следующий за &lt;code>even&lt;/code> (узел с значением 6)&lt;/li>
&lt;li>Обновляем &lt;code>odd&lt;/code> на &lt;code>odd.next&lt;/code>. с значением 6&lt;/li>
&lt;li>&lt;code>even.next&lt;/code> будет указывать на узел, следующий за новым &lt;code>odd&lt;/code> (узел с значением 5)&lt;/li>
&lt;li>Перемещаем &lt;code>even&lt;/code> на узел с значением 5&lt;/li>
&lt;li>Текущее состояние списка: &lt;code>1-3-5&lt;/code>. &lt;code>2-4&lt;/code>&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>Объединение четных и нечетных:&lt;/li>
&lt;/ol>
&lt;p>После окончания всех проходов, установить &lt;code>odd.next&lt;/code> на узел, на который указывает &lt;code>even_head&lt;/code>.&lt;/p>
&lt;h2 id="алгоритм-1">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем указатели &lt;code>odd&lt;/code> и &lt;code>even&lt;/code> на начальные нечетные и четные узлы.&lt;/li>
&lt;li>Сохраняем начальный четный узел в переменной &lt;code>even_head&lt;/code>.&lt;/li>
&lt;li>Пока четные и нечетные узлы не &lt;code>None&lt;/code>, продолжаем перестановку.&lt;/li>
&lt;li>В конце соединяем последний нечетный узел с &lt;code>even_head&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="решение-1">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ListNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#007020">next&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">oddEvenList&lt;/span>(head: ListNode) &lt;span style="color:#666">-&amp;gt;&lt;/span> ListNode:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> head:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even &lt;span style="color:#666">=&lt;/span> head&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_head &lt;span style="color:#666">=&lt;/span> even
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> even &lt;span style="color:#007020;font-weight:bold">and&lt;/span> even&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> even&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd &lt;span style="color:#666">=&lt;/span> odd&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> odd&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even &lt;span style="color:#666">=&lt;/span> even&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Соединяем последний нечетный узел с первым четным&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> even_head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>341. Flatten Nested List Iterator</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/341/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/341/</guid><description>&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан вложенный список целых чисел. Реализуйте итератор, который &amp;ldquo;разворачивает&amp;rdquo; этот вложенный список.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Задача состоит в реализации итератора, который будет последовательно возвращать все элементы из вложенного списка. Вложенный список может содержать как обычные числа, так и другие вложенные списки. Наивное решение заключается в том, чтобы сначала полностью &amp;ldquo;развернуть&amp;rdquo; весь вложенный список в одномерный список, а затем реализовать итератор для этого одномерного списка.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализация: Создать одномерный список и заполнить его элементами из вложенного списка.&lt;/li>
&lt;li>next(): Возвращает следующий элемент одномерного списка.&lt;/li>
&lt;li>hasNext(): Проверяет, остались ли еще элементы для итерации.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">NestedIterator&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, nestedList):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>stack &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>flatten(nestedList)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>stack&lt;span style="color:#666">.&lt;/span>reverse()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Рекурсивная функция для &amp;#34;разворачивания&amp;#34; вложенного списка&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">flatten&lt;/span>(self, nestedList):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> item &lt;span style="color:#007020;font-weight:bold">in&lt;/span> nestedList:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> item&lt;span style="color:#666">.&lt;/span>isInteger():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>stack&lt;span style="color:#666">.&lt;/span>append(item&lt;span style="color:#666">.&lt;/span>getInteger())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>flatten(item&lt;span style="color:#666">.&lt;/span>getList())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">next&lt;/span>(self) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">hasNext&lt;/span>(self) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(self&lt;span style="color:#666">.&lt;/span>stack) &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом решении мы сначала &amp;ldquo;разворачиваем&amp;rdquo; весь вложенный список в одномерный список, используя рекурсивную функцию flatten. Затем, для получения следующего элемента и проверки наличия следующего элемента, используются методы next() и hasNext().&lt;/p></description></item><item><title>377. Combination Sum IV</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/377/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/377/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/combination-sum-iv/">LeetCode задача 377&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан массив различных целых чисел &lt;code>nums&lt;/code> и целевое целое число &lt;code>target&lt;/code> от 1 до 1000. Нужно вернуть количество возможных комбинаций, которые в сумме дают &lt;code>target&lt;/code>.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;ol>
&lt;li>Построить дерево решений&lt;/li>
&lt;li>Задачу можно решить путем разложения ее на меньшие подзадачи с помощью динамического программирования.&lt;/li>
&lt;/ol>
&lt;p>&lt;mark>Нахождение целевого значения в дереве решений&lt;/mark>&lt;/p>
&lt;video width="100%" controls>
&lt;source src="../../assets/377.ru.mp4" type="video/mp4">
Your browser does not support the video tag.
&lt;/video>
&lt;figcaption>LeetCode 377 Решение&lt;/figcaption>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Если целевое значение - &lt;code>target=7&lt;/code> и &lt;code>nums=[2, 3, 4]&lt;/code>, то в дереве решений может быть несколько путей до этого числа. Например: &lt;code>2-2-3&lt;/code>, &lt;code>2-3-2&lt;/code>, &lt;code>3-2-2&lt;/code>, &lt;code>3-4&lt;/code>, &lt;code>4-3&lt;/code>, &lt;code>5-2&lt;/code>.&lt;/p>
&lt;p>Во время подсчета различных путей мы получаем различные суммы, например: &lt;code>2-2-3&lt;/code>, сначала сумма 2, потом 4, потом 7.
Следующи возможный путь начинается с 3. Чтобы проверить, подходит данный путь или нет, мы можем рассчитать недостающее число до &lt;code>target&lt;/code>: 7-3=4. Мы получили 4, но ранее мы уже получали такую сумму и знаем, что если на данном этапе мы хотим знать будет ли какое количество вариантов для суммы 4, то в итоге мы найдем решение.&lt;/p>
&lt;p>Это - особенность динамического программирования, когда на каждом этапе мы используем уже подсчитанные данные, пройденные до текущего момента.&lt;/p>
&lt;p>Мы будем использовать массив &lt;code>sums&lt;/code>, где &lt;code>sums[s]&lt;/code> будет хранить количество комбинаций, которые дают сумму &lt;code>s&lt;/code>.&lt;/p>
&lt;p>Для каждого числа &lt;code>s&lt;/code> от 1 до &lt;code>target&lt;/code>, мы будем итерировать по каждому числу в &lt;code>nums&lt;/code> и прибавлять &lt;code>sums[s-num]&lt;/code> к &lt;code>sums[s]&lt;/code>.&lt;/p>
&lt;p>Пример:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>sums&lt;span style="color:#666">[&lt;/span>4&lt;span style="color:#666">]&lt;/span> &lt;span style="color:#666">=&lt;/span> sums&lt;span style="color:#666">[&lt;/span>4-2&lt;span style="color:#666">]&lt;/span> + sums&lt;span style="color:#666">[&lt;/span>4-4&lt;span style="color:#666">]&lt;/span> + sums&lt;span style="color:#666">[&lt;/span>4-4&lt;span style="color:#666">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Почему мы рассматриваем числа от 1 до target?&lt;/strong>&lt;/p>
&lt;p>Целью является поиск всех возможных комбинаций чисел из &lt;code>nums&lt;/code>, которые в сумме дают &lt;code>target&lt;/code>. Начиная с 1 и заканчивая &lt;code>target&lt;/code>, мы стремимся найти все возможные комбинации для каждого промежуточного значения. Таким образом, когда мы достигаем &lt;code>target&lt;/code>, у нас уже будут вычислены комбинации для всех предыдущих значений, что позволит быстро найти ответ для &lt;code>target&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Зачем нам нужен индекс с нулевым значением в массиве?&lt;/strong>&lt;/p>
&lt;p>Значение &lt;code>sums[0] = 1&lt;/code> может показаться не совсем интуитивным, но оно имеет особый смысл. Это значение говорит нам о том, что есть один способ получить сумму 0 — не использовать ни одного числа из &lt;code>nums&lt;/code>. Это начальное условие необходимо для корректной работы алгоритма, так как при добавлении каждого нового числа из &lt;code>nums&lt;/code> к уже найденным комбинациям мы будем обращаться к этому значению.&lt;/p>
&lt;p>Рассмотрим пример. Пусть &lt;code>nums = [1,2,3]&lt;/code> и &lt;code>target = 4&lt;/code>. Когда мы рассматриваем число 1 (первый шаг итерации), наш алгоритм будет искать число комбинаций, которые дают сумму 1 - 1 = 0. И здесь значение &lt;code>sums[0]&lt;/code> приходит на помощь: благодаря ему алгоритм &amp;ldquo;понимает&amp;rdquo;, что существует одна такая комбинация.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Создаем список &lt;code>sums&lt;/code> с длиной &lt;code>target + 1&lt;/code> и заполняем его нулями. Этот список будет представлять количество комбинаций, которые приводят к определенной (промежуточной) сумме.&lt;/li>
&lt;li>Устанавливаем &lt;code>sums[0]&lt;/code> в 1, так как есть только один способ получить сумму 0: при пустом &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>Основной цикл (построение таблицы):
&lt;ol>
&lt;li>Перебираем все возможные суммы от 1 до &lt;code>target&lt;/code> (включительно). Допустим, текущее число обозначено как &lt;code>s&lt;/code>
&lt;ol>
&lt;li>Теперь перебираем каждое число &lt;code>n&lt;/code> из &lt;code>nums&lt;/code>.
&lt;ol>
&lt;li>Находим остаточную сумму &lt;code>s - n&lt;/code>&lt;/li>
&lt;li>Прибавляем к &lt;code>sums[s]&lt;/code> значение &lt;code>sums[s-n]&lt;/code>, так как любая комбинация, ведущая к &lt;code>s-n&lt;/code>, может быть дополнена числом &lt;code>n&lt;/code>, чтобы достичь &lt;code>s&lt;/code>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">combinationSum4&lt;/span>(self, nums: List[&lt;span style="color:#007020">int&lt;/span>], target: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">*&lt;/span> (target &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># entrypoint of dynamic p: sum 0 can be only in case if nums is empty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> s &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, target &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> n &lt;span style="color:#007020;font-weight:bold">in&lt;/span> nums: &lt;span style="color:#60a0b0;font-style:italic"># check all paths&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">=&lt;/span> s &lt;span style="color:#666">-&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> remainder &lt;span style="color:#666">&amp;gt;=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># use only positive indexes (sums)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums[s] &lt;span style="color:#666">+=&lt;/span> sums[remainder] &lt;span style="color:#60a0b0;font-style:italic"># count to previous results&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> sums[target]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Данное решение можно отобразить с использованием словаря для всех сумм:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">combinationSum4&lt;/span>(self, nums: List[&lt;span style="color:#007020">int&lt;/span>], target: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums &lt;span style="color:#666">=&lt;/span> {&lt;span style="color:#40a070">0&lt;/span>:&lt;span style="color:#40a070">1&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> s &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, target &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums[s] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> n &lt;span style="color:#007020;font-weight:bold">in&lt;/span> nums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">=&lt;/span> s &lt;span style="color:#666">-&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums[s] &lt;span style="color:#666">+=&lt;/span> sums&lt;span style="color:#666">.&lt;/span>get(remainder, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> sums[target]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>384. Shuffle an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/384/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/384/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/shuffle-an-array/">LeetCode задача 384&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Реализуйте класс, который принимает массив чисел в конструкторе и предоставляет метод для их случайного перемешивания, а также метод для возвращения исходного массива.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для создания случайного порядка элементов можно использовать алгоритм Фишера-Йетса или другие методы перемешивания.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Инициализация&lt;/strong>: Сохранить исходный массив в переменной класса для дальнейшего использования.&lt;/li>
&lt;li>&lt;strong>reset()&lt;/strong>: Вернуть исходный массив.&lt;/li>
&lt;li>&lt;strong>shuffle()&lt;/strong>: Вернуть перемешанный массив.&lt;/li>
&lt;/ol>
&lt;p>Из всех возможных подходов к решению этой задачи, наиболее простым является использование встроенного метода &lt;code>random.shuffle()&lt;/code> из Python стандартной библиотеки для перемешивания массива. В этом случае, вы просто создаете копию исходного массива и применяете к ней метод &lt;code>random.shuffle()&lt;/code>.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Сохранить исходный массив в переменной класса.&lt;/li>
&lt;li>В методе &lt;code>reset()&lt;/code> просто вернуть исходный массив.&lt;/li>
&lt;li>В методе &lt;code>shuffle()&lt;/code> создать копию исходного массива, перемешать её и вернуть.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">random&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>original &lt;span style="color:#666">=&lt;/span> nums
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reset&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>original
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">shuffle&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shuffled &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>original&lt;span style="color:#666">.&lt;/span>copy() &lt;span style="color:#60a0b0;font-style:italic"># создаем копию исходного массива&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> random&lt;span style="color:#666">.&lt;/span>shuffle(shuffled) &lt;span style="color:#60a0b0;font-style:italic"># перемешиваем копию&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> shuffled
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/decode-string/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an encoded string, the task is to decode it to produce a string. The encoding rule is: &lt;code>k[encoded_string]&lt;/code>, where the &lt;code>encoded_string&lt;/code> inside the square brackets is being repeated exactly &lt;code>k&lt;/code> times.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to repeatedly look for a pattern in the string where there is a number followed by square brackets. For each such pattern found, replace it with the string inside the square brackets repeated &amp;lsquo;k&amp;rsquo; times. This would work but might not be the most efficient solution, especially for nested brackets.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ol>
&lt;li>The problem can be approached using a stack data structure.&lt;/li>
&lt;li>When we encounter a number, we can store it. When we encounter an open bracket, we push what we have onto the stack and reset our current string and count. When we encounter a closing bracket, we can pop from the stack and multiply our current string the required number of times.&lt;/li>
&lt;/ol>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The ideal approach to solve this problem is using a stack. The reason a stack works perfectly here is that the decoding needs to be done from the inside out whenever we encounter nested brackets.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize an empty stack.&lt;/li>
&lt;li>Iterate over each character in the input string.
&lt;ol>
&lt;li>If the current character is a digit, store it until we get the complete number.&lt;/li>
&lt;li>If the current character is an open bracket, push the current string and number to the stack and reset them.&lt;/li>
&lt;li>If it&amp;rsquo;s a closing bracket, pop the string and number from the stack and append the current string repeated &amp;rsquo;number&amp;rsquo; times to the popped string. This becomes our new current string.&lt;/li>
&lt;li>If it&amp;rsquo;s a letter, simply append it to the current string.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Once the iteration is over, the current string contains the decoded string.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">decodeString&lt;/span>(s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_num &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> char &lt;span style="color:#007020;font-weight:bold">in&lt;/span> s:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> char&lt;span style="color:#666">.&lt;/span>isdigit():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_num &lt;span style="color:#666">+=&lt;/span> char
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> char &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;[&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append((curr_str, &lt;span style="color:#007020">int&lt;/span>(curr_num)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_num &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> char &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;]&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev_str, num &lt;span style="color:#666">=&lt;/span> stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">=&lt;/span> prev_str &lt;span style="color:#666">+&lt;/span> num &lt;span style="color:#666">*&lt;/span> curr_str
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">+=&lt;/span> char
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> curr_str
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/437/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/path-sum-iii/">LeetCode задача 437&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан корень бинарного дерева и целое число &lt;code>targetSum&lt;/code>. Верните количество путей, где сумма значений вдоль пути равна &lt;code>targetSum&lt;/code>.&lt;/p>
&lt;p>Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня. При этом на каждом уровне рекурсии мы проверяем, есть ли путь от &lt;strong>текущего узла&lt;/strong>, сумма которого равна &lt;code>targetSum&lt;/code>.&lt;/p>
&lt;p>&lt;mark>Часть 1: Обновлять корневой узел на каждом уровне рекурсии&lt;/mark>&lt;/p>
&lt;p>Под &lt;strong>текущим узлом&lt;/strong> будем иметь ввиду корневой узел (&lt;code>root&lt;/code>).&lt;/p>
&lt;p>Например, при дереве с узлами: &lt;code>[10,5,-3,3,2,null,11,3,-2,null,1]&lt;/code> и &lt;code>targetSum=8&lt;/code>&lt;/p>
&lt;p>&lt;strong>Итого каждый узел будет в какой-то момент корневым узлом.&lt;/strong>&lt;/p>
&lt;p>Текущий корневой узел (&lt;code>root&lt;/code>) = 10.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Мы обходим все возможные отрезки от текущего&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Сверяем суммы этих отрезков с &lt;code>targetSum&lt;/code> :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span> ([10], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3, -2], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 2], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 2, 1], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>После того как рассмотрели все возможные отрезки от текущего &lt;code>root=10&lt;/code>, мы идем рассматривать все возможные отрезки от нового &lt;code>root&lt;/code>.&lt;/p>
&lt;p>Новые &lt;code>root&lt;/code> становятся &lt;code>root.left&lt;/code> и &lt;code>root.right&lt;/code>.&lt;/p>
&lt;p>Тогда следующая итерация будет выглядеть следующим образом:&lt;/p>
&lt;p>Текущий корневой узел (&lt;code>root&lt;/code>) = 5.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span> ([5], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([5, 3], 8) !! нашли один отрезок
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([5, 3, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>&lt;mark>Часть 2: Правильный подсчет сумм от корня дерева до текущего узла&lt;/mark>&lt;/p>
&lt;p>Когда корневой узел был 10, мы должны были ничего предпринимать.&lt;/p>
&lt;p>Но когда во время рекурсии корневой узел будет на уровень меньше, например 5, функция должна понимать, что сумму текущего отрезка и всех его дочерних нужно считать от нового корня дерева, т.е. от 5, и так далее.&lt;/p>
&lt;p>Например: текущий корень 10, а узел 3, т.е. мы должны посчитать равен ли отрезок [10,5,3] целевому числу 8.&lt;/p>
&lt;p>Для этого узел 3 должен знать значения, которые были до него.&lt;/p>
&lt;p>Решение:&lt;/p>
&lt;ol>
&lt;li>функция с данным узлом может принимать сумму отрезка, пройденного до него&lt;/li>
&lt;li>после этого функция считает равна ли сумма значению до текущего узла и значение самого узла целевому числу &lt;code>targetSum&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>В данном случае [10,5,3] сумма до текущего узла равна $10+5=15$. Если $15+3 == 8$, то текущий отрезок подходит.&lt;/p>
&lt;h2 id="алгоритм--абстрактный-алгоритм">Алгоритм / Абстрактный алгоритм&lt;/h2>
&lt;ol>
&lt;li>Обходим дерево, начиная с корня дерева.&lt;/li>
&lt;li>Для каждого узла, проверяем существует ли путь &lt;strong>от этого узла&lt;/strong>, сумма которого равна &lt;code>targetSum&lt;/code>, перебирая все возможные дочерние пути.&lt;/li>
&lt;li>Рекурсивно выполняем шаги 1 и 2 для всех дочерних узлов.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Definition for a binary tree node.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class TreeNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, left=None, right=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.left = left&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.right = right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">pathSum&lt;/span>(self, root, targetSum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">dfs&lt;/span>(node, current_path_sum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> node:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_path_sum &lt;span style="color:#666">+=&lt;/span> node&lt;span style="color:#666">.&lt;/span>val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> current_path_sum &lt;span style="color:#666">==&lt;/span> targetSum: &lt;span style="color:#60a0b0;font-style:italic"># Равна ли текущая сумма целевому значению&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>left, current_path_sum) &lt;span style="color:#60a0b0;font-style:italic"># Считаем пути для левого &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>right, current_path_sum) &lt;span style="color:#60a0b0;font-style:italic"># и правого дочернего узла&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root_count &lt;span style="color:#666">=&lt;/span> dfs(root, &lt;span style="color:#40a070">0&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Считаем все отрезки для текущего корня дерева&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_count &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>pathSum(root&lt;span style="color:#666">.&lt;/span>left, targetSum) &lt;span style="color:#60a0b0;font-style:italic"># новый корневой узел (левый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_count &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>pathSum(root&lt;span style="color:#666">.&lt;/span>right, targetSum) &lt;span style="color:#60a0b0;font-style:italic"># и правый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> root_count &lt;span style="color:#666">+&lt;/span> left_count &lt;span style="color:#666">+&lt;/span> right_count
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>454. 4Sum II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/454/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/454/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/4sum-ii/">LeetCode задача 454&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Даны четыре списка &lt;code>A&lt;/code>, &lt;code>B&lt;/code>, &lt;code>C&lt;/code>, &lt;code>D&lt;/code> целых чисел. Вычислите, сколько существует таких кортежей &lt;code>(i, j, k, l)&lt;/code>, что ( A[i] + B[j] + C[k] + D[l] = 0 ).&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Используйте хэш-таблицу для ускорения решения.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Создание хэш-таблицы&lt;/strong>: Сначала создайте хэш-таблицу, которая будет хранить суммы пар чисел из массивов &lt;code>A&lt;/code> и &lt;code>B&lt;/code>.&lt;/li>
&lt;li>&lt;strong>Подсчет сумм&lt;/strong>: Для каждой пары &lt;code>(i, j)&lt;/code> из &lt;code>A&lt;/code> и &lt;code>B&lt;/code>, увеличьте соответствующий элемент хэш-таблицы на 1.&lt;/li>
&lt;li>&lt;strong>Поиск в хэш-таблице&lt;/strong>: Для каждой пары &lt;code>(k, l)&lt;/code> из &lt;code>C&lt;/code> и &lt;code>D&lt;/code>, проверьте, существует ли &lt;code>-(C[k] + D[l])&lt;/code> в хэш-таблице. Если да, увеличьте счетчик на соответствующее значение из хэш-таблицы.&lt;/li>
&lt;li>&lt;strong>Возврат результата&lt;/strong>: Верните значение счетчика.&lt;/li>
&lt;/ol>
&lt;p>Этот метод является простым и эффективным с точки зрения времени.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируйте &lt;code>counter = 0&lt;/code> и хэш-таблицу &lt;code>sums&lt;/code>.&lt;/li>
&lt;li>Посчитайте суммы для всех пар &lt;code>(i, j)&lt;/code> из &lt;code>A&lt;/code> и &lt;code>B&lt;/code> и сохраните их в &lt;code>sums&lt;/code>.&lt;/li>
&lt;li>Переберите все пары &lt;code>(k, l)&lt;/code> из &lt;code>C&lt;/code> и &lt;code>D&lt;/code> и проверьте наличие &lt;code>-(C[k] + D[l])&lt;/code> в &lt;code>sums&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> defaultdict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">fourSumCount&lt;/span>(A, B, C, D):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> counter &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums &lt;span style="color:#666">=&lt;/span> defaultdict(&lt;span style="color:#007020">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Считаем суммы для всех пар из A и B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> A:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> j &lt;span style="color:#007020;font-weight:bold">in&lt;/span> B:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sums[i &lt;span style="color:#666">+&lt;/span> j] &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Проверяем наличие -(C[k] + D[l]) в хэш-таблице&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> k &lt;span style="color:#007020;font-weight:bold">in&lt;/span> C:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> l &lt;span style="color:#007020;font-weight:bold">in&lt;/span> D:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#666">-&lt;/span>(k &lt;span style="color:#666">+&lt;/span> l) &lt;span style="color:#007020;font-weight:bold">in&lt;/span> sums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> counter &lt;span style="color:#666">+=&lt;/span> sums[&lt;span style="color:#666">-&lt;/span>(k &lt;span style="color:#666">+&lt;/span> l)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> counter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>621. Task Scheduler</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/621/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/621/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems//task-scheduler/">LeetCode problem 621&lt;/a>&lt;/p>
&lt;h1 id="idea">Idea&lt;/h1>
&lt;p>Think about how you can arrange the tasks with the highest frequency to minimize the idle times.&lt;/p>
&lt;p>The key to solving this problem is to focus on how to efficiently arrange tasks with the highest frequency. We can calculate the frequency of each task and start scheduling the most frequent tasks first, inserting idle slots if needed. The maximum number of idle slots is determined by the frequency of the most frequent task.&lt;/p>
&lt;p>Approach&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;ol>
&lt;li>Count Frequencies: Calculate the frequency of each task.&lt;/li>
&lt;li>Max Frequency Task: Identify the task with the maximum frequency. This task will dictate the minimum time required to complete all tasks considering the cooling period.&lt;/li>
&lt;li>Calculate Idle Slots: Calculate the number of idle slots needed by subtracting the number of tasks from the maximum slots needed.&lt;/li>
&lt;li>Reduce Idle Slots: Iterate over the frequencies of tasks to reduce the number of idle slots by placing other tasks in these slots.&lt;/li>
&lt;li>Calculate Total Time: The total time required is the sum of all tasks and any remaining idle slots.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">leastInterval&lt;/span>(self, tasks: List[&lt;span style="color:#007020">str&lt;/span>], n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task_counts &lt;span style="color:#666">=&lt;/span> Counter(tasks)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_freq &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(task_counts&lt;span style="color:#666">.&lt;/span>values())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_freq_tasks &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(freq &lt;span style="color:#666">==&lt;/span> max_freq &lt;span style="color:#007020;font-weight:bold">for&lt;/span> freq &lt;span style="color:#007020;font-weight:bold">in&lt;/span> task_counts&lt;span style="color:#666">.&lt;/span>values())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part_count &lt;span style="color:#666">=&lt;/span> max_freq &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part_length &lt;span style="color:#666">=&lt;/span> n &lt;span style="color:#666">-&lt;/span> (max_freq_tasks &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> empty_slots &lt;span style="color:#666">=&lt;/span> part_count &lt;span style="color:#666">*&lt;/span> part_length
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> available_tasks &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(tasks) &lt;span style="color:#666">-&lt;/span> max_freq &lt;span style="color:#666">*&lt;/span> max_freq_tasks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idles &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(&lt;span style="color:#40a070">0&lt;/span>, empty_slots &lt;span style="color:#666">-&lt;/span> available_tasks)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(tasks) &lt;span style="color:#666">+&lt;/span> idles
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>649. Dota2 Senate</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/649/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/649/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/dota2-senate/">LeetCode problem 649&lt;/a>&lt;/p>
&lt;h1 id="idea">Idea&lt;/h1>
&lt;p>Think about how the bans affect the sequence of senators and how you can simulate the rounds efficiently.&lt;/p>
&lt;p>The core idea is to simulate the banning process round by round, keeping track of which senators are available to ban others. A queue can efficiently manage this process. Radiant senators and Dire senators can be handled separately to easily manage the bans they are going to perform.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;ol>
&lt;li>Use two queues to represent the indices of Radiant and Dire senators, respectively.&lt;/li>
&lt;li>Iterate through the initial string, adding the index of each senator to their respective party&amp;rsquo;s queue.&lt;/li>
&lt;li>While both parties have members left, simulate each round of bans.
&lt;ol>
&lt;li>Compare the front of each queue:
&lt;ol>
&lt;li>The senator with the lower index (i.e., gets to act first) bans the other.&lt;/li>
&lt;li>Remove the banned senator&amp;rsquo;s index from their queue.&lt;/li>
&lt;li>The senator that performed the ban gets re-added to the end of their queue with an index adjusted to simulate the circular arrangement.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Continue until one of the queues is empty, declaring the party with remaining senators as the winner.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> deque
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">predictPartyVictory&lt;/span>(senate: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radiant &lt;span style="color:#666">=&lt;/span> deque()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dire &lt;span style="color:#666">=&lt;/span> deque()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, s &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">enumerate&lt;/span>(senate):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> s &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;R&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radiant&lt;span style="color:#666">.&lt;/span>append(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dire&lt;span style="color:#666">.&lt;/span>append(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(senate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> radiant &lt;span style="color:#007020;font-weight:bold">and&lt;/span> dire:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#666">=&lt;/span> radiant&lt;span style="color:#666">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d &lt;span style="color:#666">=&lt;/span> dire&lt;span style="color:#666">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> r &lt;span style="color:#666">&amp;lt;&lt;/span> d:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radiant&lt;span style="color:#666">.&lt;/span>append(r &lt;span style="color:#666">+&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dire&lt;span style="color:#666">.&lt;/span>append(d &lt;span style="color:#666">+&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Radiant&amp;#34;&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> radiant &lt;span style="color:#007020;font-weight:bold">else&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Dire&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/split-linked-list-in-parts/">LeetCode problem 725&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>The problem asks you to divide a given singly linked list into &lt;code>k&lt;/code> different parts such that the sizes of these parts are as nearly equal as possible. The parts should appear in the same order as in the original list, and earlier parts should not be smaller than later parts.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would involve counting the length of the list and then traversing the list multiple times to create each part. While this would solve the problem, it isn&amp;rsquo;t the most efficient way.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>You can use pointers and mathematical calculations to accomplish the task in a more efficient manner.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>To solve this problem, you first need to calculate the length of the original list. Once you have the length, you can divide it by &lt;code>k&lt;/code> to find the &amp;ldquo;base size&amp;rdquo; of each part. The remainder of the division will help you distribute the &amp;ldquo;extra&amp;rdquo; nodes among the first few parts.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Count the total number of nodes in the list. Call it &lt;code>n&lt;/code>.&lt;/li>
&lt;li>Calculate the base length of each part as &lt;code>batch_len = n // k&lt;/code> and find the number of &amp;ldquo;extra nodes&amp;rdquo; as &lt;code>extra_nodes = n % k&lt;/code>.&lt;/li>
&lt;li>Initialize an array &lt;code>arr&lt;/code> to store the head node of each part.&lt;/li>
&lt;li>Loop through &lt;code>k&lt;/code> times to create &lt;code>k&lt;/code> parts. Use the base length and distribute the extra nodes as you go.&lt;/li>
&lt;/ol>
&lt;h3 id="debugging-step-by-step">Debugging Step-by-Step&lt;/h3>
&lt;ol>
&lt;li>Start with &lt;code>current = head&lt;/code>.&lt;/li>
&lt;li>Loop from 1 to &lt;code>k&lt;/code>:
&lt;ol>
&lt;li>Store &lt;code>current&lt;/code> as the head of the new part.&lt;/li>
&lt;li>Traverse the list for &lt;code>batch_len&lt;/code> nodes.&lt;/li>
&lt;li>If &lt;code>extra_nodes &amp;gt; 0&lt;/code>, traverse one more node and decrement &lt;code>extra_nodes&lt;/code>.&lt;/li>
&lt;li>Cut the list to start a new part and store the old part in &lt;code>arr&lt;/code>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Definition for singly-linked list.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class ListNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, next=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.next = next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">splitListToParts&lt;/span>(self, head: Optional[ListNode], k: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> List[Optional[ListNode]]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># get linked list length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> current:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current &lt;span style="color:#666">=&lt;/span> current&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># get batch length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> batch_len &lt;span style="color:#666">=&lt;/span> n &lt;span style="color:#666">//&lt;/span> k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extra_nodes &lt;span style="color:#666">=&lt;/span> n &lt;span style="color:#666">%&lt;/span> k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># generate k batches&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> batch &lt;span style="color:#666">=&lt;/span> current &lt;span style="color:#60a0b0;font-style:italic"># define head of current batch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extra_one &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> extra_nodes &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(batch_len &lt;span style="color:#666">+&lt;/span> extra_one &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> current:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current &lt;span style="color:#666">=&lt;/span> current&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> current: &lt;span style="color:#60a0b0;font-style:italic"># switch, cut current batch, get head of next batch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next_batch &lt;span style="color:#666">=&lt;/span> current&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># cut current batch from next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current &lt;span style="color:#666">=&lt;/span> next_batch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr&lt;span style="color:#666">.&lt;/span>append(batch)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extra_nodes &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> arr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/asteroid-collision/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Imagine a row of asteroids moving in space. Each asteroid has a size (given by its absolute value) and a direction it&amp;rsquo;s moving in (given by its sign: positive for right, negative for left). All asteroids move at the same speed. Your task is to determine the final state of the asteroids after all collisions have been resolved.&lt;/p>
&lt;p>Two important points to note:&lt;/p>
&lt;ol>
&lt;li>When two asteroids of different directions meet, the smaller one explodes. If they are of the same size, both explode.&lt;/li>
&lt;li>Two asteroids moving in the same direction will never meet and thus, never explode each other.&lt;/li>
&lt;/ol>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>One straightforward approach would be to iterate through the array repeatedly. During each iteration, whenever you find two consecutive asteroids moving towards each other (i.e., a positive value followed by a negative value), remove the smaller one (or both if they are of the same size). Keep iterating until no such pairs are found. However, this approach can be very inefficient, especially for larger arrays.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>To solve this problem more efficiently, consider using a data structure that allows us to easily handle the asteroids in the order they are encountered, but can also backtrack when necessary. This hints at using a stack.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>Use a stack to simulate the asteroid collisions:&lt;/p>
&lt;ol>
&lt;li>Traverse the list of asteroids.&lt;/li>
&lt;li>If the asteroid is moving right (positive value), push it onto the stack.&lt;/li>
&lt;li>If the asteroid is moving left (negative value), then:
&lt;ul>
&lt;li>While the top of the stack is positive and less than the absolute value of the current asteroid, pop elements from the stack (indicating that the asteroids have collided and exploded).&lt;/li>
&lt;li>If the stack is empty or the top is negative, push the current asteroid onto the stack.&lt;/li>
&lt;li>If the top of the stack is a positive number greater than the absolute value of the current asteroid, just ignore the current asteroid (it has exploded).&lt;/li>
&lt;li>If the top of the stack has the same value as the absolute value of the current asteroid, pop the top (both asteroids have exploded).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize an empty stack.&lt;/li>
&lt;li>Traverse the asteroid array.&lt;/li>
&lt;li>For each asteroid:
&lt;ul>
&lt;li>If it&amp;rsquo;s positive, push it onto the stack.&lt;/li>
&lt;li>If it&amp;rsquo;s negative:
&lt;ol>
&lt;li>While the stack isn&amp;rsquo;t empty and the top of the stack is positive and less than the absolute value of the current asteroid, pop the stack.&lt;/li>
&lt;li>If the stack is empty or the top is negative, push the current asteroid.&lt;/li>
&lt;li>If the top of the stack is positive and has the same value as the absolute value of the current asteroid, pop the stack and continue.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">asteroidCollision&lt;/span>(asteroids):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> asteroid &lt;span style="color:#007020;font-weight:bold">in&lt;/span> asteroids:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> asteroid &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append(asteroid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> stack &lt;span style="color:#007020;font-weight:bold">and&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#666">-&lt;/span>asteroid:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> stack &lt;span style="color:#007020;font-weight:bold">or&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append(asteroid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#666">-&lt;/span>asteroid:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> stack
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/max-consecutive-ones-iii/">LeetCode Problem 1004&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a binary array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, the task is to return the maximum number of consecutive 1&amp;rsquo;s in the array, with the possibility to flip at most &lt;code>k&lt;/code> 0&amp;rsquo;s.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A straight forward approach is to try flipping every combination of &lt;code>k&lt;/code> zeros and checking for the longest sequence of 1&amp;rsquo;s. This would involve nested loops, with the outer loop iterating through the array and the inner loops flipping zeros and calculating sequences of 1&amp;rsquo;s. This approach can be extremely slow, especially for larger arrays.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>The task can be tackled more efficiently with a sliding window approach. This technique can be applied when we want to examine a continuous chunk of elements in an array, such as a substring or subarray.&lt;/p>
&lt;h2 id="approach-sliding-window">Approach: Sliding Window&lt;/h2>
&lt;ol>
&lt;li>We &lt;strong>expand&lt;/strong> our window &lt;strong>to the right&lt;/strong> each time and &lt;strong>record&lt;/strong> the &lt;strong>zeros&lt;/strong> we find.&lt;/li>
&lt;li>&lt;strong>If&lt;/strong> the number of &lt;strong>zeros exceeds &lt;code>k&lt;/code>&lt;/strong>, we shrink the window from the left until we&amp;rsquo;re back to at most &lt;code>k&lt;/code> zeros.&lt;/li>
&lt;li>We can track the longest window we&amp;rsquo;ve found during this process, which corresponds to the maximum number of consecutive 1&amp;rsquo;s.&lt;/li>
&lt;/ol>
&lt;p>If the number of zeros exceeds &lt;code>k&lt;/code>, we shrink the window from the left until we&amp;rsquo;re back to at most &lt;code>k&lt;/code> zeros.&lt;/p>
&lt;p>We can track the longest window we&amp;rsquo;ve found during this process, which corresponds to the maximum number of consecutive 1&amp;rsquo;s.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two pointers, &lt;code>left&lt;/code> and &lt;code>right&lt;/code>, to represent the window&amp;rsquo;s boundaries. Also, initialize a counter &lt;code>zero_count&lt;/code> to track zeros in the current window.&lt;/li>
&lt;li>Expand the right boundary of the window by moving the &lt;code>right&lt;/code> pointer.&lt;/li>
&lt;li>If the current number is 0, increment the &lt;code>zero_count&lt;/code>.&lt;/li>
&lt;li>If &lt;code>zero_count&lt;/code> exceeds &lt;code>k&lt;/code>,
4.1 move the &lt;code>left&lt;/code> pointer to the right until a zero is excluded,
4.2 and decrement the &lt;code>zero_count&lt;/code>.&lt;/li>
&lt;li>Track the maximum length of the window found.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">longestOnes&lt;/span>(nums, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zero_count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_len &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> right &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[right] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zero_count &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> zero_count &lt;span style="color:#666">&amp;gt;&lt;/span> k:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[left] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zero_count &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_len &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_len, right &lt;span style="color:#666">-&lt;/span> left &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_len
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1282/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/">LeetCode задача 1282&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Есть &lt;code>n&lt;/code> человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.&lt;/p>
&lt;p>Дан массив целых чисел &lt;code>groupSizes&lt;/code>, где &lt;code>groupSizes[i]&lt;/code> — это размер группы, в которой находится человек &lt;code>i&lt;/code>. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером &lt;code>groupSizes[i]&lt;/code>.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем словарь для временного хранения групп по их размеру и список для итогового результата.&lt;/li>
&lt;li>Итерируемся по &lt;code>groupSizes&lt;/code>, добавляя каждого человека в соответствующую группу в словаре.&lt;/li>
&lt;li>Когда группа достигает своего размера, добавьте ее в результат и очистите соответствующий список в словаре.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">typing&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> List
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">groupThePeople&lt;/span>(self, groupSizes: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> List[List[&lt;span style="color:#007020">int&lt;/span>]]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups &lt;span style="color:#666">=&lt;/span> {} &lt;span style="color:#60a0b0;font-style:italic"># временное хранение групп&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> [] &lt;span style="color:#60a0b0;font-style:italic"># итоговый список групп&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, size &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">enumerate&lt;/span>(groupSizes):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> size &lt;span style="color:#007020;font-weight:bold">not&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> groups: &lt;span style="color:#60a0b0;font-style:italic"># Если размер группы еще не существует в словаре, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups[size] &lt;span style="color:#666">=&lt;/span> [] &lt;span style="color:#60a0b0;font-style:italic"># инициализируем его пустым списком&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups[size]&lt;span style="color:#666">.&lt;/span>append(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">len&lt;/span>(groups[size]) &lt;span style="color:#666">==&lt;/span> size: &lt;span style="color:#60a0b0;font-style:italic"># Если группа достигла своего размера,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(groups[size]) &lt;span style="color:#60a0b0;font-style:italic"># добавляем ее в результат и очищаем список&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups[size] &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1372/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1372/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/">LeetCode problem 1372&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given the root of a binary tree, the task is to find the longest ZigZag path contained in that tree. A ZigZag path is defined by a sequence starting at any node and switching between left and right directions at each subsequent step.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A simplistic approach would be to kick off from every node and emulate the ZigZag movement until it&amp;rsquo;s no longer feasible, all the while updating the longest path encountered. This method can be rather inefficient as it leads to a lot of recalculations.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>A Depth First Search (DFS) can be an efficient way to tackle this problem. The current path length and direction can be passed as arguments to the DFS function, negating the need for recalculations.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>Imagine walking through the tree. Every time you take a step, you must decide whether to go left or right. But, the twist here is that you have to alternate your direction at every step. The challenge? Find the longest path you can take without breaking this rule.&lt;/p>
&lt;p>To systematically explore all possible paths, we use Depth First Search (DFS), a tree traversal strategy. Instead of starting from scratch at every node, we remember our previous direction (left or right) and continue in the opposite direction, effectively extending our ZigZag path. If a move in the current direction isn&amp;rsquo;t possible, that path ends there, but the search continues. By doing so, we can explore all potential ZigZag paths efficiently.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize DFS from the root, considering both left and right as potential starting directions.&lt;/li>
&lt;li>At each node, based on your previous direction, try extending the ZigZag by moving in the opposite direction, thus increasing the length.&lt;/li>
&lt;li>If you hit a dead end (no further movement possible in the current direction), check if this path length is your longest so far.&lt;/li>
&lt;li>Regardless of whether the current path continues, keep exploring the tree in both directions.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">TreeNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, left&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>, right&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>left &lt;span style="color:#666">=&lt;/span> left
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>right &lt;span style="color:#666">=&lt;/span> right
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">longestZigZag&lt;/span>(self, root: TreeNode) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>max_len &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">dfs&lt;/span>(node, direction, length):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> node:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>max_len &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(self&lt;span style="color:#666">.&lt;/span>max_len, length) &lt;span style="color:#60a0b0;font-style:italic"># Update the maximum length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> direction &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;left&amp;#34;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># If the last direction was left, we try to move right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(node&lt;span style="color:#666">.&lt;/span>right, &lt;span style="color:#4070a0">&amp;#34;right&amp;#34;&lt;/span>, length &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(node&lt;span style="color:#666">.&lt;/span>left, &lt;span style="color:#4070a0">&amp;#34;left&amp;#34;&lt;/span>, &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(node&lt;span style="color:#666">.&lt;/span>left, &lt;span style="color:#4070a0">&amp;#34;left&amp;#34;&lt;/span>, length &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(node&lt;span style="color:#666">.&lt;/span>right, &lt;span style="color:#4070a0">&amp;#34;right&amp;#34;&lt;/span>, &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(root, &lt;span style="color:#4070a0">&amp;#34;left&amp;#34;&lt;/span>, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(root, &lt;span style="color:#4070a0">&amp;#34;right&amp;#34;&lt;/span>, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>max_len
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1448. Count Good Nodes in Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1448/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1448/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/">LeetCode задача 1448&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дано бинарное дерево. Задача подсчитать количество &amp;ldquo;хороших&amp;rdquo; узлов. Узел считается &amp;ldquo;хорошим&amp;rdquo;, если на пути от корня дерева до этого узла (включительно) не встречается узлов с большим значением.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>&amp;ldquo;Хороший&amp;rdquo; узел в дереве — это узел, для которого все узлы на пути от корня до этого узла имеют значение не больше, чем значение этого узла.&lt;/p>
&lt;p>Использовать метод обхода в глубину (DFS) для решения этой задачи.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Идея решения задачи заключается в рекурсивном обходе дерева с сохранением максимального значения на пути от корня к текущему узлу. На каждом этапе, когда мы доходим до нового узла, мы сравниваем его значение с максимальным значением на пути. Если значение узла не меньше максимального, значит, это &amp;ldquo;хороший&amp;rdquo; узел.&lt;/p>
&lt;p>Этот метод обеспечивает простой и понятный способ решения задачи, хотя и может быть не самым оптимальным по времени и памяти.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Обход в глубину (DFS)&lt;/strong>: Используйте рекурсивный метод для обхода дерева.&lt;/li>
&lt;li>&lt;strong>Текущий максимум&lt;/strong>: На каждом шаге рекурсии передавайте текущее максимальное значение на пути от корня.&lt;/li>
&lt;li>&lt;strong>Сравнение узлов&lt;/strong>: Сравните значение текущего узла с текущим максимумом. Если значение узла больше или равно, увеличьте счетчик &amp;ldquo;хороших&amp;rdquo; узлов.&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Рекурсивно обходить дерево, начиная с корня.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>В процессе обхода обновлять максимальное значение на пути и считать &amp;ldquo;хорошие&amp;rdquo; узлы.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Инициализируйте счетчик &amp;ldquo;хороших&amp;rdquo; узлов как 0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Запустите рекурсивный DFS, начиная с корня дерева и передавая значение корня как текущий максимум.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>В рекурсивной функции сравните значение текущего узла с переданным максимумом.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Обновите текущий максимум, если значение текущего узла больше.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Повторите шаги 2-4 для всех дочерних узлов.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">TreeNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, left&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>, right&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>left &lt;span style="color:#666">=&lt;/span> left
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>right &lt;span style="color:#666">=&lt;/span> right
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">goodNodes&lt;/span>(root: TreeNode) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">dfs&lt;/span>(node, cur_max):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> node:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> node&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">&amp;gt;=&lt;/span> cur_max:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur_max &lt;span style="color:#666">=&lt;/span> node&lt;span style="color:#666">.&lt;/span>val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>left, cur_max)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>right, cur_max)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> dfs(root, root&lt;span style="color:#666">.&lt;/span>val)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">LeetCode Problem 1456&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a string &lt;code>s&lt;/code> and an integer &lt;code>k&lt;/code>, the task is to return the maximum number of vowel letters in any substring of &lt;code>s&lt;/code> with length &lt;code>k&lt;/code>.&lt;/p>
&lt;p>Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>The most straightforward solution to this problem is to take every possible substring of length &lt;code>k&lt;/code> and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length &lt;code>k&lt;/code>. The maximum count is then returned.&lt;/p>
&lt;p>However, this naive solution would be computationally expensive, with a time complexity of $O(n*k)$ where n is the length of the string &lt;code>s&lt;/code>.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>The problem can be efficiently solved using a technique called the sliding window approach.&lt;/p>
&lt;h2 id="approach-sliding-window">Approach: Sliding Window&lt;/h2>
&lt;p>The idea is to use a window of size &lt;code>k&lt;/code> and slide it across the string &lt;code>s&lt;/code>. Instead of counting the number of vowels in the entire window every time, we adjust the count by adding the new character and removing the leftmost character as the window slides.&lt;/p>
&lt;p>This way, the number of operations is reduced to just two for every slide, making it a more efficient solution.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize a counter for the number of vowels and a &lt;code>max_vowels&lt;/code> variable to keep track of the maximum number of vowels seen.&lt;/li>
&lt;li>Traverse through the first &lt;code>k&lt;/code> characters of the string, increasing the counter for each vowel seen.&lt;/li>
&lt;li>Set &lt;code>max_vowels&lt;/code> to the value of the counter.&lt;/li>
&lt;li>Start sliding the window from the &lt;code>k&lt;/code>th character. For every new character:
&lt;ul>
&lt;li>If it&amp;rsquo;s a vowel, increase the counter.&lt;/li>
&lt;li>Check the leftmost character of the previous window (i.e., &lt;code>s[i - k]&lt;/code>). If it&amp;rsquo;s a vowel, decrease the counter.&lt;/li>
&lt;li>Update &lt;code>max_vowels&lt;/code> if the counter is greater than its current value.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxVowels&lt;/span>(s, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vowels &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>([&lt;span style="color:#4070a0">&amp;#39;a&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;e&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;i&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;o&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;u&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(&lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> char &lt;span style="color:#007020;font-weight:bold">in&lt;/span> s[:k] &lt;span style="color:#007020;font-weight:bold">if&lt;/span> char &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_vowels &lt;span style="color:#666">=&lt;/span> count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(k, &lt;span style="color:#007020">len&lt;/span>(s)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Add the new character to the count if it&amp;#39;s a vowel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> s[i] &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Remove the leftmost character of the previous window from the count if it&amp;#39;s a vowel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">-=&lt;/span> s[i &lt;span style="color:#666">-&lt;/span> k] &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_vowels &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_vowels, count)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_vowels
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/">LeetCode Problem 1493&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a binary array &lt;code>nums&lt;/code>, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s. This method, however, can be inefficient for larger arrays.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>Consider that we are allowed to have a subarray with a single zero. It might make things simpler! The sliding window approach will be handy here.&lt;/p>
&lt;h2 id="approach-sliding-window-with-a-twist">Approach: Sliding Window with a Twist&lt;/h2>
&lt;p>We can use the sliding window technique again for this problem. However, we need to adapt it slightly. This time, our window can contain at most one zero. Thus, while expanding the window, we should be mindful of the zeros.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two pointers, &lt;code>left&lt;/code> and &lt;code>right&lt;/code>, to represent the window&amp;rsquo;s boundaries. Also, initialize a counter &lt;code>zeroCount&lt;/code> to track zeros in the current window.&lt;/li>
&lt;li>Expand the right boundary of the window by moving the &lt;code>right&lt;/code> pointer.&lt;/li>
&lt;li>If the current number is 0, increment the &lt;code>zeroCount&lt;/code>.&lt;/li>
&lt;li>If &lt;code>zeroCount&lt;/code> becomes 2, move the &lt;code>left&lt;/code> pointer to the right until a zero is excluded, and decrement the &lt;code>zeroCount&lt;/code>.&lt;/li>
&lt;li>Track the maximum length of the window found.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">longestSubarray&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zeroCount &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxLength &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> right &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[right] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zeroCount &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> zeroCount &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[left] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zeroCount &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Subtract 1 because we need to delete one element.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxLength &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(maxLength, right &lt;span style="color:#666">-&lt;/span> left)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> maxLength
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1647/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/">LeetCode задача 1647&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Строка &lt;code>s&lt;/code> называется хорошей, если в ней нет двух разных символов с одинаковой частотой.&lt;/p>
&lt;p>Дана строка &lt;code>s&lt;/code>, верните минимальное количество символов, которое необходимо удалить, чтобы сделать &lt;code>s&lt;/code> хорошим.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.&lt;/p>
&lt;p>Если проверять &lt;mark>встречалась ли частота текущего символа ранее&lt;/mark>, то&lt;/p>
&lt;h2 id="алгоритм--абстрактный-алгоритм">Алгоритм / Абстрактный алгоритм&lt;/h2>
&lt;ol>
&lt;li>Считаем частоты всех символов в строке.&lt;/li>
&lt;li>Сортируем частоты в порядке убывания.&lt;/li>
&lt;li>Для каждой частоты, начиная с самой большой, если она не уникальна (т.е. есть другая такая же частота), уменьшаем ее на 1 и увеличиваем счетчик удалений.&lt;/li>
&lt;li>Продолжаем, пока все частоты не станут уникальными.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">minDeletions&lt;/span>(self, s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq &lt;span style="color:#666">=&lt;/span> Counter(s) &lt;span style="color:#60a0b0;font-style:italic"># Подсчет частот символов&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freqs &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(freq&lt;span style="color:#666">.&lt;/span>values(), reverse&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">True&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Сортировка частот в порядке убывания&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deletions &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seen &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> f &lt;span style="color:#007020;font-weight:bold">in&lt;/span> freqs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> f &lt;span style="color:#007020;font-weight:bold">in&lt;/span> seen:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deletions &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> f &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seen&lt;span style="color:#666">.&lt;/span>add(f)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> deletions
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1679. Max Number of K-Sum Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1679/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1679/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/max-number-of-k-sum-pairs/">LeetCode задача 1679&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Вам дан массив чисел &lt;code>nums&lt;/code> и целое число &lt;code>k&lt;/code>. Задача — найти максимальное количество пар в массиве, сумма элементов которых равна &lt;code>k&lt;/code>.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Используйте технику двух указателей(pointers) после сортировки массива для оптимизации поиска пар.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Центральная идея решения задачи заключается в использовании техники двух указателей для быстрого нахождения пар чисел с заданной суммой &lt;code>k&lt;/code>. Прежде чем применить эту технику, массив сортируется в возрастающем порядке. Затем создаются два указателя: один, указывающий на начало массива, и второй — на конец. Двигая эти указатели в зависимости от суммы элементов, на которые они указывают, мы можем найти все пары с суммой &lt;code>k&lt;/code>.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Отсортируйте массив в возрастающем порядке.&lt;/li>
&lt;li>Инициализируйте два указателя: &lt;code>p1&lt;/code> на начало массива и &lt;code>p2&lt;/code> на конец.&lt;/li>
&lt;li>Пока &lt;code>p1&lt;/code> меньше &lt;code>p2&lt;/code>:
&lt;ul>
&lt;li>Если &lt;code>nums[p1] + nums[p2]&lt;/code> равно &lt;code>k&lt;/code>, увеличьте счетчик на 1, и сдвиньте оба указателя.&lt;/li>
&lt;li>Если сумма меньше &lt;code>k&lt;/code>, сдвиньте &lt;code>p1&lt;/code> вправо.&lt;/li>
&lt;li>Если сумма больше &lt;code>k&lt;/code>, сдвиньте &lt;code>p2&lt;/code> влево.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxOperations&lt;/span>(nums, k) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#666">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> p1 &lt;span style="color:#666">&amp;lt;&lt;/span> p2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s &lt;span style="color:#666">=&lt;/span> nums[p1] &lt;span style="color:#666">+&lt;/span> nums[p2]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> s &lt;span style="color:#666">==&lt;/span> k:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> s &lt;span style="color:#666">&amp;lt;&lt;/span> k:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2095/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2095/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/">LeetCode задача 2095&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан связный список (linked list). Задача — удалить средний узел из этого списка и вернуть начало(head) измененного списка.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Мы можем использовать метод двух указателей для того, чтобы найти средний узел в одном проходе по списку, где второй указатель проходит весь список в два раза быстрее первого указателя.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>Используем два указателя для прохода по списку: один медленный и один быстрый. Оба начинают с головного узла списка.&lt;/li>
&lt;li>Быстрый указатель будет двигаться в два раза быстрее медленного. Каждый шаг он перескакивает через два узла, в то время как медленный только на один. Таким образом, когда быстрый указатель достигнет конца список, первый указатель будет на середине.&lt;/li>
&lt;li>По мере продвижения указателей сохраняем узел, предшествующий медленному поинтеру (&lt;code>prev&lt;/code>), так как именно его &lt;code>next&lt;/code> нам нужно будет изменить.&lt;/li>
&lt;li>Когда быстрый указатель достигнет конца списка или окажется на последнем узле, медленный указатель будет указывать на средний узел.&lt;/li>
&lt;li>Удаляем средний узел.&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем два указателя: один медленный (&lt;code>p1&lt;/code>), другой быстрый (&lt;code>p2&lt;/code>), и третий указатель &lt;code>prev&lt;/code>.&lt;/li>
&lt;li>Обновляем указатели до момента достижения быстрым конца списка:
&lt;ul>
&lt;li>Быстрый указатель на каждом шаге &lt;em>перепрыгивает через&lt;/em> &lt;code>next&lt;/code>.&lt;/li>
&lt;li>Временный (&lt;code>prev&lt;/code>) указатель сохраняет ссылку на медленный указатель до его изменения&lt;/li>
&lt;li>Медленный указатель на каждом шаге обновляется до &lt;code>next&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Удаляем средний элемент путем обновления ссылки в указателе &lt;code>prev.next&lt;/code> на &lt;code>p1.next&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ListNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#007020">next&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">deleteMiddleNode&lt;/span>(head: ListNode) &lt;span style="color:#666">-&amp;gt;&lt;/span> ListNode:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> head&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> head &lt;span style="color:#60a0b0;font-style:italic"># быстрый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> head &lt;span style="color:#60a0b0;font-style:italic"># медленный&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># предыдущий. Будет в середине&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> p2 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> p2&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> p1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> p1&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> p2&lt;span style="color:#666">.&lt;/span>next&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> p1&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2130. Maximum Twin Sum of a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2130/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2130/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/">LeetCode задача 2130&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан односвязный список четной длины. Узлы в этом списке имеют &amp;ldquo;близнецов&amp;rdquo; по определенным правилам. Задача — найти максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.&lt;/p>
&lt;p>Т.е. у первой половины узлов списка есть свой близнец из второй половины.&lt;/p>
&lt;p>Пример:
для списка длиной n = 8
i = 0, twin = n-1-i = 8-1-0 = 7
i = 1, twin = n-1-1 = 6
i = 2, twin = n-1-2 = 5
&amp;hellip;&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>У первой половины узлов списка есть свой близнец из второй половины, т.е. нужно получить значения узлов и сложить значения из первой половины со значением из второй.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Мы можем решить эту задачу, проходя список дважды. В первый проход мы можем сохранить все значения узлов в массиве для удобства доступа. Во втором проходе, мы используем этот массив для вычисления суммы &amp;ldquo;близнецов&amp;rdquo; и отслеживания максимальной такой суммы.&lt;/p>
&lt;p>Массив здесь нужен для того, чтобы мы могли быстро получить доступ к &amp;ldquo;близнецу&amp;rdquo; каждого узла, не проходя список заново.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Пройдемся по связному списку, сохраняя значения всех узлов в массиве.&lt;/li>
&lt;li>Инициализируем переменную &lt;code>max_twin_sum&lt;/code> как 0, которая будет хранить максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.&lt;/li>
&lt;li>Снова пройдемся по связному списку, вычисляя сумму &amp;ldquo;близнецов&amp;rdquo; для каждого узла и обновляя &lt;code>max_twin_sum&lt;/code>, если текущая сумма больше максимальной.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Определение односвязного списка.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ListNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#007020">next&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxTwinSum&lt;/span>(self, head: ListNode) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Проходим по списку, сохраняя все значения в массив.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vals &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#666">=&lt;/span> head
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> curr:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vals&lt;span style="color:#666">.&lt;/span>append(curr&lt;span style="color:#666">.&lt;/span>val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#666">=&lt;/span> curr&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализация максимальной суммы &amp;#34;близнецов&amp;#34;.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_twin_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(vals) &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>): &lt;span style="color:#60a0b0;font-style:italic"># проходим по первой половине&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> twin_i &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">-&lt;/span>i &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> twin_sum &lt;span style="color:#666">=&lt;/span> vals[i] &lt;span style="color:#666">+&lt;/span> vals[twin_i]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_twin_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_twin_sum, twin_sum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_twin_sum
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/equal-row-and-column-pairs/">LeetCode problem 2352&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given a square grid of integers, specifically a 0-indexed &lt;code>n×n&lt;/code> matrix named &lt;code>grid&lt;/code>. The objective is to determine how many pairs of rows and columns in the grid are identical in terms of their content and order.&lt;/p>
&lt;p>To elucidate, if row $r_i$ and column $c_j$ have the same integers in the exact same sequence, they are considered an &amp;ldquo;equal&amp;rdquo; pair. The challenge is to count all such pairs in the given matrix.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to compare each row with every column in the grid. This results in a $O(n^3)$ solution since for every row $O(n)$, you compare with each column $O(n)$, and for every comparison, you traverse the entire row or column $O(n)$. This method is inefficient for large matrices.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>Instead of comparing every row with every column directly, we can convert each row and column into a tuple and utilize a dictionary to keep a count of occurrences of each unique row. While iterating through the columns, we can directly reference our dictionary to see if the tuple representation of the column matches with any row.&lt;/p>
&lt;p>&lt;strong>Why Tuples?&lt;/strong>
Before we dive into the optimized approach, it&amp;rsquo;s essential to understand the role of tuples here. We transform rows and columns into tuples because:&lt;/p>
&lt;ol>
&lt;li>Tuples are immutable: their content cannot be altered after they&amp;rsquo;re created.&lt;/li>
&lt;li>They can be used as keys in dictionaries, unlike lists or sets. This property is pivotal for our solution.&lt;/li>
&lt;li>Tuples maintain the order of elements, crucial for our problem&amp;rsquo;s requirements.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Convert each row to a tuple and count its occurrences using a dictionary.&lt;/li>
&lt;li>Traverse each column, convert it to a tuple.&lt;/li>
&lt;li>Check if the column tuple exists in our dictionary. If it does, increment the count by the occurrences of that tuple.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">equalPairs&lt;/span>(self, grid: List[List[&lt;span style="color:#007020">int&lt;/span>]]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows &lt;span style="color:#666">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Store row tuples and their occurrence count&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> row &lt;span style="color:#007020;font-weight:bold">in&lt;/span> grid:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> row &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">tuple&lt;/span>(row)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows[row]&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">+&lt;/span> rows&lt;span style="color:#666">.&lt;/span>get(row, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># For each column, check if the column tuple exists in rows dictionary&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(grid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> c &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> col &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">tuple&lt;/span>(grid[r][c] &lt;span style="color:#007020;font-weight:bold">for&lt;/span> r &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> rows&lt;span style="color:#666">.&lt;/span>get(col, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> count
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/removing-stars-from-a-string/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are provided with a string &lt;code>s&lt;/code> that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.&lt;/p>
&lt;p>The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A direct approach would be to loop through the string, and every time you find a star, remove it along with the character to its left. Continue this process till no more stars exist. However, this can be optimized.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>In Python, strings are immutable. This means, whenever you make a change to a string, a new string is created in memory. To circumvent this inefficiency, we can utilize a data structure like a list (or a stack in this case), which allows for mutable operations.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>A simplified, yet efficient approach is to use a stack:&lt;/p>
&lt;ol>
&lt;li>Use the stack to store the characters of the string.&lt;/li>
&lt;li>As you iterate through the string, push characters onto the stack. If you come across a star, pop the top character from the stack (if the stack isn&amp;rsquo;t empty).&lt;/li>
&lt;li>The remaining characters in the stack after this operation will form the transformed string.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize an empty stack, named &lt;code>stack&lt;/code>.&lt;/li>
&lt;li>Traverse the string from the beginning.&lt;/li>
&lt;li>For each character:
&lt;ul>
&lt;li>If the character is a star, pop the top character from the stack (provided the stack isn&amp;rsquo;t empty).&lt;/li>
&lt;li>Otherwise, push the character onto the stack.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Convert the stack to a string to get the result.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">removeStars&lt;/span>(s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> c &lt;span style="color:#007020;font-weight:bold">in&lt;/span> s:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> c &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;*&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>&lt;span style="color:#666">.&lt;/span>join(stack)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2840. Check if Strings Can be Made Equal With Operations II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/check-if-strings-can-be-made-equal-with-operations-ii/">LeetCode Problem 2840&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given two strings &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>, both of length &lt;code>n&lt;/code>, consisting of lowercase English letters. You can apply certain operations to make them equal. The question is, is it possible?&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to try all possible swap operations and compare the two strings at each step, which would be highly inefficient.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ol>
&lt;li>Observe that swapping can only occur at indices &lt;code>i&lt;/code> and &lt;code>j&lt;/code> where &lt;code>j - i&lt;/code> is even.&lt;/li>
&lt;li>Separate the string into two different sequences, one containing characters at even indices and the other at odd indices.&lt;/li>
&lt;li>Check the frequency of characters in both sequences.&lt;/li>
&lt;/ol>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The efficient approach involves separating characters at even and odd positions into two different sequences for each string and then comparing the frequency of characters in these sequences.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two empty lists for &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>, each to store characters at even and odd positions.&lt;/li>
&lt;li>Populate these lists with characters from &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>.&lt;/li>
&lt;li>Sort these lists.&lt;/li>
&lt;li>Compare the sorted lists for equality.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">checkStrings&lt;/span>(s1: &lt;span style="color:#007020">str&lt;/span>, s2: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_s1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s1[::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd_s1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s1[&lt;span style="color:#40a070">1&lt;/span>::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_s2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s2[::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd_s2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s2[&lt;span style="color:#40a070">1&lt;/span>::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> even_s1 &lt;span style="color:#666">==&lt;/span> even_s2 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> odd_s1 &lt;span style="color:#666">==&lt;/span> odd_s2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-sum-of-almost-unique-subarray/">LeetCode Problem 2841&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given an integer array &lt;code>nums&lt;/code> and two positive integers &lt;code>m&lt;/code> and &lt;code>k&lt;/code>.&lt;/p>
&lt;p>The task is to return the maximum sum out of all almost unique subarrays of length &lt;code>k&lt;/code> of &lt;code>nums&lt;/code>. If no such subarray exists, return 0.&lt;/p>
&lt;p>A subarray is &lt;strong>almost unique&lt;/strong> if it contains at least &lt;code>m&lt;/code> pairwise distinct elements.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive solution would be to generate all the possible subarrays of length &lt;code>k&lt;/code> and check each one to see if it is almost unique and what its sum is. This would involve nested loops and would not be efficient.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ol>
&lt;li>Use sliding window technique to find subarrays of length &lt;code>k&lt;/code>.&lt;/li>
&lt;li>Keep track of unique elements using a set.&lt;/li>
&lt;/ol>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The solution adopts a &lt;strong>sliding window&lt;/strong> approach to go through the given array &lt;code>nums&lt;/code>, checking each subarray of size &lt;code>k&lt;/code> for its &amp;ldquo;almost uniqueness&amp;rdquo; and sum.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Define a helper function, &lt;code>is_unique&lt;/code>, which will take a subarray and return whether it contains at least &lt;code>m&lt;/code> distinct elements or not.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Initialize a variable &lt;code>_max&lt;/code> to keep track of the maximum sum among the almost unique subarrays.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Loop through &lt;code>nums&lt;/code> using the sliding window technique:&lt;/p>
&lt;ul>
&lt;li>Use the &lt;code>is_unique&lt;/code> function to check if the current subarray is almost unique.&lt;/li>
&lt;li>Update &lt;code>_max&lt;/code> with the maximum sum found so far.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Return &lt;code>_max&lt;/code> if it is not 0; otherwise, return 0.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxSum&lt;/span>(nums: List[&lt;span style="color:#007020">int&lt;/span>], m: &lt;span style="color:#007020">int&lt;/span>, k: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">is_unique&lt;/span>(arr, start, end, m):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> distinct_elements &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>(arr[start:end])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(distinct_elements) &lt;span style="color:#666">&amp;gt;=&lt;/span> m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _max &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n &lt;span style="color:#666">-&lt;/span> k &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> is_unique(nums, i, i &lt;span style="color:#666">+&lt;/span> k, m):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _max &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(_max, &lt;span style="color:#007020">sum&lt;/span>(nums[i:i &lt;span style="color:#666">+&lt;/span> k]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> _max &lt;span style="color:#007020;font-weight:bold">if&lt;/span> _max &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2844/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/minimum-operations-to-make-a-special-number/">LeetCode problem 2844&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given a 0-indexed string &lt;code>num&lt;/code> representing a non-negative integer. In one operation, you can pick any digit of &lt;code>num&lt;/code> and delete it. Note that if you delete all the digits of &lt;code>num&lt;/code>, &lt;code>num&lt;/code> becomes 0.&lt;/p>
&lt;p>Return the minimum number of operations required to make &lt;code>num&lt;/code> special. An integer x is considered special if it is divisible by 25.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach to solving this problem might involve recursively generating all possible substrings of the input string, checking each one for divisibility by 25. While this would yield the correct result, the time complexity would be exponential, making it unfeasible for larger inputs.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>The main insight is that to be divisible by 25, the last two digits of the number must be one of the following: &lt;code>00&lt;/code>, &lt;code>25&lt;/code>, &lt;code>50&lt;/code>, &lt;code>75&lt;/code>. Therefore, it&amp;rsquo;s crucial to consider these patterns when trying to delete the minimum number of digits.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The core idea is to check how many minimum deletions are required for each of the four special last two-digit patterns (&lt;code>00&lt;/code>, &lt;code>25&lt;/code>, &lt;code>50&lt;/code>, &lt;code>75&lt;/code>).&lt;/p>
&lt;p>We can do this by iterating through the string in reverse order and checking how many digits do not match with each pattern, keeping track of the minimum number of deletions for each.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Analyzing Possible Endings:&lt;/strong> A number that is divisible by 25 must have one of the four possible endings: &amp;lsquo;00&amp;rsquo;, &amp;lsquo;25&amp;rsquo;, &amp;lsquo;50&amp;rsquo;, &amp;lsquo;75&amp;rsquo;.&lt;/li>
&lt;li>&lt;strong>Reverse Traversal of String:&lt;/strong> Traverse the string from right to left, keeping flags for the presence of &amp;lsquo;5&amp;rsquo; and &amp;lsquo;0&amp;rsquo;. Using these flags, look for possible endings &amp;lsquo;00&amp;rsquo;, &amp;lsquo;25&amp;rsquo;, &amp;lsquo;50&amp;rsquo;, &amp;lsquo;75&amp;rsquo;.&lt;/li>
&lt;li>&lt;strong>Operation Count:&lt;/strong> During the traversal, count the minimum number of operations required to make the number special.&lt;/li>
&lt;li>&lt;strong>Zero Check:&lt;/strong> If &amp;lsquo;0&amp;rsquo; is not present in the string, then the number cannot be made special, and the number of operations would be equal to the length of the string.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize variables to track the presence of &amp;lsquo;5&amp;rsquo; and &amp;lsquo;0&amp;rsquo;.&lt;/li>
&lt;li>Reverse traversal through the string, search for possible endings, and operation count.&lt;/li>
&lt;li>Return the result.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">minimumOperations&lt;/span>(num: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(num)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Initialize variables to track the presence of &amp;#39;5&amp;#39; and &amp;#39;0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_5 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_0 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Reverse traversal through the string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;0&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;00&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;5&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;50&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_5 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;2&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;25&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_5 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;7&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;75&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Update the flags for the presence of &amp;#39;5&amp;#39; and &amp;#39;0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_0 &lt;span style="color:#666">=&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">or&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_5 &lt;span style="color:#666">=&lt;/span> had_5 &lt;span style="color:#007020;font-weight:bold">or&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;5&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">else&lt;/span> n
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2849. Determine if a Cell Is Reachable at a Given Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2849/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2849/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/determine-if-a-cell-is-reachable-at-a-given-time">LeetCode problem 2849&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given starting coordinates &lt;code>(sx, sy)&lt;/code> and final coordinates &lt;code>(fx, fy)&lt;/code> on a 2D infinite grid. Starting from the initial position, you can move to any of the 8 adjacent cells in one second. The challenge is to determine if you can reach the final cell &lt;code>(fx, fy)&lt;/code> in exactly &lt;code>t&lt;/code> seconds.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to use a recursive function to navigate the grid from the starting point &lt;code>(sx, sy)&lt;/code> and attempt to reach the target &lt;code>(fx, fy)&lt;/code> in &lt;code>t&lt;/code> seconds. This approach will check every possible path, which can be very inefficient, especially for larger grids and values of &lt;code>t&lt;/code>.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Understand that not all paths are equal. Moving diagonally is more efficient than moving in a straight line if both x and y distances are positive.&lt;/li>
&lt;li>Check the constraints. If you cannot reach the destination within the given time &lt;code>t&lt;/code>, there&amp;rsquo;s no need to try any further.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The idea is to calculate the shortest possible time to reach the target and then compare it to the given time &lt;code>t&lt;/code>. If the starting point and the ending point are the same, we can always return to the same position unless the time is exactly 1.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Calculate the difference in x (&lt;code>diff_x&lt;/code>) and y (&lt;code>diff_y&lt;/code>) coordinates.&lt;/li>
&lt;li>For the minimum of &lt;code>diff_x&lt;/code> and &lt;code>diff_y&lt;/code>, move diagonally. This reduces both x and y distances by 1 in a single step.&lt;/li>
&lt;li>Move horizontally or vertically for the absolute difference between &lt;code>diff_x&lt;/code> and &lt;code>diff_y&lt;/code>.&lt;/li>
&lt;li>If &lt;code>(diff_x + diff_y)&lt;/code> is less than or equal to &lt;code>t&lt;/code>, and &lt;code>(t - (diff_x + diff_y))&lt;/code> is an even number or zero, return &lt;code>True&lt;/code>, otherwise return &lt;code>False&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">isReachableAtTime&lt;/span>(sx: &lt;span style="color:#007020">int&lt;/span>, sy: &lt;span style="color:#007020">int&lt;/span>, fx: &lt;span style="color:#007020">int&lt;/span>, fy: &lt;span style="color:#007020">int&lt;/span>, t: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> diff_x &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(fx &lt;span style="color:#666">-&lt;/span> sx) &lt;span style="color:#60a0b0;font-style:italic"># Calculating the differences in x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> diff_y &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(fy &lt;span style="color:#666">-&lt;/span> sy) &lt;span style="color:#60a0b0;font-style:italic"># and y coordinates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> diff_x &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> diff_y &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># If both starting and ending points are same&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> t &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> diff_x &lt;span style="color:#666">&amp;lt;=&lt;/span> t &lt;span style="color:#007020;font-weight:bold">and&lt;/span> diff_y &lt;span style="color:#666">&amp;lt;=&lt;/span> t: &lt;span style="color:#60a0b0;font-style:italic"># Check if we can reach the target within given time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>