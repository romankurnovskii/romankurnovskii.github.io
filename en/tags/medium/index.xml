<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Medium on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/medium/</link><description>Recent content in Medium on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 10 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem
Given the &amp;lsquo;head&amp;rsquo; of a linked list, remove the &amp;rsquo;nth&amp;rsquo; node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Idea:
Two pointers. Second pointer starts from nth position. Run while second pointer exist. First version:
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem 166
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</guid><description>LeetCode problem
Problem Statement Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Naive Solution A simple, but inefficient, approach would be to rotate the array k times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode problem
Problem Statement Given an encoded string, the task is to decode it to produce a string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.
Naive Solution A naive approach would be to repeatedly look for a pattern in the string where there is a number followed by square brackets. For each such pattern found, replace it with the string inside the square brackets repeated &amp;lsquo;k&amp;rsquo; times. This would work but might not be the most efficient solution, especially for nested brackets.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode problem 725
Problem Statement The problem asks you to divide a given singly linked list into k different parts such that the sizes of these parts are as nearly equal as possible. The parts should appear in the same order as in the original list, and earlier parts should not be smaller than later parts.
Naive Solution A naive approach would involve counting the length of the list and then traversing the list multiple times to create each part.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode problem
Problem Statement Imagine a row of asteroids moving in space. Each asteroid has a size (given by its absolute value) and a direction it&amp;rsquo;s moving in (given by its sign: positive for right, negative for left). All asteroids move at the same speed. Your task is to determine the final state of the asteroids after all collisions have been resolved.
Two important points to note:
When two asteroids of different directions meet, the smaller one explodes. If they are of the same size, both explode.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</guid><description>LeetCode Problem 1004
Problem Statement Given a binary array nums and an integer k, the task is to return the maximum number of consecutive 1&amp;rsquo;s in the array, with the possibility to flip at most k 0&amp;rsquo;s.
Naive Solution A straight forward approach is to try flipping every combination of k zeros and checking for the longest sequence of 1&amp;rsquo;s. This would involve nested loops, with the outer loop iterating through the array and the inner loops flipping zeros and calculating sequences of 1&amp;rsquo;s.</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1372/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1372/</guid><description>LeetCode problem 1372
Problem Statement Given the root of a binary tree, the task is to find the longest ZigZag path contained in that tree. A ZigZag path is defined by a sequence starting at any node and switching between left and right directions at each subsequent step.
Naive Solution A simplistic approach would be to kick off from every node and emulate the ZigZag movement until it&amp;rsquo;s no longer feasible, all the while updating the longest path encountered.</description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</guid><description>LeetCode Problem 1456
Problem Statement Given a string s and an integer k, the task is to return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.
Naive Solution The most straightforward solution to this problem is to take every possible substring of length k and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length k.</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode problem 2352
Problem Statement You are given a square grid of integers, specifically a 0-indexed n×n matrix named grid. The objective is to determine how many pairs of rows and columns in the grid are identical in terms of their content and order.
To elucidate, if row $r_i$ and column $c_j$ have the same integers in the exact same sequence, they are considered an &amp;ldquo;equal&amp;rdquo; pair. The challenge is to count all such pairs in the given matrix.</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2840. Check if Strings Can be Made Equal With Operations II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</guid><description>LeetCode Problem 2840
Problem Statement You are given two strings s1 and s2, both of length n, consisting of lowercase English letters. You can apply certain operations to make them equal. The question is, is it possible?
Naive Solution A naive approach would be to try all possible swap operations and compare the two strings at each step, which would be highly inefficient.
Hints &amp;amp; Tips Observe that swapping can only occur at indices i and j where j - i is even.</description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</guid><description>LeetCode Problem 2841
Problem Statement You are given an integer array nums and two positive integers m and k.
The task is to return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray is almost unique if it contains at least m pairwise distinct elements.
Naive Solution A naive solution would be to generate all the possible subarrays of length k and check each one to see if it is almost unique and what its sum is.</description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2844/</guid><description>LeetCode problem 2844
Problem Statement You are given a 0-indexed string num representing a non-negative integer. In one operation, you can pick any digit of num and delete it. Note that if you delete all the digits of num, num becomes 0.
Return the minimum number of operations required to make num special. An integer x is considered special if it is divisible by 25.
Naive Solution A naive approach to solving this problem might involve recursively generating all possible substrings of the input string, checking each one for divisibility by 25.</description></item><item><title>2849. Determine if a Cell Is Reachable at a Given Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2849/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2849/</guid><description>LeetCode problem 2849
Problem Statement You are given starting coordinates (sx, sy) and final coordinates (fx, fy) on a 2D infinite grid. Starting from the initial position, you can move to any of the 8 adjacent cells in one second. The challenge is to determine if you can reach the final cell (fx, fy) in exactly t seconds.
Naive Solution A naive approach would be to use a recursive function to navigate the grid from the starting point (sx, sy) and attempt to reach the target (fx, fy) in t seconds.</description></item></channel></rss>