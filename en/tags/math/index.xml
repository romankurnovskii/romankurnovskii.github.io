<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/math/</link><description>Recent content in Math on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2022 &lt;a href="https://romankurnovskii.com">Roman Kurnovskii&lt;/a> personal page</copyright><lastBuildDate>Mon, 09 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/13-roman-to-integer/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/13-roman-to-integer/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>66. Plus One</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/66-plus-one/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/66-plus-one/</guid><description>LeetCode problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Example 1:
Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.</description></item><item><title>69. Sqrt(x)</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/69-sqrtx/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/69-sqrtx/</guid><description>LeetCode problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2. Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/70-climbing-stairs/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/70-climbing-stairs/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/2-add-two-numbers/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/2-add-two-numbers/</guid><description>Before task: Create function for test data - code snippet You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807.</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/7-reverse-integer/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/7-reverse-integer/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/29-divide-two-integers/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/29-divide-two-integers/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1].</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/33-search-in-rotated-sorted-array/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/33-search-in-rotated-sorted-array/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/48-rotate-image/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/48-rotate-image/</guid><description>LeetCode problem
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;quot;&amp;quot;&amp;quot; Do not return anything, modify matrix in-place instead.</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</description></item></channel></rss>