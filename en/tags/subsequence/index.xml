<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Subsequence on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/subsequence/</link><description>Recent content in Subsequence on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Sun, 06 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/subsequence/index.xml" rel="self" type="application/rss+xml"/><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/is-subsequence/">LeetCode problem 392&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given two strings &lt;code>s&lt;/code> and &lt;code>t&lt;/code>, you need to determine if &lt;code>s&lt;/code> is a subsequence of &lt;code>t&lt;/code>. To be a subsequence, you can remove characters from &lt;code>t&lt;/code> without reordering to form &lt;code>s&lt;/code>.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>The naive approach would be to generate all subsequences of string &lt;code>t&lt;/code> and then check if string &lt;code>s&lt;/code> is one of them. However, generating all subsequences of &lt;code>t&lt;/code> can be computationally expensive especially when the length of &lt;code>t&lt;/code> is large.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>Understanding the nature of the problem is vital. This problem can be visualized as two pointers moving through both strings. If characters match, move both pointers. If not, only move the pointer in &lt;code>t&lt;/code>.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>To determine if &lt;code>s&lt;/code> is a subsequence of &lt;code>t&lt;/code>, we can use a two-pointer technique.&lt;/p>
&lt;ol>
&lt;li>Begin by initializing two pointers at the start of &lt;code>s&lt;/code> and &lt;code>t&lt;/code>.&lt;/li>
&lt;li>Move through &lt;code>t&lt;/code>, looking for a match with the current character of &lt;code>s&lt;/code>.&lt;/li>
&lt;li>If you find a match, move to the next character in &lt;code>s&lt;/code>.&lt;/li>
&lt;li>If you reach the end of &lt;code>s&lt;/code> while doing this, it means &lt;code>s&lt;/code> is a subsequence of &lt;code>t&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two pointers &lt;code>i&lt;/code> and &lt;code>j&lt;/code> to 0. &lt;code>i&lt;/code> points to characters in &lt;code>s&lt;/code> while &lt;code>j&lt;/code> points to characters in &lt;code>t&lt;/code>.&lt;/li>
&lt;li>Traverse through &lt;code>t&lt;/code> using the pointer &lt;code>j&lt;/code>.&lt;/li>
&lt;li>When &lt;code>s[i]&lt;/code> is equal to &lt;code>t[j]&lt;/code>, increment &lt;code>i&lt;/code>.&lt;/li>
&lt;li>If &lt;code>i&lt;/code> becomes equal to the length of &lt;code>s&lt;/code>, return True since it means all characters of &lt;code>s&lt;/code> are present in &lt;code>t&lt;/code> in order.&lt;/li>
&lt;li>If the loop completes and &lt;code>i&lt;/code> is not equal to the length of &lt;code>s&lt;/code>, return False.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">isSubsequence&lt;/span>(s, t):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Initialize two pointers at the start of the strings.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i, j &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(t):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># If the current characters match, move to the next character in s.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> i &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(s) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> s[i] &lt;span style="color:#666">==&lt;/span> t[j]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># If all characters in s were found in t, return True.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> i &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#007020">len&lt;/span>(s)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>