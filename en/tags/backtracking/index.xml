<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Backtracking on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/backtracking/</link><description>Recent content in Backtracking on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 &lt;a href="https://romankurnovskii.com">Roman Kurnovskii&lt;/a> personal page</copyright><lastBuildDate>Sat, 17 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/backtracking/index.xml" rel="self" type="application/rss+xml"/><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/17-letter-combinations-of-a-phone-number/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/17-letter-combinations-of-a-phone-number/</guid><description>LeetCode problem
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] Example 2:
Input: digits = &amp;quot;&amp;quot; Output: [] First accepted 1class Solution: 2 def letterCombinations(self, digits: str) -&amp;gt; List[str]: 3 if not digits: 4 return [] 5 6 letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, 7 &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, 8 &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] 9 10 result = [&amp;#39;&amp;#39;] 11 12 for d in digits: 13 d = int(d) 14 tmp = [] 15 for letter in letters[d]: 16 for word in result: 17 word += letter 18 tmp.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/22-generate-parentheses/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/22-generate-parentheses/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
1class Solution: 2 def generateParenthesis(self, n): 3 ans = [] 4 5 def dfs(l: int, r: int, s: str) -&amp;gt; None: 6 if l == 0 and r == 0: 7 ans.append(s) 8 if l &amp;gt; 0: 9 dfs(l - 1, r, s + &amp;#39;(&amp;#39;) 10 if l &amp;lt; r: 11 dfs(l, r - 1, s + &amp;#39;)&amp;#39;) 12 13 dfs(n, n, &amp;#39;&amp;#39;) 14 return ans</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/en/docs/algorithms-101/problems/46-permutations/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/docs/algorithms-101/problems/46-permutations/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 1class Solution: 2 def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: 3 4 result_permutation = [] 5 6 if len(nums) == 1: # base case 7 return [nums[:]] 8 9 for _ in nums: 10 tmp_removed = nums.</description></item></channel></rss>