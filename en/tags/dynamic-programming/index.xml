<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dynamic Programming on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tags/dynamic-programming/</link><description>Recent content in Dynamic Programming on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sat, 23 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
class Solution: def generateParenthesis(self, n): ans = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: ans.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return ans</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 10^9.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>122. Best Time to Buy and Sell Stock II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/122/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/122/</guid><description>LeetCode problem
To solve this problem, we can use a greedy approach.
The idea is to keep adding the profit whenever the price on the next day is higher than the price on the current day.
This way, we will maximize profit.
class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = 0 for i in range(1, len(prices)): if prices[i] &amp;gt; prices[i - 1]: profit += prices[i] - prices[i - 1] return profit LeetCode Editorial:
Editorial</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</guid><description>LeetCode problem 799
Problem Statement You are tasked with modeling a champagne tower. Glasses are stacked in a pyramid, with each row having one more glass than the previous. When champagne is poured into the top glass and it overflows, the overflowed champagne is split equally between the two glasses below. The objective is to determine how full a specified glass will be after pouring a given amount of champagne.
Naive Solution One could imagine a simulation, where we pour champagne into the top glass and then, glass-by-glass, simulate the overflow until we reach the desired glass.</description></item><item><title>1048. Longest String Chain</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</guid><description>LeetCode problem 1048
Problem Statement You are given an array of words where each word consists of lowercase English letters. Your task is to determine the longest string chain you can form given this list. A word A can be a predecessor of word B if by adding exactly one letter to A (at any position), B is formed. The objective is to find the longest sequence where each word is a predecessor of the next.
Naive Solution The straightforward brute-force way would be to try all possible combinations of word chains.</description></item><item><title>1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1420/</link><pubDate>Thu, 21 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1420/</guid><description>LeetCode Problem 1420
Problem Statement In this problem, we have three integers, n, m, and k. We need to construct an array arr having the following properties:
It consists of exactly n integers. Each integer in the array is between 1 and m inclusive. After executing a certain algorithm on arr, we get a value known as search_cost. Our goal is to ensure search_cost is equal to k. The main challenge is determining how many ways we can construct such an array arr.</description></item></channel></rss>