<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>02: Combinatorics &amp; Geometry on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/</link><description>Recent content in 02: Combinatorics &amp; Geometry on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Thu, 13 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/index.xml" rel="self" type="application/rss+xml"/><item><title>1777A - Everybody Likes Good Arrays! - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777a/</guid><description>1777A - Everybody Likes Good Arrays! (greedy, math, 800)
Statement You have an array of numbers, and you want to make it &amp;ldquo;good.&amp;rdquo; A good array is one where every pair of adjacent numbers has different parity (one is even, and the other is odd). You can do this by performing operations on pairs of adjacent numbers with the same parity (both even or both odd), and replacing them with their product. Logic Loop through the array Check the parity of the current element and the previous element If the parity is the same, perform the operation and increment the operation counter Repeat steps 2 and 3 until the end of the array Return the operation counter Solution def solve(n, ar): res = 0 i = 0 while i &amp;lt; len(ar) - 1: if ar[i] % 2 == ar[i + 1] % 2: ar[i] = ar[i] * ar[i + 1] del ar[i + 1] res += 1 else: i += 1 return res Optimized Solution Check how many times the parity changes in the given array.</description></item><item><title>1787A - Exponential Equation - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</guid><description>1787A - Exponential Equation (constructive algorithms, math, 800)
Logic The equation is a mix of multiplication and exponential operations. Given the nature of exponential operations, $ùë•^ùë¶$ and $ùë¶^ùë•$ can grow very large very quickly as x and y increase.
We can try to simplify the equation.
If we can somehow set one of the variables x or y to 1, the equation simplifies.
This is because any number (except zero) raised to the power of 1 is the number itself, and any number raised to the power of 0 is 1.</description></item><item><title>1777B - Emordnilap - 900</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1777b/</guid><description>1777B - Emordnilap (combinatorics, greedy, math, 900)
Statement In this problem, we need to find the &amp;ldquo;beauty&amp;rdquo; of all permutations of a certain length n. The beauty of a permutation is defined as the number of inversions in an array that is created by combining the permutation and its reverse.
Logic The key insight is that every permutation of length n has the same beauty.
This is because the structure of the array created by concatenating a permutation with its reverse ensures that there will always be the same number of inversions, regardless of the order of the numbers in the original permutation.</description></item><item><title>1773F - Football - 800</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1773f/</guid><description>1773F - Football (constructive algorithms, 800)
Logic Solution def solve(): n = int(input()) # number of matches a = int(input()) # goals scored b = int(input()) # goals conceded if n == 1: if a == b: print(1) else: print(0) print(f&amp;#34;{a}:{b}&amp;#34;) return matches = [[0, 0] for _ in range(n + 1)] draw = 0 match = 1 while match &amp;lt;= n and a &amp;gt; 0: a -= 1 matches[match] = [1, 0] match += 1 if a &amp;gt; 0: matches[1] = [matches[1][0] + a, 0] if b &amp;gt; 0: if match == n + 1: matches[1][0] += 1 matches[n][0] -= 1 matches[n][1] = b else: while match &amp;lt;= n and b &amp;gt; 0: b -= 1 matches[match][1] += 1 match += 1 if b &amp;gt; 0: matches[n][1] += b for i in range(1, n + 1): if matches[i][0] == matches[i][1]: draw += 1 print(draw) for i in range(1, n + 1): print(f&amp;#34;{matches[i][0]}:{matches[i][1]}&amp;#34;) solve() Codeforces Editorial PDF</description></item></channel></rss>