<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Other on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/</link><description>Recent content in Other on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sat, 29 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/index.xml" rel="self" type="application/rss+xml"/><item><title>8. String to Integer (atoi)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/8/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/8/</guid><description>LeetCode problem
// .js /** * @param {string} s * @return {number} */ var myAtoi = function(s) { let res = 0; let num = parseInt(s); if(num &amp;gt;= 2147483648){ res = 2147483647; } else if (num &amp;lt;= -2147483648){ res = -2147483648; } else if (isNaN(num)) { res = 0; } else { res = num; } return res; };</description></item><item><title>134. Gas Station</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/134/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/134/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to try starting from each gas station and check if you can complete the circuit. For each gas station, calculate the remaining gas in the tank after traveling to the next station.
If the gas is not enough to travel to the next station, stop and try starting from the next gas station.
Approach:
In this problem, we can use a greedy algorithm
We can keep track of the total gas and total cost while iterating through the gas stations.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/138/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/138/</guid><description>LeetCode problem
The problem asks to create a deep copy of a given linked list with a random pointer in each node. A deep copy means that the new linked list will have completely new nodes, and none of its pointers should point to the nodes in the original list. Both the next and random pointers of the new nodes should point to the new nodes in the copied list in the same order as the original list.</description></item><item><title>139. Word Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/139/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/139/</guid><description>LeetCode problem
Approach:
Dynamic Programming.
Logic:
Using DP:
Iterate through each character of string s. Generate all possible substrings ending at the current index. Check if the substring is in wordDict: If it is, check if the index before the substring&amp;rsquo;s first index is marked as True (this indicates that the part of the string before the current substring can be segmented into words in wordDict). If it is, then mark the current index as True. Solution:
class Solution: def wordBreak(self, s, wordDict): n = len(s) dp = [False] * n for end in range(1, n + 1): # 1.</description></item><item><title>146. LRU Cache</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/146/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/other/146/</guid><description>LeetCode problem
The operations we need to support are get and put which should both be done in O(1) time.
get(key) should return the value if the key exists in the cache, otherwise return -1. put(key, value) should update the value of the key if the key exists; otherwise, this method should insert the key-value pair into the cache. If the cache is full, this method should also evict the least recently used key-value pair. Approcah Use Doubly Linked List or Python OrderedDict</description></item></channel></rss>