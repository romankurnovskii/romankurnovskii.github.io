<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hard on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/</link><description>Recent content in Hard on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/index.xml" rel="self" type="application/rss+xml"/><item><title>332. Reconstruct Itinerary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</guid><description>LeetCode problem
Problem Statement Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from &amp;ldquo;JFK&amp;rdquo;, thus, the itinerary must begin with &amp;ldquo;JFK&amp;rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
Naive Solution One naive solution would be to use backtracking and try all possible combinations of tickets to form a valid itinerary.</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>880. Decoded String at Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/880/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/880/</guid><description>LeetCode problem 880
Problem Statement Given an encoded string s, the encoded string is transformed into a tape based on the following criteria:
When a letter is encountered, it&amp;rsquo;s written on the tape. When a digit d is encountered, the current content of the tape is repeated d - 1 more times. You are required to find and return the kth letter (1-indexed) on the decoded tape.
Naive Solution A straightforward solution would involve constructing the entire decoded tape and then simply accessing the kth character.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1004/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1004/</guid><description>LeetCode Problem 1004
Problem Statement Given a binary array nums and an integer k, the task is to return the maximum number of consecutive 1&amp;rsquo;s in the array, with the possibility to flip at most k 0&amp;rsquo;s.
Naive Solution A straight forward approach is to try flipping every combination of k zeros and checking for the longest sequence of 1&amp;rsquo;s. This would involve nested loops, with the outer loop iterating through the array and the inner loops flipping zeros and calculating sequences of 1&amp;rsquo;s.</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1372/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1372/</guid><description>LeetCode problem 1372
Problem Statement Given the root of a binary tree, the task is to find the longest ZigZag path contained in that tree. A ZigZag path is defined by a sequence starting at any node and switching between left and right directions at each subsequent step.
Naive Solution A simplistic approach would be to kick off from every node and emulate the ZigZag movement until it&amp;rsquo;s no longer feasible, all the while updating the longest path encountered.</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1732/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1732/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a biker who is going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal to 0.
We are also given an integer array gain of length n where gain[i] represents the net gain in altitude between points i and i + 1 for all 0 &amp;lt;= i &amp;lt; n. The net gain could be negative, indicating a decrease in altitude, or positive, indicating an increase in altitude.</description></item><item><title>1887. Reduction Operations to Make the Array Elements Equal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1887/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1887/</guid><description>LeetCode Problem 1887
Problem Statement The goal of this problem is to make all elements in a given integer array nums equal, through a series of reduction operations. In each operation, we find the largest element in the array, find the next largest element that is strictly smaller than the largest, and reduce the largest element to this next largest value. The task is to return the number of such operations needed to make all array elements equal.</description></item><item><title>2251. Number of Flowers in Full Bloom</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</guid><description>LeetCode Problem 2251
Problem Statement In the given problem, we are presented with two arrays. The first, flowers, represents when each flower starts and stops being in full bloom. The second, people, indicates when each person arrives to see the flowers. Our task is to determine, for each person, how many flowers they will see in full bloom upon their arrival.
Naive Solution A straightforward approach might involve iterating over each person&amp;rsquo;s arrival time. For each time, we could iterate over the flowers list to count how many flowers are in full bloom.</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2402. Meeting Rooms III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2402/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2402/</guid><description>LeetCode problem 2402
Given n rooms and a list of meetings with start and end times, allocate each meeting to an unused room with the lowest number. If all rooms are in use, meetings are delayed until a room is available, maintaining their original duration. Meetings are prioritized by their original start times. The task is to return the room number that hosts the most meetings. If multiple rooms host the same maximum number of meetings, return the room with the lowest number.</description></item><item><title>2839. Check if Strings Can be Made Equal With Operations I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2839/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2839/</guid><description>LeetCode Problem
Problem Statement You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters. The objective is to find out if it&amp;rsquo;s possible to make the two strings equal by swapping certain pairs of characters.
Naive Solution A naive approach would be to try out all possible swap combinations. However, this can be very inefficient, especially when the strings have a large number of characters.
Hints &amp;amp; Tips Observe that the swapping condition is quite specific: j - i = 2.</description></item><item><title>2849. Determine if a Cell Is Reachable at a Given Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2849/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2849/</guid><description>LeetCode problem 2849
Problem Statement You are given starting coordinates (sx, sy) and final coordinates (fx, fy) on a 2D infinite grid. Starting from the initial position, you can move to any of the 8 adjacent cells in one second. The challenge is to determine if you can reach the final cell (fx, fy) in exactly t seconds.
Naive Solution A naive approach would be to use a recursive function to navigate the grid from the starting point (sx, sy) and attempt to reach the target (fx, fy) in t seconds.</description></item><item><title>3016. Minimum Number of Pushes to Type Word II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3016/</guid><description>LeetCode problem 3016
class Solution: def minimumPushes(self, word: str) -&amp;gt; int: cnt = Counter(word) res = 0 for i, x in enumerate(sorted(cnt.values(), reverse=True)): res += (i // 8 + 1) * x return res</description></item><item><title>3032</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3032/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3032/</guid><description>https://leetcode.com/problems/count-numbers-with-unique-digits-ii
class Solution: def numberCount(self, a: int, b: int) -&amp;gt; int: # Initialize the count of numbers with all unique digits unique_digit_count = 0 # Loop through each number in the range from a to b, inclusive for num in range(a, b + 1): # Convert the number to a string to examine its digits num_str = str(num) # Convert the string to a set of characters to remove duplicates unique_digits = set(num_str) # If the length of the set is equal to the length of the number string, # it means all digits are unique if len(unique_digits) == len(num_str): # Increment the count for each number with all unique digits unique_digit_count += 1 # Return the total count of unique digit numbers return unique_digit_count</description></item><item><title>3045. Count Prefix and Suffix Pairs II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3045/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/3045/</guid><description>LeetCode problem 3045
Hint To solve this problem efficiently, consider using a Trie (prefix tree) to store each word in a way that allows checking for prefixes and suffixes simultaneously.
Idea The key idea is to leverage a Trie data structure, but with a twist: instead of only considering prefixes (as is typical with tries), we also account for suffixes simultaneously. This dual consideration allows us to efficiently count valid prefix-suffix pairs among the words.
Approach Trie Construction: Build a Trie where each node represents a pair of characters (prefix_char, suffix_char) from a word and its reversed counterpart.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2808/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2808/</guid><description>class Solution: def minimumSeconds(self, nums: List[int]) -&amp;gt; int: d = defaultdict(list) for i, x in enumerate(nums): d[x].append(i) res = inf n = len(nums) for idx in d.values(): t = idx[0] + n - idx[-1] for i, j in pairwise(idx): t = max(t, j - i) res = min(res, t // 2) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2818/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2818/</guid><description>def primeFactors(n): i = 2 res = set() while i * i &amp;lt;= n: while n % i == 0: res.add(i) n //= i i += 1 if n &amp;gt; 1: res.add(n) return len(res) class Solution: def maximumScore(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 arr = [(i, primeFactors(x), x) for i, x in enumerate(nums)] n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, f, x in arr: while stk and stk[-1][0] &amp;lt; f: stk.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2826/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2826/</guid><description>class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: f = [0] * 3 for x in nums: g = [0] * 3 if x == 1: g[0] = f[0] g[1] = min(f[:2]) + 1 g[2] = min(f) + 1 elif x == 2: g[0] = f[0] + 1 g[1] = min(f[:2]) g[2] = min(f) + 1 else: g[0] = f[0] + 1 g[1] = min(f[:2]) + 1 g[2] = min(f) f = g return min(f)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2827/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2827/</guid><description>class Solution: def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -&amp;gt; int: @cache def dfs(pos: int, mod: int, diff: int, lead: int, limit: int) -&amp;gt; int: if pos &amp;gt;= len(s): return mod == 0 and diff == 10 up = int(s[pos]) if limit else 9 res = 0 for i in range(up + 1): if i == 0 and lead: res += dfs(pos + 1, mod, diff, 1, limit and i == up) else: nxt = diff + (1 if i % 2 == 1 else -1) res += dfs(pos + 1, (mod * 10 + i) % k, nxt, 0, limit and i == up) return res s = str(high) a = dfs(0, 0, 10, 1, 1) dfs.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2846/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2846/</guid><description>class Solution: def minOperationsQueries( self, n: int, edges: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: m = n.bit_length() g = [[] for _ in range(n)] f = [[0] * m for _ in range(n)] p = [0] * n cnt = [None] * n depth = [0] * n for u, v, w in edges: g[u].append((v, w - 1)) g[v].append((u, w - 1)) cnt[0] = [0] * 26 q = deque([0]) while q: i = q.popleft() f[i][0] = p[i] for j in range(1, m): f[i][j] = f[f[i][j - 1]][j - 1] for j, w in g[i]: if j !</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2851/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2851/</guid><description>&amp;#34;&amp;#34;&amp;#34; DP, Z-algorithm, Fast mod. Approach How to represent a string? Each operation is just a rotation. Each result string can be represented by an integer from 0 to n - 1. Namely, it&amp;#39;s just the new index of s[0]. How to find the integer(s) that can represent string t? Create a new string s + t + t (length = 3 * n). Use Z-algorithm (or KMP), for each n &amp;lt;= index &amp;lt; 2 * n, calculate the maximum prefix length that each substring starts from index can match, if the length &amp;gt;= n, then (index - n) is a valid integer representation.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2852/</guid><description>class Solution: def sumRemoteness(self, grid: List[List[int]]) -&amp;gt; int: def dfs(i: int, j: int) -&amp;gt; (int, int): s, t = grid[i][j], 1 grid[i][j] = 0 for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; n and 0 &amp;lt;= y &amp;lt; n and grid[x][y] &amp;gt; 0: s1, t1 = dfs(x, y) s, t = s + s1, t + t1 return s, t n = len(grid) dirs = (-1, 0, 1, 0, -1) cnt = sum(x &amp;gt; 0 for row in grid for x in row) res = 0 for i, row in enumerate(grid): for j, x in enumerate(row): if x &amp;gt; 0: s, t = dfs(i, j) res += (cnt - t) * s return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2865/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2865/</guid><description>class Solution: def maximumSumOfHeights(self, maxHeights: List[int]) -&amp;gt; int: n = len(maxHeights) stk = [] left = [-1] * n for i, x in enumerate(maxHeights): while stk and maxHeights[stk[-1]] &amp;gt; x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] right = [n] * n for i in range(n - 1, -1, -1): x = maxHeights[i] while stk and maxHeights[stk[-1]] &amp;gt;= x: stk.pop() if stk: right[i] = stk[-1] stk.append(i) f = [0] * n for i, x in enumerate(maxHeights): if i and x &amp;gt;= maxHeights[i - 1]: f[i] = f[i - 1] + x else: j = left[i] f[i] = x * (i - j) + (f[j] if j !</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2874/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2874/</guid><description>class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2879/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2879/</guid><description>import pandas as pd def selectFirstRows(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: return employees.head(3)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2884/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2884/</guid><description>import pandas as pd def modifySalaryColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;salary&amp;#39;] *= 2 return employees</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2894/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2894/</guid><description>class Solution: def differenceOfSums(self, n: int, m: int) -&amp;gt; int: return sum(i if i % m else -i for i in range(1, n + 1))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2897/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2897/</guid><description>class Solution: def maxSum(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 cnt = [0] * 31 for x in nums: for i in range(31): if x &amp;gt;&amp;gt; i &amp;amp; 1: cnt[i] += 1 res = 0 for _ in range(k): x = 0 for i in range(31): if cnt[i]: x |= 1 &amp;lt;&amp;lt; i cnt[i] -= 1 res = (res + x * x) % mod return res</description></item></channel></rss>