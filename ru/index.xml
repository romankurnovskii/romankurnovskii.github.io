<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/</link><description>Recent content on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Mon, 12 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Two Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1/</guid><description>LeetCode problem
Problem Statement In this problem, you&amp;rsquo;re given an array of integers nums and an integer target. Your task is to find the indices of two numbers in the array that add up to the target. The input array is guaranteed to have exactly one solution, and you can&amp;rsquo;t use the same element twice. The indices can be returned in any order.
Naive Solution A naive solution would involve using two nested loops to iterate through each pair of elements in the array and check if their sum is equal to the target.</description></item><item><title>1. DevOps - общее представление</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day01/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day01/</guid><description>Введение - День 1 Первый день из 90, чтобы получить хорошее базовое понимание DevOps и инструментов.
Этот путь обучения начался для меня несколько лет назад, но тогда я сосредоточился на платформах виртуализации и облачных технологиях. В основном я изучал инфраструктуру как код и управление конфигурацией приложений с помощью Terraform и Chef.
Перенесемся в март 2021 года. Мне представилась прекрасная возможность сосредоточить свои усилия на стратегии Cloud Native в Kasten by Veeam. Это должно было стать огромным фокусом на Kubernetes и DevOps, а также на сообществе, окружающем эти технологии.</description></item><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2/</guid><description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. First accepted Idea:
Loop through lists add each value to the list reverse list calculate sum create linked list from reversed sum class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def createLinkedNode(values): head = ListNode(values[0]) current = head for i in values[1:]: node = ListNode(i) current.</description></item><item><title>Мультимедиа-устройства</title><link>https://romankurnovskii.com/ru/tracks/webrtc/media-devices/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/media-devices/</guid><description>Мультимедиа-устройства Начало работы с мультимедийными устройствами При web-разработке WebRTC-стандарт предоставляет API для доступа к камерам и микрофонам, подключенным к компьютеру или смартфону. Эти устройства обычно называются мультимедийными устройствами, и к ним можно получить доступ с помощью Java-скрипта через объект navigator.mediaDevices, который реализует интерфейс MediaDevices. С помощью этого объекта мы можем просмотреть все подключенные устройства, отслеживать изменения статуса устройства (когда устройство подключается или отключается) и открывать устройство для извлечения мультимедийного потока (см. ниже). Чаще всего для этого используют функцию getUserMedia(), которая возвращает промис, который будет преобразован в MediaStream для соответствующих мультимедийных устройств.</description></item><item><title>2. Задачи DevOps-инженера</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day02/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day02/</guid><description>Обязанности DevOps специалиста Надеюсь, вы приступили к этому после просмотра ресурсов и публикации в День 1 из #90DaysOfDevOps
В первом посте был краткий обзор, но теперь мы должны углубиться в концепцию DevOps и понять, что при создании приложения есть две основные части. У нас есть часть Разработка, где разработчики программного обеспечения программируют приложение и тестируют его. Затем у нас есть часть Операции, где приложение развертывается и поддерживается на сервере.
DevOps — это связующее звено между двумя Чтобы разобраться с DevOps или задачами, которые будет выполнять инженер DevOps, нам нужно понять инструменты или процесс, а также разобраться как они вместе они вместе взаимодейтвуют.</description></item><item><title>Захват мультимедиа и ограничения</title><link>https://romankurnovskii.com/ru/tracks/webrtc/media-capture-and-constraints/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/media-capture-and-constraints/</guid><description>Захват мультимедиа и ограничения Мультимедиа-часть WebRTC показывает, как получить доступ к оборудованию, способному записывать видео и аудио (например, камеры и микрофоны), а также как работают медиа-потоки. И помимо этого – средства отображения, которые позволяют делать захват экрана.
Мультимедиа-устройства Все камеры и микрофоны, поддерживаемые браузером, доступны и управляются через объект navigator.mediaDevices. Приложения могут получать текущий список подсоединенных устройств и отслеживать изменения, т.к. многие камеры и микрофоны подсоединены через USB, и могут подключаться/отключаться в течение работы приложения. Поскольку статус мультимедиа-устройства может меняться в любой момент времени, рекомендуем, чтоб приложения регистрировали все изменения в статусе устройства для правильной обработки статусов изменений.</description></item><item><title>3. Ориентированность на приложения</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day03/</link><pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day03/</guid><description>Жизненный цикл DevOps — ориентированность на приложения По мере того, как мы будем продолжать в течение следующих нескольких недель, мы будем сталкиваться с этими названиями (Continuous Development, Testing, Deployment, Monitor) (непрерывная разработка, тестирование, развертывание, мониторинг) снова и снова. Если вы стремитесь статья инженером DevOps, то повторяемость будет тем, к чему вы привыкнете, но постоянное улучшение каждый раз — это еще одна вещь, которая делает вещи интересными.
В этом часе мы рассмотрим общий вид приложения от начала до конца, а затем вернемся назад, как в постоянном цикле.</description></item><item><title>4. Median of Two Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</guid><description>LeetCode задача 4
Задача Даны два отсортированных массива nums1 и nums2 размера m и n соответственно. Найти медиану двух отсортированных массивов.
Подсказки Чтобы найти медиану, нужно сначала объединить два массива и отсортировать их. После этого медиана будет либо средним элементом, если общее количество элементов нечетное, либо средним значением двух центральных элементов, если общее количество элементов четное.
Подход Мы можем объединить два массива в один большой отсортированный массив и найти медиану этого массива. Этот подход не самый эффективный, но он прост и понятен.</description></item><item><title>Одноранговые соединения</title><link>https://romankurnovskii.com/ru/tracks/webrtc/peer-connections/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/peer-connections/</guid><description>Начало работы с одноранговыми соединениями Одноранговые соединения – часть спецификации WebRTC, которая занимается связью двух приложений на различных компьютерах для коммуникации через P2P-протокол. Коммуникация между узлами может быть видео-, аудио- или произвольными двоичными данными (для клиентов, поддерживающих RTCDataChannel API). Чтобы выяснить, как два узла могут быть соединены, оба клиента должны предоставить конфигурацию ICE-Server. Это или STUN, или TURN-сервер, и их роль – обеспечить ICE-кандидатов для каждого клиента, который затем передается на удаленный узел. Эта «передача» ICE-кандидатов обычно называется «сигналинг».</description></item><item><title>4. DevOps и Agile</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day04/</link><pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day04/</guid><description>DevOps и Agile Вы знаете разницу между DevOps и Agile? Они формировались как самостоятельные понятия. Но теперь эти два термина сливаются.
В этом посте мы рассмотрим важные различия между Agile и DevOps и выясним, почему они так тесно связаны.
Я думаю, что хорошее место для начала — это немного больше узнать об общем подходе, который я увидел в изучении этой области, а именно о DevOps и Agile, даже несмотря на то, что у них схожие цели и процессы. В этом разделе я, надеюсь, мы разберемся с этим.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/5/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/5/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>Удаленные потоки</title><link>https://romankurnovskii.com/ru/tracks/webrtc/remote-streams/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/remote-streams/</guid><description>Начало работы с удаленными потоками Как только RTCPeerConnection подключился к удаленному узлу, между ними можно передавать аудио- и видео-потоки. Это точка, в которой мы подключаем поток, полученный от getUserMedia(), к RTCPeerConnection. Медиаопоток состоит как минимум из одной дорожки мультимедиа, и они по отдельности добавляются в RTCPeerConnection, когда мы хотим передать данные удаленному узлу.
const localStream = await getUserMedia({vide: true, audio: true}); const peerConnection = new RTCPeerConnection(iceConfig); localStream.getTracks().forEach(track =&amp;gt; { peerConnection.addTrack(track, localStream); }); Дорожки можно добавлять в RTCPeerConnection до подключения к удаленному узлу, поэтому имеет смысл выполнить эту настройку как можно раньше, а не ждать завершения соединения.</description></item><item><title>5. Plan > Code > Build > Testing > Release > Deploy > Operate > Monitor</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day05/</link><pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day05/</guid><description>Сегодня мы сосредоточимся на отдельных шагах от начала до конца и на непрерывном цикле приложения в мире DevOps.
План Все начинается с процесса планирования, когда команда разработчиков собирается вместе и выясняет, какие типы функций и исправлений ошибок они собираются внедрить в следующем спринте. Это возможность для вас как инженера DevOps принять участие в этом и узнать, какие вещи будут происходить на вашем пути, с которыми вам нужно участвовать, а также повлиять на их решения или их путь и как бы помочь им работать с инфраструктура, которую вы построили, или направьте их к чему-то, что будет работать лучше для них, если они не на этом пути, и поэтому одна ключевая вещь, на которую здесь следует указать, это то, что разработчики или команда разработчиков программного обеспечения являются вашим клиентом как DevOps инженер, так что это ваша возможность поработать с вашим клиентом до того, как он пойдет по плохому пути.</description></item><item><title>Каналы данных</title><link>https://romankurnovskii.com/ru/tracks/webrtc/data-channels/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/data-channels/</guid><description>Стандарт WebRTC также охватывает API для отправки произвольных данных через RTCPeerConnection. Это происходит через запрос createDataChannel() для объекта RTCPeerConnection, который возвращает объект RTCDataChannel.
const peerConnection = new RTCPeerConnection(configuration); const dataChannel = peerConnection.createDataChannel();
Удаленный узел может получать каналы данных через отслеживание события datachannel в объекте RTCPeerConnection. Полученное событие имеет тип RTCDataChannelEvent и содержит свойство channel, которое представляет RTCDataChannel между двумя узлами.
const peerConnection = new RTCPeerConnection(configuration); peerConnection.addEventListener(&amp;#39;datachannel&amp;#39;, event =&amp;gt; { const dataChannel = event.channel; }); События Open и Close Прежде чем канал данных можно будет использовать для отправки данных, клиент должен дождаться его открытия.</description></item><item><title>6. DevOps - Истории</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day06/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day06/</guid><description>DevOps - Истории компаний DevOps с самого начала считался недосягаемым для многих из нас, поскольку у нас не было среды или требований, подобных Netflix или Fortune 500, но подумайте, что теперь это начинает становиться нормой, когда мы внедряем практику DevOps внутри. любой вид бизнеса.
По второй ссылке ниже в справочных материалах вы увидите множество различных отраслей и вертикалей, использующих DevOps и оказывающих огромное положительное влияние на свои бизнес-цели.
Очевидно, что основным преимуществом здесь является DevOps, если он выполнен правильно, он должен помочь вашему бизнесу повысить скорость и качество разработки программного обеспечения.</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/7/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/7/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:
Convert number to int Remove minus if exist (or convert module of number) reverse class Solution: def reverse(self, x: int) -&amp;gt; int: reversed_int = [] str_int = str(x) if x &amp;lt; 0: str_int = str_int[1:] for i in reversed(range(len(str_int))): reversed_int.</description></item><item><title>TURN сервер</title><link>https://romankurnovskii.com/ru/tracks/webrtc/turn-server/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/turn-server/</guid><description>Для работы большинства приложений WebRTC необходим сервер для ретрансляции трафика между узлами, поскольку прямой сокет часто невозможен между клиентами (если только они не находятся в одной локальной сети). Обычный способ решить эту проблему — использовать TURN-сервер (Traversal Using Relay NAT), который представляет собой протокол ретрансляции сетевого трафика.
В настоящее время существует несколько вариантов TURN-серверов, доступных в Интернете, как в виде самостоятельных приложений (например, проект COTURN с открытым исходным кодом), так и в виде облачных сервисов.
Если у вас есть доступный онлайн TURN-сервер, то все, что вам нужно - это правильная RTCConfiguration для вашего клиентского приложения.</description></item><item><title>7. DevOps - изучение языка программирования</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day07/</link><pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day07/</guid><description>Общая картина: DevOps и изучение языка программирования Я думаю, будет справедливо сказать, что для достижения успеха в качестве инженера DevOps в долгосрочной перспективе необходимо знать хотя бы один язык программирования на базовом уровне. Я хочу провести это первое занятие в этой статье, чтобы выяснить, почему это такой важный навык, и, надеюсь, к концу этой недели или раздела вы будете лучше понимать, почему, как и что делать. делайте, чтобы продвигаться в своем учебном путешествии.
Я думаю, что если бы я спросил в социальных сетях, нужны ли вам навыки программирования для ролей, связанных с DevOps, ответ, скорее всего, будет утвердительным?</description></item><item><title>8. String to Integer (atoi)</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/8/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/8/</guid><description>LeetCode problem
// .js /** * @param {string} s * @return {number} */ var myAtoi = function(s) { let res = 0; let num = parseInt(s); if(num &amp;gt;= 2147483648){ res = 2147483647; } else if (num &amp;lt;= -2147483648){ res = -2147483648; } else if (isNaN(num)) { res = 0; } else { res = num; } return res; };</description></item><item><title>Тестирование приложений WebRTC</title><link>https://romankurnovskii.com/ru/tracks/webrtc/testing/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/testing/</guid><description>При написании автоматических тестов для приложений WebRTC, существуют полезные конфигурации, которые можно включить для браузеров, и которые упростят разработку и тестирование.
Chrome При запуске автоматических тестов в Chrome полезны следующие функции:
&amp;ndash;allow-file-access-from-files — дает API-доступ для file://URLs &amp;ndash;disable-translate — отключает всплывающие окна &amp;ndash;use-fake-ui-for-media-stream — Представляет поддельные медиапотоки. Полезно при работе на CI-серверах. &amp;ndash;use-file-for-fake-audio-capture= — дает возможность использовать файл при захвате звука. &amp;ndash;use-file-for-fake-video-capture= — дает возможность использовать файл при захвате видео. &amp;ndash;headless - Запустить в автономном режиме. Полезно при работе на CI-серверах.</description></item><item><title>8. Настройка DevOps окружения для запуска Hello World на Go</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day08/</link><pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day08/</guid><description>Настройка DevOps окружения для запуска Hello World на Go Прежде чем мы приступим к некоторым основам Go, мы должны установить Go на нашу рабочую станцию и сделать то, чему нас учит каждый модуль «Изучение программирования 101», а именно создать приложение Hello World. Так как здесь будут описаны шаги по установке Go на ваш ПК, мы попытаемся задокументировать процесс в картинках, чтобы людям было легко следовать за ним.
Возможные варианты установки Golang
Исполняемый файл Пакет из исходного кода Mac Os Homebrew #Homebrew install command brew install go Быстрый тьюториал для ознакомления с языком Go</description></item><item><title>9. Palindrome Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/9/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/9/</guid><description>LeetCode задача
Задача Определите, является ли целое число палиндромом, не преобразуя его в строку.
Подсказки Переворачивая число и сравнивая его с оригиналом, мы можем определить, является ли оно палиндромом.
Подход Вместо того чтобы преобразовывать число в строку, мы можем перевернуть его цифры с использованием математических операций, а затем сравнить перевернутое число с оригинальным.
Алгоритм Если число отрицательное, то это не палиндром. Инициализируем переменную для перевернутого числа: мы будем создавать это число шаг за шагом. Переворачиваем число: Это достигается путем последовательного взятия последней цифры числа и добавления её к текущему общему количеству после сдвига текущих цифр этого общего числа.</description></item><item><title>Формат SDP унифицированного плана – план перехода</title><link>https://romankurnovskii.com/ru/tracks/webrtc/unified-plan-transition-guide/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/unified-plan-transition-guide/</guid><description>Google планирует перевести реализацию WebRTC в Chrome с текущего SDP-формата (называемого «Plan B») на формат соответствующих стандартов («Unified Plan», draft-ietf-rtcweb-jsep) в течение следующих нескольких кварталов. План включает 5 этапов и одну временную функцию API.
Кто будет затронут? Людям, которые используют несколько аудиодорожек или несколько видеодорожек в одном PeerConnection, придется протестировать свой продукт в рамках Унифицированного Плана и, соответственно, адаптироваться. В случае, когда вызов инициируется с конечной точки не из Chrome, и на него отвечают в Chrome, форма запросов может измениться.</description></item><item><title>9. Как работает hello-world на Golang</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day09/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day09/</guid><description>Разберемся как работает hello-world Как работает Go Вчера мы прошли процедуру установки Go на ПК, а затем создали наше первое приложение Go.
В этом разделе мы собираемся глубже изучить код и понять еще несколько вещей о языке Go.
Что такое компиляция? Прежде чем мы перейдем к 6 строкам кода Hello World, которые написали вчера, нам нужно немного разобраться в компиляции.
Языки программирования, которые мы обычно используем, такие как Python, Java, Go и C++, являются языками высокого уровня. Это означает, что они удобочитаемы для человека, но когда машина пытается выполнить программу, она должна быть в форме, понятной машине.</description></item><item><title>Дерево отрезков</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/data-structures/segment-tree/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/data-structures/segment-tree/</guid><description>Для изучения темы &amp;ldquo;дерево отрезков&amp;rdquo; необходимо знать следующие понятия:
массивы циклы условные операторы битовые операции Дерево отрезков (Segment Tree) - это динамическая структура данных, используемая для выполнения операций над интервалами и их обновления. Оно поддерживает две операции: обновление элементов (update) в заданном диапазоне и запрос (query) на сумму элементов в заданном диапазоне.
Выполним следующую задачу: у нас есть массив, и мы хотим находить сумму элементов в определенном диапазоне.
Для этой задачи мы можем использовать дерево отрезков. Оно построено как бинарное дерево, где каждый узел представляет интервал, а значение узла - это сумма элементов в этом интервале.</description></item><item><title>Дерево Фенвика</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/data-structures/fenwick-tree/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/data-structures/fenwick-tree/</guid><description>Дерево Фенвика, также известное как двоичное индексированное дерево (Binary Indexed Tree, BIT).
Терминология:
a - исходный массив tree - массив дерева, полученный в результате преобразований массива 'a' i - индекс массива k - индекс массива F(i) - еще не определенный индекс, полученный в реузльтате преобразования индекса `i`. F(i) &amp;lt;= i F(i) - функция, которую создадим позже. 0 1 2 3 4 5 6 7 a[ 5, 7, 9, 3, 8, 2, 4, 6] Сумма по текущему индексу содержит данные только с предыдущих индексов, не обязательно с нулевого.</description></item><item><title>Префиксные суммы</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/data-structures/prefix-sum/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/data-structures/prefix-sum/</guid><description>Подсчет префиксных сумм Сумма в текущей ячейке равна сумме в предыдущей + значение текущей.
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 a[ 5, 7, 9, 3, 8, 2, 4, 6] =&amp;gt; b[5, 12, 21, 24, 32, 34, 38, 44] 0 5 [5,] 1 5 + 7 = 12 [5,12,] 2 9 + 12 = 21 [5,12,21,] 3 3 + 21 = 24 [5,12,21,24,] ... Чтобы посчитать сумму на любом отрезкe [L, R], достаточно вычесть сумму с предыдущего индекса от `L'</description></item><item><title>Написание статей</title><link>https://romankurnovskii.com/ru/tracks/disser/articles-notes/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/articles-notes/</guid><description>Проверить журнал в диссернет
В аннотацию прописывать предложения, которые могут быть запрошены как поисковый запрос в поисковиках. Анотации индексируются поисковиками яндекс, гугл.
https://www.semanticscholar.org/ https://www.researchgate.net/ После выхода в сборнике:
Добавить на сайт pdf из журнала Добавить в ResearchGate IMF Report: September 16, 2022: West Bank and Gaza: Report to the AD HOC Liaison Committee
Конференции https://sciencen.org/konferencii/grafik-konferencij/ https://na-konferencii.ru/ https://konferencii.ru/ https://www.kon-ferenc.ru/econom.html https://www.hse.ru/science/HSEconf</description></item><item><title>10. Окружение Go</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day10/</link><pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day10/</guid><description>Окружение Go В 8-м дне мы кратко рассмотрели рабочее пространство Go, чтобы запустить его и перейти к демонстрации «Hello #90DaysOfDevOps». Но мы должны немного рассказать о рабочем пространстве Go.
Помните, что мы выбрали значения по умолчанию, а затем прошли и создали нашу папку Go в GOPATH, который уже был определен, но на самом деле этот GOPATH можно изменить, чтобы он находился там, где вы хотите.
Если вы запустите
echo $GOPATH Вывод должен быть похож на мой (может быть с другим именем пользователя), а именно:</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</guid><description>LeetCode задача 11
Задача Вам дан массив, в котором каждый элемент представляет высоту стены. Высоты стен разные. Две стены и пространство между ними образуют контейнер. Ваша задача - найти контейнер, который может вместить максимальное количество воды.
Подсказки Метод &amp;ldquo;Two Pointers&amp;rdquo;.
Подход Цель этой задачи - найти пару &amp;ldquo;стен&amp;rdquo;, между которыми будет находиться максимальное количество &amp;ldquo;воды&amp;rdquo;. Вместимость контейнера определяется двумя факторами: расстоянием между стенками и минимальной высотой из двух стенок.
Идея алгоритма заключается в следующем: начнем с самых &amp;ldquo;дальних&amp;rdquo; друг от друга стенок и будем постепенно &amp;ldquo;сужать&amp;rdquo; интервал, сдвигая одну из стенок внутрь массива.</description></item><item><title>Загрузка кода</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-get-code/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-get-code/</guid><description>Загрузка кода Если вы знакомы с сайтом git, вы можете скачать код для данной codelab с GitHub, клонировав его: git clone https://github.com/googlecodelabs/webrtc-web
Можно также нажать на ссылку ниже для загрузки zip-файла кода: https://github.com/googlecodelabs/webrtc-web/archive/master.zip
Откройте загруженный zip-файл. Разархивируйте папку проекта (adaptive-web-media), в которой по одной папке на каждый шаг этой codelab, и есть все необходимые вам ресурсы. Вы будете выполнять все действия в папке work.
Папки step-nn содержат финальную версию для каждого шага этой codelab. Они там для справки.</description></item><item><title>Обзор</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-overview/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-overview/</guid><description>Создайте приложение для получения видео и снимков с веб-камеры, с возможностью делиться ими в P2P через WebRTC. В ходе codelab вы узнаете, как использовать основные API WebRTC и настроить сервер обмена сообщениями через Node.js.
Чему вы научитесь
получать видео с вашей веб-камеры потоковое видео через RTCPeerConnection потоковая передача данных через RTCDataChannel настраивать сигналинг для обмена сообщениями комбинировать одноранговое соединение и сигналинг делать фото и передавать его через канал данных Что понадобится
Chrome версии 47 и выше веб-сервер для Chrome https://chrome.</description></item><item><title>11. Переменные и константы в Go</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day11/</link><pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day11/</guid><description>Прежде чем мы перейдем к темам сегодняшнего дня, я хочу выразить огромную благодарность Techworld with Nana и этому фантастическому краткому путешествию по основам Go.
В 8-м дне мы настроили нашу среду, в 9-м дне мы разобрали код Hello #90DaysOfDevOps, а в 10-м дне) мы поработали с нашей рабочей средой Go и немного углубились в компиляцию и запуск кода.
Сегодня мы рассмотрим переменные, константы и типы данных при написании новой программы.
Переменные и константы в Go Давайте начнем с планирования нашего приложения, я думаю, было бы неплохо поработать над программой, которая сообщает нам, сколько дней осталось в нашем испытании #90DaysOfDevOps.</description></item><item><title>12. Integer to Roman</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/12/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/12/</guid><description>LeetCode problem 12
class Solution: def intToRoman(self, num: int) -&amp;gt; str: cs = (&amp;#39;M&amp;#39;, &amp;#39;CM&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;CD&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;XC&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;XL&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;IX&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;IV&amp;#39;, &amp;#39;I&amp;#39;) vs = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) res = [] for c, v in zip(cs, vs): while num &amp;gt;= v: num -= v res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>Потоковое видео с веб-камеры</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-stream-to-cam/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-stream-to-cam/</guid><description>Чему вы научитесь:
На этом шаге вы узнаете, как
получить видеопоток с вашей веб-камеры управлять воспроизведением потока использовать CSS и SVG для обработки видео Полная версия этого шага находится в папке step-01. Немного HTML
Добавьте элемент video и элемент script в index.html в папку work.
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Realtime communication with WebRTC&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;css/main.css&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Realtime communication with WebRTC&amp;lt;/h1&amp;gt; &amp;lt;video autoplay playsinline&amp;gt;&amp;lt;/video&amp;gt; &amp;lt;script src=&amp;#34;js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; И немного JavaScript
Добавьте следующее в main.js в вашей папке js:</description></item><item><title>12. Golang - чтение данных и указатели</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day12/</link><pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day12/</guid><description>Получение данных с клавиуатуры Вчера (Днем 11-м) мы создали нашу первую программу Go, и данные, которые мы хотели получить от пользователя, были созданы как переменные в нашем коде. Теперь мы хотим спросить пользователя данные для ввода, чтобы дать переменной значение для конечного сообщения.
Получение пользовательских данных Прежде чем мы это сделаем, давайте еще раз взглянем на наше приложение и пройдемся по переменным, которые нам нужны в качестве теста, прежде чем получить этот пользовательский ввод.
Давайте теперь добавим новую переменную с именем TwitterName, вы можете найти этот новый код ниже, и если мы запустим этот код, это будет наш вывод.</description></item><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/13/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/13/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>Потоковое видео с помощью RTCPeerConnection</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-stream-with-rtcpeerconnection/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-stream-with-rtcpeerconnection/</guid><description>Чему вы научитесь
На этом шаге вы узнаете, как:
Абстрагироваться от различий браузера с помощью оболочки WebRTC, adapter.js. Использовать RTCPeerConnection API для потоковой передачи видео. Управлять захватом и потоковой передачей мультимедиа. Полная версия этого шага находится в папке step-2.
Что такое RTCPeerConnection?
RTCPeerConnection - это API для выполнения WebRTC-запросов для потоковой передачи видео и аудио и обмена данными.
В этом примере устанавливается соединение между двумя объектами RTCPeerConnection (известными как узлы) на одной и той же странице.
Не очень практично, но зато полезно для понимания того, как работает RTCPeerConnection.</description></item><item><title>13. Go - подключение Twitter API</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day13/</link><pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day13/</guid><description>Твитните о своем прогрессе с нашим новым приложением В последний день изучения этого языка программирования мы только коснулись его основ, но я думаю, что это начало.
За последние несколько дней мы взяли небольшую идею для приложения и добавили функциональность, в этой статье я хочу воспользоваться преимуществами тех пакетов, которые мы упомянули, и создать функциональность для нашего приложения, чтобы не только дать вам обновление вашего прогресса на экране, но также отправьте твит с подробностями задачи и вашим статусом.
Добавление возможности твитить свой прогресс Первое, что нам нужно сделать, это настроить доступ API разработчика к Twitter, чтобы это работало.</description></item><item><title>14. Longest Common Prefix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/14/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/14/</guid><description>LeetCode problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. First accepted Idea:
class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: strs.sort() l = strs[0] r = strs[-1] if l == r: return l res = &amp;#34;&amp;#34; for i in range(0, len(l)): if l[i] == r[i]: res += l[i] else: return res return res</description></item><item><title>Использование RTCDataChannel для обмена данными</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-rtcdatachannel-exchange-data/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-rtcdatachannel-exchange-data/</guid><description>Чему вы научитесь
как обмениваться данными между узлами WebRTC Полная версия этого шага находится в папке step-03.
Обновите свой HTML
На этом шаге вы будете использовать WebRTC каналы данных для отправки текста между двумя textarea элементами на одной странице. Это опять не сильно применимо на практике, но зато демонстрирует, как WebRTC можно использовать для обмена данными, а также для потоковых видео.
Удалите элементы video и button из index.html и замените их следующим HTML-кодом:
&amp;lt;textarea id=&amp;#34;dataChannelSend&amp;#34; disabled placeholder=&amp;#34;Press Start, enter some text, then press Send.</description></item><item><title>14. DevOps и Linux</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day14/</link><pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day14/</guid><description>Общая картина: DevOps и Linux Linux и DevOps имеют очень схожие культуры и взгляды; оба ориентированы на настройку и масштабируемость. Оба эти аспекта Linux имеют особое значение для DevOps.
Многие технологии начинаются с Linux, особенно если они связаны с разработкой программного обеспечения или управлением инфраструктурой.
Кроме того, многие проекты с открытым исходным кодом, особенно инструменты DevOps, с самого начала разрабатывались для работы в Linux.
С точки зрения DevOps или фактически с точки зрения какой-либо операционной роли вы столкнетесь с Linux, я бы сказал, в основном.</description></item><item><title>15. 3Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/15/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/15/</guid><description>LeetCode problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description></item><item><title>Настройка службы сигналинга для обмена сообщениями</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-setup-signaling-service/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-setup-signaling-service/</guid><description>Чему вы научитесь
На этом шаге вы узнаете, как:
Использовать npm для установки взаимосвязей, как указано в package.json Запускать сервер Node.js и использовать node-static для обслуживания статических файлов. Настраивать службу обмена сообщениями на Node.js через Socket.IO . Использовать это для создания ‘комнат&amp;quot; и обмена сообщениями. Полная версия этого шага находится в папке step-04.
Концепции
Чтобы установить и поддерживать вызов WebRTC, клиенты WebRTC (узлы) должны обмениваться метаданными:
Информация о кандидате (сети). сообщения offer и answer, содержащие информацию о медиа, например, о разрешении и кодеках.</description></item><item><title>15. Команды Linux в DevOps</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day15/</link><pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day15/</guid><description>Команды Linux для DevOps Я упомянул вчера, что мы собираемся провести много времени в терминале с некоторыми командами, чтобы что-то сделать.
Я также упомянул, что с нашей виртуальной машиной, подготовленной с помощью vagrant, мы можем использовать vagrant ssh и получить доступ к нашей машине. Вам нужно будет находиться в том же каталоге, из которого мы его предоставили.
Для SSH нам не понадобятся имя пользователя и пароль, они понадобятся нам только в том случае, если решим войти в консоль Virtual Box.</description></item><item><title>Соединение однорангового соединения и сигналинга</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-peer-signaling-combine/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-peer-signaling-combine/</guid><description>Чему вы научитесь
На этом шаге вы узнаете, как:
Запускать службу сигнализации WebRTC с помощью Socket.IO на Node.js Использовать эту службу для обмена метаданными WebRTC между узлами. Полная версия этого шага находится в папке step-05. Поменяйте HTML и JavaScript
Замените содержимое index.html следующим:
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Realtime communication with WebRTC&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/css/main.css&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Realtime communication with WebRTC&amp;lt;/h1&amp;gt; &amp;lt;div id=&amp;#34;videos&amp;#34;&amp;gt; &amp;lt;video id=&amp;#34;localVideo&amp;#34; autoplay muted&amp;gt;&amp;lt;/video&amp;gt; &amp;lt;video id=&amp;#34;remoteVideo&amp;#34; autoplay&amp;gt;&amp;lt;/video&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;/socket.io/socket.io.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://webrtc.github.io/adapter/adapter-latest.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Замените js/main.</description></item><item><title>16. Управление системой, файловой системой и хранилищем в Linux</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day16/</link><pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day16/</guid><description>Управление системой, файловой системой и хранилищем в Linux К этому времени мы кратко рассмотрели Linux и DevOps, а затем мы настроили нашу лабораторную среду с помощью vagant 14-й день), а затем коснулись небольшой части команд, которые будут в вашем ежедневном набор инструментов во время использования терминала - (День 15).
Сегодня мы рассмотрим три ключевые области обслуживания систем Linux с помощью обновлений, установки программного обеспечения. Поймем для чего используются системные папки, а также рассмотрим хранилище.
Управление Ubuntu и программным обеспечением Первое, что мы собираемся рассмотреть, это то, как мы обновляем нашу операционную систему.</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/17/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/17/</guid><description>LeetCode problem 17
class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] result = [&amp;#39;&amp;#39;] for d in digits: d = int(d) tmp = [] for letter in letters[d]: for word in result: word += letter tmp.append(word) result = tmp return result</description></item><item><title>Сделайте фото и отправьте его через канал данных</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-take-photo/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-take-photo/</guid><description>Чему вы научитесь
На этом шаге вы узнаете, как:
Делать снимок и получать из него данные, используя элемент canvas. Обмениваться изображениями с удаленным пользователем. Полная версия этого шага находится в папке step-06.
Как это работает
Ранее вы узнали, как обмениваться текстовыми сообщениями с помощью RTCDataChannel.
Этот шаг позволяет обмениваться целыми файлами: в этом примере - фотографиями, снятыми с помощью getUserMedia().
Основные части этого шага заключаются в следующем:
Установите канал передачи данных. Обратите внимание, что на этом шаге вы не добавляете никаких медиапотоков к одноранговому соединению.</description></item><item><title>17. Текстовые редакторы Nano/Vim</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day17/</link><pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day17/</guid><description>Текстовые редакторы nano и vim Большинство систем Linux - сервера, и у них не будет графического интерфейса. Я также упомянул в прошлой статье, что Linux в основном состоит из файлов конфигурации, и для внесения изменений вам потребуется иметь возможность редактировать эти файлы конфигурации, чтобы изменить что-либо в системе.
Существует множество вариантов, но я думаю, что мы должны рассмотреть, вероятно, два наиболее распространенных текстовых редактора терминала. Я использовал оба этих редактора, и для меня «nano» — это удобная кнопка, когда дело доходит до быстрых изменений, но у «vim» такой широкий набор возможностей.</description></item><item><title>Выводы</title><link>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-results/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/practice/practice-results/</guid><description>Вы создали приложение для потоковой передачи видео в реальном времени и обмена данными!
Что вы узнали
В этой codelab вы узнали, как:
Получать видео с вашей веб-камеры. стримить видео с помощью RTCPeerConnection. Стримить данные с помощью RTCDataChannel. Настраивать сигналинг-службу для обмена сообщениями. Комбинировать одноранговое соединение и сигналинг. Сделать снимок и поделиться им через канал передачи данных. Следующие шаги
Посмотрите на код и архитектуру канонического приложения AppRTC для чата WebRTC – приложение (https://appr.tc/), код (https://github.com/webrtc/apprtc) Попробуйте реальные примеры (http://webrtc.github.io/samples) из github.</description></item><item><title>18. Web Сервер и SSH</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day18/</link><pubDate>Sun, 08 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day18/</guid><description>SSH Как мы уже упоминали, вы, скорее всего, будете управлять множеством удаленных серверов Linux, поэтому вам необходимо убедиться, что ваше подключение к этим удаленным серверам безопасно. В этом разделе мы хотим рассказать о некоторых основах SSH (Secure Shell), которые должен знать каждый, и которые помогут вам с этим безопасным туннелем к вашим удаленным системам.
Настройка соединения по SSH Передача файлов Создайте свой закрытый ключ Введение в SSH Безопасная оболочка (Secure Shell) Сетевой протокол (Networking Protocol) Обеспечивает безопасную связь Может защитить любой сетевой сервис Обычно используется для удаленного доступа из командной строки В нашей среде, если вы следили за нами, мы уже использовали SSH, но все это было настроено и автоматизировано с помощью нашей конфигурации vagrant, поэтому нам нужно было только запустить vagrant ssh, и мы получили доступ к нашей удаленной виртуальной машине.</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem 19
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeNthFromEnd(self, head, n: int): p1 = head p2 = head for _ in range(n): p1 = p1.next if not p1: return head.next # in case: head=[1], n=1 -&amp;gt; return [] while p1.next: p1 = p1.next p2 = p2.next p2.next = p2.next.next return head</description></item><item><title>19. Автоматизация задачи с помощью bash-скриптов</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day19/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day19/</guid><description>Автоматизация задачи с помощью bash-скриптов Оболочка, которую мы собираемся использовать сегодня, — это bash, но мы рассмотрим другую оболочку завтра, когда будем углубляться в ZSH.
BASH - Bourne Again Shell («возрождённый» shell)
Мы могли бы почти посвятить целую секцию из 7 дней написанию сценариев оболочки, как и языкам программирования. Bash дает нам возможность работать вместе с другими инструментами автоматизации для достижения цели.
Я до сих пор разговариваю со многими людьми, которые настроили несколько сложных сценариев оболочки, чтобы что-то произошло, и они полагаются на этот сценарий для некоторых из наиболее важных вещей в бизнесе, я не говорю, что нам нужно понимать сценарии оболочки/bash.</description></item><item><title>Генерация аннотации</title><link>https://romankurnovskii.com/ru/tracks/disser/utils/text_2_short/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/utils/text_2_short/</guid><description> Сгенерировать</description></item><item><title>20. Valid Parentheses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/20/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/20/</guid><description>LeetCode problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true First accepted Idea:</description></item><item><title>20. Настройка рабочей среды DevOps</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day20/</link><pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day20/</guid><description>Настройка рабочей среды Не путать с тем, как мы настраиваем серверы Linux таким образом. Я хочу продемонстрировать возможности выбора и гибкость, которые у нас есть при настройке настольного компьютера Linux.
Я использую рабочий стол Linux уже почти год, и я настроил его именно так, как я хочу с точки зрения внешнего вида. Используя нашу виртуальную машину Ubuntu в Virtual Box, мы можем выполнить некоторые настройки, которые я сделал для своего ежедневного драйвера.
Я собрал видео на YouTube, показывающее остальные, так как некоторые люди могли бы лучше следовать за ним:</description></item><item><title>21. Merge Two Sorted Lists</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/21/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/21/</guid><description>LeetCode problem
You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: list1 = [], list2 = [0] Output: [0] First accepted Idea:
Get smallest head. Loop and update its next.</description></item><item><title>21. DevOps настройка сети</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day21/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day21/</guid><description>Общая картина: DevOps и Сеть Добро пожаловать в День 21! Мы собираемся заняться сетевыми технологиями в течение следующих 7 дней. Сеть и DevOps являются всеобъемлющей темой, но нам также необходимо изучить некоторые основы сетевых технологий.
В конечном счете, как мы уже говорили ранее, DevOps — это культура и изменение процессов в ваших организациях. Как мы уже говорили, это могут быть виртуальные машины, контейнеры, Kubernetes, но это также может быть и сеть. Если мы используем эти принципы DevOps для нашей инфраструктуры, которая чтобы включить сеть более точно с точки зрения DevOps, вам также необходимо знать о сети, а также о различных топологиях, сетевых инструментах и ​​стеках, которые у нас есть.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem 22
class Solution: def generateParenthesis(self, n): res = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: res.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return res</description></item><item><title>22. Открытая сетевая модель OSI</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day22/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day22/</guid><description>Модель OSI — 7 уровней Общая цель сети как отрасли состоит в том, чтобы позволить двум хостам обмениваться данными. Если я хочу передать данные от одного хоста к другому хосту, мне нужно будет что-то подключить к этому хосту, перейти к другому хосту, подключить его к первому хосту.
Сеть позволяет нам автоматизировать это, позволяя хосту автоматически обмениваться данными по сети, и для этого эти хосты должны следовать набору правил.
Это ничем не отличается от любого другого языка. У английского есть набор правил, которым должны следовать два носителя английского языка.</description></item><item><title>23. Протоколы сети</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day23/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day23/</guid><description>Протоколы сети Набор правил и сообщений, образующих стандарт.
ARP - Address Resolution Protocol - протокол разрешения адресов Если вы хотите по-настоящему разобраться в ARP, вы можете прочитать Internet Standard здесь RFC 826
ARP соединяет IP-адреса с фиксированными физическими адресами машин, также известными как MAC-адреса, в сети уровня 2.
FTP - File Transfer Protocol - протокол передачи файлов Позволяет передавать файлы из источника в место назначения. Как правило, этот процесс аутентифицируется, но при настройке можно использовать анонимный доступ. Теперь вы будете чаще видеть FTPS, который обеспечивает подключение SSL/TLS к FTP-серверам от клиента для повышения безопасности.</description></item><item><title>24. Swap Nodes in Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/24/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/24/</guid><description>LeetCode problem 24
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def swapPairs(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) pre, cur = dummy, head while cur and cur.next: t = cur.next cur.next = t.next t.next = cur pre.next = t pre, cur = cur, cur.next return dummy.next</description></item><item><title>24. Автоматизация сети</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day24/</link><pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day24/</guid><description>Автоматизация сети Основы сетевой автоматизации Основные задачи для сетевой автоматизации
Тестирование устройств и проверка конфигурации; Инициализация развернутых физических устройств и сервисов, а также развертывание и инициализация виртуальных устройств; Сбор сетевых данных, относящихся к устройствам, системам, программному обеспечению, топологии сети, трафику и сервисам в реальном времени; Анализ данных, в том числе упреждающая аналитика ИИ и машинного обучения, для обеспечения информации о текущем и будущем поведении сети; Проверка соответствия конфигурации требованиям для обеспечения правильной работы всех сетевых устройств и сервисов; Обновление программного обеспечения, включая откат программного обеспечения при необходимости; Замкнутая коррекция проблем с сетью, включая поиск и устранение неисправностей, а также исправление сложных и трудновыявляемых сбоев; Подробный анализ отчетов, панелей наблюдения, оповещений и предупреждений; Реализация требований безопасности; Мониторинг сети и ее сервисов для поддержания уровня обслуживания и удовлетворенности клиентов Процесс внедрения автоматизации специфичен для каждого бизнеса.</description></item><item><title>25. Автоматизация сети с помощью Python</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day25/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day25/</guid><description>Python для автоматизации сети Python — это стандартный язык, используемый для автоматизированных сетевых операций.
Хотя это не только автоматизация сети, кажется, что оно везде, когда вы ищете ресурсы, и, как упоминалось ранее, если это не Python, то обычно это Ansible, который также написан на Python.
Я думаю, что уже упоминал об этом, но в разделе «Изучение языка программирования» я выбрал Golang, а не Python, по причинам, связанным с тем, что моя компания разрабатывает Go, так что это было хорошей причиной для меня, чтобы учиться, но если это не так, тогда Python взял бы это время.</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/26/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/26/</guid><description>LeetCode problem
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>26. Развертывание виртуальной лаборатории EVE-NG в домашних условиях</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day26/</link><pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day26/</guid><description>Создание нашей лаборатории Мы собираемся продолжить настройку нашей эмулируемой сети с помощью EVE-NG, а затем, надеюсь, развернуть несколько устройств и начать думать о том, как мы можем автоматизировать настройку этих устройств. В День 25 мы рассказали об установке EVE-NG на нашу машину с помощью VMware Workstation.
Установка клиента EVE-NG Существует также клиентский пакет, который позволяет нам выбирать, какое приложение используется при подключении к устройствам по SSH. Он также настроит Wireshark для захвата пакетов между ссылками. Вы можете установить клиентский пакет для своей ОС (Windows, macOS, Linux).</description></item><item><title>27. Работа с сетью в Python</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day27/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day27/</guid><description>Практическое знакомство с Python и сетью В этом заключительном разделе основ работы с сетью мы рассмотрим некоторые задачи и инструменты автоматизации с помощью нашей лабораторной среды, созданной День 26
Мы будем использовать туннель SSH для подключения к нашим устройствам с нашего клиента по сравнению с telnet. Туннель SSH, созданный между клиентом и устройством, зашифрован. Мы также рассмотрели SSH в разделе Linux в День 18
Доступ к нашей виртуальной эмулируемой среде Чтобы мы могли взаимодействовать с нашими коммутаторами, нам либо нужна рабочая станция внутри сети EVE-NG, и вы можете развернуть там Linux-систему с установленным Python для выполнения вашей автоматизации (Ресурс для настройки Linux внутри EVE-NG) или можно сделать как я и определить облако для доступа со своей рабочей станции.</description></item><item><title>28. Find the Index of the First Occurrence in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/28/</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/28/</guid><description>LeetCode problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
Example 2:
Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description></item><item><title>28. DevOps в облаке</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day28/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day28/</guid><description>Общая картина: DevOps и облака Когда дело доходит до облачных вычислений и того, что они предлагают, это очень хорошо сочетается с духом и процессами DevOps. Мы можем думать об облачных вычислениях, предоставляющих технологии и услуги, в то время как DevOps, как мы уже много раз упоминали ранее, касается процессов и их улучшения.
Но начать с этого путешествия по обучению в облаке сложно, и убедиться, что вы знаете и понимаете все элементы или лучший сервис для выбора по правильной цене, сбивает с толку.</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/29/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/29/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.</description></item><item><title>29. Знакомство с Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day29/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day29/</guid><description>Знакомство с Microsoft Azure Прежде чем мы начнем, победителем опроса в Твиттере стала Microsoft Azure, отсюда и название страницы. Это было довольно интересно увидеть результаты, полученные в течение 24 часов.
Я бы сказал, что с точки зрения освещения этой темы я лучше понимаю и пользуюсь услугами, доступных в Microsoft Azure. Сегодня я склоняюсь к Amazon AWS. Однако я выделил разделы для всех трех основных облачных провайдеров.
Я ценю, что их больше, и опрос включал только эти 3, и, в частности, были некоторые комментарии об Oracle Cloud.</description></item><item><title>30. Модули безопасности Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day30/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day30/</guid><description>Microsoft Azure Security Models Следуя обзору Microsoft Azure, мы начнем с безопасности Azure и посмотрим, как это может помочь в наши дни. По большей части я обнаружил, что встроенных ролей было достаточно, и зная это, мы можем создавать и работать со многими различными областями аутентификации и конфигураций. Я обнаружил, что Microsoft Azure довольно продвинута с ее инструментом Active Directory по сравнению с другими общедоступными облаками.
Это одна из областей, в которой Microsoft Azure, по-видимому, работает иначе, чем другие поставщики общедоступных облаков, в Azure ВСЕГДА есть Azure AD.</description></item><item><title>31. Microsoft Azure Среда выполнения приложений</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day31/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day31/</guid><description>Среда выполнения приложений Вслед за вчерашним обзором основ моделей безопасности в Microsoft Azure, сегодня мы собираемся изучить различные службы вычислений, доступные нам в Azure.
Параметры службы доступности Этот раздел мне близок, учитывая мою роль в управлении данными. Как и в случае с локальной средой, очень важно обеспечить доступность ваших служб.
Высокая доступность (Защита в пределах региона) Аварийное восстановление (Защита между регионами) Резервное копирование (Восстановление с момента времени) Microsoft развертывает несколько регионов в пределах геополитических границ.
Две концепции Azure для доступности услуг.</description></item><item><title>32. Модели хранилища Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day32/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day32/</guid><description>Модели хранилища Службы хранилища Службы хранилища Azure предоставляются учетными записями хранения. Доступ к учетным записям хранения в основном осуществляется через REST API. Учетная запись хранения должна иметь уникальное имя, являющееся частью DNS-имени &amp;lt;Storage Account name&amp;gt;.core.windows.net. Различные варианты репликации и шифрования. Находится в группе ресурсов Мы можем создать нашу группу хранения, просто выполнив поиск группы хранения в строке поиска в верхней части портала Azure.
Затем мы можем выполнить шаги по созданию нашей учетной записи хранения, помня, что это имя должно быть уникальным, а также оно должно быть написано строчными буквами, без пробелов, но может включать цифры.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/33/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/33/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>33. Сетевые модели Microsoft Azure + Управление Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day33/</link><pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day33/</guid><description>Мы рассмотрим сетевые модели в Microsoft Azure и некоторые варианты управления для Azure. До сих пор мы использовали только платформу Azure, но упомянули и другие области, которые можно использовать для управления и создания наших ресурсов на платформе.
Сетевые модели Azure Виртуальные сети Виртуальная сеть — это конструкция, созданная в Azure. Виртуальной сети назначен один или несколько диапазонов IP-адресов. Виртуальные сети живут в рамках подписки внутри региона. В виртуальной сети создаются виртуальные подсети для разбиения сетевого диапазона. Виртуальные машины размещаются в виртуальных подсетях.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/34/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/34/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]
Code Idea:</description></item><item><title>34. Практические скрипты Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day34/</link><pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day34/</guid><description>Практические скрипты Microsoft Azure Последние 6 дней были сосредоточены на Microsoft Azure и общедоступном облаке в целом, большая часть этой основы должна была содержать много теории, чтобы понять строительные блоки Azure, но также это будет хорошо перенесено на других крупных облачных провайдеров. .
В самом начале я упомянул о базовых знаний об общедоступном облаке и выборе одного провайдера, по крайней мере, для начала. Если вы танцуете между разными облаками, я считаю, что вы можете довольно легко заблудиться, тогда как выбрав одно, вы поймете основы.</description></item><item><title>35. Git — контроль версий</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day35/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day35/</guid><description>Общая картина: Git — контроль версий Прежде чем мы перейдем к git, нам нужно понять, что такое контроль версий? В этой статье мы рассмотрим, что такое контроль версий и основы git.
Что такое контроль версий? Git — не единственная система контроля версий, поэтому рассмотрим, какие варианты и какие методологии доступны для контроля версий.
Наиболее очевидным и большим преимуществом контроля версий является возможность отслеживать историю проекта. Мы можем посмотреть на этот репозиторий с помощью git log и увидеть, что у нас есть много коммитов и много комментариев, а также то, что произошло на данный момент в проекте.</description></item><item><title>36. Valid Sudoku</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/36/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/36/</guid><description>LeetCode problem
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</description></item><item><title>36. Установка и настройка Git</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day36/</link><pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day36/</guid><description>Установка и настройка Git Git — это кроссплатформенный инструмент с открытым исходным кодом для контроля версий. Если я нравлюсь вам, вы используете Ubuntu или большинство сред Linux, вы можете обнаружить, что у вас уже установлен git, но мы собираемся выполнить установку и настройку.
Даже если у вас уже установлен git в вашей системе, также рекомендуется убедиться, что мы в курсе последних событий.
Установка Git Мы будем работать с Windows и Linux, но вы также можете найти macOS в списке здесь</description></item><item><title>37. Шпаргалка по Git</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day37/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day37/</guid><description>Знакомство с Git В последних двух постах мы узнали о системах контроля версий и некоторых основных рабочих процессах git как системы контроля версий День 35. Затем мы установили git в нашу систему, обновили и настроили. Мы также немного углубились в теорию между системой контроля версий клиент-сервер и Git, которая является распределенной системой контроля версий День 36.
Теперь мы пройдемся по некоторым командам и вариантам использования, которые мы все обычно видим в git.
Где получить помощь по git? Будут времена, когда вы просто не сможете вспомнить или просто не знаете команду, которая вам нужна для работы с git.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/38/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/38/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</description></item><item><title>38. Staging и Изменения</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day38/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day38/</guid><description>Working directory Git - это система трёх основных стадий: working directory, staging area и repository. Пройдем поэтапно каждую стадию.
Создадим пустую папку.
mkdir my_fodler cd my_folder Сделаем инициализацию git проекта.
git init (../images/Day38_Git1.ru.png) После инициализации git репозитория создается скрытая папка .git Здесь хранятся сведения о репозитории git, а также информация о наших ветках и коммитах.
Staging/Stage Сейчас у нас пустая папка. Создадим пустой файл README.md и выполним команду
git status Git знает о новом файле, но этот файл еще не зафиксирован в staging.</description></item><item><title>39. Просмотр, удаление, отмена и восстановление</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day39/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day39/</guid><description>GIT - Просмотр, удаление, отмена и восстановление Просмотр файлов в Stagig area и Working area Если некоторые файлы/папки уже добавлены в staging area, то можно просмотреть их рахницу по отношению в главной ветке комадой: git diff --staged
Это покажет нам все внесенные изменения и все новые файлы, которые мы добавили или удалили.
Изменения в измененных файлах обозначаются символами --- или +++ Вы можете видеть ниже, что мы только что добавили +add some text, что означает, что это новые строки.</description></item><item><title>40. GitHub | GitLab | BitBucket</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day40/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day40/</guid><description>Социальная сеть для кода Изучение GitHub | GitLab | BitBucket
Сегодня я хочу рассказать о некоторых сервисах на основе git, о которых мы, вероятно, все слышали и ожидаем, что будем использовать их ежедневно.
GitHub Наиболее распространенным, по крайней мере для меня, является GitHub, GitHub — это веб-хостинг для git. Чаще всего он используется разработчиками программного обеспечения для хранения своего кода. Управление исходным кодом с функциями контроля версий git, а также множеством дополнительных функций. Это позволяет командам или открытым участникам легко общаться и обеспечивает социальный аспект кодирования.</description></item><item><title>41. Рабочий процесс с открытым исходным кодом</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day41/</link><pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day41/</guid><description>Рабочий процесс с открытым исходным кодом Когда мы изучали основы GitHub, мы проходили процесс форка произвольного проекта и внесения изменений в наш локальный репозиторий. Здесь мы хотим сделать еще один шаг вперед и внести свой вклад в проект с открытым исходным кодом. Помните, что вклад не обязательно должен заключаться в исправлении ошибок, кодировании функций, это может быть и документация. Каждая мелочь помогает, и это также позволит вам поработать с некоторыми функциями git, которые мы рассмотрели.
Форк проекта Первое, что нам нужно сделать, это найти проект, в который мы можем внести свой вклад.</description></item><item><title>42. Trapping Rain Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</guid><description>LeetCode задача 42
Задача Дан массив неотрицательных целых чисел, представляющих собой карту высот, где ширина каждой стойки равна 1. Вычислите, сколько воды может удерживать этот массив после дождя.
Подсказки Мы можем решить эту задачу, двигаясь от краев массива к его центру, отслеживая текущую максимальную высоту с обеих сторон.
Подход Простой и понятный способ решения этой задачи - пройтись по массиву и для каждого элемента вычислить, сколько воды он может удержать.
Алгоритм Инициализируем переменную для хранения общего объема воды, который может быть удержан.</description></item><item><title>42. Контейнеры</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day42/</link><pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day42/</guid><description>Контейнеры Этот раздел будет посвящен контейнерам. Будем рассматривать Docker, вникая в некоторые ключевые области, чтобы понять больше о контейнерах.
Я также попытаюсь провести практические занятия по созданию контейнера, который мы сможем использовать не только в этом разделе, но и в последующих.
Почему другой способ запуска приложений? Первое, на что мы должны обратить внимание, - зачем нам нужен другой способ запуска программ или приложений? Просто выбор велик, мы можем запускать наши приложения в разных формах, мы можем видеть приложения, развернутые на физическом оборудовании с операционной системой и одним приложением, мы можем видеть виртуальную машину или облачные IaaS экземпляры, запускающие наше приложение, которое затем интегрируется в базу данных снова в виртуальной машине или как PaaS предложение в публичном облаке.</description></item><item><title>43. Установка Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day43/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day43/</guid><description>Что такое Docker и его установка В предыдущей статье я хотя бы раз упомянул Docker, и это потому, что Docker действительно является новатором в создании популярности контейнеров, несмотря на то, что они существуют уже очень давно.
Здесь мы будем использовать и объяснять docker, но мы также должны упомянуть [Open Container Initiative (OCI)] (https://www.opencontainers.org/), которая является организацией по отраслевым стандартам, поощряющей инновации и избегающей опасности блокировки поставщиков. Благодаря OCI у нас есть выбор при выборе инструментария для контейнеров, включая Docker, CRI-O, Podman, LXC и другие.</description></item><item><title>44. Установка образов Docker в Docker Desktop</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day44/</link><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day44/</guid><description>Образы Docker и практическая работа с Docker Desktop Теперь у нас в системе установлен Docker Desktop. (Если вы используете Linux, у вас все еще есть опции, но нет графического интерфейса, но docker, очевидно, работает на Linux)Install Docker Engine on Ubuntu (Другие дистрибутивы также доступны).
В этом посте мы собираемся начать с развертывания некоторых образов в нашей среде. Напомним, что такое образ Docker - образ Docker - это файл, используемый для выполнения кода в контейнере Docker. Образы Docker действуют как набор инструкций для создания контейнера Docker, как шаблон.</description></item><item><title>45. Что из себя представляет оьбраз Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day45/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day45/</guid><description>Анатомия образа Docker На прошлом занятии мы рассмотрели некоторые основы использования Docker Desktop в сочетании с DockerHub для развертывания и запуска некоторых проверенных образов. Вкратце о том, что такое образ, вы не забудете, если я продолжу упоминать.
Образ Docker - это шаблон, доступный только для чтения, содержащий набор инструкций для создания контейнера, который может работать на платформе Docker. Это удобный способ упаковки приложений и предварительно сконфигурированных серверных сред, которые вы можете использовать для личного пользования или публично делиться ими с другими пользователями Docker.</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/46/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/46/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: result_permutation = [] if len(nums) == 1: # base case return [nums[:]] for _ in nums: tmp_removed = nums.</description></item><item><title>46. Docker Compose</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day46/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day46/</guid><description>Docker Compose Возможность запуска одного контейнера может быть отличной, если у вас есть самодостаточный образ, в котором есть все, что вам нужно для одного случая использования, но все становится интересным, когда вы ищете возможность создания нескольких приложений между различными образами контейнеров. Например, если у меня есть фронт-энд сайта, но есть потребность в базе данных бэкенда, я могу поместить все в один контейнер, но лучше и эффективнее было бы иметь собственный контейнер для базы данных.
Именно здесь на помощь приходит Docker compose - инструмент, позволяющий запускать более сложные приложения в нескольких контейнерах.</description></item><item><title>47. Сетевое взаимодействие Docker и безопасность</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day47/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day47/</guid><description>Docker Networking &amp;amp; Security Во время этой сессии по контейнерам мы уже кое-что сделали, но не рассмотрели, как все работает за кулисами с точки зрения сетевых технологий, а также не затронули безопасность, поэтому мы планируем эту сессию.
Основы сетевого взаимодействия Docker Откройте терминал и введите команду docker network - это основная команда для настройки и управления сетями контейнеров.
Ниже показано, как мы можем использовать эту команду и все доступные подкоманды. Мы можем создавать новые сети, составлять список существующих, проверять и удалять сети.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/48/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/48/</guid><description>LeetCode problem
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify matrix in-place instead.</description></item><item><title>48. Альтернативы Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day48/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day48/</guid><description>Альтернативы Docker В самом начале этого раздела я говорил, что мы будем использовать Docker, просто потому, что ресурсов очень много, а сообщество очень большое, но также именно с него начался толчок к популярности контейнеров. Я бы посоветовал вам пойти и посмотреть немного истории о Docker и о том, как он появился, я нашел это очень полезным.
Но, как я уже упоминал, существуют и другие альтернативы Docker. Если мы подумаем о том, что такое Docker и что мы уже рассмотрели.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/49/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/49/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dd = {} for s in strs: s_sort = &amp;#34;&amp;#34;.</description></item><item><title>49. Основы Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day49/</link><pubDate>Wed, 08 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day49/</guid><description>Общая картина: Kubernetes В предыдущем разделе мы рассмотрели контейнеры. Контейнеры не справляются с задачей масштабирования и оркестровки. Лучшее, что мы можем сделать, это использовать docker-compose для объединения нескольких контейнеров. Когда речь заходит о Kubernetes, который является оркестратором контейнеров, это дает нам возможность масштабирования в автоматическом режиме или в зависимости от нагрузки ваших приложений и сервисов.
Как платформа Kubernetes предлагает возможность оркестровки контейнеров в соответствии с вашими требованиями и желаемым состоянием. Мы рассмотрим Kubernetes в этом разделе, поскольку она быстро развивается как следующая волна инфраструктуры.</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive
class Solution: def myPow(self, x, n): if not n: return 1 if n &amp;lt; 0: return 1 / self.</description></item><item><title>50. Выбор платформы Kubernetes для проекта</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day50/</link><pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day50/</guid><description>Выбор платформы Kubernetes Я хотел бы использовать эту сессию для разбора некоторых платформ или, может быть, дистрибутивов - более подходящий термин для этого, одна вещь, которая была проблемой в мире Kubernetes - это устранение сложности.
Kubernetes the hard way рассказывает о том, как построить из ничего полноценный функциональный кластер Kubernetes, очевидно, что это крайность, но все больше и больше людей, по крайней мере, тех, с кем я общаюсь, хотят устранить эту сложность и запустить управляемый кластер Kubernetes. Проблема в том, что это стоит больше денег, но преимущества могут быть следующими: если вы используете управляемый сервис, действительно ли вам нужно знать архитектуру узлов и то, что происходит с точки зрения плоскости управления узлов, когда обычно у вас нет к этому доступа.</description></item><item><title>51. Установка minikube</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day51/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day51/</guid><description>Развертывание первого кластера Kubernetes В этом посте мы собираемся запустить кластер Kubernetes на нашей локальной машине с помощью minikube, это даст нам базовый кластер Kubernetes для остальной части раздела Kubernetes, хотя позже мы рассмотрим развертывание кластера Kubernetes и в VirtualBox. Причина, по которой мы выбрали этот метод, а не развертывание управляемого кластера Kubernetes в публичном облаке, заключается в том, что это будет стоить денег даже при бесплатном уровне, однако я поделился некоторыми блогами, если вы захотите развернуть такую среду в предыдущем разделе День 50.</description></item><item><title>52. Настройка многоузлового кластера Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day52/</link><pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day52/</guid><description>Настройка многоузлового кластера Kubernetes Я хотел назвать эту статью &amp;ldquo;Настройка многоузлового кластера Kubernetes с помощью Vagrant&amp;rdquo;, но подумал, что это будет слишком длинно!
На вчерашней сессии мы использовали классный проект для развертывания нашего первого кластера Kubernetes и немного поработали с самым важным инструментом CLI, с которым вы столкнетесь при использовании Kubernetes (kubectl).
Здесь мы будем использовать VirtualBox в качестве основы, но, как мы уже говорили о Vagrant в разделе Linux, мы можем использовать любой гипервизор или инструмент виртуализации. Это был День 14, когда мы прошли и развернули машину Ubuntu для раздела Linux.</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>53. Обзор Rancher</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day53/</link><pubDate>Sun, 12 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day53/</guid><description>Обзор Rancher - практическое применение В этом разделе мы рассмотрим Rancher, до сих пор все, что мы делали, было в cli и с использованием kubectl, но у нас есть несколько действительно хороших пользовательских интерфейсов и инструментов управления несколькими кластерами, чтобы дать нашим операционным командам хорошую видимость управления кластером.
Rancher, согласно их сайту
Rancher - это полный программный стек для команд, внедряющих контейнеры. Он решает операционные проблемы и проблемы безопасности при управлении несколькими кластерами Kubernetes в любой инфраструктуре, обеспечивая команды DevOps интегрированными инструментами для запуска контейнерных рабочих нагрузок.</description></item><item><title>54. Развертывание приложений Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day54/</link><pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day54/</guid><description>Развертывание приложений Kubernetes Теперь мы, наконец, переходим к реальному развертыванию некоторых приложений в наших кластерах, некоторые говорят, что именно для этого существует Kubernetes - для доставки приложений.
Идея заключается в том, что мы можем взять наши образы контейнеров и развернуть их в виде стручков в нашем кластере Kubernetes, чтобы воспользоваться преимуществами Kubernetes как контейнерного оркестратора.
Развертывание приложений в Kubernetes Существует несколько способов развертывания наших приложений в кластере Kubernetes, мы рассмотрим два наиболее распространенных подхода - YAML-файлы и диаграммы Helm.</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>55. State и Ingress в Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/</link><pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/</guid><description>State и Ingress в Kubernetes В этом заключительном разделе, посвященном Kubernetes, мы рассмотрим State и ingress.
Все, о чем мы говорили до сих пор, касается stateless, stateless - это когда нашим приложениям не важно, какую сеть они используют, и им не нужно постоянное хранение данных. В то время как приложения с состоянием, например, базы данных, чтобы такое приложение функционировало правильно, вам нужно убедиться, что стручки могут обращаться друг к другу через уникальную идентификацию, которая не меняется (имена хостов, IP&amp;hellip; и т.</description></item><item><title>56. Merge Intervals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/56/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/56/</guid><description>LeetCode problem
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:
Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Approach 1:
class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort() res = [intervals[0]] for ir in range(1, len(intervals)): if intervals[ir][0] &amp;gt;= res[-1][0] and intervals[ir][0] &amp;lt;= res[-1][1]: # [1,3],[2,6] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) elif res[-1][0] &amp;gt;= intervals[ir][0] and res[-1][0] &amp;lt;= intervals[ir][1]: # [1,3],[0,4] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) else: res.</description></item><item><title>56. Обзор IaC</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day56/</link><pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day56/</guid><description>Обзор IaC Люди совершают ошибки! Автоматизация - это путь к успеху!
Как вы строите свои системы сегодня?
Каков был бы ваш план, если бы вы потеряли все, физические машины, виртуальные машины, облачные виртуальные машины, облачные PaaS и т.д. и т.п.?
Сколько времени у вас уйдет на замену всего?
Инфраструктура как код предоставляет решение, позволяющее сделать это и одновременно протестировать, не путайте это с резервным копированием и восстановлением, но что касается вашей инфраструктуры и сред, ваших платформ, мы должны быть в состоянии раскрутить их и обращаться с ними как со скотом и домашними животными.</description></item><item><title>57. Введение в Terraform</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day57/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day57/</guid><description>&amp;ldquo;Terraform - это инструмент для безопасного и эффективного создания, изменения и управления версиями инфраструктуры&amp;rdquo;. «Приведенная выше цитата взята из HashiCorp, HashiCorp - это компания, стоящая за Terraform.
&amp;ldquo;Terraform - это программный инструмент &amp;ldquo;инфраструктура как код&amp;rdquo; с открытым исходным кодом, который обеспечивает последовательный рабочий процесс CLI для управления сотнями облачных сервисов. Terraform кодирует облачные API в декларативные конфигурационные файлы&amp;rdquo;.
У HashiCorp есть отличный ресурс HashiCorp Learn, который охватывает все их продукты и дает несколько отличных демонстрационных примеров, когда вы пытаетесь достичь чего-то с помощью инфраструктуры как кода.</description></item><item><title>58. Язык конфигурации HashiCorp (HCL)</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day58/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day58/</guid><description>Язык конфигурации HashiCorp (HCL) Прежде чем мы начнем создавать вещи с помощью Terraform, мы должны немного погрузиться в язык HashiCorp Configuration Language (HCL). До сих пор в ходе нашей задачи мы рассмотрели несколько различных языков скриптов и программирования, и вот еще один. Мы затронули язык программирования Go, затем скрипты bash, мы даже немного затронули python, когда дело дошло до автоматизации сети.
Теперь мы должны рассмотреть язык конфигурации HashiCorp (HCL), если вы впервые видите этот язык, он может показаться немного пугающим, но он довольно прост и очень мощный.</description></item><item><title>59. Создание виртуальной машины с помощью Terraform</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day59/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day59/</guid><description>Создание виртуальной машины с помощью Terraform и переменных В этой сессии мы будем создавать виртуальную машину или две виртуальные машины с помощью Terraform внутри VirtualBox. Это не совсем обычно, VirtualBox - это вариант виртуализации рабочих станций, и на самом деле это не было бы вариантом использования Terraform, но я сейчас нахожусь на высоте 36 000 футов в воздухе, и как бы я ни развертывал ресурсы публичного облака так высоко в облаках, гораздо быстрее сделать это локально на моем ноутбуке.</description></item><item><title>60. Контейнеры, провайдеры и модули Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day60/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day60/</guid><description>Контейнеры и модули Docker Вчера мы развернули виртуальную машину с помощью Terraform в нашей локальной среде FREE virtualbox. В этом разделе мы собираемся развернуть контейнер Docker с некоторой конфигурацией в нашей локальной среде Docker.
Docker Demo Для начала мы используем приведенный ниже блок кода, суть которого заключается в том, что мы хотим развернуть простое веб-приложение в docker и опубликовать его, чтобы оно было доступно в нашей сети. Мы будем использовать nginx и сделаем его доступным извне на нашем ноутбуке через localhost и порт 8000.</description></item><item><title>61. Kubernetes и множественные среды</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day61/</link><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day61/</guid><description>Kubernetes и множественные среды До сих пор в этом разделе, посвященном инфраструктуре как коду, мы рассматривали развертывание виртуальных машин, хотя и с помощью virtualbox, но суть одна и та же: мы определяем в коде, как должна выглядеть наша виртуальная машина, а затем развертываем ее. То же самое касается контейнеров Docker, и на этом занятии мы рассмотрим, как Terraform можно использовать для взаимодействия с ресурсами, поддерживаемыми Kubernetes.
Я использовал Terraform для развертывания своих кластеров Kubernetes в демонстрационных целях на трех основных облачных провайдерах, и вы можете найти репозиторий tf_k8deploy.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 10^9.</description></item><item><title>62. Terraform - Тестирование, инструменты и альтернативы</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day62/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day62/</guid><description>Тестирование, инструменты и альтернативы Завершая этот раздел об инфраструктуре как коде, мы должны упомянуть о тестировании нашего кода, различных доступных инструментах, а также о некоторых альтернативах Terraform для достижения этой цели. Как я уже говорил в начале раздела, я остановился на Terraform, поскольку он, во-первых, бесплатный и с открытым исходным кодом, во-вторых, он кроссплатформенный и не зависит от окружения. Но есть и альтернативы, которые следует рассмотреть, но общая цель состоит в том, чтобы донести до людей, что это способ развертывания инфраструктуры.</description></item><item><title>63. Инструменты управления конфигурацией - Ansible/Terraform</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day63/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day63/</guid><description>Введение: Управление конфигурацией Сразу после раздела, посвященного инфраструктуре как коду, мы, вероятно, будем говорить об управлении конфигурацией или управлении конфигурацией приложений.
Управление конфигурацией - это процесс поддержания приложений, систем и серверов в требуемом состоянии. Пересечение с Infrastructure as code заключается в том, что IaC гарантирует, что ваша инфраструктура находится в желаемом состоянии, но после этого, особенно terraform, не будет заботиться о желаемом состоянии настроек вашей ОС или приложений, и именно здесь на помощь приходят инструменты управления конфигурацией. Убедитесь, что система и приложения работают так, как ожидается, поскольку изменения происходят в Deane.</description></item><item><title>64. Ansible Введение</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day64/</link><pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day64/</guid><description>&lt;p>Основы Ansible&lt;/p></description></item><item><title>65. Ansible Playbooks - Часть 1</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day65/</link><pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day65/</guid><description>Ansible Playbooks В этом разделе мы рассмотрим основную причину, которую я вижу, по крайней мере, для Ansible. Я имею в виду, что это здорово - взять одну команду и обратиться ко многим различным серверам для выполнения простых команд, таких как перезагрузка длинного списка серверов и избавление от необходимости подключаться к каждому из них по отдельности.
Но как насчет того, чтобы взять голую операционную систему, объявить программное обеспечение и службы, которые мы хотим запустить на этой системе, и убедиться, что все они работают в нужном состоянии.</description></item><item><title>66. Plus One</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/66/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/66/</guid><description>LeetCode problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Example 1:
Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.</description></item><item><title>66. Ansible Playbooks - Часть 2</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day66/</link><pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day66/</guid><description>Ansible Playbooks Продолжение В нашем последнем разделе мы начали с создания небольшой лаборатории, используя файл Vagrant для развертывания 4 машин, и мы использовали нашу Linux-машину, которую мы создали в этом разделе, в качестве нашей системы управления Ansible.
Мы также проверили несколько скриптов плейбуков, и в конце у нас был плейбук, который сделал наши web01 и web02 отдельными веб-серверами.
Наведение порядка Прежде чем перейти к дальнейшей автоматизации и развертыванию, мы должны рассказать о том, как сохранить наш плейбук аккуратным и опрятным и как мы можем разделить наши такты и обработчики по подпапкам.</description></item><item><title>67. Роли и развертывание балансировщика нагрузки</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day67/</link><pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day67/</guid><description>На последнем занятии мы рассмотрели роли и использовали команду ansible-galaxy, чтобы помочь создать структуру папок для некоторых ролей, которые мы будем использовать. В итоге мы получили гораздо более аккуратное рабочее хранилище для нашего кода конфигурации, поскольку все спрятано в папках ролей.
Однако мы использовали только роль apache2 и получили рабочий playbook3.yaml для работы с нашими веб-серверами.
На данном этапе, если вы использовали только vagrant up web01 web02, пришло время запустить vagrant up loadbalancer, который откроет другую систему Ubuntu, которую мы будем использовать в качестве балансировщика нагрузки/прокси.</description></item><item><title>68. Теги, переменные, инвентаризация и конфигурация сервера базы данных</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day68/</link><pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day68/</guid><description>Теги Поскольку мы оставили наш плейбук во время вчерашней сессии, нам нужно будет запустить все задачи и пьесы в рамках этого плейбука. Это означает, что нам придется запустить веб-серверы и балансировщик нагрузки до конца.
Однако теги могут позволить нам отделить их друг от друга, если мы захотим. Это может быть эффективным шагом, если в нашей среде есть очень большие и длинные плейбуки.
В нашем файле плейбука, в данном случае мы используем ansible-scenario5
- hosts: webservers become: yes vars: http_port: 8000 https_port: 4443 html_welcome_msg: &amp;#34;Hello 90DaysOfDevOps - Welcome to Day 66!</description></item><item><title>69. Sqrt(x)</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/69/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/69/</guid><description>LeetCode problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2. Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>69. Ansible - контроллер автоматизации (Tower), AWX, Vault</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day69/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day69/</guid><description>Завершая раздел об управлении конфигурацией, я хотел бы рассмотреть другие области, с которыми вы можете столкнуться при работе с Ansible.
Существует множество продуктов, составляющих платформу Ansible Automation.
Red Hat Ansible Automation Platform - это основа для создания и эксплуатации автоматизации в организации. Платформа включает в себя все инструменты, необходимые для внедрения автоматизации в масштабах предприятия.
Я постараюсь осветить некоторые из них в этом посте. Но для получения более подробной информации на официальном сайте Red Hat Ansible есть много другой информации.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/70/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/70/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>70. Конвейеры CI/CD</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day70/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day70/</guid><description>Реализация конвейера CI/CD (Continous Integration/Continous Deployment) является основой современной среды DevOps.
Он устраняет разрыв между разработкой и операциями, автоматизируя сборку, тестирование и развертывание приложений.
Мы много говорили об этой мантре Continous во вступительном разделе задачи. Но повторим еще раз:
Continous Integration (CI) - это более современная практика разработки программного обеспечения, при которой инкрементные изменения кода вносятся чаще и надежнее. Автоматизированные шаги рабочего процесса сборки и тестирования, запускаемые Contininous Integration, обеспечивают надежность изменений кода, сливаемых в репозиторий.
Затем этот код / приложение быстро и беспрепятственно доставляется в рамках процесса непрерывного развертывания.</description></item><item><title>71. Введение в Jenkins</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day71/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day71/</guid><description>Jenkins - это инструмент непрерывной интеграции, который позволяет непрерывно разрабатывать, тестировать и развертывать вновь созданный код.
Этого можно достичь двумя способами: ночные сборки или непрерывная разработка. Первый вариант заключается в том, что наши разработчики в течение дня занимаются своими задачами и в конце рабочего дня вносят свои изменения в репозиторий исходного кода. Затем в течение ночи мы проводим модульные тесты и собираем программное обеспечение. Это можно считать старым способом интеграции всего кода.
Другой вариант и более предпочтительный способ заключается в том, что наши разработчики по-прежнему фиксируют свои изменения в исходном коде, а затем, после фиксации кода, непрерывно запускается процесс сборки.</description></item><item><title>72. Работа с Jenkins</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day72/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day72/</guid><description>Сегодня мы планируем немного поработать с Jenkins и сделать что-то в рамках нашего конвейера CI, рассматривая некоторые примеры кодовых баз, которые мы можем использовать.
Что такое конвейер? Прежде чем мы начнем, нам нужно знать, что такое конвейер, когда речь идет о CI, и мы уже рассмотрели это на вчерашнем занятии с помощью следующего изображения.
Мы хотим взять процессы или шаги, описанные выше, и автоматизировать их, чтобы в итоге получить результат, то есть развернутое приложение, которое мы можем отправить нашим клиентам, конечным пользователям и т.</description></item><item><title>73. Set Matrix Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/73/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/73/</guid><description>LeetCode problem
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Approach 1:
Idea:
LeetCode Submission
class Solution: def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None: rows = len(matrix) cols = len(matrix[0]) # 1. Check first row/column for zero&amp;#39;s first_row_has_zero = 0 in matrix[0] first_col_has_zero = 0 in list(zip(*matrix))[0] # 2.</description></item><item><title>73. Построение конвейера Jenkins</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day73/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day73/</guid><description>В предыдущем разделе мы развернули Jenkins на нашем кластере Minikube и создали очень простой Jenkins Pipeline, который не делал ничего особенного, кроме как повторял этапы Pipeline.
Вы также могли заметить, что в процессе создания Jenkins Pipeline нам доступны некоторые примеры скриптов для запуска.
Первый демонстрационный скрипт - &amp;ldquo;Declartive (Kubernetes)&amp;rdquo;, и вы можете увидеть его этапы ниже.
// Uses Declarative syntax to run commands inside a container. pipeline { agent { kubernetes { // Rather than inline YAML, in a multibranch Pipeline you could use: yamlFile &amp;#39;jenkins-pod.</description></item><item><title>74. Hello World - Jenkinsfile App Pipeline</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day74/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day74/</guid><description>Здравствуй мир - Jenkinsfile App Pipeline В предыдущем разделе мы построили простой конвейер в Jenkins, который будет перемещать наш образ докера из нашего dockerfile в публичном репозитории GitHub в наш частный репозиторий Dockerhub.
В этом разделе мы хотим сделать еще один шаг вперед и добиться следующего с помощью нашего простого приложения.
Цель Dockerfile (Hello World) Jenkinsfile Jenkins Pipeline для запуска при обновлении репозитория GitHub Используйте репозиторий GitHub в качестве источника. Запуск - Clone/Get Repository, Build, Test, Deploy Stages Развертывание на DockerHub с инкрементными номерами версий Stretch Goal для развертывания на нашем кластере Kubernetes (для этого потребуется еще одно задание и репозиторий манифеста с использованием учетных данных GitHub).</description></item><item><title>75. Sort Colors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/75/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/75/</guid><description>LeetCode problem
This problem is also known as the Dutch National Flag problem. One solution is to use three pointers to partition the array into three sections: red, white, and blue.
Here&amp;rsquo;s the algorithm:
Initialize three pointers: left, mid, and right. Initialize left to 0, mid to 0, and right to n-1, where n is the length of the input array. While mid is less than or equal to right: If nums[mid] is 0, swap nums[mid] with nums[left], increment mid and left.</description></item><item><title>75. Обзор GitHub Actions</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day75/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day75/</guid><description>Обзор действий GitHub В этом разделе я хотел бы перейти к рассмотрению, возможно, другого подхода, чем тот, на который мы только что потратили время. На этом занятии мы сосредоточимся на GitHub Actions.
GitHub Actions - это платформа CI/CD, которая позволяет нам строить, тестировать и развертывать, помимо прочих задач, наш конвейер. В ней есть концепция рабочих процессов, которые собираются и тестируются на основе репозитория GitHub. Вы также можете использовать GitHub Actions для управления другими рабочими процессами на основе событий, происходящих в вашем репозитории.</description></item><item><title>76. Обзор ArgoCD</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day76/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day76/</guid><description>Обзор ArgoCD &amp;ldquo;Argo CD - это декларативный инструмент непрерывной доставки GitOps для Kubernetes&amp;rdquo;.
Контроль версий - ключевой момент здесь. Вы когда-нибудь вносили изменения в вашу среду на лету и не помните об этих изменениях, а поскольку свет горит и все вокруг зеленое, вы продолжаете упорно двигаться вперед? Вы когда-нибудь вносили изменения и ломали все или часть всего? Вы могли бы знать, что внесли изменение, и вы можете быстро откатить свое изменение, тот плохой скрипт или опечатку. А теперь сделайте это в массовом масштабе, и, возможно, это были не вы, или, возможно, ошибка была обнаружена не сразу, и теперь бизнес страдает.</description></item><item><title>77. Мониторинг</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day77/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day77/</guid><description>Введение: Мониторинг В этом разделе мы поговорим о мониторинге, что это такое, зачем он нам нужен?
Что такое мониторинг? Мониторинг - это процесс пристального наблюдения за всей инфраструктурой.
и зачем он нам нужен? Предположим, что мы управляем тысячей серверов, которые включают в себя множество специализированных серверов, таких как серверы приложений, серверы баз данных и веб-серверы. Мы также можем усложнить эту задачу за счет дополнительных сервисов и различных платформ, включая публичные облачные предложения и Kubernetes.
Мы отвечаем за то, чтобы все сервисы, приложения и ресурсы на серверах работали так, как должны.</description></item><item><title>78. Subsets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/78/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/78/</guid><description>LeetCode problem
In this solution, we start with an empty list in the results array.
For each element in the nums array, we append that element to all of the subsets in the results array to create new subsets, and then add these new subsets to the results array.
By doing this for all elements in nums, we generate all possible subsets.
class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [[]] for i in nums: for j in range(len(res)): cur = [] cur.</description></item><item><title>78. Hands-On Monitoring Tools</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day78/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day78/</guid><description>Инструменты мониторинга своими руками На последнем занятии я говорил об общей картине мониторинга и рассмотрел Nagios, для этого было две причины. Во-первых, это программное обеспечение, о котором я много слышал на протяжении многих лет, поэтому хотел узнать немного больше о его возможностях.
Сегодня я буду изучать Prometheus, я все больше и больше вижу Prometheus в ландшафте Cloud-Native, но его также можно использовать для присмотра за физическими ресурсами вне Kubernetes и тому подобного.
Prometheus - мониторинг практически всего Прежде всего, Prometheus - это Open-Source, который может помочь вам контролировать контейнеры и системы на базе микросервисов, а также физические, виртуальные и другие сервисы.</description></item><item><title>79. Log Management</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day79/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day79/</guid><description>Введение: Управление журналами В продолжение проблем и решений в области мониторинга инфраструктуры, управление журналами - это еще один пазл в общей картине наблюдаемости.
Управление и агрегация журналов Давайте поговорим о двух основных концепциях, первая из которых - агрегация журналов, это способ сбора и маркировки журналов приложений от множества различных служб в единую приборную панель, по которой можно легко осуществлять поиск.
Одной из первых систем, которые должны быть построены в системе управления производительностью приложений, является агрегация журналов. Управление производительностью приложений - это та часть жизненного цикла devops, когда все было создано и развернуто, и вам нужно убедиться, что они постоянно работают, что им выделено достаточно ресурсов и что ошибки не показываются пользователям.</description></item><item><title>80. ELK Stack</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day80/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day80/</guid><description>ELK Stack На этом занятии мы немного подробнее рассмотрим некоторые из упомянутых нами опций.
ELK Stack ELK Stack - это комбинация трех отдельных инструментов:
Elasticsearch - это распределенный, бесплатный и открытый поисковый и аналитический механизм для всех типов данных, включая текстовые, числовые, геопространственные, структурированные и неструктурированные.
Logstash - свободный и открытый конвейер обработки данных на стороне сервера, который получает данные из множества источников, преобразует их, а затем отправляет в ваш любимый &amp;ldquo;тайник&amp;rdquo;.
Kibana - это бесплатный и открытый пользовательский интерфейс, позволяющий визуализировать данные Elasticsearch и перемещаться по стеку Elastic Stack.</description></item><item><title>81. Fluentd и FluentBit</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day81/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day81/</guid><description>Fluentd и FluentBit Еще одним коллектором данных, который я хотел изучить в рамках раздела о наблюдаемости, был Fluentd. Это унифицированный уровень протоколирования с открытым исходным кодом.
Fluentd имеет четыре ключевые особенности, которые делают его подходящим для создания чистых, надежных конвейеров протоколирования:
Унифицированное протоколирование с JSON: Fluentd старается структурировать данные в виде JSON, насколько это возможно. Это позволяет Fluentd унифицировать все аспекты обработки данных журналов: сбор, фильтрацию, буферизацию и вывод журналов из нескольких источников и мест назначения. Последующая обработка данных намного проще с JSON, так как он имеет достаточную структуру, чтобы быть доступным без принуждения к жестким схемам.</description></item><item><title>82. EFK Stack</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day82/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day82/</guid><description>EFK Stack В предыдущем разделе мы говорили о ELK Stack, который использует Logstash в качестве сборщика логов в стеке, в EFK Stack мы меняем его на FluentD или FluentBit.
Наша задача в этом разделе - отслеживать журналы Kubernetes с помощью EFK.
Обзор EFK Мы развернем следующее в нашем кластере Kubernetes.
Стек EFK представляет собой набор из 3 программ, объединенных вместе, включая:
Elasticsearch : NoSQL база данных используется для хранения данных и предоставляет интерфейс для поиска и журнал запросов.</description></item><item><title>83. Визуализация данных - Grafana</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day83/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day83/</guid><description>Визуализация данных - Grafana Мы много говорили о Kibana в этом разделе, посвященном Observability. Но мы также должны уделить некоторое время Grafana. Но это не одно и то же, и они не полностью конкурируют друг с другом.
Основной функцией Kibana является запрос и анализ данных. Используя различные методы, пользователи могут искать в данных, проиндексированных в Elasticsearch, определенные события или строки в данных для анализа и диагностики первопричин. На основе этих запросов пользователи могут использовать функции визуализации Kibana, которые позволяют визуализировать данные различными способами, используя графики, таблицы, географические карты и другие виды визуализации.</description></item><item><title>84. Управление данными</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day84/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day84/</guid><description>Введение: Управление данными Управление данными - это далеко не новая стена, на которую нужно карабкаться, хотя мы знаем, что данные стали более важными, чем несколько лет назад. Ценные и постоянно меняющиеся, они также могут стать огромным кошмаром, когда мы говорим об автоматизации и непрерывной интеграции, тестировании и развертывании частых выпусков программного обеспечения. Вводим постоянные данные и базовые службы данных, которые часто являются главным виновником, когда что-то идет не так.
Но прежде чем я перейду к управлению данными в облаке, нам нужно подняться на уровень выше.</description></item><item><title>85. Службы данных</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day85/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day85/</guid><description>Службы данных Базы данных являются наиболее распространенными службами данных, с которыми мы сталкиваемся в наших средах. На этом занятии я хотел бы рассмотреть некоторые из этих различных типов баз данных и некоторые случаи их использования. Некоторые из них мы уже использовали и видели в ходе решения задачи.
С точки зрения разработки приложений выбор правильной службы данных или базы данных будет иметь огромное значение для производительности и масштабируемости вашего приложения.
https://www.youtube.com/watch?v=W2Z7fbCLSTw
Ключ-значение База данных &amp;ldquo;ключ-значение&amp;rdquo; - это тип нереляционной базы данных, которая использует простой метод &amp;ldquo;ключ-значение&amp;rdquo; для хранения данных.</description></item><item><title>86. Резервное копирование всех платформ</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day86/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day86/</guid><description>Резервное копирование всех платформ В ходе всего этого задания мы обсудили множество различных платформ и сред. Всех их объединяет то, что все они нуждаются в определенном уровне защиты данных!
Защита данных существует уже много лет, но богатство данных, которые мы имеем сегодня, и ценность, которую эти данные приносят, означает, что мы должны быть уверены не только в устойчивости к сбоям инфраструктуры за счет наличия нескольких узлов и высокой доступности приложений, но мы также должны учитывать, что нам нужна копия этих данных, этих важных данных в безопасном и надежном месте, если произойдет сбой.</description></item><item><title>87. Резервное копирование и восстановление</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day87/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day87/</guid><description>Резервное копирование и восстановление своими руками На прошлом занятии мы рассмотрели Kopia - инструмент резервного копирования с открытым исходным кодом, который мы использовали для переноса важных данных на локальный NAS и в облачное хранилище объектов.
В этом разделе я хочу погрузиться в мир резервного копирования Kubernetes. Это платформа, которую мы рассматривали в The Big Picture: Kubernetes ранее в этой задаче.
Мы снова будем использовать наш кластер minikube, но на этот раз мы воспользуемся некоторыми из доступных аддонов.
Настройка кластера Kubernetes Для настройки нашего кластера minikube мы выполним команду minikube start --addons volumesnapshots,csi-hostpath-driver --apiserver-port=6443 --container-runtime=containerd -p 90daysofdevops --kubernetes-version=1.</description></item><item><title>88. Merge Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/88/</link><pubDate>Sun, 30 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/88/</guid><description>LeetCode problem
First accepted class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify nums1 in-place instead. &amp;#34;&amp;#34;&amp;#34; i = len(nums1) - n for j in nums2: nums1[i] = j i += 1 nums1.sort()</description></item><item><title>88. Резервное копирование, ориентированное на приложения</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day88/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day88/</guid><description>Резервное копирование, ориентированное на приложения В День 85 мы уже потратили некоторое время на обсуждение служб данных или приложений с интенсивным использованием данных, таких как базы данных. Для этих служб данных мы должны подумать о том, как управлять согласованностью, особенно когда речь идет о согласованности приложений.
В этой статье мы рассмотрим требования к защите данных приложения в последовательной манере.
Для этого мы выберем инструмент Kanister
Представляем Kanister Kanister - это проект с открытым исходным кодом от Kasten, который позволяет нам управлять (резервное копирование и восстановление) данными приложений на Kubernetes.</description></item><item><title>89. Аварийное восстановление</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day89/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day89/</guid><description>Аварийное восстановление Мы уже упоминали о том, что различные скрипты сбоев требуют различных требований к восстановлению. Когда речь идет о скриптах пожара, наводнения и крови, мы можем рассматривать их как аварийные ситуации, в которых нам может потребоваться, чтобы наши рабочие нагрузки были запущены в совершенно другом месте как можно быстрее или, по крайней мере, с почти нулевым временем восстановления (RTO).
Этого можно достичь только в масштабе, если автоматизировать репликацию всего стека приложений в резервную среду.
Это позволяет быстро переходить от одного облачного региона к другому, облачным провайдерам или между локальной и облачной инфраструктурой.</description></item><item><title>90. Мобильность данных и приложений</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day90/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day90/</guid><description>Мобильность данных и приложений День 90 из #90DaysOfDevOps Challenge! В этой заключительной сессии я собираюсь рассказать о мобильности наших данных и приложений. Я сосредоточусь конкретно на Kubernetes, но потребность в мобильности между платформами и между платформами - это то, что является постоянно растущей потребностью и встречается на практике.
Сценарий использования таков: &amp;ldquo;Я хочу переместить рабочую нагрузку, приложение и данные из одного места в другое&amp;rdquo; по разным причинам, будь то стоимость, риск или предоставление бизнесу более качественных услуг.
На этом занятии мы возьмем нашу рабочую нагрузку и рассмотрим перемещение рабочей нагрузки Kubernetes с одного кластера на другой, но при этом мы изменим то, как наше приложение находится в целевом месте.</description></item><item><title>92. Reverse Linked List II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</guid><description>LeetCode задача 92
Задача Дан односвязный список и два целых числа left и right, где left &amp;lt;= right. Задача заключается в том, чтобы перевернуть узлы списка с позиции left до right
Т.е. если список 1-2-3-4-5-6-7-8-9, left=2, right=7, то итоговый список будет 1-7-6-5-4-3-2-8-9.
Подсказки Для решения задачи удобно использовать два указателя: один для сохранения начальной позиции участка, который нужно перевернуть, и второй для выполнения самого разворота.
Подход Основная идея решения заключается в использовании двух указателей: одного для начала подсписка, который нужно перевернуть, и второго для его конца.</description></item><item><title>94. Binary Tree Inorder Traversal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/94/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/94/</guid><description>LeetCode problem
Given the root of a binary tree, return the inorder traversal of its nodes' values.
Example 1:
Input: root = [1,null,2,3] Output: [1,3,2] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Thoughts Don&amp;rsquo;t understand what needed. Why:
1-null-2-3 becomes 1-3-2 [1,2,5,7,8,9,10] becomes [7,2,8,1,9,5,10] In 1-null-2-3 1 becomes the first because we loop to its left node which is null, then come back and first value here is 1.</description></item><item><title>Заметки по Израилю</title><link>https://romankurnovskii.com/ru/tracks/disser/israel-notes/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/israel-notes/</guid><description>Статистика - показатели по Израилю</description></item><item><title>Раздел 1. Экономическая теория</title><link>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/01-economic-theory/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/01-economic-theory/</guid><description>Меркантилизм как внешнеторговая теория и политика. «Игра с нулевой суммой» в торговле. Адам Смит: теория абсолютного преимущества в торговле. Давид Рикардо: теория сравнительного преимущества в торговле. Теорема Хекшера-Олина и выравнивание относительных цен на торгуемые товары. Меркантилизм как внешнеторговая теория и политика. «Игра с нулевой суммой» в торговле Меркантилизм (15-17 вв) - это экономическая политика, цель которой — накопление в стране драгоценных металлов, средство достижения цели – активный торговый баланс, то есть превышение экспорта над импортом.
Необходимость активного вмешательства государства в хозяйственную деятельность, в основном в форме протекционизма: установления высоких импортных пошлин, выдачи субсидий национальным производителям и так далее.</description></item><item><title>Установка Python</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/install/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/install/</guid><description>Для установки Python на MacOS можно использовать менеджер пакетов brew. Для этого необходимо выполнить команду:
brew install python Для операционных систем на базе Linux также существуют менеджеры пакетов, которые можно использовать для установки Python. Например, для Ubuntu можно использовать команду:
sudo apt-get install python Для Windows можно загрузить установочный пакет с официального сайта https://www.python.org/downloads/.
После установки Python необходимо убедиться, что версия Python, установленная на компьютере, соответствует требованиям для запуска необходимых библиотек и инструментов, которые будут использоваться в процессе разработки.</description></item><item><title>Раздел 2. Международная торговля</title><link>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/02-international-trade/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/02-international-trade/</guid><description>Понятие и критерии «открытости» национальной экономики. Показатели открытости экономик США, стран Европы, России. Особенности развития мировой торговли товарами в 2000-2010-е годы: стоимостная динамика и товарно-географическая структура. Крупнейшие страны-экспортеры и страны-импортеры. Сущность и причины структурных сдвигов в мировой торговле промышленными товарами, сырьем, топливом и продовольствием. Место и роль России в международной торговле. Конкурентные преимущества России. Стоимостная динамика, структура и география международной торговли услугами. Крупнейшие страны-экспортеры и страны-импортеры. Международный трансферт технологий: современные каналы, формы и показатели технологического обмена между странами.</description></item><item><title>Среда разработки</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/ide/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/ide/</guid><description>Для удобной работы с Python требуется хорошо настроенная рабочая среда. Я предпочитаю использовать Visual Studio Code - бесплатный редактор кода, разработанный Microsoft.
Для начала, нужно установить Visual Studio Code на свой компьютер. Это можно сделать с помощью официального сайта https://code.visualstudio.com/.
Установка Python на MacOS и Linux очень проста. Для MacOS можно использовать менеджер пакетов brew, который позволяет установить последнюю версию Python одной командой:
brew install --cask visual-studio-code Для Linux, в зависимости от дистрибутива, используется свой менеджер пакетов. Например, для Ubuntu это можно сделать командой:</description></item><item><title>Раздел 3. Международная торговая политика</title><link>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/03-international-policy/</link><pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/03-international-policy/</guid><description>Политика «свободной торговли» и политика протекционизма в исторической перспективе. Цели и инструменты внешнеторговой политики. Таможенно-тарифное регулирование: характеристика основных институтов и их экономическое значение. Нетарифные барьеры в международной торговле. Всемирная торговая организация (ВТО): функции, задачи, система соглашений, новые направления многосторонних торговых переговоров. Россия в ВТО: сложности вступления, принятые обязательства, экономические последствия. Характеристика современного участия РФ в ВТО. Система внешнеторгового регулирования в ЕАЭС и в России. Политика «свободной торговли» и политика протекционизма в исторической перспективе. Цели и инструменты внешнеторговой политики Политика &amp;ldquo;свободной торговли&amp;rdquo; и политика протекционизма - это две различные стратегии, которые используются государствами для регулирования их экономики.</description></item><item><title>Типы данных</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/types/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/types/</guid><description>Python - это язык программирования, который обладает динамической типизацией, что означает, что тип переменной может меняться в процессе выполнения программы.
В Python есть несколько основных типов данных:
Строковые типы (string)
Числовые типы (целые числа, числа с плавающей запятой, комплексные числа)
Логический тип (True/False)
Списки (list) - это упорядоченная коллекция элементов, которые могут быть различных типов данных.
Списки создаются при помощи квадратных скобок [ ] и элементы списка разделяются запятыми.
Кортежи (tuple) - это упорядоченная коллекция элементов, которые могут быть различных типов данных.</description></item><item><title>104. Maximum Depth of Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/104/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/104/</guid><description>LeetCode задача 104
Задача Дан корень бинарного дерева. Задача состоит в том, чтобы найти его максимальную глубину. Глубина бинарного дерева определяется как максимальное количество узлов на пути от корня дерева до любого листового узла, включая сам корень.
Подсказки Бинарное дерево представляет собой иерархическую структуру, в которой каждый узел имеет максимум двух потомков: левого и правого.
Подход / Идея решения Чтобы найти максимальную глубину бинарного дерева, можно использовать рекурсивный метод. Для каждого узла дерева, максимальная глубина поддерева с этим узлом в качестве корня будет равна максимуму из глубин левого и правого поддеревьев, увеличенному на 1 (сам узел).</description></item><item><title>Раздел 4. Международное движение капитала</title><link>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/04-international-capital-movement/</link><pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/04-international-capital-movement/</guid><description>Формы, структура и масштабы международного движения капитала. Масштабы, динамика и география прямых иностранных инвестиций. Основные инвестирующие и принимающие страны. Международная инвестиционная позиция России: динамика и состав иностранных активов и обязательств. Условия для масштабного привлечения в Россию иностранных инвестиций. Международное движение капитала - это процесс переноса финансовых ресурсов из одной страны в другую в целях получения прибыли или увеличения доходности инвестиций. Международное движение капитала имеет важное значение для экономического развития и роста стран, позволяя привлекать капитал для инвестирования в различные отрасли экономики.</description></item><item><title>Числа</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/numbers/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/numbers/</guid><description>Числовые типы данных в Python могут быть целыми числами (int), числами с плавающей запятой (float) и комплексными числами (complex).
Целые числа - это числа без дробной части, а числа с плавающей запятой - это числа с дробной частью.
Комплексные числа представляются парой вещественных чисел и используются в математических расчетах.
a = 5 # целое число b = 3.14 # вещественное число c = 2 + 3j # комплексное число print(type(a)) # выведет &amp;lt;class &amp;#39;int&amp;#39;&amp;gt; print(type(b)) # выведет &amp;lt;class &amp;#39;float&amp;#39;&amp;gt; print(type(c)) # выведет &amp;lt;class &amp;#39;complex&amp;#39;&amp;gt; Python поддерживает все стандартные арифметические операции: сложение, вычитание, умножение, деление, возведение в степень, целочисленное деление и остаток от деления.</description></item><item><title>Раздел 5. Международный валютный рынок</title><link>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/05-international-foreign-exchange-market/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/05-international-foreign-exchange-market/</guid><description>Понятие иностранной валюты. Валютный курс и паритет покупательной способности валюты. Мировой валютный рынок: понятие, функции, размер, институциональная структура, тенденции развития. Виды операций на валютном рынке. Хеджирование валютных рисков. Факторы, влияющие на формирование валютного курса. Понятие иностранной валюты. Валютный курс и паритет покупательной способности валюты Понятие иностранной валюты: Иностранная валюта - это денежные единицы других стран, которые используются в международных финансовых - операциях; Иностранная валюта может быть использована для оплаты товаров и услуг, инвестирования, торговли на - международном валютном рынке и других целей.</description></item><item><title>Строки</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/strings/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/strings/</guid><description>В Python существует несколько типов данных. Основные типы данных, с которыми вы, вероятно, будете чаще всего встречаться, - это строка, целое число, плавающая цифра, список, словарь и кортеж. В этой главе мы рассмотрим строковый тип данных. Вы удивитесь, как много вещей можно делать со строками в Python прямо из коробки. Существует также модуль string, который можно импортировать для получения доступа к еще большей функциональности, но мы не будем рассматривать его в этой главе. Вместо этого мы рассмотрим следующие темы:</description></item><item><title>Списки</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/lists/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/lists/</guid><description>Список в Python похож на массив в других языках.
Создание В Python пустой список может быть создан следующими способами.
my_list = [] &amp;gt;&amp;gt;&amp;gt; my_list = list() Можно обращаться к элементам списка и кортежа по индексу, начиная с нуля. Например, чтобы получить доступ к первому элементу списка, можно использовать индекс 0:
my_list = [1, 2, 3, &amp;#34;four&amp;#34;, 5.0] print(my_list[0]) # выводит 1 Можно также использовать срезы (slices) для получения подмножества элементов списка или кортежа. Например, чтобы получить первые три элемента списка, можно использовать срез [0:3]:</description></item><item><title>Кортежи</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/tuples/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/tuples/</guid><description>Кортежи в Python - это неизменяемые последовательности элементов, очень похожие на списки.
Создание Создаются с использованием круглых скобок и могут содержать любые типы данных, в том числе и другие кортежи.
Создание кортежей очень похоже на создание списков, только используются круглые скобки вместо квадратных скобок. Например:
t = (1, 2, 3) another_tuple = tuple() abc = tuple([4, 5, 6]) Мы создали кортеж t, содержащий три элемента. Теперь мы можем обратиться к каждому элементу этого кортежа по его индексу, так же как и в списках:</description></item><item><title>Словари</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/dict/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/dict/</guid><description>Словарь - это коллекция, которая позволяет хранить пары ключ-значение. В отличие от списков, словари не имеют порядка, и доступ к элементам словаря осуществляется по ключу, а не по индексу.
Создание Для создания словаря используется фигурная скобка {} с ключами и значениями, разделенными двоеточием. Можно также использовать функцию dict() для создания словаря.
Пример создания словаря:
my_dict = {&amp;#39;name&amp;#39;: &amp;#39;John&amp;#39;, &amp;#39;age&amp;#39;: 25, &amp;#39;city&amp;#39;: &amp;#39;New York&amp;#39;} my_dict_2 = dict(name=&amp;#39;Mary&amp;#39;, age=30, city=&amp;#39;London&amp;#39;) Для доступа к элементам словаря используется ключ. Например, чтобы получить значение, связанное с ключом &amp;ldquo;name&amp;rdquo;, можно использовать следующий синтаксис:</description></item><item><title>Множества</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/sets/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/sets/</guid><description>Создание Множество можно создать, используя фигурные скобки {} или функцию set():
my_set = {1, 2, 3} print(my_set) # {1, 2, 3} my_set = set([1, 2, 3]) print(my_set) # {1, 2, 3} Методы add(): добавляет элемент в множество. remove(): удаляет элемент из множества. Если элемента нет в множестве, возбуждается исключение. discard(): удаляет элемент из множества. Если элемента нет в множестве, ничего не происходит. union(): возвращает объединение двух множеств. intersection(): возвращает пересечение двух множеств. difference(): возвращает разность двух множеств. symmetric_difference(): возвращает симметрическую разность двух множеств.</description></item><item><title>Операторы</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/operators/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/operators/</guid><description>Оператор присваивания Оператор присваивания &amp;ldquo;=&amp;rdquo; используется для присвоения значения переменной. Например:
x = 5 Арифметические операторы Арифметические операторы используются для выполнения математических операций над числами.
+ # Сложение - # Вычитание * # Умножение / # Деление % # Остаток от деления ** # Возведение в степень // # Целочисленное деление Пример:
x = 5 y = 2 print(x + y) # 7 print(x - y) # 3 print(x * y) # 10 print(x / y) # 2.5 print(x % y) # 1 print(x ** y) # 25 print(x // y) # 2 Операторы сравнения Операторы сравнения используются для сравнения значений.</description></item><item><title>Условия</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/conditionals/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/conditionals/</guid><description>В каждом компьютерном языке есть хотя бы один условный оператор. Чаще всего этот оператор представляет собой структуру if/elif/else.
В Python 3.10 добавилась структура match/case
Оператор if Позволяет выполнить блок кода, если определенное условие истинно
x = 5 if x &amp;gt; 0: print(&amp;#34;x is positive&amp;#34;) elif x &amp;lt; 0: print(&amp;#34;x is negative&amp;#34;) else: print(&amp;#34;x is zero&amp;#34;) match/case def get_day_name(day): match day: case 1: return &amp;#34;Monday&amp;#34; case 2: return &amp;#34;Tuesday&amp;#34; case 3: return &amp;#34;Wednesday&amp;#34; case 4: return &amp;#34;Thursday&amp;#34; case 5: return &amp;#34;Friday&amp;#34; case 6: return &amp;#34;Saturday&amp;#34; case 7: return &amp;#34;Sunday&amp;#34; case _: return &amp;#34;Invalid day&amp;#34; match command.</description></item><item><title>Функции</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/functions/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/functions/</guid><description>Функция - это структура, которую вы определяете. Вы можете решать, есть ли у них аргументы или нет. Вы можете добавить аргументы в виде ключевых слов и аргументы по умолчанию.
Функция - это блок кода, который начинается с ключевого слова def, имени функции и двоеточия. Вот простой пример:
def a_function(): print(&amp;#34;You just created a function!&amp;#34;) Эта функция ничего не делает, кроме вывода какого-то текста.
def add(a, b): result = a + b return result В этом примере мы создали функцию add, которая принимает два аргумента a и b и возвращает их сумму.</description></item><item><title>Область видимости</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/scope/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/scope/</guid><description>Область видимости, или scope, определяет, где переменные могут быть использованы в программе. В Python есть две основные области видимости: глобальная и локальная.
Переменные, определенные внутри функции, имеют локальную область видимости. Это означает, что они могут быть использованы только внутри этой функции. Если попытаться использовать их вне функции, будет вызвано исключение.
Переменные, определенные вне функции, имеют глобальную область видимости. Они могут быть использованы в любом месте программы, в том числе и внутри функций. Если внутри функции определить переменную с тем же именем, что и глобальная переменная, то функция будет использовать локальную переменную.</description></item><item><title>Классы</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/classes/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/classes/</guid><description>Все в Python является объектом. Это означает, что каждая сущность в Python имеет методы и значения. Причина в том, что в основе всего лежит класс.
&amp;gt;&amp;gt;&amp;gt; x = &amp;#34;Some String&amp;#34; &amp;gt;&amp;gt;&amp;gt; dir(x) [&amp;#39;__add__&amp;#39;, &amp;#39;__class__&amp;#39;, &amp;#39;__contains__&amp;#39;, &amp;#39;__delattr__&amp;#39;, &amp;#39;__doc__&amp;#39;, &amp;#39;__eq__&amp;#39;, &amp;#39;__format__&amp;#39;, &amp;#39;__ge__&amp;#39;, &amp;#39;__getattribute__&amp;#39;, &amp;#39;__getitem__&amp;#39;, &amp;#39;__getnewargs__&amp;#39;, &amp;#39;__getslice__&amp;#39;, &amp;#39;__gt__&amp;#39;, &amp;#39;__hash__&amp;#39;, &amp;#39;__init__&amp;#39;, &amp;#39;__le__&amp;#39;, &amp;#39;__len__&amp;#39;, &amp;#39;__lt__&amp;#39;, &amp;#39;__mod__&amp;#39;, &amp;#39;__mul__&amp;#39;, &amp;#39;__ne__&amp;#39;, &amp;#39;__new__&amp;#39;, &amp;#39;__reduce__&amp;#39;, &amp;#39;__reduce_ex__&amp;#39;, &amp;#39;__repr__&amp;#39;, &amp;#39;__rmod__&amp;#39;, &amp;#39;__rmul__&amp;#39;, &amp;#39;__setattr__&amp;#39;, &amp;#39;__sizeof__&amp;#39;, &amp;#39;__str__&amp;#39;, &amp;#39;__subclasshook__&amp;#39;, &amp;#39;_formatter_field_name_split&amp;#39;, &amp;#39;_formatter_parser&amp;#39;, &amp;#39;capitalize&amp;#39;, &amp;#39;center&amp;#39;, &amp;#39;count&amp;#39;, &amp;#39;decode&amp;#39;, &amp;#39;encode&amp;#39;, &amp;#39;endswith&amp;#39;, &amp;#39;expandtabs&amp;#39;, &amp;#39;find&amp;#39;, &amp;#39;format&amp;#39;, &amp;#39;index&amp;#39;, &amp;#39;isalnum&amp;#39;, &amp;#39;isalpha&amp;#39;, &amp;#39;isdigit&amp;#39;, &amp;#39;islower&amp;#39;, &amp;#39;isspace&amp;#39;, &amp;#39;istitle&amp;#39;, &amp;#39;isupper&amp;#39;, &amp;#39;join&amp;#39;, &amp;#39;ljust&amp;#39;, &amp;#39;lower&amp;#39;, &amp;#39;lstrip&amp;#39;, &amp;#39;partition&amp;#39;, &amp;#39;replace&amp;#39;, &amp;#39;rfind&amp;#39;, &amp;#39;rindex&amp;#39;, &amp;#39;rjust&amp;#39;, &amp;#39;rpartition&amp;#39;, &amp;#39;rsplit&amp;#39;, &amp;#39;rstrip&amp;#39;, &amp;#39;split&amp;#39;, &amp;#39;splitlines&amp;#39;, &amp;#39;startswith&amp;#39;, &amp;#39;strip&amp;#39;, &amp;#39;swapcase&amp;#39;, &amp;#39;title&amp;#39;, &amp;#39;translate&amp;#39;, &amp;#39;upper&amp;#39;, &amp;#39;zfill&amp;#39;] Здесь у нас есть строка, присвоенная переменной x.</description></item><item><title>Циклы</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/loops/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/loops/</guid><description>Цикл while Цикл while повторяет набор инструкций, пока заданное условие истинно. Каждый раз, когда выполняется набор инструкций, условие проверяется снова, и если оно продолжает быть истинным, то набор инструкций выполняется снова.
i = 1 while i &amp;lt; 6: print(i) i += 1 1 2 3 4 5 Цикл for Цикл for используется для прохождения через элементы в последовательности, такой как список или строка. В отличие от цикла while, в цикле for не нужно определять начальное условие или шаг увеличения.</description></item><item><title>116. Populating Next Right Pointers in Each Node</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/116/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/116/</guid><description>LeetCode problem
from collections import deque class Solution: def connect(self, root: &amp;#39;Optional[Node]&amp;#39;) -&amp;gt; &amp;#39;Optional[Node]&amp;#39;: if not root: return root queue = deque([root]) while queue: level_size = len(queue) for i in range(level_size): node = queue.popleft() if i &amp;lt; level_size - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root LeetCode Editorial:
Editorial</description></item><item><title>Генераторы</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/comprehensions/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/comprehensions/</guid><description>В языке Python есть несколько методов создания списков и словарей, которые известны как генераторы.
Генераторы списков Генератор списка - это выражение, которое генерирует список значений на основе каких-то правил. Вместо того, чтобы создавать список целиком и хранить его в памяти, генератор списка генерирует значения по мере их запроса.
squares = [x*x for x in range(10)] Эта строка создает генератор списка, который генерирует квадраты чисел от 0 до 9. Затем можно перебрать элементы этого генератора с помощью цикла:
В Python есть функция range, которая может возвращать список чисел.</description></item><item><title>Ввод данных пользователем</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/inputs/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/inputs/</guid><description>В Python вы можете запросить у пользователя ввод данных во время выполнения программы. Для этого используется функция inp(), которая приостанавливает выполнение программы, ожидает ввода от пользователя и возвращает введенные данные в виде строки.
name = input(&amp;#34;Введите ваше имя: &amp;#34;) print(&amp;#34;Привет, &amp;#34; + name + &amp;#34;!&amp;#34;) При запуске этого кода пользователь увидит приглашение &amp;ldquo;Введите ваше имя:&amp;rdquo;, после чего он может ввести свое имя и нажать клавишу Enter. Затем программа поприветствует пользователя по имени.
Вы также можете использовать функцию int() для преобразования введенной строки в целое число.</description></item><item><title>118. Pascal's Triangle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</guid><description>LeetCode задача 118
Задача Дано целое число numRows. Верните первые numRows строк Треугольника Паскаля.
В Треугольнике Паскаля каждое число является суммой двух чисел, находящихся непосредственно над ним.
Подсказки Для построения каждой следующей строки можно использовать последнюю строку в текущей итерации. Например, если есть строка [1, 2, 1], то следующая строка начнется и закончится с 1, а числа внутри будут получены путем сложения пар чисел: 1+2 и 2+1.
Подход Для того чтобы построить Треугольник Паскаля, начнем с первой строки, состоящей только из числа 1.</description></item><item><title>Обработка исключений</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/exception_handling/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/exception_handling/</guid><description>Обработка исключений - это механизм, который позволяет обработать возможную ошибку, которая может возникнуть в процессе выполнения программы.
В Python эта конструкция исключений обычно обернута в так называемый try/except.
Оператор try-except - это основной инструмент для обработки исключений. Код, который может вызвать исключение, помещается в блок try. Если исключение возникает, то Python переходит в блок except, где вы можете обработать исключение и выполнить соответствующий код.
try: x = int(input(&amp;#34;Введите число: &amp;#34;)) result = 100 / x except ZeroDivisionError: print(&amp;#34;Деление на ноль!</description></item><item><title>Работа с файлами</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/file_io/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/file_io/</guid><description>Чтение файла Чтобы прочитать файл в Python, вам нужно сначала открыть файл. Вы можете сделать это, используя функцию open(). Эта функция принимает два аргумента: имя файла и режим открытия файла.
Режим открытия файла может быть &amp;ldquo;r&amp;rdquo; (чтение), &amp;ldquo;w&amp;rdquo; (запись) или &amp;ldquo;a&amp;rdquo; (добавление).
Пример, который читает файл &amp;ldquo;example.txt&amp;rdquo; в режиме чтения и выводит его содержимое на экран:
with open(&amp;#34;example.txt&amp;#34;, &amp;#34;r&amp;#34;) as f: content = f.read() print(content) Мы используем оператор with, который автоматически закрывает файл после его использования. Функция read() читает содержимое файла и возвращает его в виде строки.</description></item><item><title>Импорт модулей</title><link>https://romankurnovskii.com/ru/tracks/python-101/basis/imports/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/basis/imports/</guid><description>Python поставляется с большим количеством готового кода. Эти части кода известны как модули и пакеты.
Модуль - это один импортируемый файл Python, а пакет состоит из двух или более модулей. Пакет может быть импортирован так же, как и модуль.
В Python вы можете импортировать модули из других файлов, чтобы использовать функции и переменные, определенные в этих модулях.
import Python предоставляет ключевое слово import для импорта модулей.
Допустим, у нас есть два файла:
Файл dog.py, содержащий следующий код:
def bark(): print(&amp;#39;Гав-гав!</description></item><item><title>122. Best Time to Buy and Sell Stock II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/122/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/122/</guid><description>LeetCode problem
To solve this problem, we can use a greedy approach.
The idea is to keep adding the profit whenever the price on the next day is higher than the price on the current day.
This way, we will maximize profit.
class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = 0 for i in range(1, len(prices)): if prices[i] &amp;gt; prices[i - 1]: profit += prices[i] - prices[i - 1] return profit LeetCode Editorial:
Editorial</description></item><item><title>128. Longest Consecutive Sequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/128/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/128/</guid><description>LeetCode problem
Save all numbers in set to make it possible to get number at O(1). For each element look for the current+1 element if exists. class Solution: def longestConsecutive(self, nums: List[int]) -&amp;gt; int: res = 0 nset = set(nums) for x in nset: if x - 1 not in nset: # prevent double calculations _max = 1 cur = x while cur + 1 in nset: _max += 1 cur += 1 res = max(_max, res) return res</description></item><item><title>130. Surrounded Regions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/130/</link><pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/130/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to iterate through each cell in the grid, and for each O, check if it is surrounded by X&amp;rsquo;s in all four directions (up, down, left, and right). If so, flip it to X. However, this method has a high time complexity and does not take advantage of any properties of the problem.
Approach: The more efficient solution is to perform a Depth-First Search (DFS) starting from the border O&amp;rsquo;s.</description></item><item><title>131. Palindrome Partitioning</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/131/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/131/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to generate all possible partitions of the given string and then check if every substring in each partition is a palindrome.
However, this approach would be inefficient, as there would be an exponential number of partitions to check.
Approach:
Using Backtracking.
Logic:
Define a helper function, is_palindrome, to check if a given substring is a palindrome. Define the backtrack function to find all palindrome partitions recursively. This function will take the current position in the string and the current partition as input arguments.</description></item><item><title>134. Gas Station</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/134/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/134/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to try starting from each gas station and check if you can complete the circuit. For each gas station, calculate the remaining gas in the tank after traveling to the next station.
If the gas is not enough to travel to the next station, stop and try starting from the next gas station.
Approach:
In this problem, we can use a greedy algorithm
We can keep track of the total gas and total cost while iterating through the gas stations.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode задача 138
Задача Дан односвязный список, каждый узел которого содержит дополнительный &amp;ldquo;произвольный&amp;rdquo; указатель, который может указывать на любой узел в списке или быть null. Задача состоит в том, чтобы создать глубокую копию этого списка.
Подсказки Простое копирование значений не сработает. Нам нужно создать новые узлы и корректно установить как основные, так и &amp;ldquo;произвольные&amp;rdquo; указатели.
Подход / Идея решения Идея решения заключается в двухпроходном методе. В первом проходе мы создаем копии всех узлов исходного списка и сохраняем их в словаре, где ключом будет оригинальный узел, а значением — его копия.</description></item><item><title>139. Word Break</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/139/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/139/</guid><description>LeetCode problem
Approach:
Dynamic Programming.
Logic:
Using DP:
Iterate through each character of string s. Generate all possible substrings ending at the current index. Check if the substring is in wordDict: If it is, check if the index before the substring&amp;rsquo;s first index is marked as True (this indicates that the part of the string before the current substring can be segmented into words in wordDict). If it is, then mark the current index as True. Solution:
class Solution: def wordBreak(self, s, wordDict): n = len(s) dp = [False] * n for end in range(1, n + 1): # 1.</description></item><item><title>141. Linked List Cycle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/141/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/141/</guid><description>LeetCode problem 141
Problem Statement The problem asks us to determine if a given linked list contains a cycle. A cycle in a linked list occurs when a node&amp;rsquo;s next pointer points back to a previous node in the list, causing an infinite loop.
Hints &amp;amp; Tips In this problem, you can take advantage of the Floyd&amp;rsquo;s &amp;ldquo;Tortoise and Hare&amp;rdquo; cycle detection algorithm. This algorithm allows you to detect a cycle in O(1) space and O(n) time complexity, where n is the number of nodes.</description></item><item><title>146. LRU Cache</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/146/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/146/</guid><description>LeetCode problem
The operations we need to support are get and put which should both be done in O(1) time.
get(key) should return the value if the key exists in the cache, otherwise return -1. put(key, value) should update the value of the key if the key exists; otherwise, this method should insert the key-value pair into the cache. If the cache is full, this method should also evict the least recently used key-value pair. Approach Use Doubly Linked List or Python OrderedDict</description></item><item><title>148. Sort List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/148/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/148/</guid><description>LeetCode problem
Naive Solution Traverse the linked list, adding each node&amp;rsquo;s value to a Python list sort that list create a new linked list from the sorted values return the head of this new list. This solution would have a time complexity of O(n log n) due to the sort operation and a space complexity of O(n) because of the extra list we&amp;rsquo;re creating.
class Solution: def sortList(self, head): values = [] node = head while node: values.append(node.val) node = node.</description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</guid><description>LeetCode задача 151
Задача На вход подается строка s. Нам необходимо перевернуть порядок слов в этой строке. Слова определяются как последовательность символов без пробелов. Слова в s разделены хотя бы одним пробелом. Нужно вернуть строку, в которой слова расположены в обратном порядке, разделенные одним пробелом.
Важно: строка s может содержать начальные или конечные пробелы или множественные пробелы между двумя словами. В возвращаемой строке должен быть только один пробел, разделяющий слова. Лишние пробелы не включаем.
Подход Для решения задачи мы можем разделить строку на слова, используя пробел в качестве разделителя, а затем просто объединить их в обратном порядке.</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>160. Intersection of Two Linked Lists</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/160/</link><pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/160/</guid><description>LeetCode problem
Solution 1 Using hashmap.
# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode): nodes = set() cur = headA while cur: nodes.add(cur) cur = cur.next cur = headB while cur: if cur in nodes: return cur cur = cur.next return None Solution 2 Initialize two pointers, one for each head. Move each pointer to the next node in its list. If a pointer reaches the end of its list, move it to the start of the other list.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem 166
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>171. Excel Sheet Column Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/171/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/171/</guid><description>LeetCode problem
The column titles in an Excel sheet are designed similar to a base-26 number system. The columns start from &amp;lsquo;A&amp;rsquo; (which is 1) to &amp;lsquo;Z&amp;rsquo; (which is 26), then after &amp;lsquo;Z&amp;rsquo;, the column titles go to &amp;lsquo;AA&amp;rsquo; (which is 27), &amp;lsquo;AB&amp;rsquo; (28), and so on.
This problem is essentially asking us to convert a base-26 number (represented by uppercase English letters) to a decimal number.
That means that for each &amp;ldquo;new&amp;rdquo; index in columnTitle we already pass alphabet.</description></item><item><title>172. Factorial Trailing Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/172/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/172/</guid><description>LeetCode problem 172
class Solution: def trailingZeroes(self, n: int) -&amp;gt; int: res = 0 while n: n //= 5 res += n return res</description></item><item><title>173. Binary Search Tree Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/173/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/173/</guid><description>LeetCode problem 173
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] while root: self.stack.append(root) root = root.left def next(self) -&amp;gt; int: cur = self.stack.pop() node = cur.right while node: self.stack.append(node) node = node.left return cur.val def hasNext(self) -&amp;gt; bool: return len(self.stack) &amp;gt; 0 # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.</description></item><item><title>176. Second Highest Salary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/176/</guid><description>LeetCode problem 176
Drop any duplicate salary values to avoid counting duplicates as separate salary ranks Sort the unique salaries in descending order and get the second highest salary If the second highest salary doesn&amp;rsquo;t exist (e.g., there are fewer than two unique salaries), return None Create a DataFrame with the second highest salary import pandas as pd def second_highest_salary(employee: pd.DataFrame) -&amp;gt; pd.DataFrame: unique_salaries = employee[&amp;#34;salary&amp;#34;].drop_duplicates() second_highest = ( unique_salaries.nlargest(2).iloc[-1] if len(unique_salaries) &amp;gt;= 2 else None ) if second_highest is None: return pd.</description></item><item><title>177. Nth Highest Salary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/177/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/177/</guid><description>LeetCode problem 177
import pandas as pd def nth_highest_salary(employee: pd.DataFrame, N: int) -&amp;gt; pd.DataFrame: unique_salaries = employee.salary.unique() if len(unique_salaries) &amp;lt; N: return pd.DataFrame([np.NaN], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;]) salary = sorted(unique_salaries, reverse=True)[N - 1] return pd.DataFrame([salary], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;])</description></item><item><title>178. Rank Scores</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/178/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/178/</guid><description>LeetCode problem 178
import pandas as pd def order_scores(scores: pd.DataFrame) -&amp;gt; pd.DataFrame: # Use the rank method to assign ranks to the scores in descending order with no gaps scores[&amp;#34;rank&amp;#34;] = scores[&amp;#34;score&amp;#34;].rank(method=&amp;#34;dense&amp;#34;, ascending=False) # Drop id column &amp;amp; Sort the DataFrame by score in descending order result_df = scores.drop(&amp;#34;id&amp;#34;, axis=1).sort_values(by=&amp;#34;score&amp;#34;, ascending=False) return result_df</description></item><item><title>179. Largest Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/179/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/179/</guid><description>LeetCode problem 179
class Solution: def largestNumber(self, nums: List[int]) -&amp;gt; str: nums = [str(v) for v in nums] nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b &amp;lt; b + a else -1)) return &amp;#34;0&amp;#34; if nums[0] == &amp;#34;0&amp;#34; else &amp;#34;&amp;#34;.join(nums)</description></item><item><title>180. Consecutive Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/180/</guid><description>LeetCode problem 180
import pandas as pd def consecutive_numbers(logs: pd.DataFrame) -&amp;gt; pd.DataFrame: all_the_same = lambda lst: lst.nunique() == 1 logs[&amp;#34;is_consecutive&amp;#34;] = ( logs[&amp;#34;num&amp;#34;].rolling(window=3, center=True, min_periods=3).apply(all_the_same) ) return ( logs.query(&amp;#34;is_consecutive == 1.0&amp;#34;)[[&amp;#34;num&amp;#34;]] .drop_duplicates() .rename(columns={&amp;#34;num&amp;#34;: &amp;#34;ConsecutiveNums&amp;#34;}) )</description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/189/</guid><description>LeetCode problem
Problem Statement Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Naive Solution A simple, but inefficient, approach would be to rotate the array k times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations.</description></item><item><title>190. Reverse Bits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/190/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/190/</guid><description>LeetCode problem
This task involves understanding how binary representation works. An unsigned integer is a 32-bit value, where each bit represents a power of 2, from 2^0 (the least significant bit) to 2^31 (the most significant bit).
Unsigned Integers (often called &amp;ldquo;uints&amp;rdquo;) are just like integers (whole numbers) but have the property that they don&amp;rsquo;t have a + or - sign associated with them. Thus they are always non-negative (zero or positive).
Naive Solution A naive solution to this problem could involve converting the number to a binary string, reversing the string, and then converting it back to an integer.</description></item><item><title>191. Number of 1 Bits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/191/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/191/</guid><description>LeetCode problem
Problem Statement Given an integer value represented in binary format, we need to count the number of &amp;lsquo;1&amp;rsquo; bits in its binary representation.
Naive Solution The naive solution for this problem would be to convert the binary number into a string and then simply iterate over the string and count the number of &amp;lsquo;1&amp;rsquo;s. However, this solution is not optimal and is not taking advantage of the properties of binary numbers.
Algorithm The optimal solution for this problem involves using bitwise operation.</description></item><item><title>EC2</title><link>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/ec2/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/ec2/</guid><description>Amazon EC2 Документация Amazon EC2 - 1 Документация Amazon EC2 - 2 Amazon Elastic Compute Cloud (EC2) - одна из самых популярных служб AWS. EC2 позволяет запускать различные типы облачных экземпляров и оплачивать их по модели &amp;ldquo;оплата за использование&amp;rdquo;. EC2 позволяет контролировать вычислительные ресурсы на уровне операционной системы, работая в вычислительной среде Amazon.
Цены Актуальный прайс
Практика Создание EC2 инстанса Заходим на страницу EC2 -&amp;gt; Launch Instance
Образ EC2 Выбираем нужный нам образ Создание ключей Создадим ключ, чтобы использовать его для подключения к инстансу извне Вводим любое имя.</description></item><item><title>Модуль os</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/os/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/os/</guid><description>Модуль os предоставляет функции для работы с операционной системой. Этот модуль позволяет получить доступ к файловой системе, управлять процессами, получать информацию об окружении и другие.
os.listdir - получение списка файлов и директорий в указанной директории: os.mkdir() - создание директории os.system() - выполнение команды в командной строке os.getenv() os.putenv() os.remove() - удаление файла os.rename() os.startfile() os.walk() - дает способ итерации по пути корневого уровня pathlib.Path.walk() - похожий на os.walk(). (Добавлен в 3.12) os.environ: словарь, содержащий переменные окружения, доступные в текущем процессе.</description></item><item><title>202. Happy Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/202/</link><pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/202/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a number n. We have to determine whether this number is a &amp;ldquo;happy&amp;rdquo; number or not. A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.</description></item><item><title>Модуль sys</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/sys/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/sys/</guid><description>Модуль sys предоставляет специфические для системы параметры и функции. Он содержит системную информацию и функции для взаимодействия со стандартными потоками ввода/вывода, аргументами командной строки и другими модулями Python.
sys.argv - список аргументов командной строки, переданных в программу при ее запуске. Первым аргументом обычно является имя файла программы.
sys.executable - путь к интерпретатору Python, который используется для запуска текущей программы.
sys.exit([arg]) - завершает выполнение программы. Если задан аргумент, то он возвращается в качестве кода выхода.
sys.modules - словарь, содержащий все загруженные модули Python, включая стандартные и сторонние модули.</description></item><item><title>Модуль logging</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/logging/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/logging/</guid><description>Модуль логирования logging является одним из стандартных модулей Python и предоставляет возможности для записи логов в приложении. Логирование используется для записи информации о работе приложения, которую можно использовать для отслеживания ошибок и диагностики проблем.
В модуле logging определены три основных компонента: логгеры (loggers), обработчики (handlers) и форматировщики (formatters). Логгеры представляют собой объекты, которые используются для записи сообщений лога. Обработчики определяют, куда будут записываться сообщения, а форматировщики определяют, как будут отформатированы эти сообщения.
Пример использования модуля logging:
import logging # Создание логгера logger = logging.</description></item><item><title>Модуль datetime/time</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/datetime_time/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/datetime_time/</guid><description>datetime Модуль datetime в Python предоставляет классы для работы с датами и временем. Он позволяет создавать объекты даты, времени и даты-времени, а также выполнять операции с этими объектами.
Класс datetime является основным классом модуля datetime и представляет дату и время в формате &amp;ldquo;ГГГГ-ММ-ДД ЧЧ:ММ:СС&amp;rdquo;. Класс date представляет только дату, а класс time - только время.
Форматирование дат и времени может выполняться с помощью метода strftime, который позволяет создавать строку с заданным форматом даты и времени. Также существует метод strptime, который позволяет преобразовать строку в объект даты и времени.</description></item><item><title>Модуль потоков threading</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/threading/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/threading/</guid><description>Модуль threading в Python предоставляет возможность создавать и управлять потоками выполнения. Потоки - это легковесные процессы, которые выполняются параллельно в пределах одного процесса, что позволяет лучше использовать ресурсы компьютера.
Для создания нового потока необходимо создать объект Thread и передать в его конструктор функцию, которую вы хотите запустить в отдельном потоке. Затем вызовите метод start() у этого объекта, чтобы запустить поток. Если вы хотите дождаться завершения потока, вызовите метод join(), который блокирует текущий поток, пока поток, на который вы вызываете join(), не завершится.</description></item><item><title>206. Reverse Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/206/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/206/</guid><description>LeetCode задача 206
Задача Дана голова односвязного списка. Задача состоит в том, чтобы развернуть этот список и вернуть его развернутую версию.
Подсказки В этой задаче нам нужно просто обойти односвязный список и изменить направление его указателей.
Подход Задача заключается в изменении направления указателей односвязного списка. Она может быть решена с помощью итеративного метода, при котором мы будем двигаться по списку, сохраняя предыдущий элемент, текущий и следующий. Затем мы просто изменим направление указателя next для текущего элемента, чтобы он указывал на предыдущий элемент.</description></item><item><title>Модуль subprocess</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/subprocess/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/subprocess/</guid><description>Модуль subprocess является одним из наиболее мощных и распространенных модулей Python для управления другими процессами в операционной системе.
Основная цель subprocess заключается в том, чтобы предоставить простой и удобный способ создания новых процессов, подключения к уже существующим процессам, их управления и взаимодействия с ними.
Одним из основных классов в модуле subprocess является класс Popen, который представляет собой объект, связанный с запущенным в операционной системе процессом.
Например, чтобы запустить новый процесс с помощью Popen, мы можем использовать следующий код:</description></item><item><title>Модуль argparse</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/argparse/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/argparse/</guid><description>Модуль argparse позволяет легко парсить аргументы командной строки.
Это может быть полезно для создания сценариев командной строки, которые должны принимать аргументы от пользователя, например, при написании утилит командной строки.
Пример:
#script.py import argparse parser = argparse.ArgumentParser(description=&amp;#39;Process some integers.&amp;#39;) parser.add_argument(&amp;#39;integers&amp;#39;, metavar=&amp;#39;N&amp;#39;, type=int, nargs=&amp;#39;+&amp;#39;, help=&amp;#39;an integer for the accumulator&amp;#39;) parser.add_argument(&amp;#39;--sum&amp;#39;, dest=&amp;#39;accumulate&amp;#39;, action=&amp;#39;store_const&amp;#39;, const=sum, default=max, help=&amp;#39;sum the integers (default: find the max)&amp;#39;) args = parser.parse_args() print(args.accumulate(args.integers)) В этом примере мы создали парсер аргументов командной строки с помощью argparse, который принимает целочисленные значения и может вычислить их сумму или максимальное значение.</description></item><item><title>Модуль configparser</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/configparser/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/configparser/</guid><description>Модуль configparser позволяет работать с конфигурационными файлами в Python.
Для использования модуля configparser нужно сначала импортировать его:
import configparser Для чтения конфигурационного файла используется метод configparser.ConfigParser() с методом read():
config = configparser.ConfigParser() config.read(&amp;#39;config.ini&amp;#39;) Для записи в конфигурационный файл используется метод write():
config.set(&amp;#39;section&amp;#39;, &amp;#39;option&amp;#39;, &amp;#39;value&amp;#39;) with open(&amp;#39;config.ini&amp;#39;, &amp;#39;w&amp;#39;) as f: config.write(f) Пример работы с конфигурационным файлом:
import configparser # Создаем объект ConfigParser config = configparser.ConfigParser() # Читаем конфигурационный файл config.read(&amp;#39;config.ini&amp;#39;) # Получаем значение параметра из секции db_name = config.get(&amp;#39;database&amp;#39;, &amp;#39;db_name&amp;#39;) # Меняем значение параметра и записываем изменения в файл config.</description></item><item><title>Модуль email / smtplib</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/smtplib/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/smtplib/</guid><description>Модуль smtplib в Python предоставляет возможность отправки электронных писем через Simple Mail Transfer Protocol (SMTP).
Он предоставляет класс SMTP, который упрощает отправку электронной почты из Python-скрипта. Модуль smtplib позволяет отправлять электронные письма, как с аутентификацией, так и без, и можно отправлять как простые текстовые сообщения, так и письма с HTML-контентом.
Вот пример кода для отправки простого текстового сообщения:
import smtplib smtp_server = &amp;#39;smtp.yandex.ru&amp;#39; port = 587 login = &amp;#39;example@yandex.ru&amp;#39; password = &amp;#39;password&amp;#39; from_addr = &amp;#39;example@yandex.ru&amp;#39; to_addr = &amp;#39;example2@yandex.ru&amp;#39; message = &amp;#39;Hello, world!</description></item><item><title>210. Course Schedule II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</guid><description>LeetCode задача 210
Задача Вам дано ( n ) курсов для изучения, пронумерованных от ( 0 ) до ( n-1 ), и массив ( prerequisites ), где ( prerequisites[i] = [a, b] ) означает, что для изучения курса ( a ) предварительно необходимо пройти курс ( b ).
Напишите функцию для нахождения порядка, в котором можно пройти курсы. Если это невозможно, верните пустой массив.
Подсказки Топологическая сортировка может быть использована для решения этой задачи.
Подход Создадим граф, представляющий предварительные требования для каждого курса.</description></item><item><title>Модуль asyncio</title><link>https://romankurnovskii.com/ru/tracks/python-101/standard_library/asyncio/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/standard_library/asyncio/</guid><description>Асинхронное программирование — это концепция программирования, при применении которой запуск длительных операций происходит без ожидания их завершения и не блокирует дальнейшее выполнение программы.
Корутина — это более общая форма подпрограмм. Подпрограммы имеют одну точку входа и одну точку выхода. А корутины поддерживают множество точек входа, выхода и возобновления их выполнения.
Python модуль asyncio позволяет заниматься асинхронным программированием с применением конкурентного выполнения кода, основанного на корутинах.
Вот план использования модуля asyncio:
import asyncio # Определение асинхронной функции с помощью ключевого слова async.</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</guid><description>LeetCode задача 215
Задача Найти k-й по величине элемент в неотсортированном массиве. Примечание: это k-й по величине элемент в отсортированном порядке, а не k-й различный элемент.
Подсказки Можно отсортировать массив и просто взять k-й элемент с конца. Для более эффективного решения можно использовать алгоритм быстрой выборки. Подход В самом простом случае мы можем отсортировать массив и взять k-й элемент с конца.
Алгоритм Сортируем массив. Возвращаем k-й элемент с конца. Решение def findKthLargest(nums, k): nums.sort() return nums[-k] Оптимальное решение На собеседованиях обычно ожидают от кандидата более эффективного решения.</description></item><item><title>234. Palindrome Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/234/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/234/</guid><description>LeetCode problem
Problem Statement Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
Naive Solution A simple solution to this problem is to:
traverse the linked list storing the value of each node in an array. Then, we could compare the array with its reversed version.
If they match, the linked list is a palindrome. Otherwise, it is not.
This solution takes O(n) time (where n is the number of nodes in the list), as we need to traverse the list once.</description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</guid><description>LeetCode задача 236
Задача Найдите наименьшего общего предка (LCA) двух заданных узлов в бинарном дереве.
Подсказки Используйте метод обхода в глубину (DFS) для решения этой задачи.
Подход Обход в глубину (DFS): Используйте рекурсивный метод для обхода дерева. Поиск узлов: При обходе дерева ищите заданные узлы p и q. Возврат значения: Если найден один из узлов, верните его как потенциального предка. Сравнение результатов: Если оба поддерева возвращают узлы, текущий узел является LCA. Пропуск пустых узлов: Если узел пуст, верните None.</description></item><item><title>237. Delete Node in a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</guid><description>LeetCode задача 237
Задача Написать функцию для удаления узла (за исключением хвостового) в односвязном списке, дан только доступ к этому узлу.
Подсказки Обычно, для удаления узла из односвязного списка, нам нужен доступ к предыдущему узлу. В этом случае, у нас такого доступа нет. Как это обойти? Подход Поскольку доступа к предыдущему узлу нет, мы не можем просто &amp;ldquo;вырезать&amp;rdquo; текущий узел. Однако мы можем переписать значение текущего узла значением следующего узла и затем удалить следующий узел.
Алгоритм Перезаписываем значение текущего узла значением следующего узла.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</guid><description>LeetCode задача 238
Задача Дан целочисленный массив nums. Нужно вернуть массив answer, такой что answer[i] равен произведению всех элементов nums, кроме nums[i].
Подсказки Чтобы не использовать операцию деления и оставаться в рамках времени $O(n)$, можно использовать концепцию префиксного и суффиксного произведения для каждого элемента.
Подход Создадим два массива: prefix и suffix.
prefix[i] будет содержать произведение всех чисел слева от i suffix[i] будет содержать произведение всех чисел справа от i. Ответ для i будет равен prefix[i] * suffix[i]. Алгоритм Создадим два массива: prefix и suffix с таким же размером, что и nums.</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</guid><description>LeetCode задача 240
Задача Вам дана двумерная матрица размера m x n, представляющая прямоугольник, и целое число target. Отсортированные строки матрицы по неубыванию с лева направо и столбцы отсортированы по неубыванию сверху вниз.
Найдите элемент target в матрице. Верните True, если элемент target есть в матрице, и False, если его нет.
Подсказки Попробуйте использовать двоичный поиск для каждого ряда.
Подход Самый простой подход - использовать двоичный поиск для каждого ряда. Хотя это не самый эффективный метод, он достаточно прост для понимания.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</guid><description>LeetCode задача 251
Задача Дизайн и реализация итератора для 2D вектора. Итератор должен быть инициализирован 2D вектором (vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;) и должен поддерживать следующие операции:
next(): Возвращает следующий элемент из 2D вектора. Если нет больше элементов, возвращает 0. hasNext(): Возвращает True, если в 2D векторе есть следующий элемент, и False в противном случае. Подход Мы можем использовать две переменные: одну для текущего индекса строки и одну для текущего индекса столбца, чтобы навигироваться по 2D вектору.
Алгоритм Инициализируем переменные row и col в конструкторе.</description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</guid><description>LeetCode задача 277
Задача Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?
Имплементируйте функцию int findCelebrity(n), которая вернет знаменитость если она есть, иначе вернёт -1.
Вам дана функция bool knows(a, b), которая скажет вам, знает ли a человека b.
Подход Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.
Алгоритм Инициализируем переменную candidate значением 0.</description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</guid><description>LeetCode задача
Задача Дан целочисленный массив nums. Нам необходимо переместить все 0 в конец массива, сохраняя относительный порядок ненулевых элементов.
Примечание: вы должны сделать это на месте, без создания копии массива.
Подсказки Используйте два указателя: один будет указывать на текущий элемент, а другой будет указывать на первое место в массиве, куда можно поместить ненулевой элемент.
Подход Мы можем использовать два указателя: один для прохода по массиву и другой для отслеживания местоположения, куда следует поместить следующий ненулевой элемент. Этот метод позволяет нам сделать минимальное количество операций и изменений в массиве.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode задача 287
Задача Дан массив nums размера n + 1, в котором каждый элемент принимает значение от 1 до n, что означает, что как минимум одно число будет дублироваться.
Найдите это дублирующееся число.
Подход Один из способов решения задачи — использование двух указателей (tortoise и hare), что известно как &amp;ldquo;алгоритм зайца и черепахи&amp;rdquo; для нахождения цикла в связанном списке.
Алгоритм Инициализируем два указателя: tortoise и hare. Используем их для прохода по массиву: tortoise двигается на один шаг, а hare — на два.</description></item><item><title>300. Longest Increasing Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</guid><description>LeetCode задача 300
Задача Дан массив чисел, ваша задача — найти длину наибольшей возрастающей подпоследовательности.
Подсказки Для решения этой задачи вы можете использовать динамическое программирование.
Подход Инициализация: Инициализируйте массив, который будет хранить длины наибольших возрастающих подпоследовательностей для каждого элемента массива. Обход массива: Обойдите массив, и для каждого элемента обновите массив длин наибольших возрастающих подпоследовательностей. Максимум: По окончании обхода найдите максимальное значение в массиве длин. Простейший способ решения — это использовать двойной цикл для обхода массива и поиска наибольшей возрастающей подпоследовательности для каждого элемента.</description></item><item><title>Elastic Beanstalk</title><link>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/elasticbeanstalk/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/elasticbeanstalk/</guid><description>AWS Elastic Beanstalk Документация AWS Elastic Beanstalk Документация AWS Elastic Beanstalk Цены Дополнительная плата за AWS Elastic Beanstalk не взимается. Оплате подлежат только ресурсы AWS, необходимые для хранения и работы приложений.
Практика Контролируемое развертывание с AWS Elastic Beanstalk Ссылка на лабораторную работу В этой лабораторной работе развернем несколько обновлений версий приложения в среде с балансировкой нагрузки и автоматическим масштабированием.
Первое обновление развертывается с помощью простого развертывания. Второе обновление развертывается с помощью blue-green развертывания, когда создается отдельная среда для запуска новой версии приложения, а DNS свитчер переключает входящий трафик на новую среду.</description></item><item><title>Лямбда</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/lambda/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/lambda/</guid><description>Лямбда-функции в Python - это безымянные функции, которые можно определить в одной строке и не требуют ключевого слова def. Они используются для написания коротких функций внутри других функций или выражений, где требуется функция в качестве аргумента.
Лямбда-функция определяется ключевым словом lambda, за которым следуют параметры функции, после чего через двоеточие указывается выражение, которое нужно вернуть из функции.
Пример:
add = lambda x, y: x + y print(add(2, 3)) # Output: 5 Здесь мы определяем лямбда-функцию add, которая принимает два аргумента x и y и возвращает их сумму.</description></item><item><title>Декораторы</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/decorators/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/decorators/</guid><description>Декораторы в Python позволяют изменять поведение функций и методов, оборачивая их в другую функцию. В этом разделе мы рассмотрим несколько встроенных декораторов и создание собственного декоратора.
@classmethod Декоратор @classmethod используется для создания методов класса в Python. Методы класса имеют доступ к состоянию класса и могут использоваться без необходимости создания экземпляра класса. Методы класса можно вызывать как от самого класса, так и от его экземпляров.
Декоратор @classmethod применяется к методам класса. Он принимает первым аргументом класс (cls) вместо экземпляра класса (self).</description></item><item><title>Замыкания</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/closure/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/closure/</guid><description>Замыкание в Python - это функция, которая запоминает значения из внешней области видимости, даже если эта область видимости больше не существует. Таким образом, замыкание позволяет функции использовать переменные, которые были определены вне самой функции.
Пример:
def outer_func(x): def inner_func(y): return x + y return inner_func closure = outer_func(10) result = closure(5) print(result) # выводит 15 В этом примере outer_func возвращает inner_func, которая запоминает значение x. Затем outer_func вызывается, и возвращаемая функция сохраняется в closure. Затем closure вызывается с аргументом 5, и она использует сохраненное значение x (которое равно 10), чтобы вернуть результат 15.</description></item><item><title>Отладка Python</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/debugging/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/debugging/</guid><description>Python поставляется с собственным модулем отладчика, который называется pdb. Этот модуль предоставляет интерактивный отладчик исходного кода для ваших программ на Python. Вы можете устанавливать брейкпоинты, просматривать код, изучать кадры стека и многое другое. Мы рассмотрим следующие аспекты этого модуля:
Например, чтобы установить точку останова в коде, можно вставить следующую строку в месте, где вы хотите остановить выполнение программы:
import pdb; pdb.set_trace() После запуска программы выполнение остановится на этой строке, и вы сможете использовать различные команды отладчика для изучения переменных и выполнения других операций.</description></item><item><title>Тестирование</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/testing/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/testing/</guid><description>unittest Python поставляется со встроенным модулем для тестирования - unittest.
Пример теста:
import unittest def square(x): return x * x class TestSquare(unittest.TestCase): def test_positive(self): self.assertEqual(square(2), 4) self.assertEqual(square(3), 9) self.assertEqual(square(4), 16) def test_negative(self): self.assertEqual(square(-2), 4) self.assertEqual(square(-3), 9) self.assertEqual(square(-4), 16) if __name__ == &amp;#39;__main__&amp;#39;: unittest.main() В этом примере мы создаем тестовый класс TestSquare, который наследуется от unittest.TestCase. В этом классе мы определяем два метода: test_positive и test_negative. Эти методы используют метод assertEqual для проверки ожидаемых результатов.
Метод assertEqual сравнивает два значения и генерирует исключение, если они не равны.</description></item><item><title>328. Odd Even Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</guid><description>LeetCode задача 328
Задача Дан односвязный список и задача переставить его узлы таким образом, чтобы все узлы с нечетными индексами шли перед всеми узлами с четными индексами.
Вариант решения 1 Рассмотрим вариант решения более простой для понимания и реализации.
Подсказки Использовать два связных списка.
Подход Во время прохода по связному списку указатель для чётных узлов добавлять связанный список с четными, то же самое делать с нечетными.
В конце прохода список с четными узлами добавить в конец списка с нечетными узлами.</description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</guid><description>LeetCode problem
Задача Дан целочисленный массив nums. Вернуть true, если существует тройка индексов (i, j, k) таких, что
i &amp;lt; j &amp;lt; k и nums[i] &amp;lt; nums[j] &amp;lt; nums[k]. Если таких индексов нет, вернуть false.
Подсказки Для решения этой задачи вам необходимо найти возможное максимальное и минимальное число до текущего числа, не используя дополнительное пространство памяти.
Подход Мы можем обойти список, используя два указателя, чтобы хранить первое минимальное и последующие &amp;ldquo;два&amp;rdquo; минимальные значения, которые мы встретили до сих пор.</description></item><item><title>341. Flatten Nested List Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</guid><description>Задача Дан вложенный список целых чисел. Реализуйте итератор, который &amp;ldquo;разворачивает&amp;rdquo; этот вложенный список.
Подход Задача состоит в реализации итератора, который будет последовательно возвращать все элементы из вложенного списка. Вложенный список может содержать как обычные числа, так и другие вложенные списки. Наивное решение заключается в том, чтобы сначала полностью &amp;ldquo;развернуть&amp;rdquo; весь вложенный список в одномерный список, а затем реализовать итератор для этого одномерного списка.
Алгоритм Инициализация: Создать одномерный список и заполнить его элементами из вложенного списка. next(): Возвращает следующий элемент одномерного списка.</description></item><item><title>345. Reverse Vowels of a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/345/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/345/</guid><description>LeetCode задача 345
Задача Задана строка s. Необходимо перевернуть только гласные буквы в этой строке и вернуть результат.
Гласные буквы: 'a', 'e', 'i', 'o', 'u'. Они могут встречаться в верхнем и нижнем регистрах, и более одного раза.
Подсказки Для решения задачи можно использовать два указателя: один с начала строки, другой с конца. Затем можно двигаться этими указателями к центру строки, меняя местами гласные буквы.
Подход Используем два указателя для итерации по строке: один с начала (left), другой с конца (right).</description></item><item><title>Установка пакетов</title><link>https://romankurnovskii.com/ru/tracks/python-101/external_packages/install_packages/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/external_packages/install_packages/</guid><description>Python-пакеты можно искать на официальном репозитории PyPI (Python Package Index) по адресу https://pypi.org/. В PyPI представлены большинство сторонних пакетов для Python, их можно устанавливать с помощью менеджера пакетов pip.
Также существуют другие источники для поиска и установки Python-пакетов, например, Anaconda, Conda-forge и т.д.
Для установки пакетов в Python существует несколько способов. Рассмотрим наиболее распространенные из них:
Установка с помощью pip pip - это менеджер пакетов для Python, который упрощает установку, удаление и обновление пакетов. Чтобы установить пакет с помощью pip, необходимо выполнить команду в терминале:</description></item><item><title>Пакет requests</title><link>https://romankurnovskii.com/ru/tracks/python-101/external_packages/requests/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/external_packages/requests/</guid><description>Модуль requests - это сторонняя библиотека Python для отправки HTTP-запросов. Он предоставляет удобный и простой API для отправки GET-, POST-, PUT-, DELETE- и других типов запросов.
Установить requests можно с помощью менеджера пакетов pip:
pip install requests Пример GET-запроса:
import requests response = requests.get(&amp;#34;https://www.example.com&amp;#34;) print(response.status_code) print(response.text) Пример POST-запроса:
import requests payload = {&amp;#39;key1&amp;#39;: &amp;#39;value1&amp;#39;, &amp;#39;key2&amp;#39;: &amp;#39;value2&amp;#39;} response = requests.post(&amp;#34;https://site.org/post&amp;#34;, data=payload) print(response.status_code) print(response.json()) Модуль requests также поддерживает отправку запросов с использованием сессий, установку заголовков, аутентификацию и другие полезные функции для работы с HTTP-запросами.</description></item><item><title>377. Combination Sum IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</guid><description>LeetCode задача 377
Задача Дан массив различных целых чисел nums и целевое целое число target от 1 до 1000. Нужно вернуть количество возможных комбинаций, которые в сумме дают target.
Подсказки Построить дерево решений Задачу можно решить путем разложения ее на меньшие подзадачи с помощью динамического программирования. Нахождение целевого значения в дереве решений
Your browser does not support the video tag. LeetCode 377 Решение Подход Если целевое значение - target=7 и nums=[2, 3, 4], то в дереве решений может быть несколько путей до этого числа.</description></item><item><title>384. Shuffle an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</guid><description>LeetCode задача 384
Задача Реализуйте класс, который принимает массив чисел в конструкторе и предоставляет метод для их случайного перемешивания, а также метод для возвращения исходного массива.
Подсказки Для создания случайного порядка элементов можно использовать алгоритм Фишера-Йетса или другие методы перемешивания.
Подход Инициализация: Сохранить исходный массив в переменной класса для дальнейшего использования. reset(): Вернуть исходный массив. shuffle(): Вернуть перемешанный массив. Из всех возможных подходов к решению этой задачи, наиболее простым является использование встроенного метода random.shuffle() из Python стандартной библиотеки для перемешивания массива.</description></item><item><title>387. First Unique Character in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/387/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/387/</guid><description>LeetCode задача 387
Задача Дана строка s. Найдите первый уникальный символ в строке и верните его индекс. Если такого символа нет, верните -1.
Подсказки Использование хеш-таблицы может ускорить процесс поиска уникальных символов.
Подход Инициализация: Создайте хеш-таблицу для хранения частоты каждого символа в строке. Первый проход: Пройдите по строке и заполните хеш-таблицу. Второй проход: Пройдите по строке второй раз и проверьте частоту каждого символа в хеш-таблице. Первый символ с частотой 1 будет ответом. Этот подход прост для понимания и реализации.</description></item><item><title>388. Longest Absolute File Path</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/388/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/388/</guid><description>LeetCode задача 388
Задача Необходимо вычислить длину самого длинного абсолютного пути к файлу в файловой системе. Путь представлен строкой, где &amp;ldquo;\n&amp;rdquo; разделяет имена директорий и файлов, а &amp;ldquo;\t&amp;rdquo; обозначает уровень вложенности.
Подсказки Задача заключается в анализе строки, представляющей файловую систему, и определении максимальной длины пути к файлу, учитывая вложенность директорий.
Подход Мы можем решить эту задачу, используя стек для отслеживания текущего пути и его длины. Каждый раз, когда мы встречаем файл, мы сравниваем его полную длину с максимальной и обновляем максимум при необходимости.</description></item><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/392/</guid><description>LeetCode задача 392
Задача Даны две строки s и t. Верните true, если s является подпоследовательностью t, или false в противном случае.
Подпоследовательность строки - это новая строка, которая формируется из исходной строки путем удаления некоторых (может быть ни одного) символов без нарушения относительных позиций оставшихся символов. (например, &amp;ldquo;ace&amp;rdquo; является подпоследовательностью &amp;ldquo;abcde&amp;rdquo;, в то время как &amp;ldquo;aec&amp;rdquo; - нет).
Подсказки Следуя за обеими строками одновременно с помощью двух указателей, вы можете определить, является ли одна строка подпоследовательностью другой.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode задача 394
Задача На вход подается закодированная строка, необходимо вернуть её декодированное представление.
Правило кодирования таково: k[encoded_string], где encoded_string - строка внутри квадратных скобок, повторяется ровно k раз. k - это всегда положительное целое число.
Подсказки Для решения этой задачи можно использовать стек, т.к. число[строка] могут быть вложенными.
Подход Всё, что нам нужно, это итерировать строку символ за символом и обрабатывать четыре случая: числа, буквы и скобки. Мы будем использовать один стек для хранения пар вида (префикс строки, число).</description></item><item><title>Flask</title><link>https://romankurnovskii.com/ru/tracks/python-101/frameworks/flask/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/frameworks/flask/</guid><description>Flask - это легковесный фреймворк для создания веб-приложений на языке Python. Он подходит как для небольших проектов, так и для крупных веб-приложений.
Flask не имеет встроенной базы данных или абстракции уровня модели, поэтому вам нужно будет выбрать библиотеку, которая лучше всего подходит для вашего проекта.
pip install flask pip install flask_sqlalchemy Пример CRUD-операций с использованием Flask:
from flask import Flask, request, jsonify from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) app.config[&amp;#39;SQLALCHEMY_DATABASE_URI&amp;#39;] = &amp;#39;sqlite:///example.db&amp;#39; db = SQLAlchemy(app) class Book(db.Model): id = db.</description></item><item><title>Django</title><link>https://romankurnovskii.com/ru/tracks/python-101/frameworks/django/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/frameworks/django/</guid><description>Django - это высокоуровневый фреймворк для веб-приложений на языке Python. Он предоставляет множество инструментов для разработки сайтов, начиная от автоматического создания административного интерфейса до работы с базами данных. Основными принципами, которыми руководствуется Django, являются: быстрота разработки, возможность переиспользования кода и расширяемость.
Установим необходимые пакеты:
pip install django Для начала работы с Django нужно создать проект. Для этого в командной строке нужно ввести команду:
django-admin startproject project_name После этого будет создан проект с именем &amp;ldquo;project_name&amp;rdquo;. Внутри проекта есть файлы настроек и приложения.</description></item><item><title>FastAPI</title><link>https://romankurnovskii.com/ru/tracks/python-101/frameworks/fastapi/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/frameworks/fastapi/</guid><description>FastAPI - это фреймворк для создания веб-приложений на Python, использующий современный подход к созданию API и основанный на ASGI-серверах. Он разработан с упором на скорость и быстродействие, предоставляя возможности асинхронного выполнения запросов, автоматического документирования API и многие другие.
Для установки FastAPI нужно выполнить команду pip install fastapi. Для запуска приложения можно использовать стандартный инструмент uvicorn, который также необходимо установить: pip install uvicorn.
Пример CRUD приложения на FastAPI:
from fastapi import FastAPI, HTTPException from pydantic import BaseModel from typing import Dict app = FastAPI() # Имитация базы данных db = {} # Модель для создания/редактирования задачи class Task(BaseModel): title: str description: str # Модель для ответа со списком задач class TaskList(BaseModel): tasks: Dict[int, Task] # Получение списка задач @app.</description></item><item><title>Tornado</title><link>https://romankurnovskii.com/ru/tracks/python-101/frameworks/tornado/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/frameworks/tornado/</guid><description>Tornado - это еще один быстрый веб-фреймворк, который разработан для обработки больших объемов трафика в режиме реального времени.
Для начала работы с Tornado нам нужно установить его, используя команду pip:
pip install tornado import tornado.ioloop import tornado.web import tornado.escape class MainHandler(tornado.web.RequestHandler): def get(self): items = [{&amp;#39;id&amp;#39;: 1, &amp;#39;name&amp;#39;: &amp;#39;Item 1&amp;#39;}, {&amp;#39;id&amp;#39;: 2, &amp;#39;name&amp;#39;: &amp;#39;Item 2&amp;#39;}] self.write(tornado.escape.json_encode(items)) class ItemHandler(tornado.web.RequestHandler): def get(self, id): item = {&amp;#39;id&amp;#39;: id, &amp;#39;name&amp;#39;: &amp;#39;Item &amp;#39; + id} self.write(tornado.escape.json_encode(item)) def post(self, id): item = {&amp;#39;id&amp;#39;: id, &amp;#39;name&amp;#39;: self.</description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</guid><description>LeetCode задача 437
Задача Дан корень бинарного дерева и целое число targetSum. Верните количество путей, где сумма значений вдоль пути равна targetSum.
Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).
Подсказки Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.
Подход Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня.</description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</guid><description>LeetCode задача 443
Задача Дан массив символов chars, ваша задача — сжать его с помощью следующего алгоритма: Заменить последовательность одинаковых символов одним символом, за которым идет его количество.
Пример: &amp;ldquo;aaabbaaa&amp;rdquo; =&amp;gt; &amp;ldquo;a3b2a3&amp;rdquo;
Подход В этой задаче у нас есть два указателя: один для чтения элементов из исходного массива (read_ptr) и второй для записи результата сжатия в тот же массив (write_ptr). Сначала оба указателя стоят на начале массива. Далее, read_ptr движется вправо, считая количество повторяющихся символов. После подсчета, мы записываем символ и его количество в массив, используя write_ptr.</description></item><item><title>454. 4Sum II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</guid><description>LeetCode задача 454
Задача Даны четыре списка A, B, C, D целых чисел. Вычислите, сколько существует таких кортежей (i, j, k, l), что ( A[i] + B[j] + C[k] + D[l] = 0 ).
Подсказки Используйте хэш-таблицу для ускорения решения.
Подход Создание хэш-таблицы: Сначала создайте хэш-таблицу, которая будет хранить суммы пар чисел из массивов A и B. Подсчет сумм: Для каждой пары (i, j) из A и B, увеличьте соответствующий элемент хэш-таблицы на 1. Поиск в хэш-таблице: Для каждой пары (k, l) из C и D, проверьте, существует ли -(C[k] + D[l]) в хэш-таблице.</description></item><item><title>Топ 55 вопросов по Python</title><link>https://romankurnovskii.com/ru/tracks/python-101/top-questions/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/top-questions/</guid><description>В процессе заполнения
Скачать | PDF обновление 2023/02/17
Junior 1. Что такое Python? Какие преимущества использования Python? Python - это высокоуровневый интерпретируемый язык программирования общего назначения. Будучи языком общего назначения, он может быть использован для создания практически любого типа приложений при наличии соответствующих инструментов/библиотек.
Кроме того, python поддерживает объекты, модули, потоки, обработку исключений и автоматическое управление памятью, что помогает моделировать реальные проблемы и создавать приложения для решения этих проблем.
Преимущества использования Python:
Python - это язык программирования общего назначения, который имеет простой, легко изучаемый синтаксис, подчеркивающий удобочитаемость и, следовательно, снижающий затраты на сопровождение программ.</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode задача 605
Задача Дана длинная грядка, на которой некоторые участки уже засажены, а некоторые нет. Однако цветы нельзя сажать на соседние участки.
Подход Чтобы решить эту задачу, мы будем итерироваться по каждому участку грядки. Если участок пустой и его соседи (если они существуют) тоже пусты, мы сажаем цветок и уменьшаем наш счетчик.
Алгоритм Итерируемся по каждому участку грядки. Если участок пустой, проверяем его соседей. Если левый сосед пустой или его нет (начало грядки), проверяем правого соседа. Если правый сосед пустой или его нет (конец грядки), сажаем цветок на текущий участок и уменьшаем n.</description></item><item><title>643. Maximum Average Subarray I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/643/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/643/</guid><description>LeetCode problem
Problem Statement Given an integer array nums consisting of n elements and an integer k, find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. The result must be accurate up to a decimal point of 10^(-5).
Naive Solution A straightforward approach would be to calculate the average for every possible subarray of length k. For each starting point, sum the next k numbers and determine the average.</description></item><item><title>649. Dota2 Senate</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</guid><description>LeetCode задача 649
Задача В игре Dota2, сенат состоит из двух партий: партии &amp;ldquo;Radiant&amp;rdquo; и партии &amp;ldquo;Dire&amp;rdquo;. Сенат решает, когда будет следующая игра, и каждый сенатор может голосовать за бан одного из сенаторов из другой партии.
Забаненные сенаторы не могут делать действий и не участвуют в процессе подготовки следующего раунда.
Предположим, у нас есть строка &amp;ldquo;RRDDD&amp;rdquo;. Здесь первый сенатор принадлежит партии Radiant, второй тоже к Radiant, третий, четвертый и пятый к Dire. Сначала первый сенатор Radiant делает ход, затем первый сенатор Dire, и так далее.</description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</guid><description>LeetCode problem
Problem Statement Given an array of integers nums, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.
Naive Solution A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode задача 725
Задача Дан односвязный список и целое число k. Задача заключается в том, чтобы разделить односвязный список на k последовательных частей.
Длина каждой части должна быть максимально равномерной: любые две части не должны отличаться по размеру более чем на одну единицу. Это может привести к тому, что некоторые части будут пустыми (null).
Части должны идти в том порядке, в котором они встречаются в исходном списке, и ранее встречающиеся части всегда должны иметь размер больше или равный позднее встречающимся.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode задача 735
Задача Мы имеем массив asteroids целых чисел, представляющих астероиды в ряду. Для каждого астероида абсолютное значение представляет его размер, а знак представляет его направление (положительное означает вправо, отрицательное влево). Все астероиды движутся с одинаковой скоростью. Необходимо определить состояние астероидов после всех столкновений.
Подсказки Для решения задачи можно использовать стек.
Подход Мы будем использовать стек для отслеживания движущихся вправо астероидов. Когда мы видим астероид, движущийся влево, мы проверяем, будет ли он сталкиваться с верхним элементом стека (астероидом, движущимся вправо).</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>872. Leaf-Similar Trees</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/872/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/872/</guid><description>LeetCode задача 872
Задача Даны два бинарных дерева с корнями root1 и root2. Проверьте, являются ли эти деревья &amp;ldquo;листоподобными&amp;rdquo; (leaf-similar). Деревья считаются &amp;ldquo;листоподобными&amp;rdquo;, если последовательность листовых узлов каждого дерева одинакова.
Подсказки Листовые узлы бинарного дерева — это узлы, у которых нет потомков. Для проверки &amp;ldquo;листоподобности&amp;rdquo; двух деревьев нужно сравнить последовательности листовых узлов этих деревьев.
Подход / Идея решения Идея решения заключается в построении списков листовых узлов для каждого дерева, а затем сравнении этих списков. Мы можем рекурсивно обойти каждое дерево, проверяя при каждом узле, является ли он листовым.</description></item><item><title>933. Number of Recent Calls</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/933/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/933/</guid><description>LeetCode задача 933
Задача Реализуйте класс RecentCounter для подсчета вызовов ping за последние 3000 миллисекунд.
Т.е. для вызова t=100, нужно подсчитать количество таких вызовов, время которых меньше t-3000 и учесть сам вызов.
Подход В данной задаче нужно отслеживать количество вызовов ping за последние 3000 миллисекунд.
Можно использовать очередь для хранения времени вызовов ping. При каждом новом вызове будем добавлять текущее время в конец очереди и удалять из начала все времена, которые не попадают в интервал последних 3000 миллисекунд.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1004/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1004/</guid><description>LeetCode задача 1004
Задача Дан массив A состоящий из 0 и 1, и число K. Найти максимальную длину подпоследовательности единиц, которую можно получить, преобразовав не более K нулей в единицы.
Подсказки Использование скользящего окна может значительно ускорить решение задачи.
Подход Инициализация: Создайте переменные для хранения начала и конца &amp;ldquo;окна&amp;rdquo; и максимальной длины подпоследовательности. Проход по массиву: Перемещайте &amp;ldquo;окно&amp;rdquo; по массиву, подсчитывая количество нулей внутри. Сдвиг окна: Если количество нулей превышает K, сдвигайте левый край окна, пока это не станет истиной.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode задача 1071
Задача Для двух строк str1 и str2, вернуть наибольший общий делитель (НОД). Если такового не существует, вернуть пустую строку.
Подход Если строки str1 и str2 имеют НОД строки X, то str1 и str2 могут быть представлены в форме Xn и Xm (где n и m — это натуральные числа), соответственно. Это означает, что str1 должна начинаться с str2 или наоборот.
Алгоритм Проверка начала строк: если str1 не начинается с str2 или наоборот, то НОД не существует.</description></item><item><title>1207. Unique Number of Occurrences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1207/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1207/</guid><description>LeetCode problem
Problem Statement Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
Naive Solution A naive approach would be to create a dictionary to store the count of each integer, then iterate over the dictionary and compare each count with the counts of other integers. This approach requires O(n^2) time complexity, where n is the length of the array. This is not efficient for large input sizes.</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</guid><description>LeetCode задача 1359
Задача Дано n заказов, каждый заказ состоит из услуг по приему и доставке.
Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).
Так как ответ может быть очень большим, верните его по модулю 10^9 + 7.
Подсказки Использовать комбинаторный подход.
Для каждого нового заказа у нас есть 2 * (2n-1) способов добавить его в текущую последовательность.
Мы используем данную формулу, так как:
Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест).</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1372/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1372/</guid><description>LeetCode задача 1372
Задача Найти самый длинный &amp;ldquo;ZigZag&amp;rdquo; путь в бинарном дереве. Путь &amp;ldquo;ZigZag&amp;rdquo; означает альтернативное движение влево и вправо при переходе от одного узла к другому.
Подсказки Используйте Depth-First Search (DFS) для решения задачи.
Подход DFS с состоянием: Запустите DFS с дополнительным аргументом, который будет отслеживать, в какую сторону нужно двигаться следующим (влево или вправо). Обновление максимума: На каждом уровне рекурсии проверьте, не превышает ли текущая длина пути максимальную известную длину. Рекурсивный вызов: Продолжайте движение в обоих направлениях, но учитывайте, что направление должно изменяться.</description></item><item><title>1448. Count Good Nodes in Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1448/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1448/</guid><description>LeetCode задача 1448
Задача Дано бинарное дерево. Задача подсчитать количество &amp;ldquo;хороших&amp;rdquo; узлов. Узел считается &amp;ldquo;хорошим&amp;rdquo;, если на пути от корня дерева до этого узла (включительно) не встречается узлов с большим значением.
Подсказки &amp;ldquo;Хороший&amp;rdquo; узел в дереве — это узел, для которого все узлы на пути от корня до этого узла имеют значение не больше, чем значение этого узла.
Использовать метод обхода в глубину (DFS) для решения этой задачи.
Подход Идея решения задачи заключается в рекурсивном обходе дерева с сохранением максимального значения на пути от корня к текущему узлу.</description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1456/</guid><description>LeetCode Problem 1456
Problem Statement Given a string s and an integer k, the task is to return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.
Naive Solution The most straightforward solution to this problem is to take every possible substring of length k and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length k.</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</guid><description>LeetCode задача 1647
Задача Строка s называется хорошей, если в ней нет двух разных символов с одинаковой частотой.
Дана строка s, верните минимальное количество символов, которое необходимо удалить, чтобы сделать s хорошим.
Подход Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.
Если проверять встречалась ли частота текущего символа ранее, то
Алгоритм / Абстрактный алгоритм Считаем частоты всех символов в строке. Сортируем частоты в порядке убывания.</description></item><item><title>1657. Determine if Two Strings Are Close</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1657/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1657/</guid><description>LeetCode problem
Problem Statement Two strings are considered close if you can attain one from the other using two operations:
Swap any two existing characters. Transform every occurrence of one existing character into another existing character, and do the same with the other character. The challenge is to determine whether two given strings are close or not.
Naive Solution A naive approach might involve trying every possible combination of operations on the two strings until they match or until you&amp;rsquo;ve exhausted all possibilities.</description></item><item><title>1679. Max Number of K-Sum Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</guid><description>LeetCode задача 1679
Задача Вам дан массив чисел nums и целое число k. Задача — найти максимальное количество пар в массиве, сумма элементов которых равна k.
Подсказки Используйте технику двух указателей(pointers) после сортировки массива для оптимизации поиска пар.
Подход Центральная идея решения задачи заключается в использовании техники двух указателей для быстрого нахождения пар чисел с заданной суммой k. Прежде чем применить эту технику, массив сортируется в возрастающем порядке. Затем создаются два указателя: один, указывающий на начало массива, и второй — на конец.</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1732/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1732/</guid><description>LeetCode задача 1732
Задача Велосипедист совершает путешествие, которое состоит из n + 1 точек на разных высотах. Путешествие начинается с точки 0, где высота равна 0.
Дан целочисленный массив gain длиной n, где gain[i] — это прирост высоты между точками i и i + 1 для всех (0 &amp;lt;= i &amp;lt; n).
Задача - вернуть самую высокую высоту точки.
Подход В этой задаче, вам нужно пройти по массиву gain и вычислить текущую высоту на каждом этапе. При этом следует отслеживать самую высокую высоту, которую вы достигли.</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</guid><description>LeetCode задача 1768
Задача Вам даны две строки word1 и word2. Объедините эти строки, добавляя буквы в чередующем порядке, начиная с word1. Если одна строка длиннее другой, дополнительные буквы добавляются в конец результирующей строки.
Подход Чтобы решить эту задачу, мы можем использовать два указателя для каждого слова. Начнем с первого символа каждой строки и будем чередовать их, пока одна из строк не закончится. После этого, мы просто добавляем оставшиеся символы из более длинного слова к результирующей строке.
Алгоритм Инициализация результирующей строки и двух указателей для word1 и word2.</description></item><item><title>2013. Detect Squares</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2013/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2013/</guid><description>LeetCode задача 2013
В данное задаче решение будет с использованием переменных на русском языке
Задача Задача заключается в разработке структуры данных, которая позволяет добавлять точки на плоскости и подсчитывать количество квадратов, которые можно образовать, добавив новую точку.
Подсказки Решение включает в себя поддержку двух типов данных:
Счётчик точек счетчик_точек, который хранит информацию о количестве каждой точки на плоскости. Словарь координат по оси X координаты_по_x, который для каждой координаты x содержит счётчик координат y, позволяющий быстро находить все точки с данной координатой x.</description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</guid><description>LeetCode задача 2095
Задача Дан связный список (linked list). Задача — удалить средний узел из этого списка и вернуть начало(head) измененного списка.
Подсказки Мы можем использовать метод двух указателей для того, чтобы найти средний узел в одном проходе по списку, где второй указатель проходит весь список в два раза быстрее первого указателя.
Подход Используем два указателя для прохода по списку: один медленный и один быстрый. Оба начинают с головного узла списка. Быстрый указатель будет двигаться в два раза быстрее медленного.</description></item><item><title>2108. Find First Palindromic String in the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2108/</guid><description>LeetCode problem 2108
class Solution: def firstPalindrome(self, words: List[str]) -&amp;gt; str: return next((w for w in words if w == w[::-1]), &amp;#34;&amp;#34;)</description></item><item><title>2130. Maximum Twin Sum of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</guid><description>LeetCode задача 2130
Задача Дан односвязный список четной длины. Узлы в этом списке имеют &amp;ldquo;близнецов&amp;rdquo; по определенным правилам. Задача — найти максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.
Т.е. у первой половины узлов списка есть свой близнец из второй половины.
Пример: для списка длиной n = 8 i = 0, twin = n-1-i = 8-1-0 = 7 i = 1, twin = n-1-1 = 6 i = 2, twin = n-1-2 = 5 &amp;hellip;
Подсказки У первой половины узлов списка есть свой близнец из второй половины, т.</description></item><item><title>2215. Find the Difference of Two Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2215/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2215/</guid><description>LeetCode problem
Problem Statement Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:
answer[0] is a list of all distinct integers in nums1 which are not present in nums2. answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order.
Naive Solution A naive approach would be to iterate over each element of the first array and check whether it&amp;rsquo;s in the second array.</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode задача 2352
Задача Дана квадратная матрица целых чисел grid размером n×n. Задача состоит в том, чтобы определить, сколько пар строк и столбцов в матрице идентичны по своему содержанию и порядку.
Строка и столбец считаются равными, если они содержат одни и те же элементы в том же порядке.
Подсказки Для решения задачи можно воспользоваться тем фактом, что каждая строка и столбец представляют собой набор чисел. Если мы конвертируем их в строки, то можем сравнивать их друг с другом.</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2844/</guid><description>LeetCode задача 2844
Задача Дана строка num, представляющая неотрицательное целое число. За одну операцию вы можете выбрать любую цифру числа num и удалить её. Вашей задачей является определить минимальное количество операций, необходимых для преобразования данного числа в &amp;ldquo;специальное&amp;rdquo; число.
Число считается &amp;ldquo;специальным&amp;rdquo;, если оно делится на 25.
Подход Анализ возможных окончаний числа: Число, делится на 25 если одно из четырёх возможных окончаний: &amp;lsquo;00&amp;rsquo;, &amp;lsquo;25&amp;rsquo;, &amp;lsquo;50&amp;rsquo;, &amp;lsquo;75&amp;rsquo;.
При этом самое последнее число должно быть из двух вариантов: &amp;lsquo;5&amp;rsquo; и &amp;lsquo;0&amp;rsquo;.</description></item><item><title>3002. Maximum Size of a Set After Removals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3002/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3002/</guid><description>LeetCode problem 3002
class Solution: def maximumSetSize(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) s1 = set(nums1) s2 = set(nums2) a = min(len(s1 - s2), n // 2) b = min(len(s2 - s1), n // 2) return min(a + b + len(s1 &amp;amp; s2), n)</description></item><item><title>3018. Maximum Number of Removal Queries That Can Be Processed I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3018/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3018/</guid><description>LeetCode problem 3018
class Solution: def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -&amp;gt; int: n = len(nums) f = [[0] * n for _ in range(n)] m = len(queries) for i in range(n): for j in range(n - 1, i - 1, -1): if i: f[i][j] = max( f[i][j], f[i - 1][j] + (nums[i - 1] &amp;gt;= queries[f[i - 1][j]]) ) if j + 1 &amp;lt; n: f[i][j] = max( f[i][j], f[i][j + 1] + (nums[j + 1] &amp;gt;= queries[f[i][j + 1]]) ) if f[i][j] == m: return m return max(f[i][i] + (nums[i] &amp;gt;= queries[f[i][i]]) for i in range(n))</description></item><item><title>3026. Maximum Good Subarray Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3026/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3026/</guid><description>LeetCode problem 3026
class Solution: def maximumSubarraySum(self, nums: List[int], k: int) -&amp;gt; int: res = -inf p = {nums[0]: 0} s, n = 0, len(nums) for i, x in enumerate(nums): s += x if x - k in p: res = max(res, s - p[x - k]) if x + k in p: res = max(res, s - p[x + k]) if i + 1 &amp;lt; n and (nums[i + 1] not in p or p[nums[i + 1]] &amp;gt; s): p[nums[i + 1]] = s return 0 if res == -inf else res</description></item><item><title>3028. Ant on the Boundary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</guid><description>LeetCode задача 3028
Воспользуемся функцией accumulate из модуля itertools, чтобы упростить вычисление и подсчет количества раз, когда муравей возвращается на границу, пройдя через массив nums.
Применяем функцию accumulate для подсчета накопительной суммы и подсчитываем количество раз, когда накопительная сумма равна 0.
Решение class Solution: def returnToBoundaryCount(self, nums: List[int]) -&amp;gt; int: return sum(s == 0 for s in accumulate(nums)) Функция accumulate(nums) генерирует последовательность накопленных сумм элементов массива nums, начиная с первого элемента.
Затем с помощью генераторного выражения s == 0 for s in accumulate(nums) мы создаем последовательность True и False, в зависимости от того, равна ли накопленная сумма в каждой точке нулю.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3029/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3029/</guid><description>https://leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-i/description/
class Solution: def minimumTimeToInitialState(self, word: str, k: int) -&amp;gt; int: n = len(word) # Calculate the length of the word # Iterate through the word in steps of k for i in range(k, n, k): # Check if the suffix starting from i matches the prefix up to n-i if word[i:] == word[:-i]: # If they match, the word can return to the initial state in i/k steps return i // k # If no matching prefix and suffix are found, # return the ceiling division of n by k return (n + k - 1) // k Length Calculation: First, calculate the length of word to know the range we&amp;rsquo;re working with.</description></item><item><title>3030. Find the Grid of Region Average</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</guid><description>LeetCode задача 3030
Дана матрица m x n, представляющая изображение в оттенках серого, где image[i][j] представляет пиксель с интенсивностью в диапазоне от 0 до 255. Также дано неотрицательное целое число threshold (пороговое значение).
Два пикселя image[a][b] и image[c][d] считаются соседними, если |a - c| + |b - d| == 1.
Регионом считается матрица 3 x 3, где абсолютная разница в интенсивности между любыми двумя соседними пикселями меньше или равна threshold.
Необходимо вычислить матрицу m x n result, где result[i][j] - это средняя интенсивность региона, к которому принадлежит image[i][j], округленная вниз до ближайшего целого числа.</description></item><item><title>3031. Minimum Time to Revert Word to Initial State II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3031/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3031/</guid><description>LeetCode problem 3031
class Hashing: __slots__ = [&amp;#34;mod&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;p&amp;#34;] def __init__(self, s: str, base: int, mod: int): self.mod = mod self.h = [0] * (len(s) + 1) self.p = [1] * (len(s) + 1) for i in range(1, len(s) + 1): self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod self.p[i] = (self.p[i - 1] * base) % mod def query(self, l: int, r: int) -&amp;gt; int: return (self.h[r] - self.h[l - 1] * self.</description></item><item><title>3032</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3032/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3032/</guid><description>https://leetcode.com/problems/count-numbers-with-unique-digits-ii
class Solution: def numberCount(self, a: int, b: int) -&amp;gt; int: # Initialize the count of numbers with all unique digits unique_digit_count = 0 # Loop through each number in the range from a to b, inclusive for num in range(a, b + 1): # Convert the number to a string to examine its digits num_str = str(num) # Convert the string to a set of characters to remove duplicates unique_digits = set(num_str) # If the length of the set is equal to the length of the number string, # it means all digits are unique if len(unique_digits) == len(num_str): # Increment the count for each number with all unique digits unique_digit_count += 1 # Return the total count of unique digit numbers return unique_digit_count</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3033/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3033/</guid><description>class Solution: def modifiedMatrix(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: rows = len(matrix) cols = len(matrix[0]) for j in range(rows): max_val = max(matrix[i][j] for i in range(cols)) for i in range(cols): if matrix[i][j] == -1: matrix[i][j] = max_val return matrix</description></item><item><title>Инструкция для лотереи Green Card 🍀</title><link>https://romankurnovskii.com/ru/posts/green-card/</link><pubDate>Sat, 28 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/green-card/</guid><description>Фотография - один из самых важных моментов участия в лотерее. Если ваша фотография не будет соответствовать всем критериям и правилам, то вам имеют право отказать в выдаче визы. Любые нарушения остаются на усмотрение консула.
Поэтому, чтобы максимально избежать риска отказа в визе, когда вы выиграете, то нужно убедиться, что ваша фотография (и всех членов семьи) соответствует критериям, которые я описываю ниже.
1. Общие критерии — цветная фотография;
— голова на фотографии должна занимать от 50% до 69% от общей высоты изображения, начиная с верхней части головы, включая волосы, до нижней части подбородка;</description></item><item><title>Certificates</title><link>https://romankurnovskii.com/ru/posts/certificates/</link><pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/certificates/</guid><description/></item><item><title>Подписка</title><link>https://romankurnovskii.com/ru/p/subscribe/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/p/subscribe/</guid><description> LeetCode решения RU] - Email
LeetCode решения EN - Email
Все обновления - Email
Получай рассылку с сайта Подписаться</description></item><item><title>Как создать приложение React-Electron с нуля</title><link>https://romankurnovskii.com/ru/posts/howto-create-react-electron-app-ts/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/howto-create-react-electron-app-ts/</guid><description>В этом пошаговом руководстве мы создадим простое приложение React-Electron с нуля. Electron — это фреймворк, который позволяет создавать кроссплатформенные настольные приложения с использованием веб-технологий, таких как HTML, CSS и JavaScript. React — популярная библиотека JavaScript для создания пользовательских интерфейсов.
Я использую этот чистый шаблон в качестве заготовки для своих проектов.
Вкратце Перейдите к репозиторию electron-react-template Нажмите Use this template, чтобы создать новый репозиторий и начать кодирование. Предварительные требования Прежде чем начать этот урок, убедитесь, что следующие инструменты установлены на вашей системе:</description></item><item><title>SMA - Простая скользящая средняя</title><link>https://romankurnovskii.com/ru/posts/trading-indicators/sma/</link><pubDate>Tue, 13 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/trading-indicators/sma/</guid><description>SMA (Simple Moving Average) - Простая скользящая средняя
Вычисляет среднее арифметическое на выбранном отрезке.
Удобно использовать одновременно на короткий и длинный отрезок.
Например короткий период 50 дней, длинный 200 дней.
short_period = 50 long_period = 200 sma(short_period, long_period) Тенденция: Когда 50-дневная SMA находится выше 200-дневной SMA, это может указывать на продолжающийся восходящий тренд. И наоборот, если 50-дневная SMA находится ниже 200-дневной SMA, это может свидетельствовать о нисходящем тренде.
Потенциальная точка входа: Если более короткая SMA пересекается выше более длинной SMA, это обычно рассматривается как &amp;ldquo;бычий&amp;rdquo; сигнал, и трейдеры могут рассмотреть возможность входа в длинную позицию, покупать.</description></item><item><title>AI Midjourney generated</title><link>https://romankurnovskii.com/ru/photos/midjourney/</link><pubDate>Sun, 14 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/photos/midjourney/</guid><description/></item><item><title>AI generated</title><link>https://romankurnovskii.com/ru/photos/ai/</link><pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/photos/ai/</guid><description/></item><item><title>Awesome app icons</title><link>https://romankurnovskii.com/ru/photos/icons/</link><pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/photos/icons/</guid><description>All examples Icons</description></item><item><title>BrewMate</title><link>https://romankurnovskii.com/ru/apps/brewmate/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/apps/brewmate/</guid><description>BrewMate is a macOS GUI application that makes it easy to search for, install, and uninstall Homebrew casks. You can also see the top downloaded casks for the last month.
Install Download the latest DMG file from the releases page or from sourceforge.net Double-click the DMG file to open it. Drag the BrewMate app to your Applications folder. Launch BrewMate from your Applications folder. or
brew install romankurnovskii/cask/brewmate --cask or
brew tap romankurnovskii/cask brew update brew install brewmate --cask FAQ Is this app free?</description></item><item><title>Разница Валютные форварды и Фьючерсы</title><link>https://romankurnovskii.com/ru/posts/economics/diff-forward-contracts-futures/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/economics/diff-forward-contracts-futures/</guid><description>Валютные форварды Валютные форварды (forward contracts) - это договоры, в рамках которых две стороны соглашаются на обмен активами (обычно это валюты, сырьевые товары или финансовые инструменты) на определенную дату в будущем по заранее оговоренной цене. Это финансовый инструмент, который используется компаниями и инвесторами для защиты от рисков колебаний курсов валют. Например, если компания знает, что ей нужно купить определенную сумму валюты на будущее время для оплаты поставок, она может заключить валютный форвард, чтобы зафиксировать курс обмена на определенный период времени.</description></item><item><title>Разница между Маржинализмом и Меркантилизмом</title><link>https://romankurnovskii.com/ru/posts/economics/raznica-mezhdu-marzhinalizmom-i-nerkantilizmom/</link><pubDate>Thu, 26 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/economics/raznica-mezhdu-marzhinalizmom-i-nerkantilizmom/</guid><description>Маржинализм и меркантилизм - это два разных термина, которые описывают различные экономические концепции.
Маржинализм (Неоклассическое направление) - середина XIX в, это экономическая теория, которая основана на идее, что цена товара или услуги определяется его маржой, то есть разницей между продажной ценой и затратами на его производство. В рамках маржинализма обычно считается, что рост маржи является показателем эффективности экономики.
Маржинализм использует такие величины, как предельная полезность, предельная производительность, предельные издержки
Одним из главных аспектов является «субъективизм» - подход, при котором все явления в экономике оцениваются, а также исследуются с точки зрения определенного субъекта.</description></item><item><title>ChatGPT/ruGPT-3</title><link>https://romankurnovskii.com/ru/posts/rugpt-3-notes/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/rugpt-3-notes/</guid><description> https://chat.openai.com/chat/ https://russiannlp.github.io/rugpt-demo/ Краткий экскурс в ruGPT-3. Инструкция и демонстрация</description></item><item><title>Требования по иностранным языкам</title><link>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/languages-requirements/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/disser/canditate-minimum/languages-requirements/</guid><description>Необходимые документы:
Заявление на имя заведующего кафедрой. В з-и указать название и шифр специальности Монография на иностранном языке. Реферат на русском языке (объем 21-8 стр) по прочитанной лит-ре объемом 300 стр. Реферат, подписанный автором, должен иметь заключения, а также библиографию (список использованной литературы). Глосарий (словарь специальных терминов) - ен менее 300 единиц. Отзыв от научного руководителя или специалиста по данной дисциплине. Содержание экзамена:
Вышеуказанные документы сдаются н а кафедру иностраных яызков за 10 дней до экзамена. Чтение, перевод со (словарем) на руский язык оп специальности оригинального текста.</description></item><item><title>Cloud exam Quizz</title><link>https://romankurnovskii.com/ru/apps/cloud-exam-quizz/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/apps/cloud-exam-quizz/</guid><description>Goal: Check if you are ready to pass the Cloud exam
The application calculates progress after each answered question. Ability to answer at least one question and get a comment at the same time. No need to pass all questions before. It is convenient to spend 20 min a day Works from web/tablet/mobile Link: https://www.cloud-exam-prepare.com</description></item><item><title>Пополнение Interactive Brokers с Израильского счета</title><link>https://romankurnovskii.com/ru/posts/interactivebrokers-deposit/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/interactivebrokers-deposit/</guid><description>Web Создание заявки в IB Заходим на сайт https://www.interactivebrokers.co.uk/portal/#/ Нажимаем Deposit Нажимаем Use a new deposit method если ранее шаблон не был создан Bank Wire -&amp;gt; Get instructions Account Number: Номер банковского счета.
Получаем инструкции с реквизитами для пополнения Bank Wire Instructions Эти данные Вам нужны для оплаты в Discount Bank
Отправить деньги из Discount Bank Заходим в личный кабинет банка start.telebank.co.il Нажимаем: ביצוע העברה
Заполняем форму
Нажимаем המשך и жмем далее. Приходит смс с подверждением, вводим и жмем далее</description></item><item><title>Lambda</title><link>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/lambda/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/lambda/</guid><description>https://docs.aws.amazon.com/lambda/?id=docs_gateway
https://aws.amazon.com/lambda/
AWS Lambda – это сервис бессерверных вычислений, который запускает программный код в ответ на определенные события и отвечает за автоматическое выделение необходимых вычислительных ресурсов.
AWS Lambda автоматически запускает программный код в ответ на различные события, такие как HTTP‑запросы через Amazon API Gateway, изменение объектов в корзинах Amazon Simple Storage Service (Amazon S3), обновление таблиц в Amazon DynamoDB или смена состояний в AWS Step Functions.
Поддержка языков Java, Go, PowerShell, Node.js, C#, Python и Ruby
Цены Актуальный прайс</description></item><item><title>IAM</title><link>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/iam/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/aws-certified-developer-associate/iam/</guid><description>AWS Identity and Access Management Документация AWS IAM Документация AWS IAM AWS Identity and Access Management (IAM) позволяет безопасно контролировать доступ пользователей к службам и ресурсам AWS. Эта услуга предназначена для организаций с множеством пользователей или систем, использующих такие продукты AWS, как Amazon EC2, Amazon RDS и AWS Management Console. С помощью IAM вы можете централизованно управлять пользователями, учетными данными безопасности, такими как ключи доступа, и разрешениями, контролирующими доступ пользователей к ресурсам AWS.
Практика Переходим на страницу IAM</description></item><item><title>cognito-token-observer</title><link>https://romankurnovskii.com/ru/apps/npm/cognito-token-observer/</link><pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/apps/npm/cognito-token-observer/</guid><description/></item><item><title>hugo-lunr-ml</title><link>https://romankurnovskii.com/ru/apps/npm/hugo-lunr-ml/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/apps/npm/hugo-lunr-ml/</guid><description/></item><item><title>Увеличение картинки по нажатию в Hugo</title><link>https://romankurnovskii.com/ru/posts/hugo-add-image-zoomin/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/hugo-add-image-zoomin/</guid><description>Введение В Hugo по умолчанию используется парсинг markdown файлов. Т.е. мы получаем html код в том виде, как он написан в markdown.
Для того, чтобы нам понимать какие именно изображения мы можем увеличивать, добавим к этим изображениям отдельный тег/ключ/id
Инструменты Для реализации функционала нам необходимо:
написать/подключить скрипт/обработчик, который будет выполнять эффект zoomin к нужным нам изображениям Добавить необходимые метаданные к изображениям, чтобы скрипт их смог найти Скрипт zoomin Для добавления возможности увеличивать картинку при нажатии воспользуемся пакетом medium-zoom.</description></item><item><title>Израиль - Хайфа - Бахайские сады</title><link>https://romankurnovskii.com/ru/photos/22-07-02-israel-haifa-bahai-gardens/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/photos/22-07-02-israel-haifa-bahai-gardens/</guid><description>Маршрут</description></item><item><title>Установка Ubuntu Desktop 22.10 (Kinetic Kudu) на ARM CPU</title><link>https://romankurnovskii.com/ru/posts/howto-install-ubuntu-desktop-on-arm/</link><pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/howto-install-ubuntu-desktop-on-arm/</guid><description>Ubuntu - одна из популярных Linux систем и достаточно много обзоров по установке Ubuntu. В этой статье мы будем устанавливать образ Ubuntu для ARM процессора на виртуальную машину UTM. Вся установка будет проходить на Mac OS.
Загрузка установочного образа На сайте Ubuntu доступен для скачивания только образ Ubuntu Server ARM версии 22.04 - без графического интерфейса. Но можно скачать обновленный релиз Ubuntu Desktop для ARM - Daily Build по ссылке.
Находим 64-bit ARM (ARMv8/AArch64) desktop image и скачиваем Виртуальная машина В качестве виртуальной машины для установки RHEL 9 использую бесплатную виртуальную машину UTM.</description></item><item><title>Как подключить React .jsx в проект на Hugo</title><link>https://romankurnovskii.com/ru/posts/integrate-hugo-react/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/integrate-hugo-react/</guid><description>Hugo предлагает подключение различных JS библиотек в проект. Такие изменения влекут за собой полное обновление проекта. Сегодня мы подключим компонент react без внесения больших изменений.
React - это библиотека. Чтобы она заработала на сайте, необходимо ее подклчюить, а далее воспользоваться внутренними функциями.
Подключить можно двумя способоами. С помощью подгрузки скрипта с CDN или загрузки пакета в package.json, чтопозволит использовать .jsx
package.json План:
Импорт пакета в package.json Создание .jsx скрипта Загрузка/build пакета в Hugo Импорт В корне проекта запускаем команду</description></item><item><title>Установка Linux RHEL 9</title><link>https://romankurnovskii.com/ru/posts/howto-install-rhel-9-free/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/howto-install-rhel-9-free/</guid><description>Red Hat Enterprise Linux 9 (RHEL 9) под кодовым названием Plow стал общедоступным (GA). Компания Red Hat объявила об этом 18 мая 2022 года. Она сменила бета-версию, которая существовала с 3 ноября 2021 года.
RHEL 9 - это несколько первых релизов в семействе Red Hat. Это первый крупный релиз после приобретения Red Hat компанией IBM в июле 2019 года, а также первая крупная версия после отказа от проекта CentOS в пользу CentOS Stream, который теперь является предшественником RHEL.</description></item><item><title>Сниппеты Python</title><link>https://romankurnovskii.com/ru/posts/python-snippets/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/python-snippets/</guid><description>Дата Текущая import datetime x = datetime.datetime.now() # 2023-08-23 21:41:24.871910 Формат YYYY-MM-DD import datetime x = datetime.datetime.now().strftime(&amp;#34;%Y-%m-%d&amp;#34;) # 2023-08-23 Разница в секундах import datetime date1 = datetime.datetime(2023, 3, 26, 0, 0, 0) # March 26, 2023 at midnight date2 = datetime.datetime(2023, 3, 27, 0, 0, 0) # March 27, 2023 at midnight difference_in_seconds = (date2 - date1).total_seconds() if difference_in_seconds &amp;gt; 0: print(&amp;#34;Date2 is later than Date1 by&amp;#34;, difference_in_seconds, &amp;#34;seconds.&amp;#34;) elif difference_in_seconds &amp;lt; 0: print(&amp;#34;Date1 is later than Date2 by&amp;#34;, abs(difference_in_seconds), &amp;#34;seconds.</description></item><item><title>Популярные команды Docker</title><link>https://romankurnovskii.com/ru/posts/docker-commands/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/docker-commands/</guid><description>Full in english
Топ 10 комманд Docker docker ps — смотрим список запущенных контейнеров docker pull — загрузка образа docker build — собирает образ docker logs — смотрим логи docker run — запускаем контейнер docker stop — останавливает контейнер docker kill — «убивает» контейнер docker rm — удаляет контейнер docker rmi — удаляет образ docker volume ls — список томов docker build Документация Построить образ из Dockerfile.
docker build [DOCKERFILE PATH] Флаги
--file -f Путь, где находится Dockerfile --force-rm Всегда удалять временные контейнеры.</description></item><item><title>Как сделать редирект на другой URL в JavaScript</title><link>https://romankurnovskii.com/ru/posts/howto-redirect-to-url/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/howto-redirect-to-url/</guid><description>Пользователя можно перенаправлять с одной веб-страницы на любую другую несколькими способами.
с помощью обновления мета-данных HTML. Перенаправления на стороне сервера. Например, используя файл .htaccess, PHP с помощью перенаправления на стороне клиента через JavaScript. Для перенаправления на другой URL с помощью JavaScript используем window.location.href или window.location.replace(). Передать второй аргумент, чтобы произвести клик по ссылке (true - по умолчанию) или перенаправление по HTTP (false).
JavaScript функции Логика const newUrl = &amp;#39;https://www.google.com/&amp;#39;; window.location.href = newUrl; // 1 window.location.replace(newUrl); // 2 window.location.assign(newUrl) // 3 Пример функции const redirect = (url, asLink = true) =&amp;gt; asLink ?</description></item><item><title>Шпаргалка tar архиватор</title><link>https://romankurnovskii.com/ru/posts/cheat-sheet-command-tar/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/cheat-sheet-command-tar/</guid><description>Кратко Создать:
tar cf archive.tar directory Распаковать:
tar xf archive.tar Создание mkdir my_dir # Создаем папку tar cf dir_archive.tar my_dir # Создаем архив с папкой ll # Проверяем содержимое текущего каталога # -rw-r--r-- 1 r staff 1.5K Jun 4 14:42 dir_archive.tar # drwxr-xr-x 2 r staff 64B Jun 4 14:42 my_dir Распаковка tar xf dir_archive.tar Сжатие tar czf dir_archive.tar.gz dir_archive.tar Распаковка сжатого файла tar xzf dir_archive.tar.gz Сжатие с помощью bzip2 tar cjf dir_archive.tar.bz2 my_dir Распаковка с помощью bzip2 tar xjf dir_archive.</description></item><item><title>Как переименовать файлы в Python</title><link>https://romankurnovskii.com/ru/posts/howto-rename-files-in-python/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/howto-rename-files-in-python/</guid><description>os.rename Если имеется весь путь до пути файла:
old_source = &amp;#39;/Users/r/Desktop/old_source.txt&amp;#39; new_source = &amp;#39;/Users/r/Desktop/new_source.txt&amp;#39; os.rename(&amp;#34;old_source&amp;#34;, &amp;#34;new_source&amp;#34;) Если имеется только имя файла, воспользуемся os.path.splitext(), который возвращает кортеж из имени файла и расширения:
import os for file in os.listdir(): name, ext = os.path.splitext(file) # return (&amp;#39;путь до файла без расщирения&amp;#39;, &amp;#39;.txt&amp;#39;) new_name = f&amp;#34;{name}_new{ext}&amp;#34; os.rename(file, new_name) pathlib С помощью встроенного модуля pathlib
Path.rename(new_name) from pathlib import Path for file in os.listdir(): f = Path(file) new_name = f&amp;#34;{f.stem}_new{f.suffix}&amp;#34; f.rename(new_name) shutil.move Модуль Shutil предлагает ряд высокоуровневых операций с файлами и коллекциями файлов.</description></item><item><title>Как сделать глубокое клонирование объекта в JavaScript</title><link>https://romankurnovskii.com/ru/posts/howto-create-deepclone-js/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/howto-create-deepclone-js/</guid><description>В JavaScript объекты копируются по ссылке. Это означает, что фактически две(или более) ссылок ссылается на один объект Для глубокого клонирования мы можем воспользоваться рекурсией
Воспользуемся методом Object.assign() и возьмем пустой объект ({}), чтобы создать клон оригинального объекта. Используем Object.keys() и Array.prototype.forEach() для определения ключей-значений, которые нужно полностью клонировать (не ссылаться на них).
const deepClone = obj =&amp;gt; { let clone = Object.assign({}, obj); Object.keys(clone).forEach( key =&amp;gt; (clone[key] = typeof obj[key] === &amp;#39;object&amp;#39; ? deepClone(obj[key]) : obj[key]) ); return Array.</description></item><item><title>PyScript - Python, встроенный в HTML</title><link>https://romankurnovskii.com/ru/posts/pyscript-python-embedded-in-html/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/pyscript-python-embedded-in-html/</guid><description>PyScript PyScript - средство запуска Python в браузере, встроенное в HTML, был анонсирован на мероприятии PyCon в Солт-Лейк-Сити, США. Кнопка Instl здесь для шутки, так как установка не требуется
PyScript зависит от существующего проекта Pyodide, который является скомпилированным в WebAssembly интерпретатором CPython 3.8, позволяющим запускать Python в браузере, а также скомпилированных научных пакетов Python.
Связывание с файлами библиотеки CSS и JavaScript PyScript позволяет разработчикам встраивать код Python с помощью тега &amp;lt;py-script&amp;gt;, а также компонент &amp;lt;py-repl&amp;gt; (Read, Evaluate, Print, Loop), который позволяет Python печатать и выполняться динамически.</description></item><item><title>Руководство по оформлению Markdown файлов</title><link>https://romankurnovskii.com/ru/posts/markdown-syntax/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/markdown-syntax/</guid><description>&lt;p>Эта статья предлагает пример базового синтаксиса Markdown, который можно использовать в файлах содержимого Hugo, а также показывает, украшаются ли основные элементы HTML с помощью CSS в теме Hugo.&lt;/p></description></item><item><title>Отображение таблицы Google Sheets в JSON</title><link>https://romankurnovskii.com/ru/posts/google-sheets-2-json/</link><pubDate>Sat, 12 Mar 2022 11:55:25 +0200</pubDate><guid>https://romankurnovskii.com/ru/posts/google-sheets-2-json/</guid><description>Задача Есть таблица google. Необходимо конвертировать ее в JSON и не делать каждый раз ручной экспорт.
Условия таблица закрыта для общего просмотра json отображение читать по ссылке План Использовать webapps от google. Парсить google таблицу и выдавать готовый url с json.
Подготовка Открываем Таблицу Google Extensions → Apps Script Создаем скрипт Как работает endpoint. Документация
Когда пользователь посещает приложение или программа отправляет приложению HTTP-запрос GET, Apps Script запускает функцию doGet(e).
Когда отправляется приложению HTTP-запрос POST, вместо этого Apps Script запускает doPost(e).</description></item><item><title>Политика конфиденциальности</title><link>https://romankurnovskii.com/ru/p/privacy_ru/</link><pubDate>Sat, 12 Mar 2022 13:11:22 +0800</pubDate><guid>https://romankurnovskii.com/ru/p/privacy_ru/</guid><description>Список приложений: ФСФР - Базовый экзамен
Настоящая Политика конфиденциальности персональных данных (далее – Политика конфиденциальности) действует в отношении всей информации, которую приложения из раздела: &amp;ldquo;Список приложений&amp;rdquo; могут получить о Пользователе во время использования.
Общие положения 1.1. Целью Политики конфиденциальности является реализация требований законодательства в области обработки и защиты персональных данных. 1.2. Настоящий Регламент разработан на основании Конституции Российской Федерации, Трудового кодекса Российской Федерации, Гражданского кодекса Российской Федерации, Уголовного кодекса Российской Федерации, Кодекса об административных правонарушениях Российской Федерации, Федерального закона Российской Федерации «О персональных данных» № 152-ФЗ от 27 июля 2006 года.</description></item><item><title>Публикация next.js приложения на github pages</title><link>https://romankurnovskii.com/ru/posts/nextjs-to-github-pages-ations/</link><pubDate>Mon, 07 Mar 2022 15:31:25 +0200</pubDate><guid>https://romankurnovskii.com/ru/posts/nextjs-to-github-pages-ations/</guid><description>Подготовка коммит все предыдущего состояния на случай вынужденного отката
Для того чтобы Actions имели доступ к репозиторию нужно подключить ключи шифрования
Настройка репозитория Создаю ключи
ssh-keygen -t rsa -b 4096 -C &amp;#34;$(git config user.email)&amp;#34; -f gh-pages -N &amp;#34;&amp;#34; Создалось 2 файла с ключами:
gh-pages - приватный gh-pages.pub - публичный в Репозитории (не профиле)
https://github.com/romankurnovskii/notion-project/settings/keys
Settings → Deploy keys →Add new
из файла gh-pages.pub вставляю текст публичного ключа
Settings → Secrets
Имя: ACTIONS_DEPLOY_KEY
Вставляю приватный ключ из приватного файла gh-pages</description></item><item><title>Печатные публикации</title><link>https://romankurnovskii.com/ru/p/publications/</link><pubDate>Wed, 31 Mar 2021 13:11:22 +0800</pubDate><guid>https://romankurnovskii.com/ru/p/publications/</guid><description>Печатные журналы / сборники Для цитирования:
Цепочка создания стоимости: содержание, элементы и возможности ее использования // Экономика и предпринимательство | ВАК // Великородная Е. А., Курновский Р.М. // Номер 8, 2023 г. Страницы: 241-245
Статья [pdf]
Особенности региональной политики и экономические интеграции Израиля // Наука и бизнес: пути развития | ВАК // Курновский Р.М.// Номер: 1 (139) 2023 г. Страницы: 141-143
Статья [pdf]
Поддержка икт-экспорта как способ покрытия внутренних потребностей рынка // XII международной научно-практической конференции «Трансформация экономики и управления: новые вызовы и перспективы» 15-16 декабря 2022г.</description></item><item><title>IT курсы 2020</title><link>https://romankurnovskii.com/ru/posts/diploma/</link><pubDate>Fri, 01 Jan 2021 15:31:25 +0200</pubDate><guid>https://romankurnovskii.com/ru/posts/diploma/</guid><description>&lt;p>Промежуточные метрики еще в процессе расчетов&lt;/p>
&lt;p>За 2020 год:&lt;/p>
&lt;ul>
&lt;li>Затрачено времени на учебу/практику: ~5500 часов&lt;/li>
&lt;/ul></description></item><item><title>Чеклист репатриация в Израиль</title><link>https://romankurnovskii.com/ru/p/%D1%80%D0%B5%D0%BF%D0%B0%D1%82%D1%80%D0%B8%D0%B0%D1%86%D0%B8%D1%8F/</link><pubDate>Mon, 02 Dec 2019 11:55:25 +0200</pubDate><guid>https://romankurnovskii.com/ru/p/%D1%80%D0%B5%D0%BF%D0%B0%D1%82%D1%80%D0%B8%D0%B0%D1%86%D0%B8%D1%8F/</guid><description>Инфа СОХНУТ - Еврейское агентство для Израиля, — международная сионистская организация с центром в государстве Израиль, которая занимается репатриацией в Израиль и помощью репатриантам.
https://www.jewishagency.org/ru/
Министерства алии и интеграции тел. *2994 или 03-9733333
Ссылки Чаты, где спрашивать:
https://t.me/OlimHadashim https://t.me/olehadash_com_chat https://t.me/forum_israel Няни, частные учителя, частные школы и садики в Израиле. https://www.facebook.com/groups/Nyani.Uchitelya.Shkoli.Israel
ASD в Израиле. Все о детях в спектре и их родителях https://www.facebook.com/groups/asdisraelrus
Мамочки Израиля https://www.facebook.com/groups/1524467887858435
Репатрианты в Израиле: здесь помогают и делятся опытом https://www.facebook.com/groups/1511311149184796
ОТДАМ ДАРОМ В ИЗРАИЛЕ https://www.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3/</guid><description>class Solution(): def lengthOfLongestSubstring(self, s): max_len = 0 substr = &amp;#39;&amp;#39; for char in s: if char not in substr: substr += char max_len = max(max_len, len(substr)) else: start = substr.index(char) + 1 substr = substr[start:] + char return max_len</description></item><item><title>Docs</title><link>https://romankurnovskii.com/ru/tracks/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/archive/</guid><description>This page contains an archive of all posts.</description></item><item><title>Posts Archive</title><link>https://romankurnovskii.com/ru/posts/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/posts/archive/</guid><description>This page contains an archive of all posts.</description></item></channel></rss>