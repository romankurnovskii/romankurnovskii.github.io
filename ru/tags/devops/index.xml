<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Devops on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tags/devops/</link><description>Recent content in Devops on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Fri, 01 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tags/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>2. Задачи DevOps-инженера</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day02/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day02/</guid><description>&lt;h2 id="обязанности-devops-специалиста">Обязанности DevOps специалиста&lt;/h2>
&lt;p>Надеюсь, вы приступили к этому после просмотра ресурсов и публикации в &lt;a href="../day01">День 1 из #90DaysOfDevOps&lt;/a>&lt;/p>
&lt;p>В первом посте был краткий обзор, но теперь мы должны углубиться в концепцию DevOps и понять, что при создании приложения есть две основные части. У нас есть часть &lt;strong>Разработка&lt;/strong>, где разработчики программного обеспечения программируют приложение и тестируют его. Затем у нас есть часть &lt;strong>Операции&lt;/strong>, где приложение развертывается и поддерживается на сервере.&lt;/p>
&lt;h2 id="devops--это-связующее-звено-между-двумя">DevOps — это связующее звено между двумя&lt;/h2>
&lt;p>Чтобы разобраться с DevOps или задачами, которые будет выполнять инженер DevOps, нам нужно понять инструменты или процесс, а также разобраться как они вместе они вместе взаимодейтвуют.&lt;/p>
&lt;p>Все начинается с приложения! Вы увидите так много всего, что все дело в приложении, когда речь идет о DevOps.&lt;/p>
&lt;p>Разработчики создадуют приложение, это можно сделать с помощью множества различных технологических стеков, и давайте пока оставим это воображению, поскольку мы вернемся к этому позже. Это также может включать множество различных языков программирования, инструменты сборки, репозиторий кода и т. д.&lt;/p>
&lt;p>Будучи инженером DevOps, вы не будете программировать приложение, но хорошее понимание концепций работы разработчика и используемых им систем, инструментов и процессов является ключом к успеху.&lt;/p>
&lt;p>На очень высоком уровне вам нужно будет знать, как приложение настроено для взаимодействия со всеми необходимыми службами или службами данных, а затем также добавить требования о том, как это можно или нужно протестировать.&lt;/p>
&lt;p>Приложение нужно будет где-то развернуть, давайте сделаем его в целом простым и сделаем это сервером, неважно где, но сервером. Затем ожидается, что к нему будет обращаться клиент или конечный пользователь в зависимости от созданного приложения.&lt;/p>
&lt;p>Этот сервер должен работать где-то локально, в общедоступном облаке, без сервера (Хорошо, я зашел слишком далеко, мы не будем рассматривать бессерверный вариант, но это вариант, и все больше и больше предприятий идут по этому пути). Кто-то должен создать настройте эти серверы и подготовьте их к запуску приложения. Теперь этот элемент может пригодиться вам как инженеру DevOps для развертывания и настройки этих серверов.&lt;/p>
&lt;p>Эти серверы должны будут работать под управлением операционной системы, и, вообще говоря, это будет Linux, но у нас есть целый раздел или потратим неделю, где мы рассмотрим некоторые фундаментальные знания, которые вы должны получить.&lt;/p>
&lt;p>Также вероятно, что нам нужно взаимодействовать с другими службами в нашей сети или среде, поэтому нам также необходимо иметь такой уровень знаний о сети и настройке, что в некоторой степени также может оказаться в руках инженера DevOps. Опять же, мы рассмотрим это более подробно в специальном разделе, посвященном DNS, DHCP, балансировщикам нагрузки (Load Balancing) и т. д.&lt;/p>
&lt;h2 id="мастер-на-все-руки">Мастер на все руки&lt;/h2>
&lt;p>Однако на этом этапе я скажу, что вам не нужно быть специалистом по сетям или инфраструктуре, вам нужны базовые знания о том, как наладить работу и общаться друг с другом, во многом так же, как, возможно, иметь базовые знания язык программирования, но вам не нужно быть разработчиком. Однако вы можете прийти к этому как специалист в какой-то области, и это отличная основа для адаптации к другим областям.&lt;/p>
&lt;p>Вы также, скорее всего, не будете ежедневно управлять этими серверами или приложением.&lt;/p>
&lt;p>Мы говорили о серверах, но есть вероятность, что ваше приложение будет разработано для работы в виде контейнеров, которые по-прежнему работают на сервере по большей части, но вам также потребуется понимание не только виртуализации, облачной инфраструктуры как услуги (IaaS). ), но также и контейнеризация. В эти 90 дней основное внимание будет уделяться контейнерам.&lt;/p>
&lt;h2 id="общий-обзор">Общий обзор&lt;/h2>
&lt;p>С одной стороны, наши разработчики создают новые функции и функции (а также исправления ошибок) для приложения.&lt;/p>
&lt;p>С другой стороны, у нас есть какая-то среда, инфраструктура или серверы, которые настроены и управляются для запуска этого приложения и связи со всеми необходимыми службами.&lt;/p>
&lt;p>Большой вопрос заключается в том, как нам внедрить эти функции и исправления ошибок в нашу продукцию и сделать их доступными для этих конечных пользователей?&lt;/p>
&lt;p>Как мы выпускаем новую версию приложения? Это одна из основных задач для DevOps-инженера, и здесь важно не просто понять, как это сделать один раз, а нам нужно делать это непрерывно и автоматизированным, эффективным способом, который также должен включать тестирование!&lt;/p>
&lt;p>На этом мы собираемся закончить этот день обучения, надеюсь, это было полезно. В течение следующих нескольких дней мы собираемся немного глубже погрузиться в некоторые другие области DevOps, а затем мы перейдем к разделам, в которых более подробно рассматриваются инструменты и процессы, а также их преимущества.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;p>Я всегда открыт для добавления дополнительных ресурсов в эти файлы Readme, поскольку они здесь в качестве учебного пособия.&lt;/p>
&lt;p>Мой совет - просмотреть все ссылки из списка ниже, и, надеюсь, вы также что-то почерпнули из текста и объяснений выше.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=0yWAtQ6wYNM">What is DevOps? - TechWorld with Nana&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kBV8gPVZNEE">What is DevOps? - GitHub YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UbtB4sMaaNM">What is DevOps? - IBM YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/devops/what-is-devops/">What is DevOps? - AWS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/devops/what-is-devops">What is DevOps? - Microsoft&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Если вы зашли так далеко, то поймете, хотите ли вы быть здесь или нет. До встречи в &lt;a href="../day03">День 3&lt;/a>&lt;/p></description></item><item><title>3. Ориентированность на приложения</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day03/</link><pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day03/</guid><description>&lt;h2 id="жизненный-цикл-devops--ориентированность-на-приложения">Жизненный цикл DevOps — ориентированность на приложения&lt;/h2>
&lt;p>По мере того, как мы будем продолжать в течение следующих нескольких недель, мы будем сталкиваться с этими названиями (Continuous Development, Testing, Deployment, Monitor) (непрерывная разработка, тестирование, развертывание, мониторинг) снова и снова.
Если вы стремитесь стать инженером DevOps, то повторяемость будет тем, к чему вы привыкнете, но постоянное улучшение каждый раз — это еще одна вещь, которая делает вещи интересными.&lt;/p>
&lt;p>В этом часе мы рассмотрим общий вид приложения от начала до конца, а затем вернемся назад, как в постоянном цикле.&lt;/p>
&lt;h3 id="разработка">Разработка&lt;/h3>
&lt;p>Давайте возьмем совершенно новый пример приложения, для начала у нас ничего не создано, возможно, как разработчик вы должны обсудить с вашим клиентом или конечным пользователем требования и придумать какой-то план или требования для вашего приложения. Затем нам нужно создать согласно требованиям наше новое приложение.&lt;/p>
&lt;p>Что касается инструментов на данном этапе, здесь нет никаких реальных требований, кроме выбора вашей IDE и языка программирования, который вы хотите использовать для написания своего приложения.&lt;/p>
&lt;p>Как инженер DevOps, помните, что вы, вероятно, не тот, кто создает этот план или создает приложение для конечного пользователя, этим занимается опытный разработчик.&lt;/p>
&lt;p>Но вам также не помешает иметь возможность прочитать часть кода, чтобы вы могли принимать наилучшие решения по инфраструктуре для своего приложения.&lt;/p>
&lt;p>Ранее мы упоминали, что приложение может быть написано на любом языке. Важно, чтобы это поддерживалось с помощью системы контроля версий, это то, что мы также подробно рассмотрим позже, и, в частности, мы углубимся в &lt;strong>Git&lt;/strong>.&lt;/p>
&lt;p>Также вероятно, что над этим проектом будет работать не один разработчик, хотя это может иметь место, но даже в этом случае передовой опыт потребует репозиторий кода для хранения и совместной работы над кодом, он может быть частным или общедоступным и может быть размещен или если говорить о частном развертывании, вы наверняка слышали, как &lt;strong>GitHub или GitLab&lt;/strong> используются в качестве репозитория кода. Мы снова рассмотрим их позже в разделе &lt;strong>Git&lt;/strong>.&lt;/p>
&lt;h3 id="тестирование">Тестирование&lt;/h3>
&lt;p>На данном этапе у нас есть свои требования и наша задача - разработать приложение. Но нам нужно убедиться, что мы тестируем наш код во всех различных средах, которые у нас есть, или, возможно, в выбранном языке программирования.&lt;/p>
&lt;p>Этот этап позволяет QA тестировать на наличие ошибок, чаще мы видим, что контейнеры используются для моделирования тестовой среды, что в целом может снизить накладные расходы на физическую или облачную инфраструктуру.&lt;/p>
&lt;p>Этот этап также, вероятно, будет автоматизирован как часть следующей области — непрерывной интеграции.&lt;/p>
&lt;p>Возможность автоматизировать это тестирование по сравнению с 10, 100 или даже 1000 инженерами по контролю качества, которые должны делать это вручную, говорит сама за себя, эти инженеры могут сосредоточиться на чем-то другом в стеке, чтобы гарантировать, что вы двигаетесь быстрее и разрабатываете больше функций по сравнению с тестированием ошибок и программного обеспечения. что, как правило, является задержкой для большинства традиционных выпусков программного обеспечения, использующих методологию водопада (Waterfall).&lt;/p>
&lt;h3 id="интеграция">Интеграция&lt;/h3>
&lt;p>Очень важно, что интеграция находится в середине жизненного цикла DevOps. Это практика, когда разработчикам требуется чаще вносить изменения в исходный код. Это может быть ежедневно или еженедельно.&lt;/p>
&lt;p>С каждым коммитом ваше приложение может проходить этапы автоматизированного тестирования, что позволяет на раннем этапе обнаруживать проблемы или ошибки до следующего этапа.&lt;/p>
&lt;p>На этом этапе вы можете сказать: «Но мы не создаем приложения, мы покупаем их в готовом виде у поставщика программного обеспечения». Не волнуйтесь, многие компании делают это и будут продолжать делать, и именно поставщик программного обеспечения будет концентрируется на трех вышеупомянутых этапах, но вы, возможно, захотите принять последний этап, поскольку это позволит быстрее и эффективнее развертывать готовые развертывания.&lt;/p>
&lt;p>Я бы также сказал, что очень важно просто иметь эти вышеперечисленные знания, поскольку сегодня вы можете купить готовое программное обеспечение, но что насчет завтра или в будущем &amp;hellip; может быть, на следующей работе?&lt;/p>
&lt;h3 id="развертывание--deployment">Развертывание / Deployment&lt;/h3>
&lt;p>Итак, наше приложение создано и протестировано в соответствии с требованиями нашего конечного пользователя, и теперь нам нужно приступить к развертыванию этого приложения в рабочей среде для использования нашими конечными пользователями.&lt;/p>
&lt;p>Это этап, когда код развертывается на рабочих серверах, теперь все становится чрезвычайно интересным, и именно здесь оставшиеся 86 дней мы глубже погружаемся в эти области. Потому что разные приложения требуют различного аппаратного обеспечения или конфигураций. Именно здесь &lt;strong>Управление конфигурацией приложений&lt;/strong> и &lt;strong>Инфраструктура как код&lt;/strong> могут сыграть ключевую роль в жизненном цикле DevOps. Возможно, ваше приложение &lt;strong>контейнеризовано&lt;/strong>, но его также можно запустить на виртуальной машине. Это также приводит наше изучение к таким платформам, как &lt;strong>Kubernetes&lt;/strong>, которые будут организовывать эти контейнеры и следить за тем, чтобы желаемое состояние было доступно вашим конечным пользователям.&lt;/p>
&lt;p>Все эти смелые темы мы рассмотрим более подробно в течение следующих нескольких недель, чтобы лучше понять основы того, что они из себя представляют и когда их использовать.&lt;/p>
&lt;h3 id="мониторинг--monitoring">Мониторинг / Monitoring&lt;/h3>
&lt;p>Все быстро меняется, и у нас есть наше приложение, которое мы постоянно обновляем новыми функциями и функциями, и у нас есть наше тестирование, чтобы убедиться, что функциональность не нарушена. У нас есть приложение, работающее в нашей среде, которое может постоянно поддерживать требуемую конфигурацию и производительность.&lt;/p>
&lt;p>Но теперь мы должны быть уверены, что наши конечные пользователи получают то, что им нужно. Здесь нам нужно убедиться, что производительность нашего приложения постоянно отслеживается, этот этап позволит вашим разработчикам принимать более взвешенные решения об улучшениях приложения в будущих выпусках, чтобы лучше обслуживать конечных пользователей.&lt;/p>
&lt;p>Надежность также является ключевым фактором здесь, в конце концов, мы хотим, чтобы наше приложение было доступно все время, когда оно требуется. Затем это дает возможность другим областям &lt;strong>наблюдаемости, безопасности и управления данными&lt;/strong>, которые следует постоянно контролировать, а обратную связь всегда можно использовать для улучшения, обновления и непрерывного выпуска приложения.&lt;/p>
&lt;p>Некоторый вклад от сообщества здесь, в частности &lt;a href="https://twitter.com/_ediri">@_ediri&lt;/a>, упоминает также часть этого непрерывного процесса, мы также должны привлечь команды FinOps. Приложения и данные работают и хранятся где-то, за чем вы должны постоянно следить, чтобы убедиться, что если что-то изменится с точки зрения ресурсов, ваши расходы не вызовут серьезных финансовых проблем с вашими облачными счетами.&lt;/p>
&lt;p>Я думаю, что сейчас самое время упомянуть упомянутого выше «инженера DevOps». Я имею в виду, что из разговора с другими членами сообщества звание инженера DevOps не должно быть целью ни для кого, потому что на самом деле любая должность должна включать процессы DevOps и культуру, описанную здесь. DevOps следует использовать на самых разных должностях, таких как облачный инженер/архитектор, администратор виртуализации, облачный архитектор/инженер, администратор инфраструктуры. Это лишь некоторые из них, но причина использования DevOps Engineer, описанная выше, на самом деле заключалась в том, чтобы выделить объем или процесс, используемый любой из вышеперечисленных должностей, и многое другое.&lt;/p>
&lt;h2 id="источники">Источники&lt;/h2>
&lt;p>Я всегда открыт для добавления дополнительных ресурсов в эти файлы readme, поскольку они здесь в качестве учебного пособия.&lt;/p>
&lt;p>Мой совет — посмотрите все, что ниже, и, надеюсь, вы тоже что-то почерпнули из текста и объяснений выше.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://itglobal.com/ru-ru/company/blog/development-method-ci-cd/">Методология разработки CI/CD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UnjwVYAN7Ns">Continuous Development&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RYQbmjLgubM">Continuous Testing - IBM YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1er2cjUq1UI">Continuous Integration - IBM YouTube&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">Continuous Monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.notion.so/The-Remote-Flow-d90982e77a144f4f990c135f115f41c6">The Remote Flow&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.finops.org/introduction/what-is-finops/">FinOps Foundation - What is FinOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.amazon.co.uk/Phoenix-Project-DevOps-Helping-Business-ebook/dp/B00AZRBLHO">&lt;strong>NOT FREE&lt;/strong> The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>До встречи в &lt;a href="../day04">День 4&lt;/a>&lt;/p>
&lt;h2 id="thanks">Thanks&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/soudjiro">Alexey&lt;/a> for reviewing&lt;/li>
&lt;/ul></description></item><item><title>4. DevOps и Agile</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day04/</link><pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day04/</guid><description>&lt;h2 id="devops-и-agile">DevOps и Agile&lt;/h2>
&lt;p>Вы знаете разницу между DevOps и Agile? Они формировались как самостоятельные понятия. Но теперь эти два термина сливаются.&lt;/p>
&lt;p>В этом посте мы рассмотрим важные различия между Agile и DevOps и выясним, почему они так тесно связаны.&lt;/p>
&lt;p>Я думаю, что хорошее место для начала — это немного больше узнать об общем подходе, который я увидел в изучении этой области, а именно о DevOps и Agile, даже несмотря на то, что у них схожие цели и процессы. В этом разделе я, надеюсь, мы разберемся с этим.&lt;/p>
&lt;p>Начнем с определений.&lt;/p>
&lt;h3 id="разработка-agile">Разработка Agile&lt;/h3>
&lt;p>Agile — это подход, который фокусируется на более быстром получении небольших результатов, а не на выгрзуке (релизе) одного большого обновления продукта; программное обеспечение разрабатывается итерациями (неболшими изменениями). Команда выпускает новую версию каждую неделю или месяц с дополнительными обновлениями. Итоговая цель Agile — предоставить конечным пользователям оптимальный опыт.&lt;/p>
&lt;h3 id="devops">DevOps&lt;/h3>
&lt;p>В течение последних нескольких дней мы освещали это несколькими различными способами описания конечных целей DevOps. DevOps обычно описывает разработку программного обеспечения
и методы доставки, основанные на сотрудничестве между разработчиками программного обеспечения и специалистами по эксплуатации. Основными преимуществами DevOps являются упрощение процесса разработки и минимизация недопонимания.&lt;/p>
&lt;h2 id="в-чем-разница-между-agile-и-devops">В чем разница между Agile и DevOps&lt;/h2>
&lt;p>Разница в основном в заботах. У Agile и DevOps разные интересы, но они помогают друг другу. Agile требует коротких итераций, что возможно только с автоматизацией, которую обеспечивает DevOps. Agile хочет, чтобы клиент попробовал конкретную версию и быстро дал отзыв, что возможно только в том случае, если DevOps упростит создание новой среды.&lt;/p>
&lt;h3 id="разные-участники">Разные участники&lt;/h3>
&lt;p>Agile фокусируется на оптимизации взаимодействия между конечными пользователями и разработчиками, в то время как DevOps нацелен на разработчиков и членов операционной группы. Можно сказать, что Agile ориентирован на клиентов, тогда как DevOps — это набор внутренних практик.&lt;/p>
&lt;h3 id="команда">Команда&lt;/h3>
&lt;p>Agile обычно применяется к разработчикам программного обеспечения и руководителям проектов. Компетенции DevOps-инженеров лежат на стыке разработки, QA (обеспечения качества) и операций, поскольку они участвуют во всех этапах цикла продукта и являются частью Agile-команды.&lt;/p>
&lt;h3 id="прикладные-фреймворки">Прикладные фреймворки&lt;/h3>
&lt;p>В Agile есть много сред управления для достижения гибкости и прозрачности: Scrum &amp;gt; Kanban &amp;gt; Lean &amp;gt; Extreme &amp;gt; Crystal &amp;gt; Dynamic &amp;gt; Feature-Driven. DevOps фокусируется на подходе к разработке в сотрудничестве, но не предлагает конкретных методологий. Тем не менее, DevOps продвигает такие практики, как инфраструктура как код, архитектура как код, мониторинг, самовосстановление, сквозная автоматизация тестирования&amp;hellip; Но сама по себе это не структура, а практика.&lt;/p>
&lt;h3 id="обратная-связь">Обратная связь&lt;/h3>
&lt;p>В Agile основным источником обратной связи является конечный пользователь, тогда как в DevOps более высокий приоритет имеет обратная связь от заинтересованных сторон и самой команды.&lt;/p>
&lt;h3 id="целевые-области">Целевые области&lt;/h3>
&lt;p>Agile фокусируется на разработке программного обеспечения больше, чем на развертывании и обслуживании. DevOps также фокусируется на разработке программного обеспечения, но его ценности и инструменты также охватывают этапы развертывания и после выпуска, такие как мониторинг, высокая доступность, безопасность и защита данных.&lt;/p>
&lt;h3 id="документация">Документация&lt;/h3>
&lt;p>Agile отдает предпочтение гибкости и поставленным задачам, а не документации и мониторингу. С другой стороны, DevOps рассматривает проектную документацию как один из основных компонентов проекта.&lt;/p>
&lt;h3 id="риски">Риски&lt;/h3>
&lt;p>Риски Agile вытекают из гибкости методологии. Гибкие проекты трудно предсказать или оценить, поскольку приоритеты и требования постоянно меняются.&lt;/p>
&lt;p>Риски DevOps возникают из-за неправильного понимания термина и отсутствия подходящих инструментов. Некоторые люди рассматривают DevOps как набор программного обеспечения для развертывания и непрерывной интеграции, не способного изменить базовую структуру процесса разработки.&lt;/p>
&lt;h3 id="используемые-инструменты">Используемые инструменты&lt;/h3>
&lt;p>Agile-инструменты ориентированы на совместную управленческую коммуникацию, метрики и обработку отзывов. К наиболее популярным agile-инструментам относятся JIRA, Trello, Slack, Zoom, SurveyMonkey и другие.&lt;/p>
&lt;p>DevOps использует инструменты для командного общения, разработки программного обеспечения, развертывания и интеграции, такие как Jenkins, GitHub Actions, BitBucket и т. д. Несмотря на то, что Agile и DevOps имеют несколько разные фокусы и области действия, ключевые значения почти идентичны, поэтому вы можете комбинировать их.&lt;/p>
&lt;h2 id="собрать-все-вместе-хорошая-идея-или-нет-обсуждать">Собрать все вместе… хорошая идея или нет? Обсуждать?&lt;/h2>
&lt;p>Сочетание Agile и DevOps дает следующие преимущества:&lt;/p>
&lt;ul>
&lt;li>Гибкое управление и мощные технологии.&lt;/li>
&lt;li>Практики Agile помогают командам DevOps более эффективно сообщать о своих приоритетах.&lt;/li>
&lt;li>Стоимость автоматизации, которую вы должны заплатить за свои методы DevOps, оправдана вашим гибким требованием быстрого и частого развертывания.&lt;/li>
&lt;li>Это приводит к укреплению: команда, внедряющая agile-практики, улучшит сотрудничество, повысит мотивацию команды и снизит текучесть кадров.&lt;/li>
&lt;li>В результате вы получаете лучшее качество продукции.&lt;/li>
&lt;/ul>
&lt;p>Agile позволяет вернуться к предыдущим этапам разработки продукта, чтобы исправить ошибки и предотвратить накопление технического долга. Принять Agile и DevOps
одновременно просто выполните 7 шагов:&lt;/p>
&lt;ol>
&lt;li>Объедините команды разработки и эксплуатации.&lt;/li>
&lt;li>Создайте команды сборки и запуска, все проблемы, связанные с разработкой и эксплуатацией, обсуждаются всей командой DevOps.&lt;/li>
&lt;li>Измените свой подход к спринтам и назначьте рейтинги приоритета, чтобы предлагать задачи DevOps, которые имеют такое же значение, как задачи разработки. Поощряйте команды разработчиков и эксплуатации обмениваться мнениями о рабочем процессе других команд и возможных проблемах.&lt;/li>
&lt;li>Включите контроль качества на все этапы разработки.&lt;/li>
&lt;li>Выбирайте правильные инструменты.&lt;/li>
&lt;li>Автоматизируйте все, что можете.&lt;/li>
&lt;li>Измеряйте и контролируйте, используя материальные числовые результаты.&lt;/li>
&lt;/ol>
&lt;p>Что вы думаете? У вас разные взгляды? Я хочу услышать от разработчиков, специалистов по эксплуатации, QA или кого-либо, кто лучше разбирается в Agile и DevOps, которые могут поделиться комментариями и отзывами по этому поводу?&lt;/p>
&lt;h3 id="источники">Источники&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=2JymM0YoqGA">DevOps for Developers – Day in the Life: DevOps Engineer in 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=udRNM7YRdY4">3 Things I wish I knew as a DevOps Engineer&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kDQMjAQNvY4">How to become a DevOps Engineer feat. Shawn Powers&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>До встречи в &lt;a href="../day05">День 5&lt;/a>&lt;/p></description></item><item><title>5. Plan > Code > Build > Testing > Release > Deploy > Operate > Monitor</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day05/</link><pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day05/</guid><description>&lt;p>Сегодня мы сосредоточимся на отдельных шагах от начала до конца и на непрерывном цикле приложения в мире DevOps.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day5_DevOps8.ru.png"
id="zoom-default"
alt="DevOps"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="план">План&lt;/h3>
&lt;p>Все начинается с процесса планирования, когда команда разработчиков собирается вместе и выясняет, какие типы функций и исправлений ошибок они собираются внедрить в следующем спринте. Это возможность для вас как инженера DevOps принять участие в этом и узнать, какие вещи будут происходить на вашем пути, с которыми вам нужно участвовать, а также повлиять на их решения или их путь и как бы помочь им работать с инфраструктура, которую вы построили, или направьте их к чему-то, что будет работать лучше для них, если они не на этом пути, и поэтому одна ключевая вещь, на которую здесь следует указать, это то, что разработчики или команда разработчиков программного обеспечения являются вашим клиентом как DevOps инженер, так что это ваша возможность поработать с вашим клиентом до того, как он пойдет по плохому пути.&lt;/p>
&lt;h3 id="code">Code&lt;/h3>
&lt;p>Теперь, как только эта сессия планирования будет завершена, разработчики начинают писать код, в разработку котоого вы можете быть вовлечены, предоставляя информацю об инфрастуктуре, микросеврисах, если таковые имеются, и т.д.
Когда разработчики заканчивают писать код/часть кода, они объединяют (merge) все измененияю и выгруат в репозиторий.&lt;/p>
&lt;h3 id="build">Build&lt;/h3>
&lt;p>Здесь мы начнем первый из наших процессов автоматизации, потому что мы &amp;ldquo;возьмем&amp;rdquo; их код и построим (скомпилируем, &amp;ldquo;сбилдим&amp;rdquo;) его в зависимости от того, какой язык они используют, это может быть транспиляция или компиляция, а может создать образ докера из этого кода в любом случае, мы собираемся пройти этот процесс, используя наш cicd pipeline (&amp;ldquo;пайплайн&amp;rdquo;)&lt;/p>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>После того, как мы его скомпилировали проект, мы проведем на нем несколько тестов. Команда разработчиков обычно пишет тесты. У вас может быть некоторый вклад в то, какие тесты пишутся, но нам нужно запустить эти тесты. Тестирование — это способ провериь и свести к минимуму появление проблем в рабочей среде. И хотя это не гарантирует полной проверки, но мы хотим максимально точно быть уверенными, что одна из новых функций не создает новых ошибок, а две другие не ломают то, что раньше работало.&lt;/p>
&lt;h2 id="release">Release&lt;/h2>
&lt;p>Как только эти тесты пройдены, мы собираемся выполнить процесс выпуска, и, опять же, в зависимости от того, над каким типом приложения вы работаете, это может быть поэтапным. Код может просто находиться в репозитории GitHub или репозитории git или где-то еще, а также это может быть процесс зарузки вашего скомпилированного кода или созданного образа докера и помещения его в реестр или репозиторий, где он находится.&lt;/p>
&lt;h2 id="deploy">Deploy&lt;/h2>
&lt;p>Следующее, что мы собираемся сделать - это &amp;ldquo;деплой&amp;rdquo; (публикация/развертывание). Развертывание похоже на конечный результат процесса. Потому что после развертывания приложения, когда мы запускаем код в производство, наш бизнес действительно осознает ценность всех временных усилий и тяжелой работы, которые вы и команда разработчиков программного обеспечения вложили в этот продукт до этого момента.&lt;/p>
&lt;h2 id="operate">Operate&lt;/h2>
&lt;p>После того, как код выгружен скомпилирован, мы собираемся эксплуатировать его, и эксплуатация может включать в себя что-то вроде того, что вы начинаете получать звонки от своих клиентов, которые все раздражены тем, что сайт работает медленно или их приложение работает медленно, поэтому вам нужно выяснить, почему это так.
А а затем, возможно, создать автоматическое масштабирование, которое связано с увеличением количества серверов, доступных в пиковые периоды, и уменьшением количества серверов в непиковые периоды.&lt;/p>
&lt;h2 id="monitor">Monitor&lt;/h2>
&lt;p>Все вышеперечисленные части ведут к последнему шагу - мониторингу, что важно особенно в отношении проблем, возникающих в рельном времени, автоматического масштабирования, устранения неполадок.
Во время мониторига мы сохраняем данные об использовании памяти, использовании ЦП на диске, времени отклика, скорость отклика и т.д. Большая часть этого также является журналами. Журналы дают разработчикам возможность видеть, что происходит, без доступа к производственным системам.&lt;/p>
&lt;h2 id="rince--repeat">Rince &amp;amp; Repeat&lt;/h2>
&lt;p>Once that&amp;rsquo;s in place you go right back to the beginning to the planning stage and go through the whole thing again&lt;/p>
&lt;h2 id="continuous">Continuous&lt;/h2>
&lt;p>Многие инструменты помогают нам достичь вышеуказанного непрерывного процесса, весь этот код и конечная цель полной автоматизации облачной инфраструктуры или любой среды часто описывается как непрерывная интеграция/непрерывная доставка/непрерывное развертывание или сокращенно «CI/CD». Позже, в течение 90 дней, мы посвятим целую неделю CI/CD с некоторыми примерами и пошаговыми руководствами, чтобы понять основы.&lt;/p>
&lt;h3 id="continuous-delivery">Continuous Delivery&lt;/h3>
&lt;p>Continuous Delivery = Plan &amp;gt; Code &amp;gt; Build &amp;gt; Test&lt;/p>
&lt;h3 id="continuous-integration">Continuous Integration&lt;/h3>
&lt;p>Непрерывная интеграция - это результат описанных выше этапов непрерывной &amp;ldquo;доставки&amp;rdquo; и результат этапа выпуска. Это относится как к неудаче, так и к успеху, но это возвращается в непрерывную доставку или перемещается в непрерывное развертывание.&lt;/p>
&lt;p>Continuous Integration = Plan &amp;gt; Code &amp;gt; Build &amp;gt; Test &amp;gt; Release&lt;/p>
&lt;h3 id="continuous-deployment">Continuous Deployment&lt;/h3>
&lt;p>Если у вас есть успешный релиз, перейдите к непрерывному развертыванию, которое включает следующие этапы.&lt;/p>
&lt;p>Выпуск CI выполнен успешно = непрерывное развертывание = развертывание &amp;gt; эксплуатация &amp;gt; мониторинг&lt;/p>
&lt;p>Вы можете рассматривать эти три понятия выше как простой набор фаз жизненного цикла DevOps.&lt;/p>
&lt;p>Этот последний фрагмент был для меня чем-то вроде подведения итогов третьего дня, но думаю, что на самом деле это проясняет для меня ситуацию.&lt;/p>
&lt;h3 id="источники">Источники&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=a0-uE3rOyeU">DevOps for Developers – Software or DevOps Engineer?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=9pZ2xmsSDdo&amp;amp;t=125s">Techworld with Nana -DevOps Roadmap 2022 - How to become a DevOps Engineer? What is DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5pxbp6FyTfk">How to become a DevOps Engineer in 2021 - DevOps Roadmap&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>До встречи в &lt;a href="../day06">День 6&lt;/a>&lt;/p></description></item><item><title>6. DevOps - Истории</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day06/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day06/</guid><description>&lt;h2 id="devops---истории-компаний">DevOps - Истории компаний&lt;/h2>
&lt;p>DevOps с самого начала считался недосягаемым для многих из нас, поскольку у нас не было среды или требований, подобных Netflix или Fortune 500, но подумайте, что теперь это начинает становиться нормой, когда мы внедряем практику DevOps внутри. любой вид бизнеса.&lt;/p>
&lt;p>По второй ссылке ниже в справочных материалах вы увидите множество различных отраслей и вертикалей, использующих DevOps и оказывающих огромное положительное влияние на свои бизнес-цели.&lt;/p>
&lt;p>Очевидно, что основным преимуществом здесь является DevOps, если он выполнен правильно, он должен помочь вашему бизнесу повысить скорость и качество разработки программного обеспечения.&lt;/p>
&lt;p>Я хотел использовать этот день, чтобы посмотреть на успешные компании, которые внедрили практику DevOps, и поделиться некоторыми ресурсами по этому поводу. Приняли ли вы культуру DevOps в своем бизнесе? Был ли он успешным?&lt;/p>
&lt;p>Я упомянул Netflix выше и коснусь их снова, поскольку это очень хорошая модель, которая даже до сих пор продвинута к тому, что мы обычно видим сегодня, но также упомяну некоторые другие известные бренды, которые, похоже, преуспевают.&lt;/p>
&lt;h2 id="amazon">Amazon&lt;/h2>
&lt;p>В 2010 году Amazon переместила свои физические серверы в облако Amazon Web Services (AWS), что позволило им сэкономить ресурсы за счет увеличения и уменьшения емкости с очень небольшими приращениями. Мы также знаем, что это облако AWS продолжит свое существование и будет приносить огромный доход, продолжая управлять розничным филиалом компании Amazon.&lt;/p>
&lt;p>Amazon внедрила в 2011 году (согласно приведенному ниже ресурсу) непрерывный процесс развертывания, при котором их разработчики могли развертывать код в любое время и на любых серверах, которые им нужны. Это позволило Amazon добиться развертывания нового программного обеспечения на производственных серверах в среднем каждые 11,6 секунды!&lt;/p>
&lt;h2 id="netflix">NetFlix&lt;/h2>
&lt;p>Кто не пользуется NetFlix? очевидно, это огромный качественный потоковый сервис, который, по крайней мере, лично для всех, обеспечивает отличный пользовательский опыт.&lt;/p>
&lt;p>Почему этот пользовательский опыт так хорош? Что ж, возможность предоставить услугу без воспоминаний, по крайней мере, о сбоях, требует скорости, гибкости и внимания к качеству.&lt;/p>
&lt;p>Разработчики NetFlix могут автоматически встраивать фрагменты кода в развертываемые веб-образы, не полагаясь на ИТ-операции. По мере обновления изображений они интегрируются в инфраструктуру Netflix с помощью специально созданной веб-платформы.&lt;/p>
&lt;p>Непрерывный мониторинг выполняется таким образом, что в случае сбоя развертывания образов новые образы откатываются, а трафик перенаправляется на предыдущую версию.&lt;/p>
&lt;p>Ниже приводится отличная беседа, в которой подробно рассказывается о том, что нужно и чего нельзя делать, по которым Netflix живет и умирает в своих командах.&lt;/p>
&lt;h2 id="etsy">Etsy&lt;/h2>
&lt;p>Как и у многих из нас и многих компаний, медленные и болезненные развертывания были настоящим испытанием. В том же духе мы могли бы также работать в компаниях, которые имеют много бункеров и команд, которые не очень хорошо работают вместе.&lt;/p>
&lt;p>Из того, что я могу понять, по крайней мере, из чтения об Amazon и Netflix, Etsy, возможно, разрешила разработчикам развертывать свой собственный код примерно в конце 2009 года, что могло быть до двух других упомянутых. (интересный!)&lt;/p>
&lt;p>Интересный вывод, который я прочитал здесь, заключался в том, что они поняли, что когда разработчики чувствуют ответственность за развертывание, они также берут на себя ответственность за производительность приложения, время безотказной работы и другие цели.&lt;/p>
&lt;p>Культура обучения является ключевой частью DevOps, даже неудача может стать успехом, если извлечь уроки. (не уверен, откуда на самом деле взялась эта цитата, но она имеет смысл!)&lt;/p>
&lt;p>Я добавил несколько других историй о том, как DevOps изменил правила игры в некоторых из этих чрезвычайно успешных компаний.&lt;/p>
&lt;h2 id="источники">Источники&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UTKIT6STSVM">How Netflix Thinks of DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.upgrad.com/blog/devops-use-cases-applications/">16 Popular DevOps Use Cases &amp;amp; Real Life Applications [2021]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ZzLa0YEbGIY">DevOps: The Amazon Story&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.networkworld.com/article/2886672/how-etsy-makes-devops-work.html">How Etsy makes DevOps work&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=gm18-gcgXRY">Adopting DevOps @ Scale Lessons learned at Hertz, Kaiser Permanente and lBM&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.usenix.org/conference/lisa16/technical-sessions/presentation/isla">Interplanetary DevOps at NASA JPL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://enterprisersproject.com/article/2017/1/target-cio-explains-how-devops-took-root-inside-retail-giant">Target CIO explains how DevOps took root inside the retail giant&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="подведем-итоги-наших-первых-дней-посвященных-devops">Подведем итоги наших первых дней, посвященных DevOps&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>DevOps — это комбинация разработки и эксплуатации, которая позволяет одной команде управлять всем жизненным циклом разработки приложения, состоящим из &lt;strong>разработки&lt;/strong>, &lt;strong>тестирования&lt;/strong>, &lt;strong>развертывания&lt;/strong>, &lt;strong>эксплуатации&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Основное внимание и цель DevOps — сократить жизненный цикл разработки, часто предоставляя функции, исправления и функциональные возможности в тесном соответствии с бизнес-целями.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DevOps — это подход к разработке программного обеспечения, с помощью которого программное обеспечение может поставляться и разрабатываться надежно и быстро. Вы также можете увидеть это как &lt;strong>Непрерывная разработка, тестирование, развертывание, мониторинг&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>До встречи в &lt;a href="../day07">День 7&lt;/a>&lt;/p>
&lt;p>На седьмой день мы погрузимся в язык программирования. Я не стремлюсь быть разработчиком, но хочу понимать, что делают разработчики.&lt;/p>
&lt;p>Можем ли мы достичь этого за неделю? Вероятно, нет, но если мы потратим 7 дней или 7 часов на изучение чего-то, мы будем знать больше, чем когда мы начинали.&lt;/p></description></item><item><title>7. DevOps - изучение языка программирования</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day07/</link><pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day07/</guid><description>&lt;h2 id="общая-картина-devops-и-изучение-языка-программирования">Общая картина: DevOps и изучение языка программирования&lt;/h2>
&lt;p>Я думаю, будет справедливо сказать, что для достижения успеха в качестве инженера DevOps в долгосрочной перспективе необходимо знать хотя бы один язык программирования на базовом уровне. Я хочу провести это первое занятие в этой статье, чтобы выяснить, почему это такой важный навык, и, надеюсь, к концу этой недели или раздела вы будете лучше понимать, почему, как и что делать. делайте, чтобы продвигаться в своем учебном путешествии.&lt;/p>
&lt;p>Я думаю, что если бы я спросил в социальных сетях, нужны ли вам навыки программирования для ролей, связанных с DevOps, ответ, скорее всего, будет утвердительным? Дайте мне знать, если вы думаете иначе? Хорошо, но тогда более важный вопрос, и здесь вы не получите такого четкого ответа, какой язык программирования? Наиболее распространенным ответом, который я видел здесь, был Python, или все чаще мы видим, что Golang или Go должны быть языком, который вы изучаете.&lt;/p>
&lt;p>Чтобы быть успешным в DevOps, вы должны хорошо знать навыки программирования, по крайней мере, мой вывод из этого. Но мы должны понять, зачем нам это нужно, чтобы выбрать правильный путь.&lt;/p>
&lt;h2 id="понимание-зачем-вам-нужно-изучать-язык-программирования">Понимание зачем вам нужно изучать язык программирования&lt;/h2>
&lt;p>Причина, по которой Python и Go так часто рекомендуются инженерам DevOps, заключается в том, что многие инструменты DevOps написаны либо на Python, либо на Go, что имеет смысл, если вы собираетесь создавать инструменты DevOps. Теперь это важно, так как это действительно определит, что вы должны изучить, и это, вероятно, будет наиболее полезным. Если вы собираетесь создавать инструменты DevOps или присоединяетесь к команде, которая занимается этим, имеет смысл выучить тот же язык. Если вы собираетесь активно участвовать в Kubernetes или контейнерах, то, скорее всего, вы захотите выберите Go в качестве языка программирования. Для меня компания, в которой я работаю (Kasten by Veeam), находится в экосистеме Cloud-Native, ориентированной на управление данными для Kubernetes, и все написано на Go.&lt;/p>
&lt;p>Но тогда у вас может не быть четких рассуждений, подобных этим, чтобы выбрать, быть ли вам студентом или менять карьеру без реального решения за вас. Я думаю, что в этой ситуации вы должны выбрать тот, который, кажется, резонирует и подходит для приложений, с которыми вы хотите работать.&lt;/p>
&lt;p>Помните, что я не собираюсь становиться здесь разработчиком программного обеспечения, я просто хочу немного больше узнать о языке программирования, чтобы я мог читать и понимать, что делают эти инструменты, а затем это, возможно, приведет к тому, как мы можем помочь улучшить ситуацию.&lt;/p>
&lt;p>Я также хотел бы знать, как вы взаимодействуете с этими инструментами DevOps, такими как &lt;a href="https://www.kasten.io/product/">Kasten K10&lt;/a> или &lt;a href="https://www.terraform.io/">Terraform&lt;/a> и &lt;a href="https://www.terraform.io/language/configuration-0-11/syntax">HCL&lt;/a>. Это то, что мы будем называть конфигурационными файлами, и именно так вы взаимодействуете с этими инструментами DevOps, чтобы что-то происходило, обычно это будет YAML. (Мы можем использовать последний день этого раздела, чтобы немного погрузиться в YAML)&lt;/p>
&lt;h2 id="я-только-что-отговорил-себя-от-изучения-языка-программирования">Я только что отговорил себя от изучения языка программирования?&lt;/h2>
&lt;p>Большую часть времени или в зависимости от роли вы будете помогать инженерным командам внедрять DevOps в свой рабочий процесс, много тестировать приложение и следить за тем, чтобы созданный рабочий процесс соответствовал тем принципам DevOps, которые мы упоминали в первые несколько дней. . Но на самом деле много времени уходит на устранение проблем с производительностью приложений или что-то в этом роде. Это возвращает меня к моей первоначальной точке зрения и рассуждениям: язык программирования, который мне нужно знать, — это тот, на котором написан код? Если их приложение написано на NodeJS, это не сильно поможет, если у вас есть значок Go или Python.&lt;/p>
&lt;h2 id="почему-go">Почему Go&lt;/h2>
&lt;p>Почему Golang — следующий язык программирования для DevOps? В последние годы Go стал очень популярным языком программирования. Согласно опросу StackOverflow за 2021 год, Go занял четвертое место среди самых востребованных языков программирования, сценариев и разметки, а Python был на первом месте, но выслушайте меня. &lt;a href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages">StackOverflow 2021 Developer Survey – Most Wanted Link&lt;/a>&lt;/p>
&lt;p>Как я уже упоминал, некоторые из самых известных инструментов и платформ DevOps написаны на Go, такие как Kubernetes, Docker, Grafana и Prometheus.&lt;/p>
&lt;p>Какие характеристики Go делают его идеальным для DevOps?&lt;/p>
&lt;h2 id="сборка-и-развертывание-программ-go">Сборка и развертывание программ Go&lt;/h2>
&lt;p>Преимущество использования такого языка, как Python, который интерпретируется в роли DevOps, заключается в том, что вам не нужно компилировать программу Python перед ее запуском. Особенно для небольших задач автоматизации вы не хотите, чтобы процесс сборки, требующий компиляции, замедлялся, несмотря на то, что Go — компилируемый язык программирования, &lt;strong>Go компилируется непосредственно в машинный код&lt;/strong>. Go также известен быстрым временем компиляции.&lt;/p>
&lt;h2 id="go-или-python-для-devops">Go или Python для DevOps&lt;/h2>
&lt;p>Программы Go статически связаны, это означает, что когда вы компилируете программу Go, все включается в один исполняемый двоичный файл, не требуется никаких внешних зависимостей, которые необходимо установить на удаленной машине, это упрощает развертывание программ Go, по сравнению с программой Python, которая использует внешние библиотеки, где вы должны убедиться, что все эти библиотеки установлены на удаленной машине, на которой вы хотите работать.&lt;/p>
&lt;p>Go — это независимый от платформы язык, что означает, что вы можете создавать двоичные исполняемые файлы для * всех операционных систем, Linux, Windows, macOS и т. д., и это очень легко сделать. С Python не так просто создавать эти двоичные исполняемые файлы для конкретных операционных систем.&lt;/p>
&lt;p>Go — очень производительный язык, он имеет быструю компиляцию и быстрое время выполнения с меньшим использованием ресурсов, таких как процессор и память, особенно по сравнению с python, в языке Go были реализованы многочисленные оптимизации, которые делают его таким производительным. (Ресурсы ниже)&lt;/p>
&lt;p>В отличие от Python, который часто требует использования сторонних библиотек для реализации конкретной программы Python, go включает в себя стандартную библиотеку, которая имеет большую часть функций, которые вам понадобятся для DevOps, встроенных непосредственно в нее. Это включает в себя функциональную обработку файлов, веб-службы HTTP, обработку JSON, встроенную поддержку параллелизма и параллелизма, а также встроенное тестирование.&lt;/p>
&lt;p>Это ни в коем случае не бросает Python под автобус, я просто излагаю свои причины выбора Go, но они не являются вышеупомянутым Go против Python, это обычно потому, что это имеет смысл, поскольку компания, в которой я работаю, разрабатывает программное обеспечение на Go, вот почему.&lt;/p>
&lt;p>Я скажу, что как только как только вы выучите свой первый язык программирования, вам станет легче осваивать другие языки. Вероятно, у вас никогда не будет ни одной работы в какой-либо компании, где бы вам не приходилось иметь дело с управлением, архитектурой, оркестровкой, отладкой приложений JavaScript и Node JS.&lt;/p>
&lt;h2 id="источники">Источники&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://insights.stackoverflow.com/survey/2021">StackOverflow 2021 Developer Survey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7pLqIIAqZD4&amp;amp;t=9s">Why we are choosing Golang to learn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=C8LgvuEBraI&amp;amp;t=312s">Jake Wright - Learn Go in 12 minutes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana - Golang full course - 3 hours 24 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pluralsight.com/courses/go-fundamentals">&lt;strong>NOT FREE&lt;/strong> Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;amp;t=1025s">FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLRAV69dS1uWSR89FRQGZ6q9BR2b44Tr9N">Hitesh Choudhary - Complete playlist&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Теперь в течение следующих 6 дней этой темы я намерен работать с некоторыми из ресурсов, перечисленных выше, и документировать свои заметки на каждый день. Вы заметите, что они, как правило, составляют около 3 часов в качестве полного курса, я хотел поделиться своим полным списком, чтобы, если у вас есть время, вы могли двигаться вперед и работать над каждым, если позволяет время, я буду придерживаться моего часа обучения каждый день.&lt;/p>
&lt;p>До встречи в &lt;a href="../day08">День 8&lt;/a>&lt;/p></description></item><item><title>8. Настройка DevOps окружения для запуска Hello World на Go</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day08/</link><pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day08/</guid><description>&lt;h2 id="настройка-devops-окружения-для-запуска-hello-world-на-go">Настройка DevOps окружения для запуска Hello World на Go&lt;/h2>
&lt;p>Прежде чем мы приступим к некоторым основам Go, мы должны установить Go на нашу рабочую станцию и сделать то, чему нас учит каждый модуль &lt;a href="https://www.udemy.com/course/programming-101/">«Изучение программирования 101»&lt;/a>, а именно создать приложение Hello World. Так как здесь будут описаны шаги по установке Go на ваш ПК, мы попытаемся задокументировать процесс в картинках, чтобы людям было легко следовать за ним.&lt;/p>
&lt;p>Возможные варианты установки Golang&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/dl/">Исполняемый файл&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/doc/install/source#environment-variables">Пакет из исходного кода&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://formulae.brew.sh/formula/go">Mac Os Homebrew&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#Homebrew install command&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Быстрый &lt;a href="https://go.dev/tour/welcome/1">тьюториал&lt;/a> для ознакомления с языком Go&lt;/p>
&lt;p>Рассмотрим вараинт установки с помощью инсталляционного файла&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы зашли так далеко, вы, вероятно, знаете, какая операционная система рабочей станции у вас установлена, поэтому выберите соответствующую загрузку, и тогда мы сможем приступить к установке. Я использую Windows для этого пошагового руководства. На следующем шаге мы можем оставить все значения по умолчанию. &lt;em>&lt;strong>(Отмечу, что на момент написания это была последняя версия, поэтому скриншоты могут быть устаревшими)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Также обратите внимание, что если у вас установлена более старая версия Go, вам придется удалить ее перед установкой, поскольку в Windows она встроена в установщик, и она будет удалена и установлена как единое целое.&lt;/p>
&lt;p>После завершения вы должны открыть командную строку / терминал, и мы хотим проверить, установлен ли Go. Если вы не получите вывод, который мы видим ниже, значит, Go не установлен, и вам нужно будет повторить свои шаги.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы хотим проверить нашу среду на наличие Go. Это всегда полезно проверить, чтобы убедиться, что ваши рабочие каталоги настроены правильно, как вы можете видеть ниже, нам нужно убедиться, что в вашей системе есть следующий каталог.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хорошо, давайте создадим этот каталог для простоты. Я собираюсь использовать команду mkdir в своем терминале &lt;a href="https://docs.microsoft.com/ru-ru/powershell/">PowerShell&lt;/a>. Нам также нужно создать 3 папки в папке Go, как вы увидите ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас установлен Go, и у нас есть рабочий каталог Go, готовый к действию. Теперь нам нужна интегрированная среда разработки (IDE). Сейчас есть много доступных, которые вы можете использовать, но наиболее распространенным и тем, который я использую, является Visual Studio Code или Code. Вы можете узнать больше об IDE &lt;a href="https://www.youtube.com/watch?v=vUn5akOlFXQ">здесь&lt;/a>.&lt;/p>
&lt;p>Если вы еще не загрузили и не установили VSCode на свою рабочую станцию, вы можете сделать это, перейдя по &lt;a href="https://code.visualstudio.com/download">ссылке&lt;/a>. Как вы можете видеть ниже, у вас есть разные варианты ОС.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Почти так же, как и при установке Go, мы собираемся загрузить и установить и сохранить значения по умолчанию. После завершения вы можете открыть VSCode, выбрать «Открыть файл» и перейти в наш каталог Go, который мы создали выше.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете получить всплывающее окно о доверии, прочитать его, если хотите, а затем нажать «Да, доверять авторам». (Позже я не несу ответственности, если вы начнете открывать вещи, которым не доверяете!)&lt;/p>
&lt;p>Теперь вы должны увидеть три папки, которые мы также создали ранее, и теперь мы хотим щелкнуть правой кнопкой мыши папку src и создать новую папку с именем «Hello».&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Довольно простые вещи, я бы сказал до этого момента? Теперь мы собираемся создать нашу первую программу Go, не понимая, что мы вкладываем в этот следующий этап.&lt;/p>
&lt;p>Затем создайте файл с именем &lt;code>main.go&lt;/code> в папке &lt;code>Hello&lt;/code>. Как только вы нажмете Enter на main.go, вас спросят, хотите ли вы установить расширение Go, а также пакеты, вы также можете проверить этот пустой файл pkg, который мы сделали несколько шагов назад, и обратите внимание, что у нас должны быть новые пакеты. там сейчас?&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь давайте запустим это приложение Hello World, скопируйте следующий код в новый файл main.go и сохраните его.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hello #90DaysOfDevOps&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Я понимаю, что вышеизложенное может не иметь никакого смысла, но мы подробнее расскажем о функциях, пакетах и многом другом позже. А пока давайте запустим наше приложение. Вернувшись в терминал и в нашу папку Hello, мы можем проверить, все ли работает. Используя приведенную ниже команду, мы можем проверить, работает ли наша общая программа обучения.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go run main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Однако на этом это не заканчивается, что, если теперь мы захотим взять нашу программу и запустить ее на других машинах с Windows? Мы можем сделать это, создав наш двоичный файл, используя следующую команду&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go build main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Попробуем запустить&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#Windows&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./main.exe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#Linux/Mac Os&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="Day8_Go13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="источники">Источники&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/tour/welcome/1">Быстрое погружение в Golang&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://insights.stackoverflow.com/survey/2021">StackOverflow 2021 Developer Survey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7pLqIIAqZD4&amp;amp;t=9s">Why we are choosing Golang to learn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=C8LgvuEBraI&amp;amp;t=312s">Jake Wright - Learn Go in 12 minutes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana - Golang full course - 3 hours 24 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pluralsight.com/courses/go-fundamentals">&lt;strong>NOT FREE&lt;/strong> Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;amp;t=1025s">FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLRAV69dS1uWSR89FRQGZ6q9BR2b44Tr9N">Hitesh Choudhary - Complete playlist&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Увидимся на &lt;a href="../day09">9-й день&lt;/a>&lt;/p></description></item><item><title>9. Как работает hello-world на Golang</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day09/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day09/</guid><description>&lt;h2 id="разберемся-как-работает-hello-world">Разберемся как работает hello-world&lt;/h2>
&lt;h3 id="как-работает-go">Как работает Go&lt;/h3>
&lt;p>&lt;a href="../day08">Вчера&lt;/a> мы прошли процедуру установки Go на ПК, а затем создали наше первое приложение Go.&lt;/p>
&lt;p>В этом разделе мы собираемся глубже изучить код и понять еще несколько вещей о языке Go.&lt;/p>
&lt;h3 id="что-такое-компиляция">Что такое компиляция?&lt;/h3>
&lt;p>Прежде чем мы перейдем к 6 строкам кода Hello World, которые написали &lt;a href="../day08">вчера&lt;/a>, нам нужно немного разобраться в компиляции.&lt;/p>
&lt;p>Языки программирования, которые мы обычно используем, такие как Python, Java, Go и C++, являются языками высокого уровня. Это означает, что они удобочитаемы для человека, но когда машина пытается выполнить программу, она должна быть в форме, понятной машине. Мы должны перевести наш человекочитаемый код в машинный код, что называется компиляцией.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day9_Go1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Из приведенного выше вы можете видеть, что мы сделали в &lt;a href="https://romankurnovskii.com/ru/tracks/90daysofdevops/day08/">День 8&lt;/a> - мы создали простой Hello World main.go, а затем использовали команду &lt;code>go build main.go&lt;/code> для компиляции нашего исполняемого файла.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hello #90DaysOfDevOps&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="что-такое-пакеты">Что такое пакеты?&lt;/h3>
&lt;p>Пакет — это набор исходных файлов в одном каталоге, которые скомпилированы вместе. Мы можем упростить это еще больше, пакет — это набор файлов .go в одном каталоге. Помните нашу папку Hello из Дня 8? Когда вы попадете в более сложные программы Go, вы можете обнаружить, что у вас есть папка1, папка2 и папка3, содержащие разные файлы .go, которые составляют вашу программу с несколькими пакетами.&lt;/p>
&lt;p>Мы используем пакеты, чтобы мы могли повторно использовать код других людей, нам не нужно писать все с нуля. Возможно, нам нужен калькулятор как часть нашей программы, вы, вероятно, могли бы найти существующий пакет Go, содержащий математические функции, которые вы могли бы импортировать в свой код, что в конечном итоге сэкономит вам много времени и усилий.&lt;/p>
&lt;p>Go рекомендует организовывать код в пакеты, чтобы его было легко повторно использовать и поддерживать исходный код.&lt;/p>
&lt;h3 id="hello-90daysofdevops-шаг-за-шагом">Hello #90DaysOfDevOps шаг за шагом&lt;/h3>
&lt;p>Теперь давайте посмотрим на наш файл &lt;strong>main.go&lt;/strong> Hello #90DaysOfDevOps и пройдемся по строкам.
&lt;p class="md__image">
&lt;img
src="../images/Day9_Go2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В первой строке у нас есть &lt;code>package main&lt;/code>, что означает, что этот файл принадлежит пакету с именем main. Все файлы .go должны принадлежать пакету, они также должны иметь «package something» в открывающей строке.&lt;/p>
&lt;p>Пакет можно назвать как угодно. Мы должны назвать этот &lt;code>main&lt;/code>, так как это начальная точка программы, которая будет в этом пакете, это правило.
&lt;p class="md__image">
&lt;img
src="../images/Day9_Go3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Всякий раз, когда мы хотим скомпилировать и выполнить наш код, мы должны сообщить машине, где должно начаться выполнение. Мы делаем это, написав функцию с именем main. Машина будет искать функцию с именем main, чтобы найти точку входа в программу.&lt;/p>
&lt;p>Функция — это блок кода, который может выполнять определенную задачу и может использоваться во всей программе.&lt;/p>
&lt;p>Вы можете объявить функцию с любым именем, используя &lt;code>func&lt;/code>, но в этом случае нам нужно назвать ее &lt;code>main&lt;/code>, так как именно здесь начинается код.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day9_Go4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы рассмотрим строку 3 нашего кода, импорт, это в основном означает, что вы хотите добавить другой пакет в свою основную программу. &lt;strong>fmt&lt;/strong> — это стандартный пакет, используемый здесь, предоставленный Go, этот пакет содержит функцию &lt;code>Println()&lt;/code>, и, поскольку мы импортировали ее, мы можем использовать ее в строке 6. Существует ряд стандартных пакетов, которые вы можете включить в свою программу и используйте или повторно используйте их в своем коде, избавляя вас от необходимости писать с нуля.
&lt;p class="md__image">
&lt;img
src="../images/Day9_Go5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;code>Println()&lt;/code>, который у нас есть, — это способ записи в стандартный вывод на терминал, где когда-либо исполняемый файл был успешно выполнен. Не стесняйтесь изменять сообщение между скобками ().
&lt;p class="md__image">
&lt;img
src="../images/Day9_Go6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="tldr">TLDR&lt;/h3>
&lt;p>&lt;em>&lt;a href="https://ru.wikipedia.org/wiki/TL;DR">Что такое TLDR&lt;/a>&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Строка 1&lt;/strong> = Этот файл будет находиться в пакете с именем &lt;code>main&lt;/code>, и его нужно назвать &lt;code>main&lt;/code>, поскольку он включает точку входа программы.&lt;/li>
&lt;li>&lt;strong>Строка 3&lt;/strong> = Чтобы использовать &lt;code>Println()&lt;/code>, мы должны импортировать пакет fmt, чтобы использовать его в строке 6.&lt;/li>
&lt;li>&lt;strong>Строка 5&lt;/strong> = фактическая начальная точка, это функция &lt;code>main&lt;/code>.&lt;/li>
&lt;li>&lt;strong>Строка 6&lt;/strong> = Это позволит нам напечатать «Hello #90DaysOfDevOps» в нашей системе.&lt;/li>
&lt;/ul>
&lt;h2 id="источники">Источники&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/std">Стандартная библиотека Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h0zxh2TPN_I">Golang | Все Основы за 4 Часа Для Начинающих&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://insights.stackoverflow.com/survey/2021">StackOverflow 2021 Developer Survey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7pLqIIAqZD4&amp;amp;t=9s">Why we are choosing Golang to learn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=C8LgvuEBraI&amp;amp;t=312s">Jake Wright - Learn Go in 12 minutes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana - Golang full course - 3 hours 24 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pluralsight.com/courses/go-fundamentals">&lt;strong>NOT FREE&lt;/strong> Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;amp;t=1025s">FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLRAV69dS1uWSR89FRQGZ6q9BR2b44Tr9N">Hitesh Choudhary - Complete playlist&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Увидимся на &lt;a href="../day10">10-й день&lt;/a>&lt;/p></description></item><item><title>10. Окружение Go</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day10/</link><pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day10/</guid><description>&lt;h3 id="окружение-go">Окружение Go&lt;/h3>
&lt;p>В &lt;a href="../day08">8-м дне&lt;/a> мы кратко рассмотрели рабочее пространство Go, чтобы запустить его и перейти к демонстрации «Hello #90DaysOfDevOps». Но мы должны немного рассказать о рабочем пространстве Go.&lt;/p>
&lt;p>Помните, что мы выбрали значения по умолчанию, а затем прошли и создали нашу папку Go в GOPATH, который уже был определен, но на самом деле этот GOPATH можно изменить, чтобы он находился там, где вы хотите.&lt;/p>
&lt;p>Если вы запустите&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>echo $GOPATH
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вывод должен быть похож на мой (может быть с другим именем пользователя), а именно:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>/home/michael/projects/go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Затем здесь мы создали 3 директории. &lt;strong>src&lt;/strong>, &lt;strong>pkg&lt;/strong> и &lt;strong>bin&lt;/strong>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day10_Go1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>src&lt;/strong> is where all of your Go programs and projects are stored. This handles namespacing package management for all your Go repositories. This is where you will see on our workstation we have our Hello folder for the Hello #90DaysOfDevOps project.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day10_Go2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>pkg&lt;/strong> — это место, где хранятся ваши заархивированные файлы пакетов, которые установлены или были установлены в программах. Это помогает ускорить процесс компиляции в зависимости от того, были ли изменены используемые пакеты.
&lt;p class="md__image">
&lt;img
src="../images/Day10_Go3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>bin&lt;/strong> — это место, где хранятся все ваши скомпилированные двоичные файлы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day10_Go4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Наш Hello #90DaysOfDevOps не является сложной программой, поэтому вот пример более сложной программы Go, взятой из другого замечательного ресурса, на который стоит обратить внимание &lt;a href="https://gochronicles.com/">GoChronicles&lt;/a>
&lt;p class="md__image">
&lt;img
src="../images/Day10_Go5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="компиляция-и-запуск-кода">Компиляция и запуск кода&lt;/h3>
&lt;p>На &lt;a href="../day09">9-й день&lt;/a> мы также рассмотрели краткое введение в компиляцию кода, но здесь мы можем пойти немного глубже.&lt;/p>
&lt;p>Чтобы запустить наш код, мы сначала должны его &lt;strong>скомпилировать&lt;/strong>. В Go это можно сделать тремя способами.&lt;/p>
&lt;ul>
&lt;li>go build&lt;/li>
&lt;li>go install&lt;/li>
&lt;li>go run&lt;/li>
&lt;/ul>
&lt;p>Прежде чем мы перейдем к описанному выше этапу компиляции, нам нужно взглянуть на то, что мы получаем при установке Go.&lt;/p>
&lt;p>Когда мы установили Go на 8-й день, мы установили что-то, известное как инструменты Go, которые состоят из нескольких программ, которые позволяют нам создавать и обрабатывать наши исходные файлы Go. Одним из инструментов является «Go».&lt;/p>
&lt;p>Стоит отметить, что вы можете установить дополнительные инструменты, которых нет в стандартной установке Go.&lt;/p>
&lt;p>Если вы откроете командную строку и наберете «go», вы должны увидеть что-то вроде изображения ниже, а затем вы увидите «Дополнительные разделы справки» ниже, и пока нам не нужно беспокоиться об этом.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day10_Go6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Возможно, вы также помните, что мы уже использовали как минимум два из этих инструментов в День 8.
&lt;p class="md__image">
&lt;img
src="../images/Day10_Go7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы хотим узнать больше о сборке, установке и запуске.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day10_Go8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>go run&lt;/code> - Эта команда компилирует и запускает основной пакет, состоящий из файлов .go, указанных в командной строке. Команда компилируется во временную папку.&lt;/li>
&lt;li>&lt;code>go build&lt;/code> - чтобы скомпилировать пакеты и зависимости, скомпилируйте пакет в текущем каталоге. Если пакет «main», поместит исполняемый файл в текущий каталог, если нет, то он поместит исполняемый файл в папку «pkg». &lt;code>go build&lt;/code> также позволяет вам создать исполняемый файл для любой платформы ОС, поддерживаемой Go.&lt;/li>
&lt;li>&lt;code>go install&lt;/code> - то же самое, что и go build, но помещает исполняемый файл в папку &lt;code>bin&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Мы прошли через &lt;code>go build&lt;/code> и &lt;code>go run&lt;/code>, но не стесняйтесь запускать их снова здесь, если хотите, &lt;code>go install&lt;/code>, как указано выше, помещает исполняемый файл в нашу папку bin.
&lt;p class="md__image">
&lt;img
src="../images/Day10_Go9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Надеюсь, что вы следите за мной и смотрите один из плейлистов или видеороликов ниже. Я беру их по кусочкам и перевожу в свои заметки, чтобы понять основы языка Голанг. Приведенные ниже ресурсы, вероятно, дадут вам гораздо лучшее понимание многих областей, которые вам нужны в целом, но я пытаюсь задокументировать 7 дней или 7 часов путешествия с интересными вещами, которые я нашел.&lt;/p>
&lt;h2 id="источники">Источники&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://insights.stackoverflow.com/survey/2021">StackOverflow 2021 Developer Survey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7pLqIIAqZD4&amp;amp;t=9s">Why we are choosing Golang to learn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=C8LgvuEBraI&amp;amp;t=312s">Jake Wright - Learn Go in 12 minutes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana - Golang full course - 3 hours 24 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pluralsight.com/courses/go-fundamentals">&lt;strong>NOT FREE&lt;/strong> Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;amp;t=1025s">FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLRAV69dS1uWSR89FRQGZ6q9BR2b44Tr9N">Hitesh Choudhary - Complete playlist&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Увидимся на &lt;a href="../day11">11-й день&lt;/a>&lt;/p></description></item><item><title>11. Переменные и константы в Go</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day11/</link><pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day11/</guid><description>&lt;p>Прежде чем мы перейдем к темам сегодняшнего дня, я хочу выразить огромную благодарность &lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana&lt;/a> и этому фантастическому краткому путешествию по основам Go.&lt;/p>
&lt;p>В &lt;a href="../day08">8-м дне&lt;/a> мы настроили нашу среду, в &lt;a href="../day09">9-м дне&lt;/a> мы разобрали код Hello #90DaysOfDevOps, а в &lt;a href="../day10">10-м дне&lt;/a>) мы поработали с нашей рабочей средой Go и немного углубились в компиляцию и запуск кода.&lt;/p>
&lt;p>Сегодня мы рассмотрим переменные, константы и типы данных при написании новой программы.&lt;/p>
&lt;h2 id="переменные-и-константы-в-go">Переменные и константы в Go&lt;/h2>
&lt;p>Давайте начнем с планирования нашего приложения, я думаю, было бы неплохо поработать над программой, которая сообщает нам, сколько дней осталось в нашем испытании #90DaysOfDevOps.&lt;/p>
&lt;p>Первое, что нужно учитывать, это то, что, поскольку мы создаем наше приложение, мы приветствуем наших посетителей и даем пользователям отзывы о количестве дней, которые они выполнили, мы можем использовать термин #90DaysOfDevOps много раз на протяжении всей программы. Это отличный вариант использования переменной #90DaysOfDevOps в нашей программе.&lt;/p>
&lt;ul>
&lt;li>Переменные используются для хранения значений.&lt;/li>
&lt;li>Как маленькая коробка с нашей сохраненной информацией или ценностями.&lt;/li>
&lt;li>Затем мы можем использовать эту переменную во всей программе, что также выгодно тем, что если эта задача или переменная изменится, нам нужно будет изменить это только в одном месте. Это означает, что мы могли бы перенести это на другие проблемы, с которыми мы сталкиваемся в сообществе, просто изменив значение этой переменной.&lt;/li>
&lt;/ul>
&lt;p>Чтобы объявить это в нашей программе Go, мы определяем значение, используя &lt;strong>ключевое слово&lt;/strong> для переменных. Это будет жить в нашем блоке кода &lt;code>func main&lt;/code>, который вы увидите позже. Подробнее о &lt;a href="https://go.dev/ref/spec#Keywords">Ключевых словах&lt;/a> можно узнать здесь.&lt;/p>
&lt;p>Не забудьте убедиться, что ваши имена переменных являются понятными. Если вы объявляете переменную, вы должны использовать ее, иначе вы получите ошибку. Это делается для того, чтобы избежать возможного неиспользованного кода. То же самое для неиспользуемых пакетов.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span> challenge = &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>С приведенным выше набором и использованием, как мы увидим в следующем фрагменте кода, вы можете видеть из вывода ниже, что мы использовали переменную.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> challenge = &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Welcome to&amp;#34;&lt;/span>, challenge &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Затем вы увидите ниже, что мы построили наш код с помощью приведенного выше примера и получили вывод, показанный ниже.
&lt;p class="md__image">
&lt;img
src="../images/Day11_Go1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также знаем, что наш челендж длится как минимум 90 дней для этой задачи, но в следующей, может быть, будет 100, поэтому мы хотим определить переменную, которая поможет нам. Однако для нашей программы мы хотим определить это как константу. Константы похожи на переменные, за исключением того, что их значение не может быть изменено в коде (мы все еще можем создать новое приложение позже с этим кодом и изменить эту константу, но это 90 не изменится, пока мы запускаем наше приложение)&lt;/p>
&lt;p>Добавим &lt;code>const&lt;/code> в наш код и добавим еще одну строку кода, чтобы напечатать результат.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> challenge = &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> daystotal = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Welcome to&amp;#34;&lt;/span>, challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;This is a&amp;#34;&lt;/span>, daystotal, &lt;span style="color:#4070a0">&amp;#34;challenge&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Если мы затем снова пройдем этот процесс &lt;code>go build&lt;/code> и запустим, вы увидите результат.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day11_Go2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Но это не будет концом нашей программы, мы вернемся к ней в &lt;a href="../day12">12-м дне&lt;/a>, чтобы добавить больше функциональности. Теперь мы хотим добавить еще одну переменную для количества дней, в течение которых мы выполнили задание.&lt;/p>
&lt;p>Ниже я добавил переменную &lt;code>dayscomplete&lt;/code> с количеством завершенных дней.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> challenge = &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> daystotal = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> dayscomplete = &lt;span style="color:#40a070">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Welcome to&amp;#34;&lt;/span>, challenge, &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;This is a&amp;#34;&lt;/span>, daystotal, &lt;span style="color:#4070a0">&amp;#34;challenge and you have completed&amp;#34;&lt;/span>, dayscomplete, &lt;span style="color:#4070a0">&amp;#34;days&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Great work&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Давайте снова запустим &lt;code>go build&lt;/code>, или вы можете просто использовать &lt;code>go run&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day11_Go3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вот несколько других примеров, которые я использовал, чтобы упростить чтение и редактирование кода. До сих пор мы использовали &lt;code>Println&lt;/code>, но мы можем упростить это, используя &lt;code>Printf&lt;/code>, используя &lt;code>%v&lt;/code>, что означает, что мы определяем наши переменные по порядку в конце строки кода. мы также используем &lt;code>\n&lt;/code> для разрыва строки.&lt;/p>
&lt;p>Я использую &lt;code>%v&lt;/code>, поскольку здесь используется значение по умолчанию, но есть и другие параметры, которые можно найти &lt;a href="https://pkg.go.dev/fmt">документации пакета fmt&lt;/a>.&lt;/p>
&lt;p>Переменные также могут быть определены в вашем коде в более простом формате. Вместо того, чтобы определять, что это &lt;code>var&lt;/code> и &lt;code>type&lt;/code>, вы можете закодировать это следующим образом, чтобы получить ту же функциональность, но более чистый и простой вид вашего кода. Это будет работать только для переменных, а не для констант.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> challenge &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> daystotal = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="типы-в--go">Типы в Go&lt;/h2>
&lt;p>В приведенных выше примерах мы не определили тип переменных, это потому, что мы можем задать им значение, Go достаточно умен, чтобы знать, что это за тип, или, по крайней мере, может сделать вывод, что это на основе значения, которое вы сохранили. . Однако, если мы хотим, чтобы пользователь ввел данные, для этого потребуется определенный тип.&lt;/p>
&lt;p>До сих пор в нашем коде использовались строки и целые числа. Целые числа для количества дней и строки для названия задачи.&lt;/p>
&lt;p>Также важно отметить, что каждый тип данных может выполнять разные действия и вести себя по-разному. Например, целые числа могут умножаться там, где нет строк.&lt;/p>
&lt;p>Есть четыре категории&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Basic type&lt;/strong>: в эту категорию попадают числа, строки и логические значения.&lt;/li>
&lt;li>&lt;strong>Aggregate type&lt;/strong>: к этой категории относятся массивы и структуры.&lt;/li>
&lt;li>&lt;strong>Reference type&lt;/strong>: в эту категорию попадают указатели, срезы, карты, функции и каналы.&lt;/li>
&lt;li>&lt;strong>Interface type&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Тип данных — важная концепция в программировании. Тип данных определяет размер и тип значений переменных.&lt;/p>
&lt;p>Go статически типизирован, а это означает, что после определения типа переменной он может хранить данные только этого типа.&lt;/p>
&lt;p>В Go есть три основных типа данных:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>bool&lt;/strong>: представляет логическое значение и может быть либо истинным, либо ложным.&lt;/li>
&lt;li>&lt;strong>Numeric&lt;/strong>: представляет целые типы, значения с плавающей запятой и сложные типы.&lt;/li>
&lt;li>&lt;strong>string&lt;/strong>: представляет строковое значение.&lt;/li>
&lt;/ul>
&lt;p>Я нашел этот ресурс очень подробным о типах данных &lt;a href="https://golangbyexample.com/all-data-types-in-golang-with-examples/">Golang by example&lt;/a>&lt;/p>
&lt;p>Я бы также посоветовал &lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I&amp;amp;t=2023s">Techworld with Nana&lt;/a> на этом этапе довольно подробно рассказать о типах данных в Go.&lt;/p>
&lt;p>Если нам нужно определить тип в нашей переменной, мы можем сделать это так:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span> TwitterHandle &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span> DaysCompleted &lt;span style="color:#902000">uint&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Поскольку Go принимает переменные, которым задано значение, мы можем распечатать эти значения следующим образом:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;challenge is %T, daystotal is %T, dayscomplete is %T\n&amp;#34;&lt;/span>, conference, daystotal, dayscomplete)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Существует много различных типов целых чисел и типов с плавающей запятой, ссылки выше подробно описывают их.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>int&lt;/strong> = целые числа&lt;/li>
&lt;li>&lt;strong>unint&lt;/strong> = беззнаковые целые числа&lt;/li>
&lt;li>&lt;strong>floating point types&lt;/strong> = числа с плавающей запятой&lt;/li>
&lt;/ul>
&lt;h2 id="источники">Источники&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://golang-book.ru/">Введение в Golang&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://insights.stackoverflow.com/survey/2021">StackOverflow 2021 Developer Survey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7pLqIIAqZD4&amp;amp;t=9s">Why we are choosing Golang to learn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=C8LgvuEBraI&amp;amp;t=312s">Jake Wright - Learn Go in 12 minutes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana - Golang full course - 3 hours 24 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pluralsight.com/courses/go-fundamentals">&lt;strong>NOT FREE&lt;/strong> Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;amp;t=1025s">FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLRAV69dS1uWSR89FRQGZ6q9BR2b44Tr9N">Hitesh Choudhary - Complete playlist&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Далее мы начнем добавлять в нашу программу некоторые функции пользовательского ввода, чтобы программа спрашивала, сколько дней было завершено.&lt;/p>
&lt;p>Увидимся &lt;a href="../day12">завтра&lt;/a>.&lt;/p></description></item><item><title>12. Golang - чтение данных и указатели</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day12/</link><pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day12/</guid><description>&lt;h2 id="получение-данных-с-клавиуатуры">Получение данных с клавиуатуры&lt;/h2>
&lt;p>Вчера (&lt;a href="../day11">Днем 11-м&lt;/a>) мы создали нашу первую программу Go, и данные, которые мы хотели получить от пользователя, были созданы как переменные в нашем коде. Теперь мы хотим спросить пользователя данные для ввода, чтобы дать переменной значение для конечного сообщения.&lt;/p>
&lt;h2 id="получение-пользовательских-данных">Получение пользовательских данных&lt;/h2>
&lt;p>Прежде чем мы это сделаем, давайте еще раз взглянем на наше приложение и пройдемся по переменным, которые нам нужны в качестве теста, прежде чем получить этот пользовательский ввод.&lt;/p>
&lt;p>Давайте теперь добавим новую переменную с именем &lt;code>TwitterName&lt;/code>, вы можете найти этот новый код ниже, и если мы запустим этот код, это будет наш вывод.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> challenge &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> daystotal = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Welcome to %v\n&amp;#34;&lt;/span>, challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;This is a %v challenge\n&amp;#34;&lt;/span>, daystotal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> TwitterName &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> DaysComplete &lt;span style="color:#902000">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// ask user for their twitter handle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TwitterName = &lt;span style="color:#4070a0">&amp;#34;@MichaelCade1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DaysComplete = &lt;span style="color:#40a070">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%v has completed %v days of the challenge\n&amp;#34;&lt;/span>, TwitterName, DaysComplete)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Great work&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Прежде чем мы это сделаем, давайте еще раз взглянем на наше приложение и пройдемся по переменным, которые нам нужны в качестве теста, прежде чем получить этот пользовательский ввод.&lt;/p>
&lt;p>Вчера мы закончили с нашим кодом, выглядящим так:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> challenge = &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> daystotal = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> dayscomplete = &lt;span style="color:#40a070">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Welcome to %v\n&amp;#34;&lt;/span>, challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;This is a %v challenge and you have completed %v days\n&amp;#34;&lt;/span>, daystotal, dayscomplete)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Great work&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Мы вручную определили в коде наши переменные и константы &lt;code>challenge, daystotal, dayscomplete&lt;/code>.&lt;/p>
&lt;p>Давайте теперь добавим новую переменную с именем &lt;code>TwitterName&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day12_Go1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>У нас 12-й день, и нам нужно было бы менять &lt;code>dayscomplete&lt;/code> каждый день и компилировать наш код каждый день, если бы он был жестко запрограммирован, что звучит не так уж здорово.&lt;/p>
&lt;p>Получая пользовательский ввод, мы хотим получить значение, возможно, имя и количество завершенных дней. Для этого мы можем использовать другую функцию из пакета &lt;code>fmt&lt;/code>.&lt;/p>
&lt;p>Кратко о пакете &lt;code>fmt&lt;/code>, различные функции для: форматированного ввода и вывода (I/O) (input and output)&lt;/p>
&lt;ul>
&lt;li>Печать сообщений&lt;/li>
&lt;li>Собирать пользовательский ввод&lt;/li>
&lt;li>Записать в файл&lt;/li>
&lt;/ul>
&lt;p>Это вместо того, чтобы присваивать значение переменной, мы хотим попросить пользователя ввести его.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#06287e">Scan&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>TwitterName)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Обратите внимание, что мы также используем &lt;code>&amp;amp;&lt;/code> перед переменной. Этот символ известен как указатель, который мы рассмотрим в следующем разделе.&lt;/p>
&lt;p>В нашем коде вы можете видеть, что мы просим пользователя ввести две переменные, &lt;code>TwitterName&lt;/code> и &lt;code>DaysCompleted&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> DaysTotal &lt;span style="color:#902000">int&lt;/span> = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> challenge &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Welcome to the %v challenge.\nThis challenge consists of %v days\n&amp;#34;&lt;/span>, challenge, DaysTotal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> TwitterName &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> DaysCompleted &lt;span style="color:#902000">uint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// asking for user input&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Enter Your Twitter Handle: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Scanln&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>TwitterName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;How many days have you completed?: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Scanln&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Thank you %v for taking part and completing %v days.\n&amp;#34;&lt;/span>, TwitterName, DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Good luck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Давайте теперь запустим нашу программу, и вы увидите, что у нас есть входные данные для обоих вышеперечисленных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day12_Go2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хорошо, мы получили некоторый пользовательский ввод и напечатали сообщение, но как насчет того, чтобы заставить нашу программу сообщать нам, сколько дней у нас осталось в нашей задаче.&lt;/p>
&lt;p>Для этого мы создали переменную с именем &lt;code>remainingDays&lt;/code>, и мы жестко оценили ее в нашем коде как &lt;code>90&lt;/code>. Затем нам нужно изменить значение этого значения, чтобы распечатать &lt;code>remainingDays&lt;/code>, когда мы получим пользовательский ввод &lt;code>DaysCompleted&lt;/code> мы можем сделать это с помощью этого простого изменения переменной.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>remainingDays = remainingDays - DaysCompleted
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Наша программа теперь выглядит вот так:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> DaysTotal &lt;span style="color:#902000">int&lt;/span> = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> remainingDays &lt;span style="color:#902000">uint&lt;/span> = &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> challenge &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Welcome to the %v challenge.\nThis challenge consists of %v days\n&amp;#34;&lt;/span>, challenge, DaysTotal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> TwitterName &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> DaysCompleted &lt;span style="color:#902000">uint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// asking for user input&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Enter Your Twitter Handle: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Scanln&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>TwitterName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;How many days have you completed?: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Scanln&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// calculate remaining days&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainingDays = remainingDays &lt;span style="color:#666">-&lt;/span> DaysCompleted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Thank you %v for taking part and completing %v days.\n&amp;#34;&lt;/span>, TwitterName, DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;You have %v days remaining for the %v challenge\n&amp;#34;&lt;/span>, remainingDays, challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Good luck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Если мы теперь запустим эту программу, вы увидите, что простой расчет выполняется на основе пользовательского ввода и значения &lt;code>remainingDays&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day12_Go3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="что-такое-указатель-специальные-переменные">Что такое указатель? (Специальные переменные)&lt;/h2>
&lt;p>Указатель — это (специальная) переменная, которая указывает на адрес памяти другой переменной.&lt;/p>
&lt;p>Отличное объяснение этого можно найти здесь &lt;a href="https://www.geeksforgeeks.org/pointers-in-golang/">geeksforgeeks&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> challenge = &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ниже выполняется этот код.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day12_Go4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://golang-book.ru/">Введение в Golang&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://insights.stackoverflow.com/survey/2021">StackOverflow 2021 Developer Survey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7pLqIIAqZD4&amp;amp;t=9s">Why we are choosing Golang to learn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=C8LgvuEBraI&amp;amp;t=312s">Jake Wright - Learn Go in 12 minutes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana - Golang full course - 3 hours 24 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pluralsight.com/courses/go-fundamentals">&lt;strong>NOT FREE&lt;/strong> Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;amp;t=1025s">FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLRAV69dS1uWSR89FRQGZ6q9BR2b44Tr9N">Hitesh Choudhary - Complete playlist&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Увидимся &lt;a href="../day13">завтра&lt;/a>.&lt;/p></description></item><item><title>13. Go - подключение Twitter API</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day13/</link><pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day13/</guid><description>&lt;h2 id="твитните-о-своем-прогрессе-с-нашим-новым-приложением">Твитните о своем прогрессе с нашим новым приложением&lt;/h2>
&lt;p>В последний день изучения этого языка программирования мы только коснулись его основ, но я думаю, что это начало.&lt;/p>
&lt;p>За последние несколько дней мы взяли небольшую идею для приложения и добавили функциональность, в этой статье я хочу воспользоваться преимуществами тех пакетов, которые мы упомянули, и создать функциональность для нашего приложения, чтобы не только дать вам обновление вашего прогресса на экране, но также отправьте твит с подробностями задачи и вашим статусом.&lt;/p>
&lt;h2 id="добавление-возможности-твитить-свой-прогресс">Добавление возможности твитить свой прогресс&lt;/h2>
&lt;p>Первое, что нам нужно сделать, это настроить доступ API разработчика к Twitter, чтобы это работало.&lt;/p>
&lt;p>Перейдите на &lt;a href="https://developer.twitter.com">Платформу разработчиков Twitter&lt;/a> и войдите в систему, используя свой идентификатор Twitter и данные. Оказавшись внутри, вы должны увидеть что-то вроде приведенного ниже без приложения, которое я уже создал.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Здесь вы также можете запросить дополнительный доступ. Это может занять некоторое время, но для меня это было очень быстро.&lt;/p>
&lt;p>Затем мы должны выбрать «Projects &amp;amp; Apps» и создать наше приложение. Ограничения зависят от доступа к вашей учетной записи, при этом у вас должно быть только одно приложение и один проект, а с повышенными правами у вас может быть 3 приложения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Дайте вашему приложению имя&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем вам будут предоставлены эти токены API, важно сохранить их в безопасном месте. (С тех пор я удалил это приложение) Они понадобятся нам позже с нашим приложением Go.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас создано наше приложение (мне пришлось изменить имя моего приложения, так как то, что на скриншоте выше, уже было сделано, эти имена должны быть уникальными)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Ключи, которые мы собрали ранее, известны как наши потребительские ключи, и нам также понадобятся наш токен доступа и секреты. Мы можем собрать эту информацию, используя вкладку «Ключи и токены».&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хорошо, на данный момент мы закончили работу с порталом для разработчиков Twitter. Убедитесь, что вы сохранили свои ключи, потому что они понадобятся нам позже.&lt;/p>
&lt;h2 id="перейти-twitter-бот">Перейти Twitter бот&lt;/h2>
&lt;p>Помните код, который мы запускаем в нашем приложении?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>package main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> DaysTotal &lt;span style="color:#007020">int&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> remainingDays uint &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> challenge :&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;Welcome to the %v challenge.&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">This challenge consists of %v days&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, challenge, DaysTotal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> TwitterName string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> DaysCompleted uint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> asking &lt;span style="color:#007020;font-weight:bold">for&lt;/span> user input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Println(&lt;span style="color:#4070a0">&amp;#34;Enter Your Twitter Handle: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Scanln(&lt;span style="color:#666">&amp;amp;&lt;/span>TwitterName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Println(&lt;span style="color:#4070a0">&amp;#34;How many days have you completed?: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Scanln(&lt;span style="color:#666">&amp;amp;&lt;/span>DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> calculate remaining days
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainingDays &lt;span style="color:#666">=&lt;/span> remainingDays &lt;span style="color:#666">-&lt;/span> DaysCompleted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;Thank you %v for taking part and completing %v days.&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, TwitterName, DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;You have %v days remaining for the %v challenge&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, remainingDays, challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Println(&lt;span style="color:#4070a0">&amp;#34;Good luck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь нам нужно подумать о коде для отправки нашего вывода или сообщения в Twitter в виде твита. Мы будем использовать &lt;a href="https://github.com/dghubble/go-twitter">go-twitter&lt;/a>. Это клиентская библиотека Go для Twitter API.&lt;/p>
&lt;p>Чтобы проверить это, прежде чем помещать это в наше основное приложение, я создал новый каталог в нашей папке &lt;code>src&lt;/code> с именем go-twitter-bot, запустил &lt;code>go mod init github.com/michaelcade/go-twitter-bot&lt;/code> в папке который затем создал файл &lt;code>go.mod&lt;/code>, а затем мы можем начать писать наш новый main.go и протестировать его.&lt;/p>
&lt;p>Теперь нам нужны те ключи, токены и секреты, которые мы собрали на портале разработчиков Twitter. Мы собираемся установить их в наших переменных среды. Это будет зависеть от ОС, которую вы используете:&lt;/p>
&lt;p>Windows&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>set CONSUMER_KEY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set CONSUMER_SECRET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set ACCESS_TOKEN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set ACCESS_TOKEN_SECRET
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Linux / macOS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">export&lt;/span> CONSUMER_KEY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">export&lt;/span> CONSUMER_SECRET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">export&lt;/span> ACCESS_TOKEN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">export&lt;/span> ACCESS_TOKEN_SECRET
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>At this stage, you can take a look at &lt;a href="Go/day13_example2.go">day13_example2&lt;/a> at the code but you will see here that we are using a struct to define our keys, secrets and tokens.&lt;/p>
&lt;p>We then have a &lt;code>func&lt;/code> to parse those credentials and make that connection to the Twitter API&lt;/p>
&lt;p>Then based on the success we will then send a tweet.&lt;/p>
&lt;p>На этом этапе вы можете взглянуть на следующий код&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// other imports&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;github.com/dghubble/go-twitter/twitter&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;github.com/dghubble/oauth1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Credentials stores all of our access/consumer tokens&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// and secret keys needed for authentication against&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// the twitter REST API.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">type&lt;/span> Credentials &lt;span style="color:#007020;font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerKey &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerSecret &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessToken &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessTokenSecret &lt;span style="color:#902000">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// getClient is a helper function that will return a twitter client&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// that we can subsequently use to send tweets, or to stream new tweets&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// this will take in a pointer to a Credential struct which will contain&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// everything needed to authenticate and return a pointer to a twitter Client&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// or an error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">getClient&lt;/span>(creds &lt;span style="color:#666">*&lt;/span>Credentials) (&lt;span style="color:#666">*&lt;/span>twitter.Client, &lt;span style="color:#902000">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Pass in your consumer key (API Key) and your Consumer Secret (API Secret)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config &lt;span style="color:#666">:=&lt;/span> oauth1.&lt;span style="color:#06287e">NewConfig&lt;/span>(creds.ConsumerKey, creds.ConsumerSecret)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Pass in your Access Token and your Access Token Secret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> token &lt;span style="color:#666">:=&lt;/span> oauth1.&lt;span style="color:#06287e">NewToken&lt;/span>(creds.AccessToken, creds.AccessTokenSecret)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpClient &lt;span style="color:#666">:=&lt;/span> config.&lt;span style="color:#06287e">Client&lt;/span>(oauth1.NoContext, token)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client &lt;span style="color:#666">:=&lt;/span> twitter.&lt;span style="color:#06287e">NewClient&lt;/span>(httpClient)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Verify Credentials&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> verifyParams &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>twitter.AccountVerifyParams{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SkipStatus: twitter.&lt;span style="color:#06287e">Bool&lt;/span>(&lt;span style="color:#007020;font-weight:bold">true&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IncludeEmail: twitter.&lt;span style="color:#06287e">Bool&lt;/span>(&lt;span style="color:#007020;font-weight:bold">true&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// we can retrieve the user and verify if the credentials&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// we have used successfully allow us to log in!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user, _, err &lt;span style="color:#666">:=&lt;/span> client.Accounts.&lt;span style="color:#06287e">VerifyCredentials&lt;/span>(verifyParams)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;User&amp;#39;s ACCOUNT:\n%+v\n&amp;#34;&lt;/span>, user)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> client, &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> &lt;span style="color:#06287e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Go-Twitter Bot v0.01&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> creds &lt;span style="color:#666">:=&lt;/span> Credentials{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessToken: os.&lt;span style="color:#06287e">Getenv&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;ACCESS_TOKEN&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessTokenSecret: os.&lt;span style="color:#06287e">Getenv&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;ACCESS_TOKEN_SECRET&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerKey: os.&lt;span style="color:#06287e">Getenv&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;CONSUMER_KEY&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerSecret: os.&lt;span style="color:#06287e">Getenv&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;CONSUMER_SECRET&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client, err &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#06287e">getClient&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>creds)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06287e">Println&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Error getting Twitter Client&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06287e">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tweet, resp, err &lt;span style="color:#666">:=&lt;/span> client.Statuses.&lt;span style="color:#06287e">Update&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;A Test Tweet from the future, testing a #90DaysOfDevOps Program that tweets, tweet tweet&amp;#34;&lt;/span>, &lt;span style="color:#007020;font-weight:bold">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020;font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06287e">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%+v\n&amp;#34;&lt;/span>, resp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06287e">Printf&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;%+v\n&amp;#34;&lt;/span>, tweet)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Здесь вы увидите, что мы используем структуру для определения наших ключей, секретов и токенов.&lt;/p>
&lt;p>Затем у нас есть &lt;code>func&lt;/code>, чтобы проанализировать эти учетные данные и установить это соединение с API Twitter.&lt;/p>
&lt;p>Затем, в зависимости от успеха, мы отправим твит.&lt;/p>
&lt;p>Код выше либо выдаст вам ошибку в зависимости от того, что происходит, либо будет выполнен успешно, и вам будет отправлен твит с сообщением, указанным в коде.&lt;/p>
&lt;h2 id="соединение-двух-вместе---go-twitter-bot--наше-приложение">Соединение двух вместе - Go-Twitter-Bot + наше приложение&lt;/h2>
&lt;p>Теперь нам нужно объединить эти два файла в наш &lt;code>main.go&lt;/code>. Я уверен, что кто-то кричит, что есть лучший способ сделать это, и, пожалуйста, прокомментируйте это, поскольку вы можете иметь более одного файла &lt;code>.go&lt;/code> в одном файле. project это может иметь смысл, но это работает.&lt;/p>
&lt;p>Так выглядит итоговый рзультат:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>package main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> other imports
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;github.com/dghubble/go-twitter/twitter&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;github.com/dghubble/oauth1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> Credentials stores all of our access&lt;span style="color:#666">/&lt;/span>consumer tokens
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> secret keys needed &lt;span style="color:#007020;font-weight:bold">for&lt;/span> authentication against
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> the twitter REST API&lt;span style="color:#666">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type Credentials struct {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerKey string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerSecret string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessToken string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessTokenSecret string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> getClient is a helper function that will &lt;span style="color:#007020;font-weight:bold">return&lt;/span> a twitter client
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> that we can subsequently use to send tweets, &lt;span style="color:#007020;font-weight:bold">or&lt;/span> to stream new tweets
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> this will take &lt;span style="color:#007020;font-weight:bold">in&lt;/span> a pointer to a Credential struct which will contain
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> everything needed to authenticate &lt;span style="color:#007020;font-weight:bold">and&lt;/span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> a pointer to a twitter Client
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">//&lt;/span> &lt;span style="color:#007020;font-weight:bold">or&lt;/span> an error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> getClient(creds &lt;span style="color:#666">*&lt;/span>Credentials) (&lt;span style="color:#666">*&lt;/span>twitter&lt;span style="color:#666">.&lt;/span>Client, error) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> Pass &lt;span style="color:#007020;font-weight:bold">in&lt;/span> your consumer key (API Key) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> your Consumer Secret (API Secret)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config :&lt;span style="color:#666">=&lt;/span> oauth1&lt;span style="color:#666">.&lt;/span>NewConfig(creds&lt;span style="color:#666">.&lt;/span>ConsumerKey, creds&lt;span style="color:#666">.&lt;/span>ConsumerSecret)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> Pass &lt;span style="color:#007020;font-weight:bold">in&lt;/span> your Access Token &lt;span style="color:#007020;font-weight:bold">and&lt;/span> your Access Token Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> token :&lt;span style="color:#666">=&lt;/span> oauth1&lt;span style="color:#666">.&lt;/span>NewToken(creds&lt;span style="color:#666">.&lt;/span>AccessToken, creds&lt;span style="color:#666">.&lt;/span>AccessTokenSecret)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpClient :&lt;span style="color:#666">=&lt;/span> config&lt;span style="color:#666">.&lt;/span>Client(oauth1&lt;span style="color:#666">.&lt;/span>NoContext, token)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client :&lt;span style="color:#666">=&lt;/span> twitter&lt;span style="color:#666">.&lt;/span>NewClient(httpClient)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> Verify Credentials
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> verifyParams :&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">&amp;amp;&lt;/span>twitter&lt;span style="color:#666">.&lt;/span>AccountVerifyParams{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SkipStatus: twitter&lt;span style="color:#666">.&lt;/span>Bool(true),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IncludeEmail: twitter&lt;span style="color:#666">.&lt;/span>Bool(true),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> we can retrieve the user &lt;span style="color:#007020;font-weight:bold">and&lt;/span> verify &lt;span style="color:#007020;font-weight:bold">if&lt;/span> the credentials
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> we have used successfully allow us to &lt;span style="color:#007020">log&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span>&lt;span style="color:#666">!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user, _, err :&lt;span style="color:#666">=&lt;/span> client&lt;span style="color:#666">.&lt;/span>Accounts&lt;span style="color:#666">.&lt;/span>VerifyCredentials(verifyParams)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> nil {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> nil, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">log&lt;/span>&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;User&amp;#39;s ACCOUNT:&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">%+v&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, user)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> client, nil
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">func&lt;/span> main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> creds :&lt;span style="color:#666">=&lt;/span> Credentials{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessToken: os&lt;span style="color:#666">.&lt;/span>Getenv(&lt;span style="color:#4070a0">&amp;#34;ACCESS_TOKEN&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessTokenSecret: os&lt;span style="color:#666">.&lt;/span>Getenv(&lt;span style="color:#4070a0">&amp;#34;ACCESS_TOKEN_SECRET&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerKey: os&lt;span style="color:#666">.&lt;/span>Getenv(&lt;span style="color:#4070a0">&amp;#34;CONSUMER_KEY&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerSecret: os&lt;span style="color:#666">.&lt;/span>Getenv(&lt;span style="color:#4070a0">&amp;#34;CONSUMER_SECRET&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> DaysTotal &lt;span style="color:#007020">int&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> remainingDays uint &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> challenge :&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;#90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;Welcome to the %v challenge.&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">This challenge consists of %v days&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, challenge, DaysTotal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> TwitterName string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">var&lt;/span> DaysCompleted uint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> asking &lt;span style="color:#007020;font-weight:bold">for&lt;/span> user input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Println(&lt;span style="color:#4070a0">&amp;#34;Enter Your Twitter Handle: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Scanln(&lt;span style="color:#666">&amp;amp;&lt;/span>TwitterName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Println(&lt;span style="color:#4070a0">&amp;#34;How many days have you completed?: &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt&lt;span style="color:#666">.&lt;/span>Scanln(&lt;span style="color:#666">&amp;amp;&lt;/span>DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> calculate remaining days
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainingDays &lt;span style="color:#666">=&lt;/span> remainingDays &lt;span style="color:#666">-&lt;/span> DaysCompleted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span>fmt&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;Thank you %v for taking part and completing %v days.&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, TwitterName, DaysCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span>fmt&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;You have %v days remaining for the %v challenge&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, remainingDays, challenge)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">//&lt;/span> fmt&lt;span style="color:#666">.&lt;/span>Println(&lt;span style="color:#4070a0">&amp;#34;Good luck&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client, err :&lt;span style="color:#666">=&lt;/span> getClient(&lt;span style="color:#666">&amp;amp;&lt;/span>creds)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> nil {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">log&lt;/span>&lt;span style="color:#666">.&lt;/span>Println(&lt;span style="color:#4070a0">&amp;#34;Error getting Twitter Client, this is expected if you did not supply your Twitter API tokens&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">log&lt;/span>&lt;span style="color:#666">.&lt;/span>Println(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message :&lt;span style="color:#666">=&lt;/span> fmt&lt;span style="color:#666">.&lt;/span>Sprintf(&lt;span style="color:#4070a0">&amp;#34;Hey I am %v I have been doing the %v for %v days and I have %v Days left&amp;#34;&lt;/span>, TwitterName, challenge, DaysCompleted, remainingDays)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tweet, resp, err :&lt;span style="color:#666">=&lt;/span> client&lt;span style="color:#666">.&lt;/span>Statuses&lt;span style="color:#666">.&lt;/span>Update(message, nil)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> err &lt;span style="color:#666">!=&lt;/span> nil {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">log&lt;/span>&lt;span style="color:#666">.&lt;/span>Println(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">log&lt;/span>&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;%+v&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, resp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">log&lt;/span>&lt;span style="color:#666">.&lt;/span>Printf(&lt;span style="color:#4070a0">&amp;#34;%+v&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, tweet)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Результатом этого должен быть твит, но если вы не указали свои переменные среды, вы должны получить сообщение об ошибке, подобное приведенному ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После того, как вы исправите это или решите не проходить аутентификацию в Twitter, вы можете использовать код, с которым мы закончили вчера. Вывод терминала в случае успеха будет выглядеть примерно так:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Полученный твит должен выглядеть примерно так:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day13_Go9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="как-скомпилировать-для-нескольких-ос">Как скомпилировать для нескольких ОС&lt;/h2>
&lt;p>Далее я хочу затронуть вопрос: «Как компилировать для нескольких операционных систем?» Отличительной особенностью Go является то, что он может легко компилироваться для многих различных операционных систем. Вы можете получить полный список, выполнив следующую команду:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>go &lt;span style="color:#007020;font-weight:bold">tool&lt;/span> dist list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Использование наших команд &lt;code>go build&lt;/code> до сих пор было замечательным, и оно будет использовать переменные среды &lt;code>GOOS&lt;/code> и &lt;code>GOARCH&lt;/code>, чтобы определить хост-компьютер и то, для чего должна быть собрана сборка. Но мы также можем создавать другие двоичные файлы, используя приведенный ниже код в качестве примера.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>GOARCH=amd64 GOOS=darwin go build -o ${BINARY_NAME}_0.1_darwin main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOARCH=amd64 GOOS=linux go build -o ${BINARY_NAME}_0.1_linux main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOARCH=amd64 GOOS=windows go build -o ${BINARY_NAME}_0.1_windows main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOARCH=arm64 GOOS=linux go build -o ${BINARY_NAME}_0.1_linux_arm64 main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOARCH=arm64 GOOS=darwin go build -o ${BINARY_NAME}_0.1_darwin_arm64 main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Это даст вам двоичные файлы в вашем каталоге для всех вышеперечисленных платформ. Затем вы можете взять это и создать make-файл для создания этих двоичных файлов всякий раз, когда вы добавляете новые функции и функции в свой код.&lt;/p>
&lt;p>Файл: &lt;code>makefile&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>BINARY_NAME=90DaysOfDevOps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>build:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GOARCH=amd64 GOOS=darwin go build -o ${BINARY_NAME}_0.2_darwin main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GOARCH=amd64 GOOS=linux go build -o ${BINARY_NAME}_0.2_linux main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GOARCH=amd64 GOOS=windows go build -o ${BINARY_NAME}_0.2_windows main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GOARCH=arm64 GOOS=linux go build -o ${BINARY_NAME}_0.2_linux_arm64 main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GOARCH=arm64 GOOS=darwin go build -o ${BINARY_NAME}_0.2_darwin_arm64 main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>run:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ./${BINARY_NAME}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>build_and_run: build run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clean:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go clean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm ${BINARY_NAME}-darwin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm ${BINARY_NAME}-linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rm ${BINARY_NAME}-windows
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="источники">Источники&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://insights.stackoverflow.com/survey/2021">StackOverflow 2021 Developer Survey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7pLqIIAqZD4&amp;amp;t=9s">Why we are choosing Golang to learn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=C8LgvuEBraI&amp;amp;t=312s">Jake Wright - Learn Go in 12 minutes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=yyUHQIec83I">Techworld with Nana - Golang full course - 3 hours 24 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pluralsight.com/courses/go-fundamentals">&lt;strong>NOT FREE&lt;/strong> Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;amp;t=1025s">FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLRAV69dS1uWSR89FRQGZ6q9BR2b44Tr9N">Hitesh Choudhary - Complete playlist&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/bregman-arie/devops-exercises">A great repo full of all things DevOps &amp;amp; exercises&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gobyexample.com/">GoByExample - Example based learning&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/tour/list">go.dev/tour/list&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/learn/">go.dev/learn&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>На этом блок &amp;ldquo;язык программирования&amp;rdquo;. Так много всего, что можно охватить, и я надеюсь, что вы смогли продолжить изучение вышеизложенного и понять некоторые другие аспекты языка программирования Go.&lt;/p>
&lt;p>Затем мы сосредоточимся на Linux и некоторых основах, которые мы все должны знать.&lt;/p></description></item><item><title>14. DevOps и Linux</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day14/</link><pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day14/</guid><description>&lt;h2 id="общая-картина-devops-и-linux">Общая картина: DevOps и Linux&lt;/h2>
&lt;p>Linux и DevOps имеют очень схожие культуры и взгляды; оба ориентированы на настройку и масштабируемость. Оба эти аспекта Linux имеют особое значение для DevOps.&lt;/p>
&lt;p>Многие технологии начинаются с Linux, особенно если они связаны с разработкой программного обеспечения или управлением инфраструктурой.&lt;/p>
&lt;p>Кроме того, многие проекты с открытым исходным кодом, особенно инструменты DevOps, с самого начала разрабатывались для работы в Linux.&lt;/p>
&lt;p>С точки зрения DevOps или фактически с точки зрения какой-либо операционной роли вы столкнетесь с Linux, я бы сказал, в основном. Есть место для WinOps, но большую часть времени вы будете администрировать и развертывать серверы Linux.&lt;/p>
&lt;p>Я использую Linux ежедневно в течение нескольких лет, но мой настольный компьютер всегда был либо macOS, либо Windows. Однако, когда я перешел на роль Cloud Native, в которой я сейчас нахожусь, я сделал решительный шаг, чтобы убедиться, что мой ноутбук полностью основан на Linux и является моим ежедневным драйвером, в то время как мне по-прежнему нужна была Windows для рабочих приложений и многих моих аудио и видеоаппаратура не работает в Linux Я заставлял себя постоянно работать на рабочем столе Linux, чтобы лучше понять многие вещи, которые мы собираемся затронуть в течение следующих 7 дней.&lt;/p>
&lt;h2 id="начало">Начало&lt;/h2>
&lt;p>Я не предлагаю вам делать то же самое, что и я, в любом случае, поскольку есть более простые варианты и менее разрушительные, но я скажу, что этот полный рабочий день заставит вас быстрее научиться тому, как заставить все работать в Linux.&lt;/p>
&lt;p>В течение большей части этих 7 дней я фактически собираюсь развернуть виртуальную машину в Virtual Box на моей машине с Windows. Я также собираюсь развернуть настольную версию дистрибутива Linux, в то время как многие серверы Linux, которыми вы будете администрировать, скорее всего, будут серверами без графического интерфейса и полностью основанными на оболочке. Однако, как я сказал в начале, многие инструменты, которые мы рассмотрели в течение всех этих 90 дней, начинались с Linux, я также настоятельно рекомендую вам погрузиться в работу этого рабочего стола Linux для этого обучения.&lt;/p>
&lt;p>В оставшейся части этого поста мы сосредоточимся на настройке и запуске виртуальной машины Ubuntu Desktop в нашей среде Virtual Box. Теперь мы можем просто загрузить &lt;a href="https://www.virtualbox.org/">Virtual Box&lt;/a> и получить последний &lt;a href="https://ubuntu.com/download">Ubuntu ISO&lt;/a> с сайтов, на которые даны ссылки, и продолжить сборку. нашу среду рабочего стола, но это не было бы очень DevOps с нашей стороны, не так ли?&lt;/p>
&lt;p>Еще одна веская причина использовать большинство дистрибутивов Linux заключается в том, что они бесплатны и имеют открытый исходный код. Мы также выбираем Ubuntu, поскольку это, вероятно, наиболее широко используемый дистрибутив, не думая о мобильных устройствах и корпоративных серверах RedHat Enterprise. Я могу ошибаться, но с CentOS и ее историей я уверен, что Ubuntu занимает первое место в списке, и это очень просто.&lt;/p>
&lt;h2 id="hashicorp-vagrant">HashiCorp Vagrant&lt;/h2>
&lt;p>Vagrant — это утилита CLI, которая управляет жизненным циклом ваших виртуальных машин. Мы можем использовать vagrant для запуска и отключения виртуальных машин на разных платформах, включая vSphere, Hyper-v, Virtual Box, а также Docker. У него есть другие провайдеры, но мы будем придерживаться того, что здесь мы используем Virtual Box, так что все готово.&lt;/p>
&lt;p>Vagrant — свободное и открытое программное обеспечение для создания и конфигурирования виртуальной среды разработки. Является обёрткой для программного обеспечения виртуализации, например VirtualBox, и средств управления конфигурациями, таких как Chef, Salt и Puppet.&lt;/p>
&lt;p>Первое, что нам нужно сделать, это установить Vagrant на нашу машину, когда вы перейдете на страницу загрузок, вы увидите все операционные системы, перечисленные на ваш выбор. &lt;a href="https://www.vagrantup.com/downloads">HashiCorp Vagrant&lt;/a> Я использую Windows, поэтому я взял двоичный файл для своей системы и установил его в свою систему.&lt;/p>
&lt;p>Далее нам также нужно установить &lt;a href="https://www.virtualbox.org/wiki/Downloads">Virtual Box&lt;/a>. Опять же, это также может быть установлено на многих разных операционных системах.&lt;/p>
&lt;h2 id="файл-vagrantfile">Файл VAGRANTFILE&lt;/h2>
&lt;p>VAGRANTFILE описывает тип машины, которую мы хотим развернуть. Он также определяет, как мы хотим, чтобы конфигурация и подготовка этой машины выглядели.&lt;/p>
&lt;p>Когда дело доходит до их сохранения и организации ваших VAGRANTFILE, я стараюсь помещать их в отдельные папки в своем рабочем пространстве. Ниже вы можете увидеть, как это выглядит в моей системе. Надеюсь, после этого вы поиграете с Vagrant и увидите легкость запуска разных систем, это также отлично подходит для этой кроличьей норы, известной как скачок дистрибутива для Linux Desktops.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day14_Linux1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Давайте взглянем на этот VAGRANTFILE и посмотрим, что мы строим.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Vagrant.configure(&amp;#34;2&amp;#34;) do |config|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.vm.box = &amp;#34;chenhan/ubuntu-desktop-20.04&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.vm.provider :virtualbox do |v|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v.memory = 8096
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v.cpus = 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v.customize [&amp;#34;modifyvm&amp;#34;, :id, &amp;#34;--vram&amp;#34;, &amp;#34;128mb&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Это очень простой VAGRANTFILE. В целом, мы говорим, что нам нужна конкретная «сборка». Сборка, возможно, является либо общедоступным образом, либо частной сборкой системы, которую вы ищете. Вы можете найти длинный список здесь, в &lt;a href="https://app.vagrantup.com/boxes/search">общедоступном каталоге Vagrant&lt;/a>&lt;/p>
&lt;p>Далее мы говорим, что хотим использовать определенного провайдера, в данном случае это «VirtualBox», а затем мы хотим определить память нашей машины как «8 ГБ, а количество процессоров — как «4». Мой опыт также говорит мне, что вы можете также добавить следующую строку, если у вас возникли проблемы с отображением. Это установит видеопамять на то, что вы хотите, я бы увеличил ее до 128 МБ, но зависит от вашей системы.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v.customize [&amp;#34;modifyvm&amp;#34;, :id, &amp;#34;--vram&amp;#34;, &amp;#34;&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="инициализация-нашего-рабочего-стола-linux">Инициализация нашего рабочего стола Linux&lt;/h2>
&lt;p>Теперь мы готовы запустить нашу первую машину в терминале нашего ПК. В моем случае я использую PowerShell на своем компьютере с Windows, перейдите в папку своих проектов и там, где вы найдете свой VAGRANTFILE. Оказавшись там, вы можете ввести команду &lt;code>vagrant up&lt;/code>, и если все правильно, вы увидите что-то вроде того, что показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day14_Linux2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Еще одна вещь, которую следует добавить, это то, что сеть будет настроена на &lt;code>NAT&lt;/code> на вашей виртуальной машине, на данном этапе нам действительно не нужно знать о NAT, и я планирую провести целую сессию в следующем разделе о сети. Но знайте, что это просто кнопка, когда дело доходит до включения машины в вашу домашнюю сеть, это также сетевой режим по умолчанию в Virtual Box. Вы можете узнать больше в &lt;a href="https://www.virtualbox.org/manual/ch06.html#network_nat">документации Virtual Box&lt;/a>&lt;/p>
&lt;p>Как только &lt;code>vagrant up&lt;/code> завершен, мы можем использовать &lt;code>vagrant ssh&lt;/code>, чтобы перейти прямо в терминал нашей новой виртуальной машины.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day14_Linux3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Именно здесь мы будем проводить большую часть наших исследований в течение следующих нескольких дней, но я также хочу погрузиться в некоторые настройки для вашей рабочей станции разработчика, которые я сделал, и это значительно упрощает вашу жизнь при использовании этого в качестве ежедневного драйвера, и, конечно же, а ты реально в DevOps разве что у тебя крутой нестандартный терминал?&lt;/p>
&lt;p>Но просто для подтверждения в Virtual Box вы должны увидеть приглашение для входа в систему при выборе виртуальной машины.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day14_Linux4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>О, и если вы зашли так далеко и спрашивали: «ЧТО ТАКОЕ ИМЯ ПОЛЬЗОВАТЕЛЯ И ПАРОЛЬ?»&lt;/p>
&lt;ul>
&lt;li>Username = vagrant&lt;/li>
&lt;li>Password = vagrant&lt;/li>
&lt;/ul>
&lt;p>Завтра мы рассмотрим некоторые команды и то, что они делают. Терминал станет местом, где все произойдет.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kPylihJRG70">Learn the Linux Fundamentals - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=VbEx7B_PTOE">Linux for hackers (don&amp;rsquo;t worry you don&amp;rsquo;t need be a hacker!)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.hashicorp.com/vagrant">Vargant tutorial&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Как я уже упоминал, далее мы рассмотрим команды, которые мы можем использовать ежедневно в наших средах Linux.&lt;/p></description></item><item><title>15. Команды Linux в DevOps</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day15/</link><pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day15/</guid><description>&lt;h2 id="команды-linux-для-devops">Команды Linux для DevOps&lt;/h2>
&lt;p>Я упомянул &lt;a href="../day14">вчера&lt;/a>, что мы собираемся провести много времени в терминале с некоторыми командами, чтобы что-то сделать.&lt;/p>
&lt;p>Я также упомянул, что с нашей виртуальной машиной, подготовленной с помощью vagrant, мы можем использовать &lt;code>vagrant ssh&lt;/code> и получить доступ к нашей машине. Вам нужно будет находиться в том же каталоге, из которого мы его предоставили.&lt;/p>
&lt;p>Для SSH нам не понадобятся имя пользователя и пароль, они понадобятся нам только в том случае, если решим войти в консоль Virtual Box.&lt;/p>
&lt;p>Вот где мы хотим быть, как показано ниже:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="команды">Команды&lt;/h2>
&lt;p>Очевидно, что я не могу охватить здесь все команды. Есть тонны документации, которые охватывают их, но также, если вы находитесь в своем терминале, и вам просто нужно понять параметры конкретной команды, у нас есть команда &lt;code>man&lt;/code>, сокращенная от manual. Мы можем использовать это, чтобы просмотреть каждую из команд, которые мы коснемся в этом посте, чтобы узнать больше вариантов для каждой из них. Мы можем запустить &lt;code>man man&lt;/code>, который поможет вам со страницами руководства. Чтобы выйти из справочных страниц, вы должны нажать &lt;code>q&lt;/code> для выхода.&lt;/p>
&lt;p>Примеры:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>man ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>man whoami
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;code>sudo&lt;/code> Если вы знакомы с Windows и щелкаете правой кнопкой мыши по &lt;code>запустить от имени администратора&lt;/code>, мы можем думать о &lt;code>sudo&lt;/code> как об этом. Когда вы запускаете команду с помощью этой команды, вы будете запускать ее как «root», она запросит у вас пароль перед запуском команды.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для разовых работ, таких как установка приложений или служб, вам может понадобиться эта команда sudo, но что, если у вас есть несколько задач, и вы хотите какое-то время пожить как sudo? Здесь вы можете снова использовать &lt;code>sudo su&lt;/code> так же, как &lt;code>sudo&lt;/code>, после ввода вам будет предложено ввести пароль &lt;code>root&lt;/code>. В тестовой виртуальной машине, такой как наша, это нормально, но мне было бы очень сложно работать как «root» в течение длительного времени, могут произойти плохие вещи. Чтобы выйти из этого возвышенного положения, вы просто набираете «exit».&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я ловлю себя на том, что все время использую &lt;code>clear&lt;/code>. Команда &lt;code>clear&lt;/code> делает именно то, о чем говорит: она очищает экран от всех предыдущих команд, помещая курсор наверх и предоставляя вам красивое чистое рабочее пространство. Windows, это «cls» в .mdprompt.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Давайте теперь посмотрим на некоторые команды, с помощью которых мы можем создавать вещи в нашей системе, а затем визуализировать их в нашем терминале. Прежде всего, у нас есть &lt;code>mkdir&lt;/code>, это позволит нам создать папку в нашей системе. С помощью следующей команды мы можем создать папку в нашем домашнем каталоге с именем Day15 &lt;code>mkdir Day15&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>С помощью &lt;code>cd&lt;/code> это позволяет нам изменить каталог, поэтому для перехода в наш вновь созданный каталог мы можем сделать это с помощью вкладки &lt;code>cd Day15&lt;/code>, которая также может использоваться для автозаполнения доступного каталога. Если мы хотим вернуться к тому, с чего начали, мы можем использовать &lt;code>cd ..&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;code>rmdir&lt;/code> позволяет нам удалить каталог, если мы запустим &lt;code>rmdir Day15&lt;/code>, тогда папка будет удалена (обратите внимание, что это будет работать, только если у вас ничего нет в папке)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я уверен, что все мы делали это, когда мы переходили в глубины нашей файловой системы в каталог и не знали, где мы находимся. &lt;code>pwd&lt;/code> дает нам распечатку рабочего каталога, pwd, насколько это похоже на пароль, означает печать рабочего каталога.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы знаем, как создавать папки и каталоги, но как мы создаем файлы? Мы можем создавать файлы с помощью команды «touch», если бы мы запускали «touch Day15», это создало бы файл. Игнорируйте &lt;code>mkdir&lt;/code>, мы еще увидим это позже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;code>ls&lt;/code> Я могу поставить на это свой дом, вы будете использовать эту команду так много раз, что она выведет список всех файлов и папок в текущем каталоге. Давайте посмотрим, сможем ли мы увидеть тот файл, который мы только что создали.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как мы можем найти файлы в нашей системе Linux? &lt;code>locate&lt;/code> позволит нам искать в нашей файловой системе. Если мы используем &lt;code>locate Day15&lt;/code>, он сообщит о местонахождении файла. Бонусом является то, что если вы знаете, что файл существует, но вы получаете пустой результат, запустите &lt;code>sudo updatedb&lt;/code>, который проиндексирует все файлы в файловой системе, а затем снова запустите &lt;code>locate&lt;/code>. Если у вас нет &lt;code>locate&lt;/code>, вы можете установить его с помощью этой команды &lt;code>sudo apt install mlocate&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как насчет перемещения файлов из одного места в другое? &lt;code>mv&lt;/code> позволит вам перемещать ваши файлы. Пример &lt;code>mv Day15 90DaysOfDevOps&lt;/code> переместит ваш файл в папку 90DaysOfDevOps.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы переместили наш файл, но что, если мы хотим переименовать его сейчас во что-то другое? Мы можем сделать это снова с помощью команды &lt;code>mv&lt;/code>. Мы можем просто использовать &lt;code>mv Day15 day15&lt;/code>, чтобы перейти к верхнему регистру, или мы могли бы использовать &lt;code>mv day15 AnotherDay&lt;/code>, чтобы полностью изменить его, теперь используйте &lt;code>ls&lt;/code> для проверки файла.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хватит, теперь давайте избавимся (удалим) от нашего файла и, возможно, даже от нашего каталога, если он у нас есть. &lt;code>rm&lt;/code> просто &lt;code>rm AnotherDay&lt;/code> удалит наш файл. Мы также будем использовать &lt;code>rm -R&lt;/code>, который будет рекурсивно работать через папку или местоположение. Мы также можем использовать &lt;code>rm -R -f&lt;/code>, чтобы принудительно удалить все эти файлы. Спойлер, если вы запустите &lt;code>rm -R -f /&lt;/code>, добавьте к нему sudo, и вы можете попрощаться со своей системой &amp;hellip;.!&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы рассмотрели перемещение файлов, но что, если я просто хочу скопировать файлы из одной папки в другую, просто скажу, что это очень похоже на команду &lt;code>mv&lt;/code>, но мы используем &lt;code>cp&lt;/code>, чтобы теперь мы могли сказать &lt;code>cp Day15 Desktop&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы создали папки и файлы, но на самом деле мы не поместили никакого содержимого в нашу папку, мы можем добавить содержимое несколькими способами, но самый простой способ - это &lt;code>echo&lt;/code>, мы также можем использовать &lt;code>echo&lt;/code>, чтобы распечатать много вещей в нашей папке. терминал, я лично часто использую эхо для вывода системных переменных, чтобы узнать, установлены они или нет. мы можем использовать &lt;code>echo &amp;quot;Hello #90DaysOfDevOps&amp;quot; &amp;gt; Day15&lt;/code>, и это добавит это в наш файл. Мы также можем добавить к нашему файлу, используя &lt;code>echo &amp;quot;Commands are fun!&amp;quot; &amp;gt;&amp;gt; День15&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Еще одна из тех команд, которые вы будете часто использовать! &lt;code>кошка&lt;/code> сокращение от конкатенации. Мы можем использовать &lt;code>cat Day15&lt;/code>, чтобы увидеть содержимое внутри файла. Отлично подходит для быстрого чтения этих файлов конфигурации.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если у вас есть длинный сложный файл конфигурации, и вы хотите или вам нужно найти что-то быстрое в этом файле, а не читать каждую строку, тогда &lt;code>grep&lt;/code> вам в помощь, это позволит нам искать в вашем файле определенное слово, используя &lt;code>cat Day15 | grep &amp;quot;#90DaysOfDevOps&amp;quot;&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы похожи на меня и часто используете эту команду &lt;code>clear&lt;/code>, то вы можете пропустить некоторые из ранее запущенных команд, мы можем использовать «историю», чтобы узнать все те команды, которые мы запускали ранее. &lt;code>history -c&lt;/code> удалит историю.&lt;/p>
&lt;p>Когда вы запускаете &lt;code>history&lt;/code> и хотите выбрать конкретную команду, вы можете использовать &lt;code>!3&lt;/code>, чтобы выбрать 3-ю команду в списке.&lt;/p>
&lt;p>Вы также можете использовать &lt;code>history | grep &amp;quot;Команда&amp;quot;&lt;/code> для поиска чего-то определенного.&lt;/p>
&lt;p>На серверах для отслеживания времени выполнения команды может быть полезно добавлять дату и время к каждой команде в файле истории.&lt;/p>
&lt;p>Следующая системная переменная управляет этим поведением:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>HISTTIMEFORMAT=&amp;#34;%d-%m-%Y %T &amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вы можете легко добавить ее в свой bash_profile:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#4070a0">&amp;#39;export HISTTIMEFORMAT=&amp;#34;&lt;/span>&lt;span style="color:#70a0d0">%d&lt;/span>&lt;span style="color:#4070a0">-%m-%Y %T &amp;#34;&amp;#39;&lt;/span> &lt;span style="color:#666">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#666">~/.&lt;/span>bash_profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Можем увеличить размер файла для хранения истории:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#4070a0">&amp;#39;export HISTSIZE=100000&amp;#39;&lt;/span> &lt;span style="color:#666">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#666">~/.&lt;/span>bash_profile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#4070a0">&amp;#39;export HISTFILESIZE=10000000&amp;#39;&lt;/span> &lt;span style="color:#666">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#666">~/.&lt;/span>bash_profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нужно сменить пароль? &lt;code>passwd&lt;/code> позволит нам изменить наш пароль. Обратите внимание, что когда вы добавляете свой пароль таким образом, когда он скрыт, он не будет отображаться в &lt;code>history&lt;/code>, однако, если ваша команда имеет &lt;code>-p ПАРОЛЬ&lt;/code>, тогда он будет виден в вашей &lt;code>history&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем добавить новых пользователей в нашу систему, мы можем сделать это с помощью &lt;code>useradd&lt;/code>, мы должны добавить пользователя с помощью нашей команды &lt;code>sudo&lt;/code>, мы можем добавить нового пользователя с помощью &lt;code>sudo useradd NewUser&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для повторного создания группы требуется &lt;code>sudo&lt;/code>, и мы можем использовать &lt;code>sudo groupadd DevOps&lt;/code>, тогда, если мы хотим добавить нашего нового пользователя в эту группу, мы можем сделать это, запустив &lt;code>sudo usermod -a -G DevOps&lt;/code> &lt;code>-a&lt;/code> is add а &lt;code>-G&lt;/code> это имя группы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux24.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как добавить пользователей в группу &lt;code>sudo&lt;/code>? Это было бы очень редким случаем но для того, чтобы сделать это, выполним: &lt;code>usermod -a -G sudo NewUser&lt;/code>&lt;/p>
&lt;h3 id="права--permissions">Права / Permissions&lt;/h3>
&lt;p>read, write and execute - — это права доступа ко всем нашим файлам и папкам в нашей системе Linux.&lt;/p>
&lt;p>Полный список:&lt;/p>
&lt;ul>
&lt;li>0 = None &lt;code>---&lt;/code>&lt;/li>
&lt;li>1 = Execute only &lt;code>--X&lt;/code>&lt;/li>
&lt;li>2 = Write only &lt;code>-W-&lt;/code>&lt;/li>
&lt;li>3 = Write &amp;amp; Exectute &lt;code>-WX&lt;/code>&lt;/li>
&lt;li>4 = Read Only &lt;code>R--&lt;/code>&lt;/li>
&lt;li>5 = Read &amp;amp; Execute &lt;code>R-X&lt;/code>&lt;/li>
&lt;li>6 = Read &amp;amp; Write &lt;code>RW-&lt;/code>&lt;/li>
&lt;li>7 = Read, Write &amp;amp; Execute &lt;code>RWX&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Вы также увидите «777» или «775», и они представляют те же числа, что и в приведенном выше списке, но каждый из них представляет &lt;strong>User - Group - Everyone&lt;/strong>*&lt;/p>
&lt;p>Давайте посмотрим на наш файл. &lt;code>ls -al Day15&lt;/code> вы можете увидеть 3 группы, упомянутые выше, пользователь и группа могут читать и изменять (write), но все остальыне только читать (read).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux25.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем изменить это с помощью &lt;code>chmod&lt;/code>, вы можете сделать это, если вы также создаете двоичные файлы в своих системах, и вам нужно дать возможность запускать эти двоичные файлы. &lt;code>chmod 750 Day15&lt;/code> теперь запустите &lt;code>ls -la Day15&lt;/code>, если вы хотите запустить это для всей папки, вы можете использовать &lt;code>-R&lt;/code>, чтобы сделать это рекурсивно.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux26.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как насчет смены владельца файла? Мы можем использовать «chown» для этой операции, если мы хотим изменить владельца нашего «Day15» с пользователя «vagrant» на «NewUser», мы можем запустить «sudo chown NewUser Day15» снова, можно использовать «-R».&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux27.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Команда, с которой вы столкнетесь, это &lt;code>awk&lt;/code>, где она реально используется, когда у вас есть выходные данные, из которых вам нужны только определенные данные. например, запуская who, мы получаем строки с информацией, но, возможно, нам нужны только имена. Мы можем запустить &lt;code>кто | awk '{print $1}'&lt;/code>, чтобы получить только список этого первого столбца.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux28.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы хотите читать потоки данных из стандартного ввода, то генерирует и выполняет командные строки; это означает, что он может принимать вывод команды и передавать его в качестве аргумента другой команды. &lt;code>xargs&lt;/code> — полезный инструмент для этого случая использования. Если, например, мне нужен список всех учетных записей пользователей Linux в системе, которую я могу запустить. &lt;code>cut -d: -f1 &amp;lt; /etc/passwd&lt;/code> и получите длинный список, который мы видим ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux29.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если я хочу заархивировать этот список, я могу сделать это, используя &lt;code>xargs&lt;/code> в команде вроде этой &lt;code>cut -d: -f1 &amp;lt; /etc/passwd | sort | xargs&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux30.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я также не упомянул команду &lt;code>cut&lt;/code>, которая позволяет нам удалять разделы из каждой строки файла. Его можно использовать для вырезания частей строки по положению байта, символу и полю. Команда &lt;code>cut -d &amp;quot; &amp;quot; -f 2 list.txt&lt;/code> позволяет нам удалить первую букву, которая у нас есть, и просто отобразить наши числа. Есть так много комбинаций, которые можно использовать здесь с этой командой, я уверен, что потратил слишком много времени, пытаясь использовать эту команду, когда я мог бы быстрее извлечь данные вручную.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day15_Linux31.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Также обратите внимание, если вы вводите команду, и вы больше не довольны ею, и вы хотите начать снова, просто нажмите Ctrl + c, и это отменит эту строку и начнет все заново.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kPylihJRG70">Learn the Linux Fundamentals - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=VbEx7B_PTOE">Linux for hackers (don&amp;rsquo;t worry you don&amp;rsquo;t need be a hacker!)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Это уже довольно большой список, но я могу с уверенностью сказать, что я использую все эти команды в своей повседневной жизни, будь то администрирование серверов Linux или мой рабочий стол Linux, это очень легко, когда вы находитесь в Windows или macOS для навигации по пользовательскому интерфейсу, но в Linux Servers их нет, все делается через терминал.&lt;/p></description></item><item><title>16. Управление системой, файловой системой и хранилищем в Linux</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day16/</link><pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day16/</guid><description>&lt;h2 id="управление-системой-файловой-системой-и-хранилищем-в-linux">Управление системой, файловой системой и хранилищем в Linux&lt;/h2>
&lt;p>К этому времени мы кратко рассмотрели Linux и DevOps, а затем мы настроили нашу лабораторную среду с помощью vagant &lt;a href="../day14">14-й день)&lt;/a>, а затем коснулись небольшой части команд, которые будут в вашем ежедневном набор инструментов во время использования терминала - &lt;a href="../day15">(День 15)&lt;/a>.&lt;/p>
&lt;p>Сегодня мы рассмотрим три ключевые области обслуживания систем Linux с помощью обновлений, установки программного обеспечения. Поймем для чего используются системные папки, а также рассмотрим хранилище.&lt;/p>
&lt;h2 id="управление-ubuntu-и-программным-обеспечением">Управление Ubuntu и программным обеспечением&lt;/h2>
&lt;p>Первое, что мы собираемся рассмотреть, это то, как мы обновляем нашу операционную систему. Большинству из вас этот процесс знаком в ОС Windows и macOS, он немного отличается на рабочем столе и сервере Linux.&lt;/p>
&lt;p>Мы рассмотрим диспетчер пакетов apt - утилита, которую мы собираемся использовать на нашей виртуальной машине Ubuntu для обновлений и установки программного обеспечения.&lt;/p>
&lt;p>Как правило, по крайней мере на рабочих станциях разработчиков, мы запускаем эту команду, чтобы убедиться, что у нас есть последние доступные обновления из центральных репозиториев перед установкой любого программного обеспечения.&lt;/p>
&lt;p>&lt;code>sudo apt-get update&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас есть обновленная виртуальная машина Ubuntu с установленными последними обновлениями ОС. Теперь мы хотим установить здесь некоторое программное обеспечение.
Давайте выберем &lt;code>figlet&lt;/code> — программу, генерирующую текстовые баннеры.
Если мы введем «figlet» в наш терминал, вы увидите, что приложение не установлен в нашей системе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Однако из вышеизложенного вы увидите, что утилита &lt;code>apt&lt;/code> предлагает нам некотоыре опции установки &lt;code>apt install ...&lt;/code>, которые мы можем попробовать. Это потому, что в репозиториях по умолчанию есть программа figlet. Давайте попробуем &lt;code>sudo apt install figlet&lt;/code>
&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Теперь мы можем использовать наше приложение figlet
&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы хотим удалить эту или любую из наших установок программного обеспечения, мы также можем сделать это с помощью менеджера пакетов «apt».
&lt;code>sudo apt remove figlet&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Существуют сторонние репозитории, которые мы также можем добавить в нашу систему, те, к которым у нас есть доступ из коробки, являются репозиториями Ubuntu по умолчанию.&lt;/p>
&lt;p>Если бы, например, мы хотели установить vagrant на нашу виртуальную машину Ubuntu, мы не смогли бы сделать это прямо сейчас, и вы можете увидеть это ниже в первой введенной команде. Затем мы добавляем ключ к репозиторию HashiCorp, а затем добавляем репозиторий в нашу систему.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-add-repository &amp;#34;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Как только мы добавим репозиторий HashiCorp, мы можем запустить &lt;code>sudo apt install vagrant&lt;/code> и установить vagrant в нашей системе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Существует много вариантов, когда дело доходит до установки программного обеспечения, различных вариантов менеджеров пакетов, встроенных в Ubuntu, мы также могли бы использовать сохраненные темплейты (snapshots) для установки нашего программного обеспечения.&lt;/p>
&lt;p>Надеюсь, это даст вам представление о том, как управлять установками ОС и программного обеспечения в Linux.&lt;/p>
&lt;h2 id="файловая-система">Файловая система&lt;/h2>
&lt;p>Linux состоит из файлов конфигурации, и если вы хотите что-то изменить, вы меняете эти файлы конфигурации.&lt;/p>
&lt;p>В Windows у вас есть диск &lt;code>C:&lt;/code>, и это то, что мы считаем корнем. В Linux у нас есть &lt;code>/&lt;/code>, где мы собираемся найти важные папки в нашей системе Linux.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/bin&lt;/code> - Сокращенно от binary, папка bin — это место, где в основном находятся наши двоичные файлы, которые нужны вашей системе, исполняемые файлы и инструменты.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/boot&lt;/code> - Все файлы, необходимые вашей системе для загрузки. Как загрузиться и с какого диска загрузиться.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/dev&lt;/code> - Вы можете найти информацию об устройстве здесь, здесь вы найдете указатели на ваши диски &lt;code>sda&lt;/code>, которые будут вашим основным диском ОС.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/etc&lt;/code> - Вероятно, это самая важная папка в вашей системе Linux, где находится большинство ваших файлов конфигурации.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/home&lt;/code> - здесь вы найдете свои пользовательские папки и файлы. У нас есть пользовательская папка &lt;code>vagrant&lt;/code>. В ней вы найдете папки &amp;ldquo;Documents&amp;rdquo; и «Desktop», с которыми мы работали для раздела команд.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/lib&lt;/code> - Мы упомянули, что &lt;code>/bin&lt;/code> — это место, где находятся наши бинарные и исполняемые файлы, а &lt;code>/lib&lt;/code> — это место, где вы найдете разделяемые библиотеки для них.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/media&lt;/code> - Съемные носители. Флешки, диски и тд).&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/mnt&lt;/code> - Mount. Это временная точка монтирования. Подробнее мы расскажем в следующем разделе о хранении данных.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/opt&lt;/code> - Дополнительные пакеты программного обеспечения. Вы заметите, что здесь хранится некоторое программное обеспечение для vagrant и virtual box.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/proc&lt;/code> - Информация о ядре (kernel) и процессе (process), аналогичная &lt;code>/dev&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/root&lt;/code> - Домашняя папка для root. Чтобы получить доступ, вам нужно войти в эту папку с помощью sudo.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/run&lt;/code> - Каталог, содержащий PID файлы процессов, похожий на /var/run, но в отличие от него, он размещен в TMPFS, а поэтому после перезагрузки все файлы теряются. Сохраняет состояния текущих процессов&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/sbin&lt;/code> - System binaries. Так же как и /bin, содержит двоичные исполняемые файлы, которые доступны на ранних этапах загрузки, когда не примонтирован каталог /usr. Но здесь находятся программы, которые можно выполнять только с правами суперпользователя. Это разные утилиты для обслуживания системы. Например, iptables, reboot, fdisk, ifconfig,swapon и т д.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/tmp&lt;/code> - Содержит временные файлы, созданные системой, любыми программами или пользователями&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>/usr&lt;/code> - User Aplications. Если бы мы, как обычный пользователь, установили пакеты программного обеспечения, они обычно устанавливались бы в папку &lt;code>/usr/bin&lt;/code>. Здесь находятся исполняемые файлы, исходники программ, различные ресурсы приложений, картинки, музыка и документация&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/usr/bin&lt;/code> - Содержит исполняемые файлы различных программ, которые не нужны на первых этапах загрузки системы, например, музыкальные плееры, графические редакторы, браузеры и т.д.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>/var&lt;/code> - Variable. Переменные файлы. Наши приложения устанавливаются в папку &lt;code>bin&lt;/code>. Нам нужно где-то хранить все файлы журналов, это &lt;code>/var&lt;/code>. Здесь содержатся файлы системных журналов, различные кеши, базы данных и так далее&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux24.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>/var/log&lt;/code> - Logs. Здесь содержатся большинство файлов логов всех программ, установленных в операционной системе. У многих программ есть свои подкаталоги в этой папке, например, /var/log/apache - логи веб-сервера, /var/log/squid - файлы журналов кеширующего сервера squid. Если в системе что-либо сломалось, скорее всего, ответы вы найдете здесь.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/var/run&lt;/code> - Содержит файлы с PID процессов, которые могут быть использованы, для взаимодействия между программами. В отличие от каталога /run данные сохраняются после перезагрузки.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/sys&lt;/code> - System. Информация о системе. Назначение каталогов Linux из этой папки - получение информации о системе непосредственно от ядра. Это еще одна файловая система организуемая ядром и позволяющая просматривать и изменить многие параметры работы системы, например, работу swap, контролировать вентиляторы и многое другое.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="хранение">Хранение&lt;/h2>
&lt;p>Когда мы подходим к системе Linux или любой другой системе, мы можем захотеть узнать о доступных дисках и о том, сколько свободного места у нас есть на этих дисках. Следующие несколько команд помогут нам идентифицировать, использовать и управлять хранилищем.&lt;/p>
&lt;ul>
&lt;li>&lt;code>lsblk&lt;/code> Список заблокированных устройств. «sda» — это наш физический диск, а затем «sda1, sda2, sda3» — наши разделы на этом диске.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux25.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>&lt;code>df&lt;/code> дает нам немного больше информации об этих разделах, сколько всего, используется и доступно. Здесь вы можете использовать и другие флаги. Я обычно использую &lt;code>df -h&lt;/code>, чтобы дать нам &amp;ldquo;человеческий (понятный&amp;rdquo; (human) вывод данных.
&lt;p class="md__image">
&lt;img
src="../images/Day16_Linux26.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Если вы добавляли новый диск в свою систему, и это то же самое в Windows, вам нужно было бы отформатировать диск в управлении дисками, в терминале Linux вы можете сделать это с помощью &lt;code>sudo mkfs -t ext4 /dev/sdb&lt;/code> с sdb, относящимся к нашему недавно добавленному диску.&lt;/p>
&lt;p>Затем нам нужно будет смонтировать наш недавно отформатированный диск, чтобы его можно было использовать. Мы сделали бы это в нашей ранее упомянутой папке &lt;code>/mnt&lt;/code> и создали бы там каталог с &lt;code>sudo mkdir NewDisk&lt;/code>, а затем использовали бы &lt;code>sudo mount /dev/sdb newdisk&lt;/code> для монтирования диска в это место.&lt;/p>
&lt;p>Также возможно, что вам нужно будет безопасно отключить хранилище из вашей системы, а не просто вытащить его из конфигурации. Мы можем сделать это с помощью sudo umount /dev/sdb.&lt;/p>
&lt;p>Если вы не хотите размонтировать этот диск и собираетесь использовать этот диск для базы данных или какого-либо другого варианта постоянного использования, тогда вы хотите, чтобы он был там при перезагрузке системы. Чтобы это произошло, нам нужно добавить этот диск в наш файл конфигурации &lt;code>/etc/fstab&lt;/code>, чтобы он сохранялся, если вы этого не сделаете, его нельзя будет использовать при перезагрузке машины, и вам придется вручную выполнить описанное выше. процесс. Данные по-прежнему будут на диске, но они не будут автоматически монтироваться, пока вы не добавите конфигурацию в этот файл.&lt;/p>
&lt;p>После того, как вы отредактировали файл конфигурации &lt;code>fstab&lt;/code>, вы можете проверить свою работу с помощью &lt;code>sudo mount -a&lt;/code>, если ошибок нет, тогда ваши изменения теперь будут сохраняться при перезапусках.&lt;/p>
&lt;p>Мы расскажем, как вы будете редактировать файл с помощью текстового редактора в будущем сеансе.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://losst.ru/ctruktura-fajlovoj-sistemy-linux">Структура файловой системы Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kPylihJRG70">Learn the Linux Fundamentals - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=VbEx7B_PTOE">Linux for hackers (don&amp;rsquo;t worry you don&amp;rsquo;t need to be a hacker!)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>17. Текстовые редакторы Nano/Vim</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day17/</link><pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day17/</guid><description>&lt;h2 id="текстовые-редакторы-nano-и-vim">Текстовые редакторы nano и vim&lt;/h2>
&lt;p>Большинство систем Linux - сервера, и у них не будет графического интерфейса. Я также упомянул в прошлой статье, что Linux в основном состоит из файлов конфигурации, и для внесения изменений вам потребуется иметь возможность редактировать эти файлы конфигурации, чтобы изменить что-либо в системе.&lt;/p>
&lt;p>Существует множество вариантов, но я думаю, что мы должны рассмотреть, вероятно, два наиболее распространенных текстовых редактора терминала. Я использовал оба этих редактора, и для меня «nano» — это удобная кнопка, когда дело доходит до быстрых изменений, но у «vim» такой широкий набор возможностей.&lt;/p>
&lt;h3 id="nano">nano&lt;/h3>
&lt;ul>
&lt;li>Доступна не во всех системах.&lt;/li>
&lt;li>Отлично для начала.&lt;/li>
&lt;/ul>
&lt;p>Если вы запустите &lt;code>nano 90DaysOfDevOps.txt&lt;/code>, мы создадим новый файл, в котором ничего не будет, здесь мы можем добавить наш текст, и в окне внизу есть инструкции о том, что мы хотим сделать с этим файлом.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем нажать &lt;code>control x + enter&lt;/code>, а затем запустить &lt;code>ls&lt;/code>, теперь вы можете увидеть наш новый текстовый файл.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Можно запустить &lt;code>cat&lt;/code> для этого файла, чтобы прочитать наш файл. Затем мы можем использовать тот же &lt;code>nano 90DaysOfDevOps.txt&lt;/code>, чтобы добавить дополнительный текст или изменить ваш файл.&lt;/p>
&lt;p>Для меня nano очень удобен, когда дело доходит до внесения небольших изменений в файлы конфигурации.&lt;/p>
&lt;h3 id="vim">vim&lt;/h3>
&lt;p>Возможно, самый распространенный текстовый редактор.&lt;/p>
&lt;ul>
&lt;li>В значительной степени поддерживается в каждом дистрибутиве Linux.&lt;/li>
&lt;li>Невероятно мощный! Скорее всего, вы найдете полный 7-часовой курс, посвященный только vim.&lt;/li>
&lt;/ul>
&lt;p>Мы можем перейти в vim с помощью команды &lt;code>vim&lt;/code> или, если мы хотим отредактировать наш новый текстовый файл, мы могли бы запустить &lt;code>vim 90DaysOfDevOps.txt&lt;/code>, но сначала вы увидите отсутствие меню справки внизу.&lt;/p>
&lt;p>Первый вопрос может быть «Как мне выйти из vim?» это будет &lt;code>escape&lt;/code>, и если мы не внесли никаких изменений, то это будет &lt;code>:q&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы начинаете в обычном «normal» режиме, есть и другие режимы «command, normal, visual, insert», если мы хотим добавить текст, нам нужно будет переключиться с «normal» на «insert», нам нужно нажать «i», если вы добавили какой-то текст и хотели бы сохранить эти изменения, тогда вы нажмете escape, а затем &lt;code>:wq&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете подтвердить это с помощью команды &lt;code>cat&lt;/code>, чтобы убедиться, что вы сохранили эти изменения.&lt;/p>
&lt;p>В vim есть несколько крутых быстрых функций, которые позволяют очень быстро выполнять простые задачи, если вы знаете ярлыки, что само по себе является лекцией. Допустим, мы добавили список повторяющихся слов, и теперь нам нужно его изменить, может быть, это файл конфигурации, и мы повторяем сетевое имя, и теперь это изменилось, и мы хотим быстро изменить это. Я использую слово &amp;ldquo;Day&amp;rdquo; в этом примере.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы хотим заменить это слово на 90DaysOfDevOps, мы можем сделать это, нажав «esc» и набрав «:%s/Day/90DaysOfDevOps».
&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
В результате, когда вы нажимаете Enter, слово day заменяется на 90DaysOfDevOps.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day17_Linux8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Копировать и вставить стало для меня большим открытием. Копия не копия, а дерьмо. мы можем скопировать, используя &lt;code>yy&lt;/code> на клавиатуре в обычном режиме. &lt;code>p&lt;/code> вставьте в ту же строку, &lt;code>P&lt;/code> вставьте в новую строку.&lt;/p>
&lt;p>Вы также можете удалить эти строки, выбрав количество строк, которые вы хотите удалить, а затем &lt;code>dd&lt;/code>&lt;/p>
&lt;p>Также, вероятно, вам понадобится время для поиска файла, теперь мы можем использовать &lt;code>grep&lt;/code>, как упоминалось в предыдущем сеансе, но мы также можем использовать vim. мы можем использовать &lt;code>/word&lt;/code>, и это найдет первое совпадение, для перехода к следующему вы будете использовать клавишу &lt;code>n&lt;/code> и так далее.&lt;/p>
&lt;p>Для vim это даже не касается поверхности, самый большой совет, который я могу дать, — взяться за руки и использовать vim везде, где это возможно.&lt;/p>
&lt;p>Обычный вопрос на собеседовании: какой ваш любимый текстовый редактор в Linux, и я хотел бы убедиться, что у вас есть хотя бы эти знания об обоих, чтобы вы могли ответить: «Нано» — это нормально, потому что это просто. По крайней мере, вы показываете компетентность в понимании того, что такое текстовый редактор. Но потренируйтесь с ними, чтобы стать более опытным.&lt;/p>
&lt;p>Еще один указатель для навигации в vim, мы можем использовать «H, J, K, L», а также наши клавиши со стрелками.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://vim.rtorr.com/">Vim Cheat Sheet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=-txKSRn0qeA">Vim in 100 Seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IiwGbcd8S7I">Vim tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kPylihJRG70">Learn the Linux Fundamentals - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=VbEx7B_PTOE">Linux for hackers (don&amp;rsquo;t worry you don&amp;rsquo;t need to be a hacker!)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>18. Web Сервер и SSH</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day18/</link><pubDate>Sun, 08 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day18/</guid><description>&lt;h2 id="ssh">SSH&lt;/h2>
&lt;p>Как мы уже упоминали, вы, скорее всего, будете управлять множеством удаленных серверов Linux, поэтому вам необходимо убедиться, что ваше подключение к этим удаленным серверам безопасно. В этом разделе мы хотим рассказать о некоторых основах SSH (Secure Shell), которые должен знать каждый, и которые помогут вам с этим безопасным туннелем к вашим удаленным системам.&lt;/p>
&lt;ul>
&lt;li>Настройка соединения по SSH&lt;/li>
&lt;li>Передача файлов&lt;/li>
&lt;li>Создайте свой закрытый ключ&lt;/li>
&lt;/ul>
&lt;h3 id="введение-в-ssh">Введение в SSH&lt;/h3>
&lt;ul>
&lt;li>Безопасная оболочка (Secure Shell)&lt;/li>
&lt;li>Сетевой протокол (Networking Protocol)&lt;/li>
&lt;li>Обеспечивает безопасную связь&lt;/li>
&lt;li>Может защитить любой сетевой сервис&lt;/li>
&lt;li>Обычно используется для удаленного доступа из командной строки&lt;/li>
&lt;/ul>
&lt;p>В нашей среде, если вы следили за нами, мы уже использовали SSH, но все это было настроено и автоматизировано с помощью нашей конфигурации vagrant, поэтому нам нужно было только запустить &lt;code>vagrant ssh&lt;/code>, и мы получили доступ к нашей удаленной виртуальной машине.&lt;/p>
&lt;p>Если бы наша удаленная машина не находилась в той же системе, что и наша рабочая станция, и находилась бы в удаленном месте, возможно, в облачной системе или в центре обработки данных, к которому мы могли бы получить доступ только через Интернет, нам потребовался бы безопасный способ, чтобы получить доступ к системе для управления ею.&lt;/p>
&lt;p>SSH обеспечивает безопасный туннель между клиентом и сервером, поэтому злоумышленники ничего не могут перехватить.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На сервере есть служба SSH на стороне сервера, которая всегда работает и прослушивает определенный TCP-порт (22).&lt;/p>
&lt;p>Если мы используем наш клиент для подключения с правильными учетными данными или ключом SSH, мы получаем доступ к этому серверу.&lt;/p>
&lt;h3 id="добавление-bridged-network-adapter-в-нашу-систему">Добавление bridged network adapter в нашу систему&lt;/h3>
&lt;p>Чтобы мы могли использовать SSH с нашей виртуальной машиной, нам нужно добавить сетевой адаптер на нашу машину.&lt;/p>
&lt;p>Выключите виртуальную машину, щелкните ее правой кнопкой мыши в Virtual Box и выберите настройки. В новом окне выберите сеть.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь снова включите вашу машину, и теперь у вас будет IP-адрес на вашей локальной машине. Вы можете подтвердить это с помощью команды &lt;code>ip addr&lt;/code>.&lt;/p>
&lt;h3 id="проверка-работы-ssh-сервера">Проверка работы SSH-сервера&lt;/h3>
&lt;p>Мы знаем, что SSH уже настроен на нашей машине, поскольку мы использовали его с vagrant, но мы можем удостовериться, что сервер бежит, запустив&lt;/p>
&lt;p>&lt;code>sudo systemctl status ssh&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если в вашей системе нет SSH-сервера, вы можете установить его, введя эту команду &lt;code>sudo apt install openssh-server&lt;/code>&lt;/p>
&lt;p>Затем вы хотите убедиться, что наш SSH разрешен и брандмауэр работает. Мы можем сделать это с помощью &lt;code>sudo ufw allow ssh&lt;/code>. Это не требуется в нашей конфигурации, поскольку мы автоматизировали это с помощью нашего vagrant.&lt;/p>
&lt;h3 id="удаленный-доступ--пароль-ssh">Удаленный доступ — пароль SSH&lt;/h3>
&lt;p>Теперь, когда наш SSH-сервер прослушивает порт 22 для любых входящих запросов на подключение, и мы добавили &amp;ldquo;мост&amp;rdquo; (bridged networking), мы можем использовать &lt;a href="https://www.ssh.com/academy/ssh/putty/download">putty&lt;/a> или SSH-клиент на нашей локальной машине для подключения к нашей системе с помощью SSH.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем нажмите «Открыть», если вы впервые подключаетесь к этой системе через этот IP-адрес, вы получите это предупреждение. Мы знаем, что это наша система, поэтому вы можете выбрать «yes».&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем нам будет предложено ввести имя пользователя (vagrant) и пароль (пароль по умолчанию — vagrant). Ниже вы увидите, что теперь мы используем наш SSH-клиент (Putty) для подключения к нашей машине с использованием имени пользователя и пароля.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На этом этапе мы подключаемся к нашей виртуальной машине с нашего удаленного клиента и можем выполнять наши команды в нашей системе.&lt;/p>
&lt;h3 id="удаленный-доступ--ключ-ssh">Удаленный доступ — ключ SSH&lt;/h3>
&lt;p>Вышеупомянутый простой способ получить доступ к вашим системам, однако, по-прежнему зависит от имени пользователя и пароля, и если какой-либо злоумышленник получит доступ к этой информации, а также к общедоступному адресу или IP-адресу вашей системы, это может быть легко скомпрометировано. Здесь предпочтительны SSH-ключи.&lt;/p>
&lt;p>Ключи SSH означают, что мы предоставляем пару ключей, чтобы и клиент, и сервер знали, что это доверенное устройство.&lt;/p>
&lt;p>Создать ключ несложно. На нашем локальном компьютере (Windows) мы можем выполнить следующую команду: если у вас установлен ssh-клиент в любой системе, я полагаю, что эта же команда будет работать?&lt;/p>
&lt;p>&lt;code>ssh-keygen -t ed25519&lt;/code>&lt;/p>
&lt;p>Я не буду вдаваться в подробности того, что такое ed25519 и что означает здесь, но вы можете воспользоваться поиском, если хотите узнать больше о &lt;a href="https://en.wikipedia.org/wiki/EdDSA#Ed25519">криптографии&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На данный момент у нас есть созданный ключ SSH, хранящийся в &lt;code>C:\Users\micha/.ssh/&lt;/code>&lt;/p>
&lt;p>Но чтобы связать это с нашей виртуальной машиной Linux, нам нужно скопировать ключ. Мы можем сделать это, используя &lt;code>ssh-copy-id vagrant@192.168.169.135&lt;/code>.&lt;/p>
&lt;p>Я использовал &lt;a href="https://docs.microsoft.com/ru-ru/powershell/">PowerShell&lt;/a> для создания своих ключей на моем клиенте Windows, но здесь нет доступного &lt;code>ssh-copy-id&lt;/code>. Есть способы, которыми вы можете сделать это в Windows, и небольшой поиск в Интернете найдет вам альтернативу, но я просто использую git bash на своем компьютере с Windows, чтобы сделать копию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем вернуться к Powershell, чтобы проверить, что наше соединение теперь работает с нашими ключами SSH, и пароль не требуется.&lt;/p>
&lt;p>&lt;code>ssh vagrant@192.168.169.135&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>При необходимости мы могли бы защититься, используя кодовую фразу. Мы также могли бы сделать еще один шаг, заявив, что пароли вообще не нужны, что означает, что будут разрешены только пары ключей через SSH. Вы можете сделать это в следующем файле конфигурации.&lt;/p>
&lt;p>&lt;code>sudo nano /etc/ssh/sshd_config&lt;/code>&lt;/p>
&lt;p>здесь есть строка с &lt;code>PasswordAuthentication yes&lt;/code>, она будет закомментирована &lt;code>#&lt;/code>, вы должны раскомментировать и изменить yes на no. Затем вам нужно будет перезагрузить службу SSH с помощью «sudo systemctl reload sshd».&lt;/p>
&lt;h2 id="настройка-веб-сервера">Настройка веб-сервера&lt;/h2>
&lt;p>Не имеет прямого отношения к тому, что мы только что сделали с SSH выше, но я хотел рассмотрть, поскольку это снова еще одна задача, которая может показаться вам немного сложной, но на самом деле этого не должно быть.&lt;/p>
&lt;p>У нас есть виртуальная машина с Linux, и на данном этапе мы хотим добавить веб-сервер apache к нашей виртуальной машине, чтобы мы могли разместить на нем простой веб-сайт, который обслуживает мою домашнюю сеть. Обратите внимание, что эта веб-страница не будет доступна из Интернета, это можно сделать, но здесь это не рассматривается.&lt;/p>
&lt;p>Вы также можете увидеть, что это называется стеком LAMP.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>L&lt;/strong>inux Operating System&lt;/li>
&lt;li>&lt;strong>A&lt;/strong>pache Web Server&lt;/li>
&lt;li>&lt;strong>m&lt;/strong>ySQL database&lt;/li>
&lt;li>&lt;strong>P&lt;/strong>HP&lt;/li>
&lt;/ul>
&lt;h3 id="apache2">Apache2&lt;/h3>
&lt;p>Apache2 — это HTTP-сервер с открытым исходным кодом. Мы можем установить apache2 с помощью следующей команды.&lt;/p>
&lt;p>&lt;code>sudo apt-get install apache2&lt;/code>&lt;/p>
&lt;p>Чтобы убедиться, что apache2 установлен правильно, мы можем запустить &lt;code>sudo service apache2 restart&lt;/code>.&lt;/p>
&lt;p>Затем, используя сетевой адрес моста из пошагового руководства по SSH, откройте браузер и перейдите по этому адресу. Мой &lt;code>http://192.168.169.135/&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="mysql">mySQL&lt;/h3>
&lt;p>MySQL — это база данных, в которой мы будем хранить данные для нашего простого веб-сайта. Чтобы установить MySQL, мы должны использовать следующую команду &lt;code>sudo apt-get install mysql-server&lt;/code>&lt;/p>
&lt;h3 id="php">PHP&lt;/h3>
&lt;p>PHP — это серверный язык (server-side scripting language), мы будем использовать его для взаимодействия с базой данных MySQL. Окончательная установка заключается в установке PHP и зависимостей с помощью sudo apt-get install php libapache2-mod-php php-mysql.&lt;/p>
&lt;p>Первое изменение конфигурации, которое мы хотим внести в apache из коробки, — это использование index.html, и вместо этого мы хотим использовать index.php.&lt;/p>
&lt;p>Мы будем использовать sudo nano /etc/apache2/mods-enabled/dir.conf и переместим index.php в первый элемент списка.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Перезапустите службу apache2 &lt;code>sudo systemctl restart apache2&lt;/code>&lt;/p>
&lt;p>Теперь давайте подтвердим, что наша система правильно настроена для PHP. Создайте следующий файл с помощью этой команды, это откроет пустой файл в nano.&lt;/p>
&lt;p>&lt;code>sudo nano /var/www/html/90Days.php&lt;/code>&lt;/p>
&lt;p>затем скопируйте следующее и используйте Ctrl + x, чтобы выйти и сохранить файл.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>&amp;lt;?php
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>phpinfo();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>?&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь снова перейдите к IP-адресу виртуальной машины Linux с дополнительным 90Days.php в конце URL-адреса. &lt;code>http://192.168.169.135/90Days.php&lt;/code> вы должны увидеть что-то похожее на показанное ниже, если PHP настроен правильно.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day18_Linux12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="установка-wordpress">Установка WordPress&lt;/h3>
&lt;p>Я просмотрел тьюториал, чтобы установить WordPress в наш стек LAMP, некоторые команды показаны ниже, если они не показаны правильно в пошаговом руководстве [How to install wordpress on Ubuntu with LAMP](&lt;a href="https://blog.ssdnodes.com/blog/">https://blog.ssdnodes.com/blog/&lt;/a> как установить-wordpress-на-ubuntu-18-04-с-лампой-учебник/)&lt;/p>
&lt;p>&lt;code>sudo mysql -u root -p&lt;/code>&lt;/p>
&lt;p>&lt;code>CREATE DATABASE wordpressdb;&lt;/code>&lt;/p>
&lt;p>&lt;code>CREATE USER 'admin-user'@'localhost' IDENTIFIED BY 'password';&lt;/code>&lt;/p>
&lt;p>&lt;code>GRANT ALL PRIVILEGES ON wordpressdb.* TO 'admin-user'@'localhost';&lt;/code>&lt;/p>
&lt;p>&lt;code>FLUSH PRIVILEGES;&lt;/code>&lt;/p>
&lt;p>&lt;code>EXIT;&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo apt install php-curl php-gd php-mbstring php-xml php-xmlrpc php-soap php-intl php-zip&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo systemctl restart apache2&lt;/code>&lt;/p>
&lt;p>&lt;code>cd /var/www&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo curl -O https://wordpress.org/latest.tar.gz&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo tar -xvf latest.tar.gz&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo rm latest.tar.gz&lt;/code>&lt;/p>
&lt;p>На данный момент вы находитесь на шаге 4 в связанной статье, вам нужно будет выполнить шаги, чтобы убедиться, что для каталога WordPress установлены все правильные разрешения.&lt;/p>
&lt;p>Поскольку это только внутреннее действие, вам не нужно «генерировать ключи безопасности» на этом шаге. Перейдите к шагу 5, который меняет конфигурацию Apache на WordPress.&lt;/p>
&lt;p>Затем, если все настроено правильно, вы сможете получить доступ через свой внутренний сетевой адрес и запустить установку WordPress.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://remmina.org/">Client SSH GUI - Remmina&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=2QXkrLVsRmk">The Beginner&amp;rsquo;s guide to SSH&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=-txKSRn0qeA">Vim in 100 Seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IiwGbcd8S7I">Vim tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kPylihJRG70">Learn the Linux Fundamentals - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=VbEx7B_PTOE">Linux for hackers (don&amp;rsquo;t worry you don&amp;rsquo;t need to be a hacker!)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>19. Автоматизация задачи с помощью bash-скриптов</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day19/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day19/</guid><description>&lt;h2 id="автоматизация-задачи-с-помощью-bash-скриптов">Автоматизация задачи с помощью bash-скриптов&lt;/h2>
&lt;p>Оболочка, которую мы собираемся использовать сегодня, — это bash, но мы рассмотрим другую оболочку завтра, когда будем углубляться в ZSH.&lt;/p>
&lt;p>BASH - &lt;strong>B&lt;/strong>ourne &lt;strong>A&lt;/strong>gain &lt;strong>Sh&lt;/strong>ell («возрождённый» shell)&lt;/p>
&lt;p>Мы могли бы почти посвятить целую секцию из 7 дней написанию сценариев оболочки, как и языкам программирования. Bash дает нам возможность работать вместе с другими инструментами автоматизации для достижения цели.&lt;/p>
&lt;p>Я до сих пор разговариваю со многими людьми, которые настроили несколько сложных сценариев оболочки, чтобы что-то произошло, и они полагаются на этот сценарий для некоторых из наиболее важных вещей в бизнесе, я не говорю, что нам нужно понимать сценарии оболочки/bash. для этой цели это не путь. Но мы должны изучить сценарии оболочки/bash, чтобы работать вместе с нашими инструментами автоматизации и для специальных задач.&lt;/p>
&lt;p>Одним из примеров, который мы использовали, может быть VAGRANTFILE, который мы использовали для создания нашей виртуальной машины, мы могли бы обернуть его в простой сценарий bash, который удалял и обновлял его каждый понедельник утром, чтобы у нас была свежая копия нашей виртуальной машины Linux. каждую неделю мы могли бы также добавлять весь программный стек, который нам нужен, на указанную машину с Linux и так далее с помощью одного сценария bash.&lt;/p>
&lt;p>Я думаю, что еще одна вещь, которую я, по крайней мере, слышу, это то, что практические вопросы по скриптам становятся все более и более очевидными во всех интервью.&lt;/p>
&lt;h3 id="начало">Начало&lt;/h3>
&lt;p>Как и в случае со многим, что мы рассмотрим за все эти 90 дней, единственный реальный способ научиться — это делать. Практический опыт поможет впитать все это в вашу мышечную память.&lt;/p>
&lt;p>Прежде всего, нам понадобится текстовый редактор. В &lt;a href="../Day17">День 17&lt;/a> мы рассказали, наверное, о двух самых распространенных текстовых редакторах и немного о том, как их использовать.&lt;/p>
&lt;p>Давайте приступим прямо к делу и создадим наш первый сценарий оболочки.&lt;/p>
&lt;p>&lt;code>touch 90DaysOfDevOps.sh&lt;/code> - создает файл 90DaysOfDevOps.sh&lt;/p>
&lt;p>За ним следует &lt;code>nano 90DaysOfDevOps.sh&lt;/code>, это откроет наш новый пустой сценарий оболочки в nano. Опять же, вы можете выбрать другой текстовый редактор.&lt;/p>
&lt;p>Первая строка всех скриптов bash должна выглядеть примерно так: &lt;code>#!/usr/bin/bash&lt;/code>, это путь к вашему двоичному файлу bash.&lt;/p>
&lt;p>Однако вы должны проверить это в терминале, запустив &lt;code>which bash&lt;/code>, если вы не используете Ubuntu, вы также можете попробовать &lt;code>whereis bash&lt;/code> из терминала.&lt;/p>
&lt;p>Однако вы можете увидеть другие пути, перечисленные в уже созданных сценариях оболочки, которые могут включать:&lt;/p>
&lt;ul>
&lt;li>&lt;code>#!/bin/bash&lt;/code>&lt;/li>
&lt;li>&lt;code>#!/usr/bin/env bash&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>В следующей строке нашего скрипта я хотел бы добавить комментарий и добавить цель скрипта или хотя бы какую-то информацию обо мне. Вы можете сделать это, используя &lt;code>#&lt;/code>. Это позволяет нам комментировать определенные строки в нашем коде и предоставлять описания того, что будут делать следующие команды. Я считаю, что чем больше заметок, тем лучше для пользователя, особенно если вы делитесь этим.&lt;/p>
&lt;p>Иногда я использую figlet, программу, которую мы установили ранее в разделе Linux, для создания аски-арта, чтобы начать что-то в наших скриптах.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Все команды, которые мы использовали ранее в этом разделе Linux (&lt;a href="../Day15">День 15&lt;/a>) можно использовать здесь как простую команду для тестирования нашего скрипта.&lt;/p>
&lt;p>Давайте добавим в наш скрипт простой блок кода.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>mkdir 90DaysOfDevOps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd 90DaysOfDevOps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>touch Day19
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Затем вы можете сохранить это и выйти из текстового редактора. Если мы запустим наш скрипт с &lt;code>./90DaysOfDevOps.sh&lt;/code>, вы должны получить сообщение об отказе в разрешении. Вы можете проверить права доступа к этому файлу с помощью команды &lt;code>ls -la&lt;/code>, и вы увидите, что у нас нет прав на выполнение этого файла.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем изменить это, используя &lt;code>chmod +x 90DaysOfDevOps.sh&lt;/code>, и тогда вы увидите &lt;code>x&lt;/code>, означающий, что теперь мы можем запустить (execute) наш скрипт.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем снова запустить наш скрипт, используя &lt;code>./90DaysOfDevOps.sh&lt;/code> после того, как запуск скрипта создал новый каталог, перешел в этот каталог, а затем создал новый файл.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Довольно простые вещи, но вы можете начать понимать, как это можно использовать для вызова других инструментов, как часть способов сделать вашу жизнь проще и автоматизировать вещи.&lt;/p>
&lt;h3 id="переменные-условные-операторы">Переменные, условные операторы&lt;/h3>
&lt;p>Большая часть этого раздела на самом деле является повторением того, что мы рассмотрели, когда изучали Golang, но я думаю, что нам стоит углубиться в это снова.&lt;/p>
&lt;ul>
&lt;li>
&lt;h3 id="переменные">Переменные&lt;/h3>
&lt;/li>
&lt;/ul>
&lt;p>Переменные позволяют нам один раз определить конкретный повторяющийся термин, который используется в потенциально сложном сценарии.&lt;/p>
&lt;p>Чтобы добавить переменную, вы просто добавляете ее вот так на чистую строку в вашем скрипте.&lt;/p>
&lt;p>&lt;code>challenge=&amp;quot;90DaysOfDevOps&amp;quot;&lt;/code>&lt;/p>
&lt;p>Таким образом, когда и где мы используем &lt;code>$challenge&lt;/code> в нашем коде, если мы изменим переменную, это будет отражено повсюду.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы сейчас запустим наш скрипт &lt;code>sh&lt;/code>, вы увидите распечатку, которая была добавлена к нашему скрипту.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем запросить пользовательский ввод, который может установить наши переменные, используя следующее:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>echo &amp;#34;Enter your name&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>read name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Затем это определило бы ввод как переменную &lt;code>$name&lt;/code>. Затем мы могли бы использовать это позже.&lt;/p>
&lt;ul>
&lt;li>
&lt;h3 id="условные-операторы">Условные операторы&lt;/h3>
&lt;/li>
&lt;/ul>
&lt;p>Может быть, мы хотим узнать, кто участвует в нашем марафоне &amp;ldquo;90 дней&amp;rdquo; и сколько дней они прошли, мы можем определить это, используя условные выражения &lt;code>if&lt;/code> &lt;code>if-else&lt;/code> &lt;code>else-if&lt;/code>, это то, что мы определили ниже в нашем скрипте. .&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>&lt;span style="color:#60a0b0;font-style:italic"># ___ ___ ____ ___ __ ____ ___&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># / _ \ / _ \| _ \ __ _ _ _ ___ / _ \ / _| _ \ _____ __/ _ \ _ __ ___&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#| (_) | | | | | | |/ _` | | | / __| | | | |_| | | |/ _ \ \ / / | | | &amp;#39;_ \/ __|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># \__, | |_| | |_| | (_| | |_| \__ \ |_| | _| |_| | __/\ V /| |_| | |_) \__ \&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># /_/ \___/|____/ \__,_|\__, |___/\___/|_| |____/ \___| \_/ \___/| .__/|___/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># |___/ |_|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># This script is to demonstrate bash scripting!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Variables to be defined&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bb60d5">ChallengeName&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#60a0b0;font-style:italic">#90DaysOfDevOps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bb60d5">TotalDays&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># User Input&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Enter Your Name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">read&lt;/span> name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Welcome &lt;/span>&lt;span style="color:#bb60d5">$name&lt;/span>&lt;span style="color:#4070a0"> to &lt;/span>&lt;span style="color:#bb60d5">$ChallengeName&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;How Many Days of the &lt;/span>&lt;span style="color:#bb60d5">$ChallengeName&lt;/span>&lt;span style="color:#4070a0"> challenge have you completed?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">read&lt;/span> DaysCompleted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#666">[&lt;/span> &lt;span style="color:#bb60d5">$DaysCompleted&lt;/span> -eq &lt;span style="color:#40a070">90&lt;/span> &lt;span style="color:#666">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;You have finished, well done&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">elif&lt;/span> &lt;span style="color:#666">[&lt;/span> &lt;span style="color:#bb60d5">$DaysCompleted&lt;/span> -lt &lt;span style="color:#40a070">90&lt;/span> &lt;span style="color:#666">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Keep going you are doing great&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;You have entered the wrong amount of days&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вы также можете видеть из вышеприведенного, что мы проводим некоторые сравнения или сверяем значения друг с другом, чтобы перейти к следующему этапу. У нас есть разные варианты, которые стоит отметить.&lt;/p>
&lt;ul>
&lt;li>&lt;code>eq&lt;/code> - if the two values are equal will return TRUE&lt;/li>
&lt;li>&lt;code>ne&lt;/code> - if the two values are not equal will return TRUE&lt;/li>
&lt;li>&lt;code>gt&lt;/code> - if the first value is greater than the second value will return TRUE&lt;/li>
&lt;li>&lt;code>ge&lt;/code> - if the first value is greater than or equal to the second value will return TRUE&lt;/li>
&lt;li>&lt;code>lt&lt;/code> - if the first value is less than the second value will return TRUE&lt;/li>
&lt;li>&lt;code>le&lt;/code> - if the first value is less than or equal to the second value will return TRUE&lt;/li>
&lt;/ul>
&lt;p>Мы также можем использовать сценарии bash для получения информации о файлах и папках, это называется условиями файлов.&lt;/p>
&lt;ul>
&lt;li>&lt;code>-d file&lt;/code> True if the file is a directory&lt;/li>
&lt;li>&lt;code>-e file&lt;/code> True if the file exists&lt;/li>
&lt;li>&lt;code>-f file&lt;/code> True if the provided string is a file&lt;/li>
&lt;li>&lt;code>g file&lt;/code> True if the group id is set on a file&lt;/li>
&lt;li>&lt;code>-r file&lt;/code> True if the file is readable&lt;/li>
&lt;li>&lt;code>-s file&lt;/code> True if the file has a non-zero size&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>FILE=&amp;#34;90DaysOfDevOps.txt&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>if [ -f &amp;#34;$FILE&amp;#34; ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>then
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#34;$FILE is a file&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>else
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#34;$FILE is not a file&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
При условии, что этот файл все еще находится в нашем каталоге, мы должны вернуть первую команду &lt;code>echo&lt;/code>. Но если мы удалим этот файл, мы должны получить вторую команду &lt;code>echo&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Надеюсь, вы увидите, как это можно использовать для экономии времени при поиске в системе определенных элементов.&lt;/p>
&lt;p>Я нашел этот удивительный репозиторий на GitHub, в котором, кажется, бесконечное количество скриптов &lt;a href="https://github.com/HariSekhon/DevOps-Bash-tools/blob/master/README">DevOps Bash Tools&lt;/a>&lt;/p>
&lt;h3 id="пример">Пример&lt;/h3>
&lt;p>&lt;strong>Scenario&lt;/strong>: У нас есть наша компания под названием «90DaysOfDevOps», и мы работаем некоторое время, и теперь пришло время расширить команду с 1 человека до гораздо большего в ближайшие недели. Я пока единственный, кто знает процесс адаптации, поэтому мы хотим чтобы уменьшить это узкое место, автоматизировав некоторые из этих задач.&lt;/p>
&lt;p>&lt;strong>Requirements&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Пользователь может быть передан в качестве аргумента командной строки.&lt;/li>
&lt;li>Пользователь создается с именем аргумента командной строки.&lt;/li>
&lt;li>Пароль может быть проанализирован как аргумент командной строки.&lt;/li>
&lt;li>Пароль установлен для пользователя&lt;/li>
&lt;li>Отображается сообщение об успешном создании учетной записи.&lt;/li>
&lt;/ul>
&lt;p>Давайте начнем с создания нашего сценария оболочки с помощью &lt;code>touch create_user.sh&lt;/code>.&lt;/p>
&lt;p>Прежде чем мы двинемся дальше, давайте также создадим этот исполняемый файл, используя &lt;code>chmod +x create_user.sh&lt;/code>&lt;/p>
&lt;p>затем мы можем использовать &lt;code>nano create_user.sh&lt;/code>, чтобы начать редактирование нашего скрипта для сценария, который мы установили.&lt;/p>
&lt;p>Мы можем взглянуть на первое требование «Пользователь может быть передан в качестве аргумента командной строки», мы можем использовать следующее&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#! /usr/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A user can be passed in as a command line argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$1&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Идем далее и запускаем &lt;code>./create_user.sh Michael&lt;/code>, замените Michael своим именем при запуске скрипта.
&lt;p class="md__image">
&lt;img
src="Day19_Linux10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы можем выполнить второе требование: «Пользователь создается с именем аргумента командной строки», это можно сделать с помощью команды &lt;code>useradd&lt;/code>. Опция &lt;code>-m&lt;/code> предназначена для создания домашнего каталога пользователя как /home/username.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#! /usr/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A user can be passed in as a command line argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$1&lt;/span>&lt;span style="color:#4070a0"> user account being created.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A user is created with the name of command line argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo useradd -m &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$1&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Предупреждение: если вы не укажете имя учетной записи пользователя, произойдет ошибка, поскольку мы не заполнили переменную &lt;code>$1&lt;/code>&lt;/p>
&lt;p>Затем мы можем проверить, была ли создана эта учетная запись с помощью команды &lt;code>awk -F: '{print $1}' /etc/passwd&lt;/code>.&lt;/p>
&lt;p>&lt;a href="https://www.freecodecamp.org/news/the-linux-awk-command-linux-and-unix-usage-syntax-examples/">More about awk linux command&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Наше следующее требование: «Пароль может быть проанализирован как аргумент командной строки». Во-первых, мы никогда не собираемся делать это в продакшене, нам нужно проработать список требований в лаборатории, чтобы понять.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#! /usr/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A user can be passed in as a command line argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$1&lt;/span>&lt;span style="color:#4070a0"> user account being created.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A user is created with the name of command line argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo useradd -m &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$1&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A password can be parsed in as a command line argument.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo chpasswd &lt;span style="color:#666">&amp;lt;&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$1&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>:&lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$2&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Если мы затем запустим этот скрипт с двумя параметрами &lt;code>./create_user.sh пароль 90DaysOfDevOps&lt;/code>&lt;/p>
&lt;p>На изображении ниже вы можете видеть, что мы выполнили наш скрипт, он создал нашего пользователя и пароль, а затем мы вручную перешли к этому пользователю и подтвердили это с помощью команды whoami.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Последнее требование: «Отображается сообщение об успешном создании учетной записи». На самом деле у нас уже есть это в верхней строке нашего кода, и мы можем видеть на снимке экрана выше, что у нас есть «созданная учетная запись пользователя 90DaysOfDevOps». Это осталось от нашего тестирования с параметром &lt;code>$1&lt;/code>.&lt;/p>
&lt;p>Теперь этот сценарий можно использовать для быстрого подключения и настройки новых пользователей в наших системах Linux. Но, может быть, вместо того, чтобы некоторым историческим людям приходилось работать с этим, а затем получать новые имена пользователей или пароли для других людей, мы могли бы добавить некоторый пользовательский ввод, который мы ранее рассмотрели ранее, для захвата наших переменных.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#! /usr/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;What is your intended username?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">read&lt;/span> username
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;What is your password&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">read&lt;/span> password
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A user can be passed in as a command line argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">echo&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#bb60d5">$username&lt;/span>&lt;span style="color:#4070a0"> user account being created.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A user is created with the name of command line argument&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo useradd -m &lt;span style="color:#bb60d5">$username&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#A password can be parsed in as a command line argument.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo chpasswd &lt;span style="color:#666">&amp;lt;&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#bb60d5">$username&lt;/span>:&lt;span style="color:#bb60d5">$password&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Шаги стали более интерактивными,&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Просто чтобы закончить это, возможно, мы хотим вывести успешный вывод, чтобы сказать, что наша новая учетная запись пользователя завершена.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Одна вещь, которую я заметил, это то, что мы отображаем пароль на нашем входе, мы можем скрыть это, используя флаг &lt;code>-s&lt;/code> в строке кода &lt;code>read -s password&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="Day19_Linux16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы хотите удалить пользователя, которого вы создали для лабораторных целей, вы можете сделать это с помощью &lt;code>sudo userdel test_user&lt;/code>&lt;/p>
&lt;p>Еще раз, я не говорю, что это будет то, что вы будете создавать в своей повседневной жизни, но я думал, что это то, что подчеркнет гибкость того, для чего вы можете использовать сценарии оболочки.&lt;/p>
&lt;p>Подумайте о любых повторяющихся задачах, которые вы выполняете каждый день, неделю или месяц, и о том, как вы могли бы лучше автоматизировать это. Первым вариантом, вероятно, будет использование сценария bash, прежде чем переходить к более сложной территории.&lt;/p>
&lt;p>Я создал очень простой bash-файл, который помогает мне развернуть кластер Kubernetes с помощью minikube на моем локальном компьютере вместе со службами данных и Kasten K10, чтобы продемонстрировать требования и нужды, связанные с управлением данными. &lt;a href="https://github.com/MichaelCade/project_pace/blob/main/singlecluster_demo.sh">Project Pace&lt;/a>. Но я не счел уместным поднимать вопрос здесь, поскольку мы еще не рассмотрели Kubernetes.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=I4EWvMFj37g">Bash in 100 seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=TPRSJbtfK4M">Bash script with practical examples - Full Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://remmina.org/">Client SSH GUI - Remmina&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=2QXkrLVsRmk">The Beginner&amp;rsquo;s guide to SSH&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=-txKSRn0qeA">Vim in 100 Seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IiwGbcd8S7I">Vim tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kPylihJRG70">Learn the Linux Fundamentals - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=VbEx7B_PTOE">Linux for hackers (don&amp;rsquo;t worry you don&amp;rsquo;t need to be a hacker!)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>20. Настройка рабочей среды DevOps</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day20/</link><pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day20/</guid><description>&lt;h2 id="настройка-рабочей-среды">Настройка рабочей среды&lt;/h2>
&lt;p>Не путать с тем, как мы настраиваем серверы Linux таким образом. Я хочу продемонстрировать возможности выбора и гибкость, которые у нас есть при настройке настольного компьютера Linux.&lt;/p>
&lt;p>Я использую рабочий стол Linux уже почти год, и я настроил его именно так, как я хочу с точки зрения внешнего вида. Используя нашу виртуальную машину Ubuntu в Virtual Box, мы можем выполнить некоторые настройки, которые я сделал для своего ежедневного драйвера.&lt;/p>
&lt;p>Я собрал видео на YouTube, показывающее остальные, так как некоторые люди могли бы лучше следовать за ним:&lt;/p>
&lt;p>&lt;a href="https://youtu.be/jeEslAtHfKc">&lt;p class="md__image">
&lt;img
src="../images/Day20_YouTube.ru.png?v1"
id="zoom-default"
alt="Нажмите для доступа к видео YouTube"
loading="lazy"
/>
&lt;/p>
&lt;/a>&lt;/p>
&lt;p>Из коробки наша система будет выглядеть примерно так:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем увидеть нашу оболочку bash по умолчанию:
&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Многое из этого сводится к точечным файлам, которые мы рассмотрим в этой заключительной статье Linux из этой серии.&lt;/p>
&lt;h3 id="dotfiles">dotfiles&lt;/h3>
&lt;p>Сначала я хочу покопаться в dotfiles, я сказал в предыдущий день, что Linux состоит из файлов конфигурации. Эти файлы представляют собой файлы конфигурации для вашей системы Linux и приложений.&lt;/p>
&lt;p>Я также добавлю, что dotfiles используются не только для настройки и придания красивого вида вашему рабочему столу, но и для изменения и конфигурации dotfile, которые помогут вам повысить производительность.&lt;/p>
&lt;p>Как я уже упоминал, многие программы хранят свои конфигурации в этих точечных файлах. Эти файлы помогают управлять функциональностью.&lt;/p>
&lt;p>Каждый файл начинается с &lt;code>.&lt;/code> Вы, наверное, догадались, откуда взялось название?&lt;/p>
&lt;p>До сих пор мы использовали bash в качестве нашей оболочки, что означает, что у вас будут .bashrc и .bash_profile в нашей домашней папке. Ниже вы можете увидеть несколько точечных файлов, которые есть в нашей системе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Мы собираемся изменить нашу оболочку, поэтому позже мы увидим новый точечный файл конфигурации &lt;code>.zshrc&lt;/code>.&lt;/p>
&lt;p>Но теперь вы знаете, если мы ссылаемся на точечные файлы, вы знаете, что это файлы конфигурации. Мы можем использовать их для добавления псевдонимов в нашу командную строку, а также путей к различным местоположениям. Некоторые люди публикуют свои точечные файлы, чтобы они были общедоступными. Вы найдете мой здесь, на моем GitHub &lt;a href="https://github.com/MichaelCade/dotfiles">MichaelCade/dotfiles&lt;/a>, здесь вы найдете мой пользовательский файл &lt;code>.zshrc&lt;/code>, мой предпочтительный терминал - терминатор, который также имеет некоторые файлы конфигурации в папке, а затем также некоторые параметры фона.&lt;/p>
&lt;h3 id="zsh">ZSH&lt;/h3>
&lt;p>Как я упоминал во время наших взаимодействий, до сих пор мы использовали оболочку bash по умолчанию с Ubuntu. ZSH очень похож, но имеет некоторые преимущества перед bash.&lt;/p>
&lt;p>Zsh имеет такие функции, как интерактивное завершение с помощью табуляции, автоматический поиск файлов, интеграция с регулярными выражениями, расширенное сокращение для определения области действия команды и богатый движок тем.&lt;/p>
&lt;p>Мы можем использовать наш менеджер пакетов «apt», чтобы установить zsh в нашей системе. Давайте продолжим и запустим &lt;code>sudo apt install zsh&lt;/code> с нашего терминала bash. Я собираюсь сделать это из консоли виртуальной машины, а не через SSH.&lt;/p>
&lt;p>Когда команда установки завершена, вы можете запустить &lt;code>zsh&lt;/code> внутри вашего терминала, это запустит сценарий настройки оболочки.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я выбрал «1» на вопрос выше, и теперь у нас есть еще несколько вариантов.
&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Из этого меню видно, что мы можем внести некоторые готовые изменения, чтобы настроить ZSH в соответствии с нашими потребностями.&lt;/p>
&lt;p>Если вы выходите из мастера с &lt;code>0&lt;/code>, а затем используете &lt;code>ls -la | grep .zshrc&lt;/code> вы должны увидеть, что у нас есть новый файл конфигурации.&lt;/p>
&lt;p>Теперь мы хотим сделать zsh нашей оболочкой по умолчанию каждый раз, когда мы открываем наш терминал, мы можем сделать это, выполнив следующую команду, чтобы изменить нашу оболочку &lt;code>chsh -s $(which zsh)&lt;/code>, нам затем нужно выйти из системы и снова войти в нее для грядут изменения.&lt;/p>
&lt;p>Когда вы снова войдете в систему и откроете терминал, он должен выглядеть примерно так. Мы также можем подтвердить, что наша оболочка теперь изменена, запустив &lt;code>which $SHELL&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Обычно я выполняю этот шаг на каждом рабочем столе Ubuntu, который я запускаю, и в целом, не заходя дальше, обнаруживаю, что оболочка &lt;code>zsh&lt;/code> немного быстрее, чем bash.&lt;/p>
&lt;h3 id="ohmyzsh">OhMyZSH&lt;/h3>
&lt;p>Далее мы хотим немного улучшить внешний вид, а также добавить некоторые функции, которые помогут нам перемещаться по терминалу.&lt;/p>
&lt;p>OhMyZSH — это бесплатная платформа с открытым исходным кодом для управления вашей конфигурацией zsh. Существует множество плагинов, тем и других вещей, которые просто делают взаимодействие с оболочкой zsh намного приятнее.&lt;/p>
&lt;p>Вы можете узнать больше о &lt;a href="https://ohmyz.sh/">ohmyzsh&lt;/a>&lt;/p>
&lt;p>Давайте установим Oh My ZSH, у нас есть несколько вариантов с &lt;code>curl&lt;/code>, &lt;code>wget&lt;/code> или &lt;code>fetch&lt;/code>, у нас есть первые два, доступные в нашей системе, но я начну с &lt;code>curl&lt;/code>.&lt;/p>
&lt;p>&lt;code>sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;&lt;/code>&lt;/p>
&lt;p>Когда вы запустите приведенную выше команду, вы должны увидеть вывод, как показано ниже.
&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем перейти к добавлению темы для нашего опыта, в комплекте с Oh My ZSH более 100, но я выбираю для всех своих приложений, и все это тема Дракулы.&lt;/p>
&lt;p>Я также хочу добавить, что эти два плагина являются обязательными при использовании Oh My ZSH.&lt;/p>
&lt;p>&lt;code>git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions&lt;/code>&lt;/p>
&lt;p>&lt;code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting&lt;/code>&lt;/p>
&lt;p>&lt;code>nano ~/.zshrc&lt;/code>&lt;/p>
&lt;p>отредактируйте &lt;code>plugins&lt;/code>, чтобы включить &lt;code>plugins=(git zsh-autosuggestions zsh-syntax-highlighting)&lt;/code>&lt;/p>
&lt;h2 id="расширения-gnome">Расширения Gnome&lt;/h2>
&lt;p>Я также использую расширения Gnome, и в частности список ниже&lt;/p>
&lt;p>&lt;a href="https://extensions.gnome.org">Gnome extensions&lt;/a>&lt;/p>
&lt;pre>&lt;code>- Caffeine
- CPU Power Manager
- Dash to Dock
- Desktop Icons
- User Themes
&lt;/code>&lt;/pre>
&lt;h2 id="установка-программ">Установка программ&lt;/h2>
&lt;p>Краткий список программ, которые я устанавливаю на машину с помощью &lt;code>apt&lt;/code>&lt;/p>
&lt;pre>&lt;code>- VSCode
- azure-cli
- containerd.io
- docker
- docker-ce
- google-cloud-sdk
- insomnia
- packer
- terminator
- terraform
- vagrant
&lt;/code>&lt;/pre>
&lt;h3 id="тема-dracula">тема Dracula&lt;/h3>
&lt;p>Этот сайт - единственная тема, которую я использую в данный момент. Выглядит четким, чистым и все выглядит отлично. &lt;a href="https://draculatheme.com/">Dracula Theme&lt;/a>&lt;/p>
&lt;p>По ссылке выше можем поискать zsh на сайте и найдем как минимум два варианта.&lt;/p>
&lt;p>Следуйте приведенным инструкциям, чтобы выполнить установку вручную или с помощью git. Затем вам нужно будет, наконец, отредактировать файл конфигурации &lt;code>.zshrc&lt;/code>, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day20_Linux8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Далее нам понадобится &lt;a href="https://draculatheme.com/gnome-terminal">тема Gnome Terminal Dracula&lt;/a> со всеми инструкциями&lt;/p>
&lt;p>На самом деле мне потребовалось бы много времени, чтобы задокументировать каждый шаг, поэтому я создал пошаговое видео процесса. (&lt;strong>Нажмите на изображение ниже&lt;/strong>)&lt;/p>
&lt;p>&lt;a href="https://youtu.be/jeEslAtHfKc">&lt;p class="md__image">
&lt;img
src="../images/Day20_YouTube.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/a>&lt;/p>
&lt;p>Если вы дочитали до этого момента, значит, мы закончили наш раздел Linux в #90DaysOfDevOps. Я снова открыт для отзывов и дополнений к ресурсам здесь.&lt;/p>
&lt;p>Я также подумал, что было проще показать вам многие шаги с помощью видео, чем записывать их здесь, что вы думаете об этом? У меня есть цель вернуться к этим дням и, где это возможно, создать видео-пошаговые руководства, чтобы добавить и, возможно, лучше объяснить и показать некоторые вещи, которые мы рассмотрели. Что вы думаете?&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=I4EWvMFj37g">Bash in 100 seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=TPRSJbtfK4M">Bash script with practical examples - Full Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://remmina.org/">Client SSH GUI - Remmina&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=2QXkrLVsRmk">The Beginner&amp;rsquo;s guide to SSH&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=-txKSRn0qeA">Vim in 100 Seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IiwGbcd8S7I">Vim tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kPylihJRG70">Learn the Linux Fundamentals - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=VbEx7B_PTOE">Linux for hackers (don&amp;rsquo;t worry you don&amp;rsquo;t need to be a hacker!)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Завтра мы начинаем наши 7 дней погружения в сетевое взаимодействие, мы будем стараться получить базовые знания и понимание сетевого взаимодействия (Networking) в DevOps.&lt;/p></description></item><item><title>21. DevOps настройка сети</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day21/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day21/</guid><description>&lt;h2 id="общая-картина-devops-и-сеть">Общая картина: DevOps и Сеть&lt;/h2>
&lt;p>Добро пожаловать в День 21! Мы собираемся заняться сетевыми технологиями в течение следующих 7 дней. Сеть и DevOps являются всеобъемлющей темой, но нам также необходимо изучить некоторые основы сетевых технологий.&lt;/p>
&lt;p>В конечном счете, как мы уже говорили ранее, DevOps — это культура и изменение процессов в ваших организациях. Как мы уже говорили, это могут быть виртуальные машины, контейнеры, Kubernetes, но это также может быть и сеть. Если мы используем эти принципы DevOps для нашей инфраструктуры, которая чтобы включить сеть более точно с точки зрения DevOps, вам также необходимо знать о сети, а также о различных топологиях, сетевых инструментах и ​​стеках, которые у нас есть.&lt;/p>
&lt;p>Я бы сказал, что наши сетевые устройства должны быть настроены с использованием инфраструктуры как кода, и все должно быть автоматизировано, как и наши виртуальные машины, но для этого мы должны хорошо понимать, что мы автоматизируем.&lt;/p>
&lt;h3 id="что-такое-netdevops--сетевой-devops">Что такое NetDevOps | Сетевой DevOps?&lt;/h3>
&lt;p>Вы также можете услышать термины Network DevOps или NetDevOps. Возможно, вы уже являетесь сетевым инженером (network engineer) и хорошо разбираетесь в сетевых компонентах в инфраструктуре, вы понимаете элементы, используемые в сети, такие как DHCP, DNS, NAT и т. д. и т. д. У вас также будет хорошее понимание аппаратных или программно-определяемых сетей. опции, коммутаторы, маршрутизаторы и т.д. и т.п.&lt;/p>
&lt;p>Но если вы не сетевой инженер, то нам, вероятно, необходимо получить базовые знания по всем направлениям в некоторых из этих областей, чтобы мы могли понять конечную цель Network DevOps.&lt;/p>
&lt;p>Но в отношении этих терминов мы можем думать о NetDevOps или Network DevOps как о применении принципов и практик DevOps к сети, применении инструментов управления версиями и автоматизации к созданию, тестированию, мониторингу и развертыванию сети.&lt;/p>
&lt;p>Если мы думаем о сетевой DevOps как о необходимости автоматизации, мы упоминали ранее о том, что DevOps разрушает разрозненность между командами. Если сетевые команды не перейдут на аналогичную модель и процесс, они станут узким местом или даже полным провалом.&lt;/p>
&lt;p>Использование принципов автоматизации подготовки, настройки, тестирования, контроля версий и развертывания — отличное начало. Автоматизация в целом обеспечит скорость развертывания, стабильность сетевой инфраструктуры и последовательное улучшение, а также процесс, который будет совместно использоваться в нескольких средах после их тестирования. Например, полностью протестированная сетевая политика, которая была полностью протестирована в одной среде, может быть быстро использована в другом месте из-за характера этого в коде, а не в процессе, созданном вручную, как это могло быть раньше.
Действительно хорошую точку зрения и схему этого мышления можно найти здесь. &lt;a href="https://www.thousandeyes.com/learning/techtorials/network-devops">Сетевой DevOps&lt;/a>&lt;/p>
&lt;h2 id="networking---основы">Networking - основы&lt;/h2>
&lt;p>Давайте для начала забудем о стороне DevOps, и теперь нам нужно очень кратко взглянуть на некоторые основы работы в сети.&lt;/p>
&lt;h3 id="сетевые-устройства">Сетевые устройства&lt;/h3>
&lt;p>&lt;strong>Host&lt;/strong> — это любые устройства, которые отправляют или получают трафик.
&lt;p class="md__image">
&lt;img
src="../images/Day21_Networking1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>IP Address&lt;/strong> &amp;ldquo;определение&amp;rdquo; каждого хоста. (адрес)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day21_Networking2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>Network&lt;/strong> — (Сеть) это то, что транспортирует трафик между хостами. Если бы у нас не было сетей, было бы много ручного перемещения данных!
Логическая группа хостов, для которых требуется аналогичное подключение.
&lt;p class="md__image">
&lt;img
src="../images/Day21_Networking3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>Switches&lt;/strong> (Коммутаторы) облегчают связь &lt;em>&lt;strong>внутри&lt;/strong>&lt;/em> сети. Коммутатор пересылает пакеты данных между хостами. Коммутатор отправляет пакеты напрямую хостам.&lt;/p>
&lt;ul>
&lt;li>Сеть: группа хостов, которым требуется одинаковое подключение.&lt;/li>
&lt;li>Хосты в сети используют одно и то же пространство IP-адресов.
&lt;p class="md__image">
&lt;img
src="../images/Day21_Networking4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;strong>Маршрутизатор&lt;/strong> (Router) облегчает связь между сетями. Если мы сказали ранее, что коммутатор следит за связью внутри сети, маршрутизатор позволяет нам объединить эти сети или, по крайней мере, предоставить им доступ друг к другу, если это разрешено.&lt;/li>
&lt;/ul>
&lt;p>Маршрутизатор может обеспечить точку контроля трафика (безопасность, фильтрация, перенаправление). Все больше и больше коммутаторов теперь также предоставляют некоторые из этих функций.&lt;/p>
&lt;p>Маршрутизаторы узнают, к каким сетям они подключены. Это известно как маршруты, таблица маршрутизации — это все сети, о которых знает маршрутизатор.&lt;/p>
&lt;p>Маршрутизатор имеет IP-адрес в сетях, к которым он подключен. Этот IP-адрес также будет использоваться каждым хостом за пределами их локальной сети, также известной как шлюз.&lt;/p>
&lt;p>Маршрутизаторы также создают иерархию в сетях, о которой я упоминал ранее.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day21_Networking5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="коммутаторы-и-маршрутизаторы-switches-vs-routers-">Коммутаторы и маршрутизаторы (Switches vs Routers )&lt;/h2>
&lt;p>&lt;strong>Маршрутизация&lt;/strong> – это процесс перемещения данных между сетями.&lt;/p>
&lt;ul>
&lt;li>Маршрутизатор — это устройство, основной задачей которого является маршрутизация.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Коммутация&lt;/strong> — это процесс перемещения данных в сети.&lt;/p>
&lt;ul>
&lt;li>Коммутатор — это устройство, основное назначение которого — коммутация.&lt;/li>
&lt;/ul>
&lt;p>Это во многом базовый обзор устройств, поскольку мы знаем, что существует множество различных сетевых устройств, таких как:&lt;/p>
&lt;ul>
&lt;li>Access Points&lt;/li>
&lt;li>Firewalls&lt;/li>
&lt;li>Load Balancers&lt;/li>
&lt;li>Layer 3 Switches&lt;/li>
&lt;li>IDS / IPS&lt;/li>
&lt;li>Proxies&lt;/li>
&lt;li>Virtual Switches&lt;/li>
&lt;li>Virtual Routers&lt;/li>
&lt;/ul>
&lt;p>Хотя все эти устройства будут выполнять маршрутизацию и/или коммутацию.&lt;/p>
&lt;p>В течение следующих нескольких дней мы собираемся узнать немного больше об этом списке.&lt;/p>
&lt;ul>
&lt;li>OSI Model&lt;/li>
&lt;li>Network Protocols&lt;/li>
&lt;li>DNS (Domain Name System)&lt;/li>
&lt;li>NAT&lt;/li>
&lt;li>DHCP&lt;/li>
&lt;li>Subnets&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=IPvYjXCsTg8">Computer Networking full course&lt;/a>&lt;/p></description></item><item><title>22. Открытая сетевая модель OSI</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day22/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day22/</guid><description>&lt;h2 id="модель-osi--7-уровней">Модель OSI — 7 уровней&lt;/h2>
&lt;p>Общая цель сети как отрасли состоит в том, чтобы позволить двум хостам обмениваться данными. Если я хочу передать данные от одного хоста к другому хосту, мне нужно будет что-то подключить к этому хосту, перейти к другому хосту, подключить его к первому хосту.&lt;/p>
&lt;p>Сеть позволяет нам автоматизировать это, позволяя хосту автоматически обмениваться данными по сети, и для этого эти хосты должны следовать набору правил.&lt;/p>
&lt;p>Это ничем не отличается от любого другого языка. У английского есть набор правил, которым должны следовать два носителя английского языка. У испанского есть свой собственный набор правил.&lt;/p>
&lt;p>Правила организации сети разделены на семь разных уровней, и эти уровни известны как модель OSI.&lt;/p>
&lt;h3 id="введение-в-модель-osi">Введение в модель OSI&lt;/h3>
&lt;p>Модель OSI (модель взаимодействия открытых систем)/(Open Systems Interconnection Model) — это структура, используемая для описания функций сетевой системы. Модель OSI характеризует вычислительные функции в виде универсального набора правил и требований для обеспечения функциональной совместимости между различными продуктами и программным обеспечением. В эталонной модели OSI обмен данными между вычислительной системой разделен на семь различных уровней абстракции: &lt;strong>физический, канальный, сетевой, транспортный, сеансовый, презентационный и прикладной&lt;/strong> (&lt;strong>Physical, Data Link, Network, Transport, Session, Presentation, Application&lt;/strong>).
&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="физический">Физический&lt;/h3>
&lt;p>Уровень 1 в модели OSI, известный как физический, предполагает возможность передачи данных с одного хоста на другой с помощью средств, будь то физический кабель или мы также можем рассмотреть Wi-Fi на этом уровне. Мы также можем увидеть здесь более устаревшее оборудование вокруг концентраторов и повторителей для передачи данных с одного хоста на другой.
&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="канал-передачи-данных">Канал передачи данных&lt;/h3>
&lt;p>Уровень 2, канал передачи данных обеспечивает передачу данных от узла к узлу, где данные упакованы в кадры. Существует также уровень исправления ошибок, которые могли возникнуть на физическом уровне. Здесь мы также вводим или впервые видим MAC-адреса.&lt;/p>
&lt;p>Здесь мы видим первое упоминание о коммутаторах, о которых мы рассказали в первый день нашей работы с сетью &lt;a href="../day21">День 21&lt;/a>
&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="сеть">Сеть&lt;/h3>
&lt;p>Вы, вероятно, слышали термин «коммутаторы уровня 3» или «коммутаторы уровня 2». В нашей модели OSI уровень 3. Цель сети — прямая(end to end) доставка, именно здесь мы видим наши IP-адреса, также упомянутые в обзоре первого дня.&lt;/p>
&lt;p>Маршрутизаторы и хосты существуют на уровне 3, помните, что маршрутизатор — это возможность маршрутизации между несколькими сетями. Все, что имеет IP, может считаться уровнем 3.
&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Так зачем же нам нужны схемы адресации как на уровне 2, так и на уровне 3? (MAC-адреса и IP-адреса)&lt;/p>
&lt;p>Если мы подумаем о передаче данных с одного хоста на другой, каждый хост имеет IP-адрес, но между ними есть несколько коммутаторов и маршрутизаторов. Каждое из устройств имеет этот MAC-адрес уровня 2.&lt;/p>
&lt;p>MAC-адрес уровня 2 будет передаваться только от хоста к коммутатору/маршрутизатору, он ориентирован на переходы, где IP-адреса уровня 3 будут оставаться с этим пакетом данных, пока он не достигнет своего конечного хоста. (Концы с концами)&lt;/p>
&lt;p>IP-адреса — уровень 3 = сквозная доставка&lt;/p>
&lt;p>MAC-адреса — уровень 2 = доставка между переходами&lt;/p>
&lt;p>Теперь есть сетевой протокол, который мы рассмотрим, но не сегодня, называемый ARP (протокол разрешения адресов), который связывает наши адреса Layer3 и Layer2.&lt;/p>
&lt;h3 id="транспорт">Транспорт&lt;/h3>
&lt;p>Предоставление услуг между услугами, уровень 4 предназначен для различения потоков данных. Точно так же, как уровни 3 и 2 имели свои схемы адресации, на уровне 4 у нас есть порты.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="сессия-презентация-приложение">Сессия, Презентация, Приложение&lt;/h3>
&lt;p>Различие между слоями 5, 6, 7 немного расплывчато&lt;/p>
&lt;p>Стоит взглянуть на &lt;a href="https://www.geeksforgeeks.org/tcp-ip-model/">IP-модель TCP&lt;/a>, чтобы получить более свежее представление.&lt;/p>
&lt;p>Давайте теперь попробуем объяснить, что на самом деле происходит, когда хосты общаются друг с другом, используя этот сетевой стек. На одном хосте есть приложение, которое будет генерировать данные, предназначенные для отправки на другой хост.&lt;/p>
&lt;p>Исходный хост будет проходить так называемый процесс инкапсуляции. Эти данные будут сначала отправлены на уровень 4.&lt;/p>
&lt;p>Уровень 4 добавит заголовок к этим данным, что может облегчить задачу уровня 4, которая заключается в доставке услуг. Это будет порт, использующий либо TCP, либо UDP. Он также будет включать исходный порт и порт назначения.&lt;/p>
&lt;p>Это также может быть известно как сегмент (данные и порт).&lt;/p>
&lt;p>Этот сегмент будет передан по стеку osi на уровень 3, сетевой уровень, сетевой уровень добавит к этим данным еще один заголовок.
Этот заголовок будет способствовать цели уровня 3, который является сквозной доставкой, что означает, что в этом заголовке у вас будет IP-адрес источника и IP-адрес назначения, заголовок плюс данные также могут называться пакетом.&lt;/p>
&lt;p>Затем уровень 3 возьмет этот пакет и передаст его уровню 2, уровень 2 еще раз добавит еще один заголовок к этим данным для достижения цели уровня 2 по доставке переходов, что означает, что этот заголовок будет включать в себя MAC-адреса источника и получателя.
Это называется кадром, когда у вас есть заголовок и данные уровня 2.&lt;/p>
&lt;p>Затем этот кадр преобразуется в единицы и нули и отправляется по физическому кабелю уровня 1 или Wi-Fi.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Выше я упомянул названия для каждого уровня заголовка и данных, но решил нарисовать и это.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Очевидно, что приложение, отправляющее данные, отправляется куда-то, поэтому получение происходит в обратном порядке, чтобы получить эту резервную копию в стеке и на принимающем хосте.
&lt;p class="md__image">
&lt;img
src="../images/Day22_Networking8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IPvYjXCsTg8">Computer Networking full course&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.practicalnetworking.net/">Practical Networking&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>23. Протоколы сети</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day23/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day23/</guid><description>&lt;h2 id="протоколы-сети">Протоколы сети&lt;/h2>
&lt;p>Набор правил и сообщений, образующих стандарт.&lt;/p>
&lt;ul>
&lt;li>ARP - Address Resolution Protocol - протокол разрешения адресов&lt;/li>
&lt;/ul>
&lt;p>Если вы хотите по-настоящему разобраться в ARP, вы можете прочитать Internet Standard здесь &lt;a href="https://datatracker.ietf.org/doc/html/rfc826">RFC 826&lt;/a>&lt;/p>
&lt;p>ARP соединяет IP-адреса с фиксированными физическими адресами машин, также известными как MAC-адреса, в сети уровня 2.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>FTP - File Transfer Protocol - протокол передачи файлов&lt;/li>
&lt;/ul>
&lt;p>Позволяет передавать файлы из источника в место назначения. Как правило, этот процесс аутентифицируется, но при настройке можно использовать анонимный доступ. Теперь вы будете чаще видеть FTPS, который обеспечивает подключение SSL/TLS к FTP-серверам от клиента для повышения безопасности. Этот протокол можно найти на прикладном уровне модели OSI.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>SMTP - Simple Mail Transfer Protocol - протокол передачи почты&lt;/li>
&lt;/ul>
&lt;p>Почтовые серверы, используемые для передачи электронной почты, используют SMTP для отправки и получения почтовых сообщений. Вы по-прежнему обнаружите, что даже с Microsoft 365 протокол SMTP используется для той же цели.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>HTTP - Hyper Text Transfer Protocol - Протокол передачи гипертекста&lt;/li>
&lt;/ul>
&lt;p>HTTP является основой Интернета и просмотра контента. Дает нам возможность легко получить доступ к нашим любимым веб-сайтам. HTTP по-прежнему широко используется, но HTTPS используется или должен использоваться на большинстве ваших любимых сайтов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>SSL - Secure Sockets Layer | TLS - Transport Layer Security - Уровень защищенных сокетов | TLS — безопасность транспортного уровня&lt;/li>
&lt;/ul>
&lt;p>TLS заменил SSL, TLS — это криптографический протокол, который обеспечивает безопасность связи по сети. Его можно найти в почте, мессенджерах и других приложениях, но чаще всего он используется для защиты HTTPS.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>HTTPS - HTTP secured with SSL/TLS - HTTP, защищенный с помощью SSL/TLS&lt;/li>
&lt;/ul>
&lt;p>Расширение HTTP, используемое для безопасной связи по сети, HTTPS шифруется с помощью TLS, как упоминалось выше. Основное внимание здесь уделялось обеспечению аутентификации, конфиденциальности и целостности при обмене данными между хостами.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>DNS - Domain Name System - система доменных имен&lt;/li>
&lt;/ul>
&lt;p>DNS используется для сопоставления удобных для человека доменных имен, например, все мы знаем &lt;a href="https://google.com">google.com&lt;/a>, но если вы откроете браузер и введете &lt;a href="https://8.8.8.8">8.8.8.8&lt;/a> вы получите Google в том виде, в каком мы его знаем. Однако удачи вам в попытках запомнить все IP-адреса всех ваших веб-сайтов, на некоторых из них мы даже используем Google для поиска информации.&lt;/p>
&lt;p>Именно здесь в дело вступает DNS, он гарантирует доступность хостов, служб и других ресурсов.&lt;/p>
&lt;p>На всех хостах, если им требуется подключение к Интернету, они должны иметь DNS, чтобы иметь возможность разрешать эти доменные имена. DNS — это область, на изучение которой вы можете потратить дни и годы. Я бы также сказал по опыту, что DNS в основном является распространенной причиной всех ошибок, когда речь идет о сети. Однако не уверен, что сетевой инженер согласится с этим.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>DHCP - Dynamic Host Configuration Protocol - Протокол динамического конфигурирования сервера&lt;/li>
&lt;/ul>
&lt;p>Мы много обсуждали протоколы, необходимые для работы наших хостов, будь то доступ в Интернет или передача файлов между собой.&lt;/p>
&lt;p>На каждом хосте нам нужны 4 вещи, чтобы он мог выполнять обе эти задачи.&lt;/p>
&lt;ul>
&lt;li>IP Address&lt;/li>
&lt;li>Subnet Mask&lt;/li>
&lt;li>Default Gateway&lt;/li>
&lt;li>DNS&lt;/li>
&lt;/ul>
&lt;p>Мы рассмотрели IP-адрес, являющийся уникальным адресом для вашего хоста в сети, в которой он находится, мы можем думать об этом как о нашем домашнем номере.&lt;/p>
&lt;p>Маску подсети мы скоро рассмотрим, но вы можете думать об этом как о почтовом индексе или почтовом индексе.&lt;/p>
&lt;p>Шлюз по умолчанию — это IP-адрес нашего маршрутизатора, как правило, в нашей сети, предоставляющий нам возможность подключения уровня 3. Вы могли бы думать об этом как о единственной дороге, которая позволяет нам покинуть нашу улицу.&lt;/p>
&lt;p>Затем у нас есть DNS, как мы только что рассмотрели, чтобы помочь нам преобразовать сложные общедоступные IP-адреса в более подходящие и запоминающиеся доменные имена. Может быть, мы можем думать об этом как о гигантском сортировочном офисе, чтобы убедиться, что мы получаем правильный пост.&lt;/p>
&lt;p>Как я уже сказал, каждому хосту требуются эти 4 вещи, если у вас 1000 или 10 000 хостов, вам потребуется очень много времени, чтобы определить каждый из них по отдельности. Здесь в дело вступает DHCP, который позволяет вам определить область действия вашей сети, а затем этот протокол будет распространяться на все доступные хосты в вашей сети.&lt;/p>
&lt;p>Другой пример: вы идете в кафе, берете кофе и садитесь за свой ноутбук, или ваш телефон позволяет назвать это вашим хостом. Вы подключаете свой хост к Wi-Fi в кофейне, и вы получаете доступ к Интернету, сообщения и почта начинают пинговаться, и вы можете просматривать веб-страницы и социальные сети. Когда вы подключались к Wi-Fi в кофейне, ваша машина получала DHCP-адрес либо от выделенного DHCP-сервера, либо, скорее всего, от маршрутизатора, который также обрабатывает DHCP.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="subnetting---подсети">Subnetting - Подсети&lt;/h3>
&lt;p>Подсеть — это логическое подразделение IP-сети.&lt;/p>
&lt;p>Подсети разбивают большие сети на более мелкие, более управляемые сети, которые работают более эффективно.&lt;/p>
&lt;p>Каждая подсеть является логическим подразделением большей сети. Подключенные устройства с достаточным количеством подсетей имеют общий идентификатор IP-адреса, что позволяет им взаимодействовать друг с другом.&lt;/p>
&lt;p>Маршрутизаторы управляют связью между подсетями.&lt;/p>
&lt;p>Размер подсети зависит от требований к подключению и используемой сетевой технологии.&lt;/p>
&lt;p>Организация несет ответственность за определение своего количества и размера подсетей в пределах адресного пространства.
доступны, и детали остаются локальными для этой организации. Подсети также могут быть сегментированы на еще более мелкие подсети для таких вещей, как соединения «точка-точка», или для подсетей, поддерживающих несколько устройств.&lt;/p>
&lt;p>Среди прочих преимуществ сегментация крупных
сети в подсети включает IP-адрес
перераспределение и уменьшает перегрузку сети, оптимизацию, сетевую связь и эффективность.&lt;/p>
&lt;p>Подсети также могут повысить безопасность сети.
Если часть сети скомпрометирована, ее можно поместить в карантин, что затруднит перемещение злоумышленников по более крупной сети.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day23_Networking9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IPvYjXCsTg8">Computer Networking full course&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.practicalnetworking.net/">Practical Networking&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>24. Автоматизация сети</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day24/</link><pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day24/</guid><description>&lt;h2 id="автоматизация-сети">Автоматизация сети&lt;/h2>
&lt;h3 id="основы-сетевой-автоматизации">Основы сетевой автоматизации&lt;/h3>
&lt;p>Основные задачи для сетевой автоматизации&lt;/p>
&lt;ul>
&lt;li>Тестирование устройств и проверка конфигурации;&lt;/li>
&lt;li>Инициализация развернутых физических устройств и сервисов, а также развертывание и инициализация виртуальных устройств;&lt;/li>
&lt;li>Сбор сетевых данных, относящихся к устройствам, системам, программному обеспечению, топологии сети, трафику и сервисам в реальном времени;&lt;/li>
&lt;li>Анализ данных, в том числе упреждающая аналитика ИИ и машинного обучения, для обеспечения информации о текущем и будущем поведении сети;&lt;/li>
&lt;li>Проверка соответствия конфигурации требованиям для обеспечения правильной работы всех сетевых устройств и сервисов;&lt;/li>
&lt;li>Обновление программного обеспечения, включая откат программного обеспечения при необходимости;&lt;/li>
&lt;li>Замкнутая коррекция проблем с сетью, включая поиск и устранение неисправностей, а также исправление сложных и трудновыявляемых сбоев;&lt;/li>
&lt;li>Подробный анализ отчетов, панелей наблюдения, оповещений и предупреждений;&lt;/li>
&lt;li>Реализация требований безопасности;&lt;/li>
&lt;li>Мониторинг сети и ее сервисов для поддержания уровня обслуживания и удовлетворенности клиентов&lt;/li>
&lt;/ul>
&lt;p>Процесс внедрения автоматизации специфичен для каждого бизнеса. Когда дело доходит до развертывания автоматизации, не существует универсального решения. Способность определить и использовать подход, который лучше всего подходит для вашей организации, имеет решающее значение для продвижения к поддержке и созданию более гибкой среды для пользователей. (Мы обсуждали что-то подобное в самом начале в отношении всего DevOps, изменения культуры и автоматизированного процесса, который это приносит)&lt;/p>
&lt;p>Чтобы разобраться во всем, вам нужно будет определить, как задача или процесс, которые вы пытаетесь автоматизировать, будут улучшать опыт конечного пользователя или ценность для бизнеса, следуя пошаговому систематическому подходу.&lt;/p>
&lt;p>«Если не знаешь, куда идешь, любая дорога приведет тебя туда».&lt;/p>
&lt;p>Имея структуру проекта, которую вы пытаетесь достичь, зная, какова ваша конечная цель, а затем шаг за шагом работая над достижением этой цели, измеряйте успех автоматизации на различных этапах на основе бизнес-результатов.&lt;/p>
&lt;p>Создавайте концепции, моделируя существующие приложения. Нет необходимости разрабатывать концепции автоматизации в пузыре, потому что их нужно применять к вашему приложению, вашему сервису, вашей инфраструктуре, поэтому начните создавать концепции и моделировать их вокруг вашей существующей инфраструктуры, вы повторно существующие приложения.&lt;/p>
&lt;h3 id="подход-к-автоматизации-сети">Подход к автоматизации сети&lt;/h3>
&lt;p>Мы должны определить задачи и выполнить обнаружение запросов на изменение сети, чтобы у вас были наиболее распространенные проблемы и проблемы, решение которых нужно автоматизировать.&lt;/p>
&lt;ul>
&lt;li>Составьте список всех запросов на изменение и рабочих процессов, которые в настоящее время обрабатываются вручную.&lt;/li>
&lt;li>Определить наиболее распространенные, трудоемкие и подверженные ошибкам действия.&lt;/li>
&lt;li>Приоритизируйте запросы, используя бизнес-ориентированный подход.&lt;/li>
&lt;li>Это основа построения процесса автоматизации, что нужно автоматизировать, а что нет.&lt;/li>
&lt;/ul>
&lt;p>Затем мы должны разделить задачи и проанализировать, как разные сетевые функции работают и взаимодействуют друг с другом.&lt;/p>
&lt;ul>
&lt;li>Команда инфраструктуры/сети получает заявки на изменения на нескольких уровнях для развертывания приложений.&lt;/li>
&lt;li>На основе сетевых сервисов разделить их на разные области и понять, как они взаимодействуют друг с другом.
&lt;ul>
&lt;li>Оптимизация приложений&lt;/li>
&lt;li>ADC (контроллер доставки приложений) (Application Delivery Controller)&lt;/li>
&lt;li>Межсетевой экран&lt;/li>
&lt;li>DDI (DNS, DHCP, IPAM и т. д.)&lt;/li>
&lt;li>Маршрутизация&lt;/li>
&lt;li>Другие&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Определите различные зависимости, чтобы устранить деловые и культурные различия и обеспечить сотрудничество между командами.&lt;/li>
&lt;/ul>
&lt;p>Повторно используемые политики, определение и упрощение повторно используемых сервисных задач, процессов и ввода/вывода.&lt;/p>
&lt;ul>
&lt;li>Определить предложения для различных услуг, процессов и ввода/вывода.&lt;/li>
&lt;li>Упрощение процесса развертывания сократит время выхода на рынок как новых, так и существующих рабочих нагрузок.&lt;/li>
&lt;li>Когда у вас есть стандартный процесс, его можно упорядочить и согласовать с отдельными запросами для многопоточного подхода и доставки.&lt;/li>
&lt;/ul>
&lt;p>Объедините политики со специфическими для бизнеса действиями. Как внедрение этой политики помогает бизнесу? Экономит время? Экономит деньги? Обеспечивает лучший бизнес-результат?&lt;/p>
&lt;ul>
&lt;li>Убедитесь, что сервисные задачи совместимы.&lt;/li>
&lt;li>Свяжите добавочные сервисные задачи, чтобы они соответствовали созданию бизнес-сервисов.&lt;/li>
&lt;li>Обеспечьте гибкость связывания и повторного связывания сервисных задач по запросу.&lt;/li>
&lt;li>Разверните возможности самообслуживания и проложите путь к повышению операционной эффективности.&lt;/li>
&lt;li>Разрешить несколько наборов технологических навыков продолжать вносить свой вклад в надзор и соответствие.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Управляйте&lt;/strong> политиками и процессами, добавляя и улучшая их, сохраняя при этом доступность и обслуживание.&lt;/p>
&lt;ul>
&lt;li>Начните с малого, автоматизировав существующие задачи.&lt;/li>
&lt;li>Ознакомьтесь с процессом автоматизации, чтобы вы могли определить другие области, которые могут выиграть от автоматизации.&lt;/li>
&lt;li>повторяйте свои инициативы по автоматизации, постепенно добавляя гибкость при сохранении требуемой доступности.&lt;/li>
&lt;li>Использование поэтапного подхода прокладывает путь к успеху!&lt;/li>
&lt;/ul>
&lt;p>Оркестрируйте сетевой сервис!&lt;/p>
&lt;ul>
&lt;li>Для быстрой доставки приложений требуется автоматизация процесса развертывания.&lt;/li>
&lt;li>Создание гибкой сервисной среды требует управления различными элементами в рамках набора технологических навыков.&lt;/li>
&lt;li>Подготовьтесь к комплексной оркестровке, обеспечивающей контроль над автоматизацией и порядком развертывания.&lt;/li>
&lt;/ul>
&lt;h2 id="инструменты-автоматизации-сети">Инструменты автоматизации сети&lt;/h2>
&lt;p>Хорошей новостью здесь является то, что по большей части инструменты, которые мы используем для автоматизации сети, как правило, те же, что мы будем использовать для других областей автоматизации.&lt;/p>
&lt;p>&lt;strong>Опреационная система.&lt;/strong> Большую часть своего обучения я сосредоточился на использовании инструментов под Linux. Но почти все инструменты, которых мы коснемся, кросплатформенные.&lt;/p>
&lt;p>&lt;strong>Интегрированная среда разработки (IDE).&lt;/strong> Опять же, здесь особо нечего сказать, кроме всего прочего, я бы предложил Visual Studio Code в качестве вашей IDE, основываясь на обширных подключаемых модулях, доступных для стольких разных языков.&lt;/p>
&lt;p>&lt;strong>Управление конфигурацией.&lt;/strong> Мы еще не добрались до раздела «Управление конфигурацией», но совершенно очевидно, что Ansible является фаворитом в этой области для управления и автоматизации конфигураций. Ansible написан на Python, но вам не нужно знать Python.
&lt;a href="https://docs.ansible.com/ansible/2.9/modules/list_of_network_modules.html">Link to Ansible Network Modules&lt;/a>&lt;/p>
&lt;p>Мы также коснемся &lt;strong>Ansible Tower&lt;/strong> в разделе управления конфигурацией, рассматривая его как внешний интерфейс с графическим интерфейсом (GUI) для Ansible.&lt;/p>
&lt;p>&lt;strong>CI/CD.&lt;/strong> Мы рассмотрим больше концепций и инструментов, связанных с этим, но важно хотя бы упомянуть здесь, поскольку это охватывает не только сеть, но и все предоставление услуг и платформ.&lt;/p>
&lt;p>В частности, &lt;strong>Jenkins&lt;/strong> предоставляет или кажется популярным инструментом для сетевой автоматизации.&lt;/p>
&lt;ul>
&lt;li>Отслеживает репозиторий git на наличие изменений, а затем инициирует их.&lt;/li>
&lt;/ul>
&lt;p>Контроль версий (Version Control). Углубимся в это позже.&lt;/p>
&lt;ul>
&lt;li>Git обеспечивает контроль версий вашего кода на локальном устройстве - Кроссплатформенность&lt;/li>
&lt;li>GitHub, GitLab, BitBucket и т. д. — это онлайн-сайты, на которых вы определяете свои репозитории и загружаете свой код.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Language | Scripting.&lt;/strong> Что-то, что мы здесь не рассмотрели, это Python как язык, я решил вместо этого погрузиться в Go как язык программирования, исходя из моих обстоятельств, я бы сказал, что это был тесный контакт между Golang и Python и Python, кажется, Победитель в категории «Сетевая автоматизация».&lt;/p>
&lt;ul>
&lt;li>Здесь стоит упомянуть Nornir, фреймворк автоматизации, написанный на Python. Кажется, что это берет на себя роль Ansible, но особенно в отношении сетевой автоматизации. &lt;a href="https://nornir.readthedocs.io/en/latest/">Документация Nornir&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Анализ API.&lt;/strong> &lt;strong>Postman&lt;/strong> — отличный инструмент для анализа RESTful API. Помогает создавать, тестировать и изменять API.&lt;/p>
&lt;ul>
&lt;li>POST &amp;raquo;&amp;gt; Для создания объектов ресурсов.&lt;/li>
&lt;li>GET &amp;raquo;&amp;gt; Для получения ресурсов.&lt;/li>
&lt;li>PUT &amp;raquo;&amp;gt; Для создания или замены ресурсов.&lt;/li>
&lt;li>PATCH &amp;raquo;&amp;gt; Для создания или обновления объекта ресурсов.&lt;/li>
&lt;li>Delete &amp;raquo;&amp;gt; Чтобы удалить ресурс&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.postman.com/downloads/">Postman tool Download&lt;/a>&lt;/p>
&lt;h3 id="еще-инструменты">Еще инструменты&lt;/h3>
&lt;p>&lt;a href="https://www.cisco.com/c/en/us/products/cloud-systems-management/network-services-orchestrator/index.html">Cisco NSO (Network Services Orchestrator)&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://netyce.com/">NetYCE - Simplify Network Automation&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/">Network Test Automation&lt;/a>&lt;/p>
&lt;p>В течение следующих 3 дней я планирую более подробно изучить некоторые вещи, которые мы рассмотрели, и поработать над Python и сетевой автоматизацией.&lt;/p>
&lt;p>До сих пор мы далеко не охватили все сетевые темы, но хотели сделать это достаточно широким, чтобы следовать за ним и продолжать учиться на ресурсах, которые я добавляю ниже.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KhiJ7Fu9kKA&amp;amp;list=WL&amp;amp;index=122&amp;amp;t=89s">3 Necessary Skills for Network Automation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IPvYjXCsTg8">Computer Networking full course&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.practicalnetworking.net/">Practical Networking&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=xKPzLplPECU&amp;amp;list=WL&amp;amp;index=126">Python Network Automation&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>25. Автоматизация сети с помощью Python</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day25/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day25/</guid><description>&lt;h2 id="python-для-автоматизации-сети">Python для автоматизации сети&lt;/h2>
&lt;p>Python — это стандартный язык, используемый для автоматизированных сетевых операций.&lt;/p>
&lt;p>Хотя это не только автоматизация сети, кажется, что оно везде, когда вы ищете ресурсы, и, как упоминалось ранее, если это не Python, то обычно это Ansible, который также написан на Python.&lt;/p>
&lt;p>Я думаю, что уже упоминал об этом, но в разделе «Изучение языка программирования» я выбрал Golang, а не Python, по причинам, связанным с тем, что моя компания разрабатывает Go, так что это было хорошей причиной для меня, чтобы учиться, но если это не так, тогда Python взял бы это время.&lt;/p>
&lt;ul>
&lt;li>Удобочитаемость и простота использования. Кажется, что Python просто имеет смысл. Похоже, что в коде нет требований к &lt;code>{}&lt;/code> для начального и конечного блоков. Соедините это с сильной IDE, такой как VS Code, у вас будет довольно легкий старт, если вы хотите запустить какой-либо код Python.&lt;/li>
&lt;/ul>
&lt;p>Pycharm может быть еще одной IDE, о которой стоит упомянуть.&lt;/p>
&lt;ul>
&lt;li>Библиотеки. Расширяемость Python - это настоящая золотая жила, я упоминал ранее, что это не только для сетевой автоматизации, но на самом деле существует множество библиотек для всех видов устройств и конфигураций. Вы можете увидеть огромное количество здесь &lt;a href="https://pypi.python.org/pypi">PyPi&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Если вы хотите загрузить библиотеку на свою рабочую станцию, вы используете инструмент под названием «pip», чтобы подключиться к PyPI и загрузить его локально. Сетевые поставщики, такие как Cisco, Juniper и Arista, разработали библиотеки для облегчения доступа к своим устройствам.&lt;/p>
&lt;ul>
&lt;li>Мощный и эффективный - Помните, во времена Go я прошел сценарий &amp;ldquo;Hello World&amp;rdquo;, и мы прошли, кажется, 6 строк кода? В Питоне это&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>print(&amp;#39;hello world&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Сложите все вышеперечисленные пункты вместе, и должно быть легко понять, почему Python обычно упоминается как инструмент де-факто при работе над автоматизацией.&lt;/p>
&lt;p>Я думаю, важно отметить, что, возможно, несколько лет назад существовали сценарии, которые могли взаимодействовать с вашими сетевыми устройствами, чтобы, возможно, автоматизировать резервное копирование конфигурации или собирать журналы и другую информацию о ваших устройствах. Автоматизация, о которой мы здесь говорим, немного отличается, потому что общий сетевой ландшафт также изменился, чтобы лучше соответствовать этому образу мышления и обеспечить большую автоматизацию.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Программно-определяемая сеть (Software-Defined Network). Контроллеры SDN несут ответственность за доставку конфигурации уровня управления на все устройства в сети, что означает только единую точку контакта для любых изменений в сети, больше не требуется telnet или SSH для доступа к каждому устройству, а также полагаются на люди, чтобы сделать это, что имеет повторяющийся шанс отказа или неправильной конфигурации.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Оркестрация высокого уровня (High-Level Orchestration ). Поднимитесь на уровень выше этих контроллеров SDN, и это позволит оркестровать уровни обслуживания, а затем интегрировать этот уровень оркестровки в выбранные вами платформы, VMware, Kubernetes, общедоступные облака и т. д.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Управление на основе политик (Policy-based management) - Что вы хотите иметь? Какое желаемое состояние? Вы описываете это, и в системе есть все детали, как это понять, чтобы стать желаемым состоянием.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="настройка-рабочей-среды">Настройка рабочей среды&lt;/h2>
&lt;p>Не у всех есть доступ к физическим маршрутизаторам, коммутаторам и другим сетевым устройствам.&lt;/p>
&lt;p>Я хотел дать нам возможность ознакомиться с некоторыми из ранее упомянутых инструментов, а также получить практические навыки и научиться автоматизировать настройку наших сетей.&lt;/p>
&lt;p>Когда дело доходит до вариантов, есть несколько, из которых мы можем выбрать.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.gns3.com/software/download-vm">GNS3 VM&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.eve-ng.net/">Eve-ng&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unimus.net/">Unimus&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Мы построим нашу среду, используя &lt;a href="https://www.eve-ng.net/">Eve-ng&lt;/a>, как упоминалось ранее, вы можете использовать физическое устройство, но, честно говоря, виртуальная среда означает, что у нас может быть среда-песочница. для тестирования множества различных сценариев. Кроме того, может быть интересна возможность играть с различными устройствами и топологиями.&lt;/p>
&lt;p>Мы собираемся делать все на EVE-NG с изданием сообщества.&lt;/p>
&lt;h3 id="начало">Начало&lt;/h3>
&lt;p>Издание сообщества поставляется в форматах ISO и OVF для &lt;a href="https://www.eve-ng.net/index.php/download/">загрузки&lt;/a>.&lt;/p>
&lt;p>Мы будем использовать загрузку в формате OVF, но в случае с ISO есть возможность сборки на «голом железе» без использования гипервизора.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для нашего пошагового руководства мы будем использовать VMware Workstation, поскольку у меня есть лицензия через мой vExpert, но вы в равной степени можете использовать VMware Player или любой другой вариант, упомянутый в &lt;a href="https://www.eve-ng.net/index.php/documentation/installation/system-requirement/">документации&lt;/a>. К сожалению, мы не можем использовать нашу ранее созданную среду в Virtual box!&lt;/p>
&lt;p>Здесь также у меня возникла проблема с GNS3 с Virtual Box, хотя он и поддерживается.&lt;/p>
&lt;p>&lt;a href="https://www.vmware.com/uk/products/workstation-player.html">Download VMware Workstation Player - FREE&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.vmware.com/uk/products/workstation-pro.html">VMware Workstation PRO&lt;/a>. Есть бесплатный пробный период.&lt;/p>
&lt;h3 id="установка-на-vmware-workstation-pro">Установка на VMware Workstation PRO&lt;/h3>
&lt;p>Теперь у нас загружено и установлено программное обеспечение hypervisor, а также загружен файл EVE-NG OVF.
Теперь мы готовы к настройке.
Откройте VMware Workstation, а затем выберите &lt;code>file&lt;/code> -&amp;gt; &lt;code>open&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда вы загружаете образ EVE-NG OVF, он будет находиться в сжатом файле. Извлеките содержимое в свою папку, чтобы оно выглядело так.
&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Перейдите в папку, в которую вы загрузили образ EVE-NG OVF, и начните импорт.
Дайте ему узнаваемое имя и сохраните виртуальную машину где-нибудь в вашей системе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда процесс импорта завершится, увеличьте количество процессоров до 4 и объем выделенной памяти до 8 ГБ. (Это должно быть после импорта с последней версией, если нет, то отредактируйте настройки ВМ)&lt;/p>
&lt;p>Также убедитесь, что установлен флажок Virtualise Intel VT-x/EPT или AMD-V/RVI. Этот параметр указывает рабочей станции VMware передавать флаги виртуализации гостевой ОС (вложенная виртуализация). Это была проблема, с которой я столкнулся с GNS3 с Virtual Box, хотя мой процессор это позволяет.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="включение-и-доступ">Включение и доступ&lt;/h3>
&lt;p>&lt;em>Примечание и кроличья нора&lt;/em>: помните, я упоминал, что это не будет работать с VirtualBox! Ну да, была такая же проблема с VMware Workstation и EVE-NG, но это не вина платформы виртуализации!&lt;/p>
&lt;p>У меня есть WSL2, работающий на моей машине с Windows, и это, похоже, лишает возможности запускать что-либо, вложенное в вашу среду. Я смущен тем, почему виртуальная машина Ubuntu работает, поскольку она, кажется, устраняет аспект виртуализации Intel VT-d ЦП при использовании WSL2.&lt;/p>
&lt;p>Чтобы решить эту проблему, мы можем запустить следующую команду на нашем компьютере с Windows и перезагрузить систему, обратите внимание, что, пока она отключена, вы не сможете использовать WSL2.&lt;/p>
&lt;p>&lt;code>bcdedit /set hypervisorlaunchtype off&lt;/code>&lt;/p>
&lt;p>Если вы хотите вернуться и использовать WSL2, вам нужно будет запустить эту команду и перезагрузиться.&lt;/p>
&lt;p>&lt;code>bcdedit /set hypervisorlaunchtype auto&lt;/code>&lt;/p>
&lt;p>Обе эти команды нужно запускать от имени администратора!&lt;/p>
&lt;p>Хорошо, вернемся к шоу. Теперь у вас должна быть включенная машина в VMware Workstation, и у вас должно появиться приглашение, похожее на это.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Данные для входа:&lt;/p>
&lt;p>username = root
password = eve&lt;/p>
&lt;p>Затем вас попросят снова ввести пароль root, который позже будет использоваться для SSH-соединения с хостом.
Затем мы можем изменить имя хоста.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Затем мы определяем доменное имя DNS, я использовал имя ниже, но я не уверен, нужно ли будет его изменить позже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Затем мы настраиваем сеть, я выбираю статический, чтобы указанный IP-адрес оставался постоянным после перезагрузки.
&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
На последнем шаге укажите статический IP-адрес из сети, доступной с вашей рабочей станции.
&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Здесь есть несколько дополнительных шагов, где вам нужно будет указать маску подсети для вашей сети, шлюз по умолчанию и DNS.
После завершения он перезагрузится, когда будет выполнено резервное копирование, вы можете взять свой статический IP-адрес и ввести его в свой браузер.
&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Имя пользователя по умолчанию для графического интерфейса — «admin», пароль — «eve», а имя пользователя по умолчанию для SSH — «root» и пароль — «eve», но это было бы изменено, если бы вы изменили его во время установки.
&lt;p class="md__image">
&lt;img
src="../images/Day25_Networking12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я выбрал HTML5 для консоли вместо нативной, так как это откроет новую вкладку в вашем браузере, когда вы будете перемещаться по разным консолям.&lt;/p>
&lt;p>Далее мы собираемся:&lt;/p>
&lt;ul>
&lt;li>Установить клиентский пакет EVE-NG&lt;/li>
&lt;li>Загрузить некоторые сетевые образы в EVE-NG.&lt;/li>
&lt;li>Построить топологию сети&lt;/li>
&lt;li>Добавить &amp;ldquo;ноды&amp;rdquo; (машины/хосты, Nodes)&lt;/li>
&lt;li>Соединить ноды между собой&lt;/li>
&lt;li>Начнем создавать скрипты Python&lt;/li>
&lt;li>Посмотрим на telnetlib, Netmiko, Paramiko и Pexpect&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=g6B0f_E0NMg">Free Course: Introduction to EVE-NG&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=9dPWARirtK8">EVE-NG - Creating your first lab&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KhiJ7Fu9kKA&amp;amp;list=WL&amp;amp;index=122&amp;amp;t=89s">3 Necessary Skills for Network Automation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IPvYjXCsTg8">Computer Networking full course&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.practicalnetworking.net/">Practical Networking&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=xKPzLplPECU&amp;amp;list=WL&amp;amp;index=126">Python Network Automation&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>26. Развертывание виртуальной лаборатории EVE-NG в домашних условиях</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day26/</link><pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day26/</guid><description>&lt;h2 id="создание-нашей-лаборатории">Создание нашей лаборатории&lt;/h2>
&lt;p>Мы собираемся продолжить настройку нашей эмулируемой сети с помощью EVE-NG, а затем, надеюсь, развернуть несколько устройств и начать думать о том, как мы можем автоматизировать настройку этих устройств. В &lt;a href="../day25">День 25&lt;/a> мы рассказали об установке EVE-NG на нашу машину с помощью VMware Workstation.&lt;/p>
&lt;h3 id="установка-клиента-eve-ng">Установка клиента EVE-NG&lt;/h3>
&lt;p>Существует также клиентский пакет, который позволяет нам выбирать, какое приложение используется при подключении к устройствам по SSH. Он также настроит &lt;a href="https://ru.wikipedia.org/wiki/Wireshark">Wireshark&lt;/a> для захвата пакетов между ссылками. Вы можете установить клиентский пакет для своей ОС (Windows, macOS, Linux).&lt;/p>
&lt;p>&lt;a href="https://www.eve-ng.net/index.php/download/">EVE-NG Client Download&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Подсказка: если вы используете Linux в качестве клиента, то есть этот &lt;a href="https://github.com/SmartFinn/eve-ng-integration">клиентский пакет&lt;/a>.&lt;/p>
&lt;p>Установка проста: next, next и я бы посоветовал оставить значения по умолчанию.&lt;/p>
&lt;h3 id="получение-сетевых-образов">Получение сетевых образов&lt;/h3>
&lt;p>Этот шаг непростой, я просмотрел несколько видеороликов, на которые я дам ссылки в конце, которые ссылаются на некоторые ресурсы и загрузки для нашего маршрутизатора и переключают изображения, рассказывая нам, как и куда их загрузить.&lt;/p>
&lt;p>Важно отметить, что я использую все в образовательных целях. Я бы предложил загрузить официальные образы от сетевых поставщиков.&lt;/p>
&lt;p>&lt;a href="https://loopedback.com/2019/11/15/setting-up-eve-ng-for-ccna-ccnp-ccie-level-studies-includes-multiple-vendor-node-support-an-absolutely-amazing-study-tool-to-check-out-asap/">Blog &amp;amp; Links to YouTube videos&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://networkhunt.com/how-to-add-cisco-virl-vios-image-to-eve-ng/">How To Add Cisco VIRL vIOS image to Eve-ng&lt;/a>&lt;/p>
&lt;p>В целом шаги здесь немного сложны и могли бы быть намного проще, но приведенные выше блоги и видео показывают процесс добавления изображений в вашу коробку EVE-NG.&lt;/p>
&lt;p>Я использовал &lt;a href="https://filezilla-project.org/">FileZilla&lt;/a> для передачи &lt;a href="https://ru.wikipedia.org/wiki/Qcow2">qcow2&lt;/a> на виртуальную машину через SFTP.&lt;/p>
&lt;p>Для нашей лаборатории нам нужны Cisco vIOS L2 (коммутаторы) и Cisco vIOS (маршрутизатор).&lt;/p>
&lt;h3 id="создаем-лабораторию">Создаем лабораторию&lt;/h3>
&lt;p>Внутри веб-интерфейса EVE-NG мы собираемся создать нашу новую топологию сети. У нас будет четыре коммутатора и один маршрутизатор, который будет нашим шлюзом во внешние сети.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Node&lt;/th>
&lt;th>IP Address&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Router&lt;/td>
&lt;td>10.10.88.110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch1&lt;/td>
&lt;td>10.10.88.111&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch2&lt;/td>
&lt;td>10.10.88.112&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch3&lt;/td>
&lt;td>10.10.88.113&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch4&lt;/td>
&lt;td>10.10.88.114&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="добавление-наших-узлов-в-eve-ng">Добавление наших узлов в EVE-NG&lt;/h4>
&lt;p>Когда вы впервые войдете в EVE-NG, вы увидите экран, как показано ниже, мы хотим начать с создания нашей первой лаборатории.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Дайте вашей лаборатории имя, а остальные поля являются необязательными.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем увидим пустой экран, чтобы начать создание вашей сети. Щелкните правой кнопкой мыши на своем холсте и выберите &amp;lsquo;add node&amp;rsquo;.&lt;/p>
&lt;p>Далее появляется длинный список опций. Если вы следовали вышеизложенному, у вас будут два синих, показанных ниже, а остальные будут серыми и недоступными для выбора.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы хотим добавить следующее в нашу лабораторию:&lt;/p>
&lt;ul>
&lt;li>1 x Cisco vIOS Router&lt;/li>
&lt;li>4 x Cisco vIOS Switch&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h4 id="соединяем-наши-ноды">Соединяем наши ноды&lt;/h4>
&lt;p>Теперь нам нужно добавить возможность подключения между нашими маршрутизаторами и коммутаторами. Мы можем сделать это довольно легко, наведя курсор на устройство и увидев значок подключения, как показано ниже, а затем подключив его к устройству, к которому мы хотим подключиться.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Когда вы закончите подключение своей среды, вы также можете добавить способ определения физических границ или местоположений с помощью прямоугольников или кругов, которые также можно найти в контекстном меню. Вы также можете добавить текст, который полезен, когда мы хотим определить наши имена или IP-адреса в наших лабораториях.&lt;/p>
&lt;p>Я пошел дальше и сделал свою лабораторию такой, как показано ниже.
&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>You will also notice that the lab above is all powered off, we can start our lab by selecting everything and right-clicking and selecting start selected.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day26_Networking8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Как только мы запустим нашу лабораторию, вы сможете подключаться к консоли на каждом устройстве, и вы заметите, что на этом этапе они довольно тупые без настройки. Мы можем добавить некоторую конфигурацию к каждому узлу, скопировав или создав свою собственную в каждом терминале.&lt;/p>
&lt;p>Я оставлю свою конфигурацию в сетевой папке репозитория для справки.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Node&lt;/th>
&lt;th>Configuration&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Router&lt;/td>
&lt;td>&lt;a href="../networking/R1">R1&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch1&lt;/td>
&lt;td>&lt;a href="../networking/SW1">SW1&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch2&lt;/td>
&lt;td>&lt;a href="../networking/SW2">SW2&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch3&lt;/td>
&lt;td>&lt;a href="../networking/SW3">SW3&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch4&lt;/td>
&lt;td>&lt;a href="../networking/SW4">SW4&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=g6B0f_E0NMg">Free Course: Introduction to EVE-NG&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=9dPWARirtK8">EVE-NG - Creating your first lab&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KhiJ7Fu9kKA&amp;amp;list=WL&amp;amp;index=122&amp;amp;t=89s">3 Necessary Skills for Network Automation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IPvYjXCsTg8">Computer Networking full course&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.practicalnetworking.net/">Practical Networking&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=xKPzLplPECU&amp;amp;list=WL&amp;amp;index=126">Python Network Automation&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Большинство примеров, которые я использую здесь, поскольку я не сетевой инженер, взяты из этой обширной книги, которая не является бесплатной, но я использую некоторые примеры оттуда, чтобы помочь понять автоматизацию сети.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.packtpub.com/product/hands-on-enterprise-automation-with-python/9781788998512">Hands-On Enterprise Automation with Python (Book)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>27. Работа с сетью в Python</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day27/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day27/</guid><description>&lt;h2 id="практическое-знакомство-с-python-и-сетью">Практическое знакомство с Python и сетью&lt;/h2>
&lt;p>В этом заключительном разделе основ работы с сетью мы рассмотрим некоторые задачи и инструменты автоматизации с помощью нашей лабораторной среды, созданной &lt;a href="../day26">День 26&lt;/a>&lt;/p>
&lt;p>Мы будем использовать туннель SSH для подключения к нашим устройствам с нашего клиента по сравнению с telnet. Туннель SSH, созданный между клиентом и устройством, зашифрован. Мы также рассмотрели SSH в разделе Linux в &lt;a href="../day18">День 18&lt;/a>&lt;/p>
&lt;h2 id="доступ-к-нашей-виртуальной-эмулируемой-среде">Доступ к нашей виртуальной эмулируемой среде&lt;/h2>
&lt;p>Чтобы мы могли взаимодействовать с нашими коммутаторами, нам либо нужна рабочая станция внутри сети EVE-NG, и вы можете развернуть там Linux-систему с установленным Python для выполнения вашей автоматизации (&lt;a href="https://www.youtube.com/watch?v=3Qstk3zngrY">Ресурс для настройки Linux внутри EVE-NG&lt;/a>) или можно сделать как я и определить облако для доступа со своей рабочей станции.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для этого мы щелкнули правой кнопкой мыши на нашем холсте и выбрали сеть, а затем выбрали &amp;ldquo;Management(Cloud0)&amp;rdquo;, чтобы подключиться к нашей домашней сети.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Однако внутри этой сети у нас ничего нет, поэтому нам нужно добавить соединения из новой сети на каждое из наших устройств.
Я вошел в систему на каждом из наших устройств и выполнил следующие команды для интерфейсов, применимых к тому месту, где появляется облако.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>enable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>config t
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int gi0/0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip add dhcp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>no sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sh ip int br
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Последний шаг дает нам адрес DHCP из нашей домашней сети. Список сетей моего устройства выглядит следующим образом:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Node&lt;/th>
&lt;th>IP Address&lt;/th>
&lt;th>Home Network IP&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Router&lt;/td>
&lt;td>10.10.88.110&lt;/td>
&lt;td>192.168.169.115&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch1&lt;/td>
&lt;td>10.10.88.111&lt;/td>
&lt;td>192.168.169.178&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch2&lt;/td>
&lt;td>10.10.88.112&lt;/td>
&lt;td>192.168.169.193&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch3&lt;/td>
&lt;td>10.10.88.113&lt;/td>
&lt;td>192.168.169.125&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Switch4&lt;/td>
&lt;td>10.10.88.114&lt;/td>
&lt;td>192.168.169.197&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ssh-к-сетевому-устройству">SSH к сетевому устройству&lt;/h3>
&lt;p>Имея все вышеперечисленное, мы теперь можем подключаться к нашим устройствам в нашей домашней сети, используя нашу рабочую станцию. Я использую Putty, но также имею доступ к другим терминалам, таким как git bash, которые дают мне возможность подключаться к нашим устройствам по SSH.&lt;/p>
&lt;p>Ниже вы можете видеть, что у нас есть SSH-соединение с нашим маршрутизатором. (Р1)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="использование-python-для-сбора-информации-с-наших-устройств">Использование Python для сбора информации с наших устройств&lt;/h3>
&lt;p>Первый пример того, как мы можем использовать Python, — это сбор информации со всех наших устройств, и, в частности, я хочу иметь возможность подключаться к каждому из них и запускать простую команду, чтобы предоставить мне конфигурацию и настройки интерфейса. Я сохранил этот скрипт:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>#!/usr/bin/env python
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>from netmiko import ConnectHandler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>from getpass import getpass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#password = getpass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>R1 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.115&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW1 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.178&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW2 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.193&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW3 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.125&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW4 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.197&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>command = &amp;#34;show ip int brief&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>for device in (R1, SW1, SW2, SW3, SW4):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> net_connect = ConnectHandler(**device)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(net_connect.find_prompt())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(net_connect.send_command(command))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> net_connect.disconnect()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь, когда я запускаю это, я вижу каждую конфигурацию порта на всех моих устройствах.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это может быть удобно, если у вас много разных устройств, создайте этот один скрипт, чтобы вы могли централизованно контролировать и быстро понимать все конфигурации в одном месте.&lt;/p>
&lt;h3 id="использование-python-для-настройки-наших-устройств">Использование Python для настройки наших устройств&lt;/h3>
&lt;p>Вышеупомянутое полезно, но как насчет использования Python для настройки наших устройств, в нашем сценарии у нас есть транковый порт между &amp;lsquo;SW1&amp;rsquo; и &amp;lsquo;SW2&amp;rsquo;, снова представьте, если бы это нужно было сделать на многих из тех же коммутаторов, которые мы хотим автоматизировать, и не нужно вручную подключаться к каждому коммутатору, чтобы внести изменения в конфигурацию.&lt;/p>
&lt;p>Для этого мы можем использовать следующий скрипт. Это подключится через SSH и выполнит это изменение на нашем &amp;lsquo;SW1&amp;rsquo;, которое также изменится на &amp;lsquo;SW2&amp;rsquo;.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>from netmiko import ConnectHandler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW2 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.193&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;secret&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>core_sw_config = [&amp;#34;int range gig0/1 - 2&amp;#34;, &amp;#34;switchport trunk encapsulation dot1q&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;switchport mode trunk&amp;#34;, &amp;#34;switchport trunk allowed vlan 1,2&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&amp;#34;########## Connecting to Device {0} ############&amp;#34;.format(SW2))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>net_connect = ConnectHandler(**SW2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>net_connect.enable()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&amp;#34;***** Sending Configuration to Device *****&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>net_connect.send_config_set(core_sw_config)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь если посмотреть на код, вы увидите, что появляется сообщение «sending configuration to device», но нет подтверждения того, что это произошло. Мы могли бы добавить дополнительный код в наш скрипт, чтобы выполнить эту проверку и проверку на нашем switch или мы могли бы изменить наш сценарий, прежде чем показать нам это.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>#!/usr/bin/env python
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>from netmiko import ConnectHandler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>from getpass import getpass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#password = getpass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW1 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.178&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW2 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.193&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW3 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.125&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SW4 = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device_type&amp;#34;: &amp;#34;cisco_ios&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;host&amp;#34;: &amp;#34;192.168.169.197&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;username&amp;#34;: &amp;#34;admin&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;password&amp;#34;: &amp;#34;access123&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>command = &amp;#34;show int trunk&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>for device in (SW1, SW2, SW3, SW4):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> net_connect = ConnectHandler(**device)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(net_connect.find_prompt())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(net_connect.send_command(command))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> net_connect.disconnect()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="резервное-копирование-конфигураций-вашего-устройства">Резервное копирование конфигураций вашего устройства&lt;/h3>
&lt;p>Другим вариантом использования может быть захват наших сетевых конфигураций и обеспечение их резервного копирования, но опять же, мы не хотим подключаться ко всем устройствам, которые у нас есть в нашей сети, поэтому мы также можем автоматизировать это с помощью скрипта&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>import sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import paramiko
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import os
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>import datetime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>now = datetime.datetime.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dt_string = now.strftime(&amp;#34;%d/%m/%Y %H:%M:%S&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&amp;#34;Your backup has started at&amp;#34;, dt_string)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tic = time.perf_counter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#user = input(&amp;#34;Enter username:&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#password = input(&amp;#34;Enter Paswd:&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#enable_password = input(&amp;#34;Enter enable pswd:&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user = &amp;#34;admin&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>password = &amp;#34;access123&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enable_password = &amp;#34;access123&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>port=22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>f0 = open(&amp;#39;backup.txt&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>for ip in f0.readlines():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip = ip.strip()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename_prefix =&amp;#39;/Users/shambhu/Documents&amp;#39; + ip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ssh = paramiko.SSHClient()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ssh.connect(ip,port, user, password, look_for_keys=False)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chan = ssh.invoke_shell()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.sleep(2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chan.send(&amp;#39;enable\n&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chan.send(enable_password +&amp;#39;\n&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.sleep(1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chan.send(&amp;#39;term len 0\n&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.sleep(1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chan.send(&amp;#39;sh run\n&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.sleep(20)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output = chan.recv(999999)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename = &amp;#34;%s_%.2i%.2i%i_%.2i%.2i%.2i&amp;#34; % (ip,now.year,now.month,now.day,now.hour,now.minute,now.second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f1 = open(filename, &amp;#39;a&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f1.write(output.decode(&amp;#34;utf-8&amp;#34;) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f1.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ssh.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f0.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>toc = time.perf_counter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&amp;#34;Congratulations You Have Backed Up Your 90DaysOfDevOps Lab&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(f&amp;#34;Your backup duration was {toc - tic:0.4f} seconds&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dt_string = now.strftime(&amp;#34;%d/%m/%Y %H:%M:%S&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&amp;#34;Your backup completed at&amp;#34;, dt_string)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вам также потребуется заполнить &lt;code>backup.txt&lt;/code> IP-адресами, для которых вы хотите сделать резервную копию.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>192.168.169.115
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.169.178
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.169.193
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.169.125
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.169.197
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Запустите свой скрипт, и вы должны увидеть что-то вроде того, что показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это может быть я просто пишу простой скрипт печати на питоне, поэтому я также должен показать вам файлы резервных копий.
&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="paramiko">Paramiko&lt;/h3>
&lt;p>Широко используемый модуль Python для SSH. Вы можете узнать больше по официальной ссылке GitHub &lt;a href="https://github.com/paramiko/paramiko">здесь&lt;/a>&lt;/p>
&lt;p>Мы можем установить этот модуль с помощью команды &lt;code>pip install paramiko&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем проверить установку, войдя в оболочку Python и импортировав модуль paramiko.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day27_Networking2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="netmiko">Netmiko&lt;/h3>
&lt;p>Модуль &lt;em>netmiko&lt;/em> предназначен специально для сетевых устройств, тогда как paramiko — это более широкий инструмент для обработки SSH-соединений в целом.&lt;/p>
&lt;p>Netmiko, который мы использовали выше вместе с paramiko, можно установить с помощью &lt;code>pip install netmiko&lt;/code>.&lt;/p>
&lt;p>Netmiko поддерживает множество сетевых поставщиков и устройств, список поддерживаемых устройств можно найти на &lt;a href="https://github.com/ktbyers/netmiko#supports">странице GitHub&lt;/a>.&lt;/p>
&lt;h3 id="другие-модули">Другие модули&lt;/h3>
&lt;p>Также стоит упомянуть несколько других модулей, на которые у нас не было возможности взглянуть, но они дают гораздо больше функциональных возможностей, когда речь идет об автоматизации сети.&lt;/p>
&lt;p>&lt;code>netaddr&lt;/code> используется для работы с IP-адресами и управления ими, опять же установка проста с помощью &lt;code>pip install netaddr&lt;/code>&lt;/p>
&lt;p>вы можете захотеть сохранить большую часть конфигурации вашего коммутатора в электронной таблице Excel, &lt;code>xlrd&lt;/code> позволит вашим сценариям читать книгу Excel и преобразовывать строки и столбцы в матрицу. &lt;code>pip install xlrd&lt;/code>, чтобы установить модуль.&lt;/p>
&lt;p>Еще несколько случаев использования сетевой автоматизации, которые я не имел возможности изучить, можно найти &lt;a href="https://github.com/ktbyers/pynet/tree/master/presentations/dfwcug/examples">здесь&lt;/a>&lt;/p>
&lt;p>Я думаю, что это завершает наш раздел «Сетевые ресурсы» #90DaysOfDevOps. Networking — это одна из областей, которую я действительно не касался какое-то время, и есть так много всего, что нужно осветить, но я надеюсь, что мои заметки и ресурсы, которыми я делюсь, будут полезны для некоторый.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=g6B0f_E0NMg">Free Course: Introduction to EVE-NG&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=9dPWARirtK8">EVE-NG - Creating your first lab&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KhiJ7Fu9kKA&amp;amp;list=WL&amp;amp;index=122&amp;amp;t=89s">3 Necessary Skills for Network Automation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=IPvYjXCsTg8">Computer Networking full course&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.practicalnetworking.net/">Practical Networking&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=xKPzLplPECU&amp;amp;list=WL&amp;amp;index=126">Python Network Automation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.packtpub.com/product/hands-on-enterprise-automation-with-python/9781788998512">Hands-On Enterprise Automation with Python (Book)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Увидимся &lt;a href="../day28">завтра&lt;/a>, где начнем изучать облачные вычисления и получите хорошее представление и базовые знания&lt;/p></description></item><item><title>28. DevOps в облаке</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day28/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day28/</guid><description>&lt;h2 id="общая-картина-devops-и-облака">Общая картина: DevOps и облака&lt;/h2>
&lt;p>Когда дело доходит до облачных вычислений и того, что они предлагают, это очень хорошо сочетается с духом и процессами DevOps. Мы можем думать об облачных вычислениях, предоставляющих технологии и услуги, в то время как DevOps, как мы уже много раз упоминали ранее, касается процессов и их улучшения.&lt;/p>
&lt;p>Но начать с этого путешествия по обучению в облаке сложно, и убедиться, что вы знаете и понимаете все элементы или лучший сервис для выбора по правильной цене, сбивает с толку.
&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Накладывается ли на облака парадигма DevOps? Мой ответ здесь — нет, но чтобы по-настоящему воспользоваться преимуществами облачных вычислений и, возможно, избежать больших счетов за облачные вычисления, от которых пострадало так много людей, важно думать об облачных вычислениях и DevOps вместе.&lt;/p>
&lt;p>Если мы посмотрим на то, что мы подразумеваем под Public Cloud в общем смысле, речь идет о снятии некоторой ответственности с управляемой службы, чтобы вы и ваша команда могли сосредоточиться на более важных аспектах, имя которых должно быть приложением и конечными пользователями. . В конце концов, Public Cloud — это просто чей-то компьютер.
&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В этом первом разделе я хочу немного подробнее рассказать о том, что такое Public Cloud, и о некоторых блоках, которые в целом называются Public Cloud .&lt;/p>
&lt;h3 id="saas">SaaS&lt;/h3>
&lt;p>Первая область, которую следует рассмотреть, — это программное обеспечение как услуга (SaaS - Software as a service,). Эта услуга устраняет почти все накладные расходы на управление службой, которую вы, возможно, когда-то запускали локально. Давайте подумаем о Microsoft Exchange для нашей электронной почты. Раньше это была физическая коробка, которая находилась в вашем центре обработки данных или, может быть, в шкафу под лестницей. Вам нужно будет кормить и поить этот сервер. Под этим я подразумеваю, что вам нужно будет обновлять его, и вы будете нести ответственность за покупку серверного оборудования, скорее всего, за установку операционной системы, установку необходимых приложений, а затем за исправление, если что-то пойдет не так, вам придется устранить неполадки и получить вещи встали на свои места.&lt;/p>
&lt;p>О, и вам также нужно будет убедиться, что вы делаете резервную копию своих данных, хотя по большей части это не меняется и с SaaS.&lt;/p>
&lt;p>Что делает SaaS и, в частности, Microsoft 365, потому что я упомянул, что Exchange устраняет эти накладные расходы на администрирование, и они предоставляют услугу, которая обеспечивает ваши функции обмена по почте, а также многие другие параметры производительности (Office 365) и варианты хранения (OneDrive), которые в целом дают большой опыт для конечного пользователя.&lt;/p>
&lt;p>Широко распространены и другие приложения SaaS, такие как Salesforce, SAP, Oracle, Google, Apple. Все это избавляет от необходимости управлять большим количеством стека.&lt;/p>
&lt;p>Я уверен, что есть история с приложениями на основе DevOps и SaaS, но я изо всех сил пытаюсь выяснить, что они могут собой представлять. Я знаю, что у Azure DevOps есть отличная интеграция с Microsoft 365, которую я мог бы изучить и сообщить.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="public-cloud">Public Cloud&lt;/h3>
&lt;p>Далее у нас есть public cloud. Большинство людей думают об этом по-разному, некоторые считают, что это только гипермасштаберы, такие как Microsoft Azure, Google Cloud Platform и AWS.
&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Некоторые также видят в общедоступном облаке гораздо более широкое предложение, включающее не только гиперскейлеры, но и тысячи MSP (managed service provider) по всему миру. В этом посте мы собираемся рассмотреть общедоступное облако, включая гиперскейлеры и MSP, хотя позже мы специально углубимся в один или несколько гиперскейлеров, чтобы получить базовые знания.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;em>тысячи других компаний могли бы присоединиться к этому, я просто выбираю из местных, региональных, телекоммуникационных и глобальных брендов, с которыми я работал и о которых знаю.&lt;/em>&lt;/p>
&lt;p>В разделе SaaS мы упомянули, что облако сняло ответственность или бремя администрирования частей системы. Если SaaS, мы видим, что многие уровни абстракции удалены, то есть физические системы, сеть, хранилище, операционная система и даже приложения в некоторой степени. Когда дело доходит до облака, существуют различные уровни абстракции, которые мы можем удалить или оставить в зависимости от ваших требований.&lt;/p>
&lt;p>Мы уже упоминали SaaS, но есть еще по крайней мере два, которые следует упомянуть в отношении общедоступного облака.&lt;/p>
&lt;p>Инфраструктура как услуга. Вы можете думать об этом уровне как о виртуальной машине, но в то время как локально вам придется заботиться о физическом уровне в облаке, это не так, физический уровень является обязанностью облачных провайдеров, и вы будете управлять и управлять операционной системой, данными и приложениями, которые вы хотите запустить.&lt;/p>
&lt;p>Платформа как услуга. Это по-прежнему снимает ответственность уровней, и на самом деле это означает, что вы берете под свой контроль данные и приложение, но вам не нужно беспокоиться об аппаратном обеспечении или операционной системе.&lt;/p>
&lt;p>Есть много других предложений AaS, но это два основных принципа. Вы можете увидеть предложения вокруг StaaS (Storage as a service), которые предоставляют вам уровень хранения, но не нужно беспокоиться об оборудовании под ним. Или вы, возможно, слышали о CaaS для контейнеров как об услуге, к которой мы вернемся позже. Еще одна услуга как услуга, которую мы рассмотрим в течение следующих 7 дней, — это FaaS (Functions as a Service), где, возможно, вам не нужна работающая система. все время, и вы просто хотите, чтобы функция выполнялась как и когда.&lt;/p>
&lt;p>Есть много способов, которыми общедоступное облако может предоставить уровни абстракции управления, от которых вы хотите отказаться и заплатить за них.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="private-cloud">Private Cloud&lt;/h3>
&lt;p>Наличие собственного центра обработки данных не осталось в прошлом. Я думаю, что это стало возрождением среди многих компаний, которым было трудно управлять моделью OPEX, а также набором навыков только в использовании общедоступного облака.&lt;/p>
&lt;p>Здесь важно отметить, что общедоступное облако, скорее всего, теперь будет вашей ответственностью и будет находиться на вашей территории.&lt;/p>
&lt;p>У нас есть некоторые интересные вещи, происходящие в этой сфере не только с VMware, которая доминировала в эпоху виртуализации, и с локальными инфраструктурными средами. У нас также есть гиперскейлеры, предлагающие локальную версию своих публичных облаков.
&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="hybrid-cloud">Hybrid Cloud&lt;/h3>
&lt;p>В продолжение упоминаний о публичном и частном облаке мы также можем охватить обе эти среды, чтобы обеспечить гибкость между ними, возможно, воспользоваться услугами, доступными в общедоступном облаке, а затем также воспользоваться преимуществами функций и возможностей локальной среды. или это может быть правило, которое предписывает вам хранить данные локально.
&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Собрав все это вместе, у нас есть много вариантов, где мы будем хранить и запускать наши рабочие нагрузки.
&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Прежде чем мы перейдем к конкретному гипермасштабу, я спросил силу Твиттера, куда нам следует двигаться?
&lt;p class="md__image">
&lt;img
src="../images/Day28_Cloud10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;a href="https://twitter.com/MichaelCade1/status/1486814904510259208?s=20&amp;amp;t=x2n6QhyOXSUs7Pq0itdIIQ">Link to Twitter Poll&lt;/a>&lt;/p>
&lt;p>Какой бы процент ни получил самый высокий процент, мы углубимся в предложения, я думаю, что важно упомянуть, что услуги во всех них очень похожи, поэтому я говорю начать с одного, потому что я обнаружил, что, зная основа одного из них и как создавать виртуальные машины, настраивать сеть и т. д. Я смог перейти к другим и быстро набраться опыта в этих областях.&lt;/p>
&lt;p>В любом случае, я поделюсь отличными &lt;strong>БЕСПЛАТНЫМИ&lt;/strong> ресурсами, которые охватывают все три гиперскейлера.&lt;/p>
&lt;p>Я также собираюсь разработать сценарий, как я делал это в других разделах, где мы можем что-то построить по мере продвижения по дням.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qkj5W98Xdvw">Hybrid Cloud and MultiCloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=NKEFWyqJ5XA&amp;amp;list=WL&amp;amp;index=130&amp;amp;t=12s">Microsoft Azure Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UGRDM86MBIQ&amp;amp;list=WL&amp;amp;index=131&amp;amp;t=10s">Google Cloud Digital Leader Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ulprqHHWlng&amp;amp;t=5352s">AWS Basics for Beginners - Full Course&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>29. Знакомство с Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day29/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day29/</guid><description>&lt;h2 id="знакомство-с-microsoft-azure">Знакомство с Microsoft Azure&lt;/h2>
&lt;p>Прежде чем мы начнем, победителем опроса в Твиттере стала Microsoft Azure, отсюда и название страницы. Это было довольно интересно увидеть результаты, полученные в течение 24 часов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Я бы сказал, что с точки зрения освещения этой темы я лучше понимаю и пользуюсь услугами, доступных в Microsoft Azure. Сегодня я склоняюсь к Amazon AWS. Однако я выделил разделы для всех трех основных облачных провайдеров.&lt;/p>
&lt;p>Я ценю, что их больше, и опрос включал только эти 3, и, в частности, были некоторые комментарии об Oracle Cloud. Я хотел бы услышать больше о других облачных провайдерах, которые используются в дикой природе.&lt;/p>
&lt;h3 id="основы">Основы&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Предоставляет общедоступные облачные сервисы&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Географически распределены (более 60 регионов по всему миру)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Доступ через Интернет и/или частные соединения&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Мультитенантная модель&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Выставление счетов на основе потребления - (Плати по мере использования | Плати по мере роста)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Большое количество типов услуг и предложений для различных требований.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://infrastructuremap.microsoft.com/explore">Microsoft Azure Global Infrastructure&lt;/a>
Сколько бы мы ни говорили о SaaS и Hybrid Cloud, мы не планируем затрагивать эти темы здесь.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Лучший способ начать и продолжить работу — щелкнуть ссылку, которая позволит вам зарегистрировать &lt;a href="https://azure.microsoft.com/en-gb/free/">Бесплатную учетную запись Microsoft Azure&lt;/a>&lt;/p>
&lt;h3 id="регионы">Регионы&lt;/h3>
&lt;p>Я связал интерактивную карту выше, но мы можем видеть изображение под широтой регионов, предлагаемых на платформе Microsoft Azure по всему миру.
&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;em>image taken from &lt;a href="https://docs.microsoft.com/ru-ru/azure/networking/microsoft-global-network">Microsoft Docs - 01/05/2021&lt;/a>&lt;/em>&lt;/p>
&lt;p>Вы также увидите несколько sovereign облаков, что означает, что они не связаны или не могут взаимодействовать с другими регионами, например, они будут связаны с правительствами, такими как «AzureUSGovernment», а также «AzureChinaCloud» и другими.&lt;/p>
&lt;p>Когда мы развертываем наши службы в Microsoft Azure, мы выбираем регион почти для всего. Однако важно отметить, что не все услуги доступны в каждом регионе. Вы можете увидеть &lt;a href="https://azure.microsoft.com/en-us/global-infrastructure/services/?products=all">Продукты, доступные по регионам&lt;/a> на момент написания моего письма, что в западно-центральной части США мы не можем использовать Azure Databricks.&lt;/p>
&lt;p>Я также упомянул «почти все» выше, есть определенные службы, связанные с регионом, такие как Azure Bot Services, Bing Speech, Azure Virtual Desktop, статические веб-приложения и некоторые другие.&lt;/p>
&lt;p>За кулисами регион может состоять из более чем одного центра обработки данных. Они будут называться зонами доступности.&lt;/p>
&lt;p>На изображении ниже вы увидите, что это снова взято из официальной документации Microsoft, в которой описывается, что такое регион и как он состоит из зон доступности. Однако не во всех регионах есть несколько зон доступности.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В Microsoft хорошая документация, и вы можете прочитать больше о &lt;a href="https://docs.microsoft.com/ru-ru/azure/availability-zones/az-overview">Регионах и зонах доступности&lt;/a> здесь.&lt;/p>
&lt;h3 id="подписки">Подписки&lt;/h3>
&lt;p>Помните, что мы упоминали, что Microsoft Azure — это облако модели потребления, и вы обнаружите, что все основные поставщики облачных услуг следуют этой модели.&lt;/p>
&lt;p>Если вы являетесь Предприятием, вы можете захотеть или заключить соглашение Enterprise с Microsoft, чтобы ваша компания могла использовать эти службы Azure.&lt;/p>
&lt;p>Если вы похожи на меня и используете Microsoft Azure для обучения, у нас есть несколько других вариантов.&lt;/p>
&lt;p>У нас есть &lt;a href="https://azure.microsoft.com/en-gb/free/">Бесплатная учетная запись Microsoft Azure&lt;/a>, которая обычно дает вам несколько бесплатных облачных кредитов, которые вы можете потратить в Azure в течение некоторого времени.&lt;/p>
&lt;p>Существует также возможность использовать подписку Visual Studio, которая дает вам, возможно, несколько бесплатных кредитов каждый месяц вместе с вашей годовой подпиской на Visual Studio, которая много лет назад была широко известна как MSDN. &lt;a href="https://azure.microsoft.com/en-us/pricing/member-offers/credit-for-visual-studio-subscribers/">Visual Studio&lt;/a>&lt;/p>
&lt;p>Затем, наконец, вручите кредитную карту и заплатите, как вы идете, модель. &lt;a href="https://azure.microsoft.com/en-us/pricing/purchase-options/pay-as-you-go/">Оплата по мере использования&lt;/a>&lt;/p>
&lt;p>Подписку можно рассматривать как границу между разными подписками, потенциально являющимися центрами затрат, но совершенно разными средами. Подписка — это место, где создаются ресурсы.&lt;/p>
&lt;h3 id="management-groups">Management Groups&lt;/h3>
&lt;p>Группы управления дают нам возможность разделять управление в нашей Azure AD или в нашей клиентской среде. Группы управления позволяют нам контролировать политики, &lt;a href="https://habr.com/ru/company/custis/blog/248649/">RBAC&lt;/a> (Role-based access control) и бюджеты.&lt;/p>
&lt;p>Подписки принадлежат этим группам управления, поэтому у вас может быть много подписок в вашем клиенте Azure AD. Эти подписки также могут управлять политиками, RBAC и бюджетами.&lt;/p>
&lt;h3 id="resource-manager-and-resource-groups">Resource Manager and Resource Groups&lt;/h3>
&lt;p>&lt;strong>Azure Resource Manager&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>API на основе JSON, основанный на поставщиках ресурсов.&lt;/li>
&lt;li>Ресурсы принадлежат группе ресурсов и имеют общий жизненный цикл.&lt;/li>
&lt;li>Параллелизм&lt;/li>
&lt;li>Развертывания на основе JSON являются декларативными, идемпотентными и понимают зависимости между ресурсами для управления созданием и порядком.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Resource Groups&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Каждый ресурс Azure Resource Manager существует в одной и только одной группе ресурсов!&lt;/li>
&lt;li>Группы ресурсов создаются в регионе, который может содержать ресурсы из-за пределов региона.&lt;/li>
&lt;li>Ресурсы можно перемещать между группами ресурсов&lt;/li>
&lt;li>Группы ресурсов не отгорожены от других групп ресурсов, между группами ресурсов может быть связь.&lt;/li>
&lt;li>Группы ресурсов также могут управлять политиками, RBAC и бюджетами.&lt;/li>
&lt;/ul>
&lt;h3 id="практика">Практика&lt;/h3>
&lt;p>Давайте подключимся и убедимся, что у нас есть &lt;strong>Подписка&lt;/strong>. Мы можем проверить нашу простую готовую &lt;strong>Группу управления&lt;/strong>. Затем мы можем пойти и создать новую выделенную &lt;strong>Группу ресурсов&lt;/strong> в предпочитаемом нами &lt;strong>Регионе&lt;/strong>.&lt;/p>
&lt;p>При первом входе на наш &lt;a href="https://portal.azure.com/#home">портал Azure&lt;/a> вверху вы увидите возможность поиска ресурсов, служб и документов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Сначала мы рассмотрим нашу подписку. Здесь вы увидите, что я использую подписку Visual Studio Professional, которая дает мне бесплатный &amp;ldquo;кредит&amp;rdquo; каждый месяц.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы углубимся в это, вы получите более широкое представление и посмотрите, что происходит или что можно сделать с подпиской, мы можем увидеть информацию о выставлении счетов с функциями управления слева, где вы можете определить контроль доступа к IAM, а ниже доступно больше ресурсов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Может возникнуть ситуация, когда у вас есть несколько подписок, и вы хотите управлять ими всеми в рамках одной, и именно здесь можно использовать группы управления для разделения групп ответственности. В моем ниже вы можете видеть, что есть только моя корневая группа арендатора с моей подпиской.&lt;/p>
&lt;p>Вы также увидите на предыдущем изображении, что родительская группа управления — это тот же идентификатор, который используется в корневой группе арендатора.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем у нас есть группы ресурсов, здесь мы объединяем наши ресурсы и можем легко управлять ими в одном месте. У меня есть несколько созданных для различных других проектов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Что мы собираемся делать в течение следующих нескольких дней, мы хотим создать нашу группу ресурсов. Это легко сделать в этой консоли, выбрав опцию создания на предыдущем изображении.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Происходит этап проверки, после чего у вас есть возможность просмотреть свое творение, а затем создать его. Вы также увидите внизу «Загрузить шаблон для автоматизации», это позволяет нам получить формат JSON, чтобы мы могли выполнить это просто автоматически позже, если мы захотим, мы также рассмотрим это позже.
&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Нажмите «Create», затем в нашем списке групп ресурсов у нас теперь есть группа «90DaysOfDevOps», готовая к тому, что мы будем делать в следующем сеансе.
&lt;p class="md__image">
&lt;img
src="../images/Day29_Cloud11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qkj5W98Xdvw">Hybrid Cloud and MultiCloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=NKEFWyqJ5XA&amp;amp;list=WL&amp;amp;index=130&amp;amp;t=12s">Microsoft Azure Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UGRDM86MBIQ&amp;amp;list=WL&amp;amp;index=131&amp;amp;t=10s">Google Cloud Digital Leader Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ulprqHHWlng&amp;amp;t=5352s">AWS Basics for Beginners - Full Course&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>30. Модули безопасности Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day30/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day30/</guid><description>&lt;h2 id="microsoft-azure-security-models">Microsoft Azure Security Models&lt;/h2>
&lt;p>Следуя обзору Microsoft Azure, мы начнем с безопасности Azure и посмотрим, как это может помочь в наши дни. По большей части я обнаружил, что встроенных ролей было достаточно, и зная это, мы можем создавать и работать со многими различными областями аутентификации и конфигураций. Я обнаружил, что Microsoft Azure довольно продвинута с ее инструментом &lt;a href="https://docs.microsoft.com/ru-ru/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">Active Directory&lt;/a> по сравнению с другими общедоступными облаками.&lt;/p>
&lt;p>Это одна из областей, в которой Microsoft Azure, по-видимому, работает иначе, чем другие поставщики общедоступных облаков, в Azure ВСЕГДА есть Azure AD.&lt;/p>
&lt;h3 id="службы-каталогов-directory-services-">Службы каталогов (Directory Services )&lt;/h3>
&lt;ul>
&lt;li>Azure Active Directory содержит принципы безопасности, используемые Microsoft Azure и другими облачными службами Microsoft.&lt;/li>
&lt;li>Аутентификация осуществляется с помощью таких протоколов, как SAML, WS-Federation, OpenID Connect и OAuth2.&lt;/li>
&lt;li>Запросы выполняются через REST API, который называется Microsoft Graph API.&lt;/li>
&lt;li>У арендаторов по умолчанию есть имя tenant.onmicrosoft.com, но они также могут иметь собственные доменные имена.&lt;/li>
&lt;li>Подписки связаны с арендатором Azure Active Directory.&lt;/li>
&lt;/ul>
&lt;p>Если мы сравним с AWS, эквивалентным предложением будет &lt;a href="https://aws.amazon.com/iam/">AWS IAM&lt;/a> (управление идентификацией и доступом), хотя все еще очень разные&lt;/p>
&lt;p>Azure AD Connect предоставляет возможность репликации учетных записей из AD в Azure AD. Сюда также могут входить группы и иногда объекты. Это может быть гранулировано и отфильтровано. Поддерживает несколько лесов и доменов.&lt;/p>
&lt;p>В Microsoft Azure Active Directory (AD) можно создавать облачные учетные записи, но большинство организаций уже учли своих пользователей в собственной локальной Active Directory.&lt;/p>
&lt;p>Azure AD Connect также позволяет вам видеть не только серверы Windows AD, но и другие Azure AD, Google и другие. Это также дает возможность сотрудничать с внешними людьми и организациями, что называется Azure B2B.&lt;/p>
&lt;p>Варианты аутентификации между доменными службами Active Directory и Microsoft Azure Active Directory возможны с синхронизацией удостоверений с хэшем пароля.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Передача хэша пароля необязательна, если он не используется, требуется сквозная аутентификация.&lt;/p>
&lt;p>Ниже приведено видео, в котором подробно рассказывается о сквозной аутентификации.&lt;/p>
&lt;p>&lt;a href="https://docs.microsoft.com/ru-ru/azure/active-directory/hybrid/how-to-connect-pta">User sign-in with Azure Active Directory Pass-through Authentication&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="федерации-federation">Федерации (Federation)&lt;/h3>
&lt;p>Справедливости ради стоит сказать, что если вы используете Microsoft 365, Microsoft Dynamics и локальную Active Directory, их довольно легко понять и интегрировать в Azure AD для федерации. Однако вы можете использовать другие службы за пределами экосистемы Microsoft.&lt;/p>
&lt;p>Azure AD может выступать в качестве посредника федерации для этих других приложений сторонних производителей и других служб каталогов.&lt;/p>
&lt;p>Это будет отображаться на портале Azure как корпоративные приложения, для которых существует большое количество вариантов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы прокрутите вниз страницу корпоративного приложения, вы увидите длинный список рекомендуемых приложений.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Эта опция также позволяет «принести свою» интеграцию, приложение, которое вы разрабатываете, или приложение, не являющееся галереей.&lt;/p>
&lt;p>Я не изучал это раньше, но вижу, что это вполне подходящий набор функций по сравнению с другими облачными провайдерами и возможностями.&lt;/p>
&lt;h3 id="управление-доступом-на-основе-ролей">Управление доступом на основе ролей&lt;/h3>
&lt;p>Мы уже рассмотрели в &lt;a href="../day29">День 29&lt;/a> области, которые мы собираемся охватить здесь, мы можем настроить управление доступом на основе ролей в соответствии с одной из этих областей.&lt;/p>
&lt;ul>
&lt;li>Subscriptions&lt;/li>
&lt;li>Management Group&lt;/li>
&lt;li>Resource Group&lt;/li>
&lt;li>Resources&lt;/li>
&lt;/ul>
&lt;p>Роли можно разделить на три, в Microsoft Azure много встроенных ролей. Эти три:&lt;/p>
&lt;ul>
&lt;li>Owner&lt;/li>
&lt;li>Contributor&lt;/li>
&lt;li>Reader&lt;/li>
&lt;/ul>
&lt;p>Владелец и участник очень похожи по своим границам, однако владелец может изменять разрешения.&lt;/p>
&lt;p>Другие роли относятся к определенным типам ресурсов Azure, а также к пользовательским ролям.&lt;/p>
&lt;p>Мы должны сосредоточиться на назначении разрешений группам и пользователям.&lt;/p>
&lt;p>Разрешения наследуются.&lt;/p>
&lt;p>Если мы вернемся назад и посмотрим на группу ресурсов «90DaysOfDevOps», которую мы создали, и проверим контроль доступа (IAM) внутри, вы увидите, что у нас есть список участников и администратор доступа пользователей клиента, и у нас есть список владельцев (но Я не могу это показать)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем проверить роли, которые мы назначили здесь, являются ли они встроенными ролями и к какой категории они относятся.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем использовать вкладку проверки доступа, если мы хотим проверить учетную запись по этой группе ресурсов и убедиться, что учетная запись, к которой мы хотим иметь этот доступ, имеет правильные разрешения, или, может быть, мы хотим проверить, не имеет ли пользователь слишком много доступа.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="microsoft-defender-for-cloud">Microsoft Defender for Cloud&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Microsoft Defender for Cloud (ранее известный как Azure Security Center) предоставляет информацию о безопасности всей среды Azure.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Единая панель мониторинга для просмотра общего состояния безопасности всех ресурсов Azure и других ресурсов (через Azure Arc) и рекомендации по усилению безопасности.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Уровень бесплатного пользования включает постоянную оценку и рекомендации по безопасности.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Платные планы для защищенных типов ресурсов (например, серверы, AppService, SQL, хранилище, контейнеры, KeyVault).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Я перешел на другую подписку для просмотра Центра безопасности Azure, и вы можете увидеть здесь, основываясь на очень небольшом количестве ресурсов, что у меня есть некоторые рекомендации в одном месте.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="azure-policy">Azure Policy&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Azure Policy — это собственная служба Azure, которая помогает применять организационные стандарты и оценивать соответствие в масштабе.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Интегрирован в Microsoft Defender для облака. Azure Policy проверяет несоответствующие ресурсы и применяет исправления.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Обычно используется для управления согласованностью ресурсов, соблюдением нормативных требований, безопасностью, стоимостью и стандартами управления.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Использует формат JSON для хранения логики оценки и определения того, соответствует ли ресурс требованиям или нет, а также любых действий, которые необходимо предпринять в случае несоответствия (например, аудит, аудит, если не существует, запретить, изменить, развернуть, если не существует).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Бесплатно для использования. Исключение составляют подключенные ресурсы Azure Arc, взимаемые за сервер в месяц за использование гостевой конфигурации политики Azure.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="практика">Практика&lt;/h3>
&lt;p>Я купил домен и хотел бы добавить этот на свой портал Azure Active Directory, &lt;a href="https://docs.microsoft.com/ru-ru/azure/active-directory/fundamentals/add-custom-domain">Add your custom domain name using the Azure Active Directory Portal&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем создать нового пользователя в нашем новом домене Active Directory.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы хотим создать группу для всех наших новых пользователей 90DaysOfDevOps в одной группе. Мы можем создать группу, как показано ниже, обратите внимание, что я использую «Динамический пользователь», это означает, что Azure AD будет запрашивать учетные записи пользователей и добавлять их динамически по сравнению с назначенными, когда вы вручную добавляете пользователя в свою группу.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Существует множество вариантов создания вашего запроса, мой план состоит в том, чтобы просто найти основное имя и убедиться, что оно содержит мой запрос.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, поскольку мы уже создали нашу учетную запись пользователя, мы можем проверить, работают ли правила. Для сравнения я также добавил здесь еще одну учетную запись, связанную с другим доменом, и вы можете видеть, что из-за этого правила наш пользователь не попадет в эту группу.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>С тех пор я добавил нового пользователя, и если мы пойдем и проверим группу, мы увидим наших участников.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если у нас есть это требование x100, то мы не собираемся делать все это в консоли, мы собираемся воспользоваться либо массовыми параметрами для создания, приглашения, удаления пользователей, либо вы захотите изучить &lt;a href="https://docs.microsoft.com/ru-ru/powershell/">PowerShell&lt;/a> для достичь этого автоматизированного подхода к масштабированию.&lt;/p>
&lt;p>Теперь мы можем перейти к нашей группе ресурсов и указать, что в группе ресурсов 90DaysOfDevOps мы хотим, чтобы владельцем была группа, которую мы только что создали.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем войти сюда и запретить доступ назначений к нашей группе ресурсов.&lt;/p>
&lt;p>Теперь, если мы войдем на портал Azure с нашей новой учетной записью пользователя, вы увидите, что у нас есть доступ только к нашей группе ресурсов 90DaysOfDevOps, а не к другим, показанным на предыдущих рисунках, потому что у нас нет доступа.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вышеприведенное замечательно, если это пользователь, имеющий доступ к ресурсам внутри вашего портала Azure, но не каждый пользователь должен знать о портале, но для проверки доступа мы можем использовать &lt;a href="https://myapps.microsoft.com/">Портал приложений&lt;/a> Это портал единого входа, который мы тестируем.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day30_Cloud17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете настроить этот портал под своим собственным брендом, и мы, возможно, вернемся к этому позже.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qkj5W98Xdvw">Hybrid Cloud and MultiCloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=NKEFWyqJ5XA&amp;amp;list=WL&amp;amp;index=130&amp;amp;t=12s">Microsoft Azure Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UGRDM86MBIQ&amp;amp;list=WL&amp;amp;index=131&amp;amp;t=10s">Google Cloud Digital Leader Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ulprqHHWlng&amp;amp;t=5352s">AWS Basics for Beginners - Full Course&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>31. Microsoft Azure Среда выполнения приложений</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day31/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day31/</guid><description>&lt;h2 id="среда-выполнения-приложений">Среда выполнения приложений&lt;/h2>
&lt;p>Вслед за вчерашним обзором основ моделей безопасности в Microsoft Azure, сегодня мы собираемся изучить различные службы вычислений, доступные нам в Azure.&lt;/p>
&lt;h3 id="параметры-службы-доступности">Параметры службы доступности&lt;/h3>
&lt;p>Этот раздел мне близок, учитывая мою роль в управлении данными. Как и в случае с локальной средой, очень важно обеспечить доступность ваших служб.&lt;/p>
&lt;ul>
&lt;li>Высокая доступность (Защита в пределах региона)&lt;/li>
&lt;li>Аварийное восстановление (Защита между регионами)&lt;/li>
&lt;li>Резервное копирование (Восстановление с момента времени)&lt;/li>
&lt;/ul>
&lt;p>Microsoft развертывает несколько регионов в пределах геополитических границ.&lt;/p>
&lt;p>Две концепции Azure для доступности услуг.&lt;/p>
&lt;p>Наборы доступности (виртуальных машин) — обеспечивают отказоустойчивость в центре обработки данных.&lt;/p>
&lt;p>Зоны доступности — обеспечивают отказоустойчивость между центрами обработки данных в пределах региона.&lt;/p>
&lt;h3 id="виртуальные-машины">Виртуальные машины&lt;/h3>
&lt;ul>
&lt;li>Предоставляет виртуальные машины различных серий и размеров с различными возможностями (иногда огромными) &lt;a href="https://docs.microsoft.com/ru-ru/azure/virtual-machines/sizes">Размеры виртуальных машин в Azure&lt;/a>&lt;/li>
&lt;li>Существует множество различных вариантов и фокусов для виртуальных машин, от высокопроизводительных, с малой задержкой до виртуальных машин с большим объемом памяти.&lt;/li>
&lt;li>У нас также есть расширяемый тип ВМ, который можно найти в серии B. Это отлично подходит для рабочих нагрузок, где у вас могут быть низкие требования к ЦП по большей части, но требуется, чтобы, возможно, один раз в месяц требовалась всплеск производительности.&lt;/li>
&lt;li>Виртуальные машины размещаются в виртуальной сети, которая может обеспечить подключение к любой сети.&lt;/li>
&lt;li>Поддержка гостевых ОС Windows и Linux.&lt;/li>
&lt;li>Существуют также ядра, настроенные для Azure, если речь идет о конкретных дистрибутивах Linux. &lt;a href="https://docs.microsoft.com/ru-ru/azure/virtual-machines/linux/endorsed-distros#azure-tuned-kernels">Ядра, настроенные Azure&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="шаблоны">Шаблоны&lt;/h3>
&lt;p>В Microsoft Azure шаблоны исполнений можно конфигурировать с помощью JSON.&lt;/p>
&lt;p>Существует несколько различных порталов и консолей управления, которые мы можем использовать для создания наших ресурсов. Предпочтительнее будет через шаблоны JSON.&lt;/p>
&lt;p>Идемпотентные развертывания в инкрементном или полном режиме — т.е. повторяемое желаемое состояние.&lt;/p>
&lt;p>Существует большой выбор шаблонов, которые могут экспортировать развернутые определения ресурсов. Мне нравится думать об этой функции шаблонов как о чем-то вроде AWS CloudFormation или, возможно, о Terraform для мультиоблачного варианта. Подробнее о Terraform мы расскажем в разделе «Инфраструктура как код».&lt;/p>
&lt;h3 id="масштабирование">Масштабирование&lt;/h3>
&lt;p>Автоматическое масштабирование — это крупная функция общедоступного облака, позволяющая сократить ресурсы, которые вы не используете, или активировать, когда они вам нужны.&lt;/p>
&lt;p>В Azure у нас есть так называемые масштабируемые наборы виртуальных машин (VMSS) для IaaS. Это позволяет автоматически создавать и масштабировать изображение золотого стандарта на основе расписаний и показателей.&lt;/p>
&lt;p>Это идеально подходит для обновления окон, чтобы вы могли обновлять свои образы и развертывать их с наименьшими последствиями.&lt;/p>
&lt;p>В другие службы, такие как службы приложений Azure, встроено автоматическое масштабирование.&lt;/p>
&lt;h3 id="контейнеры">Контейнеры&lt;/h3>
&lt;p>Мы не рассмотрели контейнеры как пример использования и то, что и как они могут и должны быть необходимы в нашем учебном путешествии по DevOps, но мы должны упомянуть, что у Azure есть некоторые конкретные службы, ориентированные на контейнеры, которые следует упомянуть.&lt;/p>
&lt;p>&lt;a href="https://azure.microsoft.com/ru-ru/services/kubernetes-service/">Служба Azure Kubernetes&lt;/a> (AKS) (Azure Kubernetes Service) — предоставляет управляемое решение Kubernetes.&lt;/p>
&lt;p>Экземпляры контейнеров Azure — контейнеры как услуга с посекундной оплатой. Запустите образ и интегрируйте его с вашей виртуальной сетью, не нуждаясь в оркестровке контейнеров.&lt;/p>
&lt;p>Service Fabric — имеет множество возможностей, но включает оркестрацию для экземпляров контейнеров.&lt;/p>
&lt;p>Azure также имеет реестр контейнеров, который предоставляет частный реестр для образов Docker, диаграмм &lt;a href="https://helm.sh/">Helm&lt;/a>, &lt;a href="https://docs.microsoft.com/ru-ru/azure/container-registry/container-registry-oci-artifacts">артефактов Open Container Initiative (OCI)&lt;/a> и образов. Подробнее об этом снова, когда мы дойдем до раздела контейнеров.&lt;/p>
&lt;p>Многие службы контейнеров действительно могут использовать контейнеры &amp;ldquo;под капотом&amp;rdquo;, но это абстрагируется от наших требований к управлению.&lt;/p>
&lt;h3 id="службы-приложений">Службы приложений&lt;/h3>
&lt;ul>
&lt;li>Службы приложений Azure предоставляют решение для размещения приложений, которое обеспечивает простой способ установки служб.&lt;/li>
&lt;li>Автоматическое развертывание и масштабирование.&lt;/li>
&lt;li>Поддерживает решения на базе Windows и Linux.&lt;/li>
&lt;li>Службы выполняются в плане службы приложений, который имеет тип и размер.&lt;/li>
&lt;li>Количество различных сервисов, включая веб-приложения, приложения API и мобильные приложения.&lt;/li>
&lt;li>Поддержка слотов развертывания для надежного тестирования и продвижения.&lt;/li>
&lt;/ul>
&lt;h3 id="бессерверные-вычисления">Бессерверные вычисления&lt;/h3>
&lt;p>Цель бессерверных вычислений заключается в том, что мы платим только за время выполнения функции, и нам не нужно постоянно запускать виртуальные машины или приложения PaaS. Мы просто запускаем нашу функцию, когда она нам нужна, а затем она исчезает.&lt;/p>
&lt;p>Функции Azure — предоставляет бессерверный код. Если мы вернемся к нашему первому взгляду на общедоступное облако, вы вспомните уровень абстракции управления, с бессерверными функциями вы будете управлять только кодом.&lt;/p>
&lt;p>У меня есть план, ориентированный на события в больших масштабах, когда я получу здесь немного практики, надеюсь, позже.&lt;/p>
&lt;p>Обеспечивает входную и выходную привязку ко многим Azure и сторонним службам.&lt;/p>
&lt;p>Поддерживает множество различных языков программирования. (C#, NodeJS, Python, PHP, bash, Golang, Rust или любой исполняемый файл)&lt;/p>
&lt;p>Сетка событий Azure позволяет запускать логику из служб и событий.&lt;/p>
&lt;p>Приложение Azure Logic обеспечивает графический рабочий процесс и интеграцию.&lt;/p>
&lt;p>Мы также можем рассмотреть пакетную службу Azure, которая может выполнять крупномасштабные задания на узлах Windows и Linux с согласованным управлением и планированием.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qkj5W98Xdvw">Hybrid Cloud and MultiCloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=NKEFWyqJ5XA&amp;amp;list=WL&amp;amp;index=130&amp;amp;t=12s">Microsoft Azure Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UGRDM86MBIQ&amp;amp;list=WL&amp;amp;index=131&amp;amp;t=10s">Google Cloud Digital Leader Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ulprqHHWlng&amp;amp;t=5352s">AWS Basics for Beginners - Full Course&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>32. Модели хранилища Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day32/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day32/</guid><description>&lt;h2 id="модели-хранилища">Модели хранилища&lt;/h2>
&lt;h3 id="службы-хранилища">Службы хранилища&lt;/h3>
&lt;ul>
&lt;li>Службы хранилища Azure предоставляются учетными записями хранения.&lt;/li>
&lt;li>Доступ к учетным записям хранения в основном осуществляется через REST API.&lt;/li>
&lt;li>Учетная запись хранения должна иметь уникальное имя, являющееся частью DNS-имени &lt;code>&amp;lt;Storage Account name&amp;gt;.core.windows.net&lt;/code>.&lt;/li>
&lt;li>Различные варианты репликации и шифрования.&lt;/li>
&lt;li>Находится в группе ресурсов&lt;/li>
&lt;/ul>
&lt;p>Мы можем создать нашу группу хранения, просто выполнив поиск группы хранения в строке поиска в верхней части портала Azure.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Затем мы можем выполнить шаги по созданию нашей учетной записи хранения, помня, что это имя должно быть уникальным, а также оно должно быть написано строчными буквами, без пробелов, но может включать цифры.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Мы также можем выбрать уровень избыточности, который мы хотели бы использовать для нашей учетной записи хранения и всего, что мы здесь храним. Чем дальше по списку, тем дороже вариант, но также и распространение ваших данных.&lt;/p>
&lt;p>Даже опция избыточности по умолчанию дает нам 3 копии наших данных.&lt;/p>
&lt;p>&lt;a href="https://docs.microsoft.com/ru-ru/azure/storage/common/storage-redundancy">Azure Storage Redundancy&lt;/a>&lt;/p>
&lt;p>Концепции из ссылки выше:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Локально-избыточное хранилище&lt;/strong> — трижды реплицирует ваши данные в пределах одного центра обработки данных в основном регионе.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Геоизбыточное хранилище&lt;/strong> — трижды синхронно копирует ваши данные в одном физическом расположении в основном регионе с помощью LRS.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Хранилище с избыточностью в пределах зоны&lt;/strong> — синхронно реплицирует данные службы хранилища Azure в трех зонах доступности Azure в основном регионе.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Хранилище с избыточностью в геозонах&lt;/strong> — сочетает в себе высокую доступность, обеспечиваемую избыточностью в зонах доступности, с защитой от региональных сбоев, обеспечиваемой георепликацией. Данные в учетной записи хранения GZRS копируются в три зоны доступности Azure в основном регионе, а также реплицируются во второй географический регион для защиты от региональных аварий.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Просто возвращаюсь к параметрам производительности. У нас есть Стандарт и Премиум на выбор. В нашем пошаговом руководстве мы выбрали «Стандартный», но «Премиум» дает вам некоторые специфические опции.
&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем в раскрывающемся списке вы можете увидеть, что у нас есть эти три варианта на выбор.
&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для учетной записи хранения доступно множество дополнительных параметров, но пока нам не нужно вдаваться в это. Эти параметры связаны с шифрованием и защитой данных.&lt;/p>
&lt;h3 id="управляемые-диски">Управляемые диски&lt;/h3>
&lt;p>Доступ к хранилищу можно получить несколькими способами.&lt;/p>
&lt;p>Аутентифицированный доступ через:&lt;/p>
&lt;ul>
&lt;li>Общий ключ для полного контроля.&lt;/li>
&lt;li>Shared Access Signature для делегированного, детализированного доступа.&lt;/li>
&lt;li>Azure Active Directory (где доступно)&lt;/li>
&lt;/ul>
&lt;p>Публичный доступ:&lt;/p>
&lt;ul>
&lt;li>Общий доступ также может быть предоставлен для включения анонимного доступа, в том числе через HTTP.
— Примером этого может быть размещение базового контента и файлов в блочном BLOB-объекте, чтобы браузер мог просматривать и скачивать эти данные.&lt;/li>
&lt;/ul>
&lt;p>Если вы получаете доступ к своему хранилищу из другой службы Azure, трафик остается в Azure.&lt;/p>
&lt;p>Когда дело доходит до производительности хранилища, у нас есть два разных типа:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Standard&lt;/strong> - Максимальное количество операций ввода-вывода в секунду&lt;/li>
&lt;li>&lt;strong>Premium&lt;/strong> - Гарантированное количество операций ввода-вывода в секунду&lt;/li>
&lt;/ul>
&lt;p>Существует также разница между неуправляемыми и управляемыми дисками, которую следует учитывать при выборе правильного хранилища для поставленной задачи.&lt;/p>
&lt;h3 id="хранилище-виртуальной-машины">Хранилище виртуальной машины&lt;/h3>
&lt;ul>
&lt;li>Диски ОС виртуальной машины обычно хранятся в постоянном хранилище.&lt;/li>
&lt;li>Некоторым рабочим нагрузкам без сохранения состояния не требуется постоянное хранилище, и уменьшение задержки является большим преимуществом.&lt;/li>
&lt;li>Существуют виртуальные машины, поддерживающие эфемерные управляемые диски ОС, созданные в локальном хранилище узла.
&lt;ul>
&lt;li>Их также можно использовать с масштабируемыми наборами виртуальных машин.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Управляемые диски — это надежное блочное хранилище, которое можно использовать с виртуальными машинами Azure. Вы можете иметь Ultra Disk Storage, Premium SSD, Standard SSD, Standard HDD. Они также несут некоторые характеристики.&lt;/p>
&lt;ul>
&lt;li>Поддержка снимков и изображений&lt;/li>
&lt;li>Простое перемещение между SKU&lt;/li>
&lt;li>Лучшая доступность в сочетании с наборами доступности&lt;/li>
&lt;li>Плата взимается в зависимости от размера диска, а не от использованного хранилища.&lt;/li>
&lt;/ul>
&lt;h2 id="хранилище-архивов">Хранилище архивов&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Cool Tier&lt;/strong> — доступен классный уровень хранилища для блокировки и добавления больших двоичных объектов.
&lt;ul>
&lt;li>Более низкая стоимость хранения&lt;/li>
&lt;li>Более высокая стоимость сделки.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Archive Tier&lt;/strong>* — Архивное хранилище доступно для блочных больших двоичных объектов.
&lt;ul>
&lt;li>Это настраивается для каждого BLOB-объекта.&lt;/li>
&lt;li>Более низкая стоимость, более длительная задержка поиска данных.&lt;/li>
&lt;li>Такая же надежность данных, как и в обычном хранилище Azure.&lt;/li>
&lt;li>Пользовательские уровни данных могут быть включены по мере необходимости.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="общий-доступ-к-файлам">Общий доступ к файлам&lt;/h3>
&lt;p>Из вышеописанного создания нашей учетной записи хранения теперь мы можем создавать общие файловые ресурсы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это обеспечит файловые ресурсы SMB2.1 и 3.0 в Azure.&lt;/p>
&lt;p>Можно использовать в Azure и извне через SMB3 и порт 445, открытый для Интернета.&lt;/p>
&lt;p>Предоставляет общее хранилище файлов в Azure.&lt;/p>
&lt;p>Можно сопоставить с помощью стандартных клиентов SMB в дополнение к REST API.&lt;/p>
&lt;p>Вы также можете почитать &lt;a href="https://vzilla.co.uk/vzilla-blog/azure-netapp-files-how">Azure NetApp Files&lt;/a> (SMB и NFS)&lt;/p>
&lt;h3 id="службы-кэширования-и-мультимедиа">Службы кэширования и мультимедиа&lt;/h3>
&lt;p>Сеть доставки содержимого Azure предоставляет кэш статического веб-содержимого с местоположениями по всему миру.&lt;/p>
&lt;p>Службы мультимедиа Azure предоставляют технологии транскодирования мультимедиа в дополнение к службам воспроизведения.&lt;/p>
&lt;h2 id="модели-баз-данных-microsoft-azure">Модели баз данных Microsoft Azure&lt;/h2>
&lt;p>Еще в &lt;a href="../day28">День 28&lt;/a> мы рассмотрели различные варианты обслуживания. Одним из них была PaaS (Platform as a Service) (платформа как услуга), где вы абстрагируете большую часть инфраструктуры и операционной системы, и вам остается контролировать приложение или, в данном случае, модели базы данных.&lt;/p>
&lt;h3 id="реляционные-базы-данных">Реляционные базы данных&lt;/h3>
&lt;p>База данных SQL Azure предоставляет реляционную базу данных как службу на основе Microsoft SQL Server.&lt;/p>
&lt;p>Это SQL, работающий с последней веткой SQL с доступным уровнем совместимости базы данных, где требуется конкретная версия функциональности.&lt;/p>
&lt;p>Есть несколько вариантов того, как это можно настроить: мы можем предоставить единую базу данных, которая предоставляет одну базу данных в экземпляре, в то время как эластичный пул позволяет использовать несколько баз данных, которые совместно используют пул емкости и совместно масштабируются.&lt;/p>
&lt;p>Доступ к этим экземплярам базы данных можно получить как к обычным экземплярам SQL.&lt;/p>
&lt;p>Дополнительные управляемые предложения для MySQL, PostgreSQL и MariaDB.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="решения-nosql">Решения NoSQL&lt;/h3>
&lt;p>Azure Cosmos DB — это реализация NoSQL, не зависящая от схемы.&lt;/p>
&lt;p>99,99% SLA&lt;/p>
&lt;p>Глобально распределенная база данных с однозначными задержками на 99-м процентиле в любой точке мира с автоматическим возвратом в исходное положение.&lt;/p>
&lt;p>Ключ раздела, используемый для разделения/разбиения/распределения данных.&lt;/p>
&lt;p>Поддерживает различные модели данных (документы, ключ-значение, график, удобный для столбцов)&lt;/p>
&lt;p>Поддерживает различные API (DocumentDB SQL, MongoDB, Azure Table Storage и Gremlin).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Доступны различные модели согласованности, основанные на &lt;a href="https://en.wikipedia.org/wiki/CAP_theorem">теореме CAP&lt;/a>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="кэширование">Кэширование&lt;/h3>
&lt;p>Не вдаваясь в подробности о системах кэширования, таких как Redis, я хотел добавить, что у Microsoft Azure есть служба под названием &lt;a href="https://azure.microsoft.com/ru-ru/services/cache/">Azure Cache for Redis&lt;/a>.&lt;/p>
&lt;p>Кэш Azure для Redis предоставляет хранилище данных в памяти на основе программного обеспечения Redis.&lt;/p>
&lt;ul>
&lt;li>Это реализация Redis Cache с открытым исходным кодом.
&lt;ul>
&lt;li>Размещенный безопасный экземпляр кэша Redis.&lt;/li>
&lt;li>Доступны разные уровни&lt;/li>
&lt;li>Приложение должно быть обновлено, чтобы использовать кеш.&lt;/li>
&lt;li>Предназначен для приложения, которое имеет высокие требования к чтению по сравнению с записью.&lt;/li>
&lt;li>На основе хранилища ключей-значений.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day32_Cloud10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я ценю, что за последние несколько дней было много заметок и теории о Microsoft Azure, но я хотел охватить строительные блоки, прежде чем мы перейдем к практическим аспектам того, как эти компоненты объединяются и работают.&lt;/p>
&lt;p>У нас есть еще немного теории, связанной с сетью, прежде чем мы сможем запустить и запустить некоторые основанные на сценариях развертывания сервисов. Мы также хотим взглянуть на некоторые различные способы взаимодействия с Microsoft Azure по сравнению с порталом, который мы использовали до сих пор.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qkj5W98Xdvw">Hybrid Cloud and MultiCloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=NKEFWyqJ5XA&amp;amp;list=WL&amp;amp;index=130&amp;amp;t=12s">Microsoft Azure Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UGRDM86MBIQ&amp;amp;list=WL&amp;amp;index=131&amp;amp;t=10s">Google Cloud Digital Leader Certification Course&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>33. Сетевые модели Microsoft Azure + Управление Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day33/</link><pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day33/</guid><description>&lt;p>Мы рассмотрим сетевые модели в Microsoft Azure и некоторые варианты управления для Azure. До сих пор мы использовали только платформу Azure, но упомянули и другие области, которые можно использовать для управления и создания наших ресурсов на платформе.&lt;/p>
&lt;h2 id="сетевые-модели-azure">Сетевые модели Azure&lt;/h2>
&lt;h3 id="виртуальные-сети">Виртуальные сети&lt;/h3>
&lt;ul>
&lt;li>Виртуальная сеть — это конструкция, созданная в Azure.&lt;/li>
&lt;li>Виртуальной сети назначен один или несколько диапазонов IP-адресов.&lt;/li>
&lt;li>Виртуальные сети живут в рамках подписки внутри региона.&lt;/li>
&lt;li>В виртуальной сети создаются виртуальные подсети для разбиения сетевого диапазона.&lt;/li>
&lt;li>Виртуальные машины размещаются в виртуальных подсетях.&lt;/li>
&lt;li>Все виртуальные машины в виртуальной сети могут обмениваться данными.&lt;/li>
&lt;li>65 536 частных IP-адресов на виртуальную сеть.&lt;/li>
&lt;li>Платите только за исходящий трафик из региона. (данные покидают регион)&lt;/li>
&lt;li>Поддерживаются IPv4 и IPv6.
&lt;ul>
&lt;li>IPv6 для общедоступных и внутри виртуальных сетей.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Мы можем сравнить &lt;a href="https://docs.microsoft.com/ru-ru/azure/virtual-network/virtual-networks-overview">виртуальные сети Azure&lt;/a> с &lt;a href="https://aws.amazon.com/ru/vpc/">AWS VPC&lt;/a>. Однако следует отметить некоторые отличия:&lt;/p>
&lt;ul>
&lt;li>В AWS создается виртуальная сеть по умолчанию, чего нет в Microsoft Azure, вам необходимо создать свою первую виртуальную сеть в соответствии с вашими требованиями.&lt;/li>
&lt;li>Все виртуальные машины в Azure по умолчанию имеют доступ к Интернету через NAT. Нет шлюзов NAT в соответствии с AWS.&lt;/li>
&lt;li>В Microsoft Azure нет понятия частных или общедоступных подсетей.&lt;/li>
&lt;li>Общедоступные IP-адреса — это ресурс, который может быть назначен виртуальным сетевым адаптерам или балансировщикам нагрузки.&lt;/li>
&lt;li>Виртуальная сеть и подсети имеют свои собственные списки управления доступом, позволяющие делегировать уровень подсети.&lt;/li>
&lt;li>Подсети в зонах доступности, тогда как в AWS у вас есть подсети для каждой зоны доступности.&lt;/li>
&lt;/ul>
&lt;p>У нас также есть &lt;a href="https://docs.microsoft.com/ru-ru/azure/virtual-network/virtual-network-peering-overview">виртуальный сетевой пиринг&lt;/a>. Пиринг между виртуальными сетями позволяет эффективно соединить две &lt;a href="https://docs.microsoft.com/ru-ru/azure/virtual-network/virtual-networks-overview">Виртуальные сети Azure&lt;/a>. После создания пиринговой связи две виртуальные сети выглядят как одна сеть в плане подключения. Точно так же трафик между виртуальными машинами в одноранговых виртуальных сетях использует магистральную инфраструктуру Майкрософт. Как и трафик между виртуальными машинами в одной сети, трафик направляется только через частную сеть корпорации Майкрософт.&lt;/p>
&lt;h3 id="контроль-доступа">Контроль доступа&lt;/h3>
&lt;ul>
&lt;li>Azure использует группы безопасности сети, они сохраняют состояние.&lt;/li>
&lt;li>Разрешить создавать правила, а затем назначать их группе безопасности сети.&lt;/li>
&lt;li>Группы безопасности сети применяются к подсетям или виртуальным машинам.&lt;/li>
&lt;li>При применении к подсети он по-прежнему применяется к сетевой карте виртуальной машины и не является &amp;ldquo;Edge&amp;rdquo; устройством.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Правила объединены в группу безопасности сети.&lt;/li>
&lt;li>В зависимости от приоритета возможны гибкие конфигурации.&lt;/li>
&lt;li>Более низкий номер приоритета означает высокий приоритет.&lt;/li>
&lt;li>Большая часть логики построена на IP-адресах, но также могут использоваться некоторые теги и метки.&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Description&lt;/th>
&lt;th>Priority&lt;/th>
&lt;th>Source Address&lt;/th>
&lt;th>Source Port&lt;/th>
&lt;th>Destination Address&lt;/th>
&lt;th>Destination Port&lt;/th>
&lt;th>Action&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Inbound 443&lt;/td>
&lt;td>1005&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>443&lt;/td>
&lt;td>Allow&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ILB&lt;/td>
&lt;td>1010&lt;/td>
&lt;td>Azure LoadBalancer&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>10000&lt;/td>
&lt;td>Allow&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Deny All Inbound&lt;/td>
&lt;td>4000&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;td>DENY&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>У нас также есть &lt;a href="https://docs.microsoft.com/ru-ru/azure/virtual-network/application-security-groups">группы безопасности приложений&lt;/a> (Application Security Groups) (ASG) .&lt;/p>
&lt;ul>
&lt;li>Где &lt;a href="https://docs.microsoft.com/ru-ru/azure/network-watcher/network-watcher-nsg-flow-logging-overview">журналы потоков групп безопасности&lt;/a>) (NSG) (Network Security Groups) сети сосредоточены на диапазонах IP-адресов, которые может быть сложно поддерживать для растущих сред.&lt;/li>
&lt;li>ASG позволяют определять настоящие имена (моникеры) для различных ролей приложений (веб-серверы, серверы БД, WebApp1 и т. д.).&lt;/li>
&lt;li>Сетевая карта виртуальной машины становится членом одной или нескольких групп ASG.&lt;/li>
&lt;/ul>
&lt;p>Затем группы ASG можно использовать в правилах, которые являются частью групп безопасности сети, для управления потоком связи и по-прежнему могут использовать функции NSG, такие как теги обслуживания.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Action&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Source&lt;/th>
&lt;th>Destination&lt;/th>
&lt;th>Port&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Allow&lt;/td>
&lt;td>AllowInternettoWeb&lt;/td>
&lt;td>Internet&lt;/td>
&lt;td>WebServers&lt;/td>
&lt;td>443(HTTPS)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Allow&lt;/td>
&lt;td>AllowWebToApp&lt;/td>
&lt;td>WebServers&lt;/td>
&lt;td>AppServers&lt;/td>
&lt;td>443(HTTPS)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Allow&lt;/td>
&lt;td>AllowAppToDB&lt;/td>
&lt;td>AppServers&lt;/td>
&lt;td>DbServers&lt;/td>
&lt;td>1443 (MSSQL)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Deny&lt;/td>
&lt;td>DenyAllinbound&lt;/td>
&lt;td>Any&lt;/td>
&lt;td>Any&lt;/td>
&lt;td>Any&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="балансировщики-нагрузки">Балансировщики нагрузки&lt;/h3>
&lt;p>Load Balancing. В Microsoft Azure есть два отдельных решения для балансировки нагрузки. (От Microsoft Azure и сторонние на маркетплейсе) Оба могут работать с внешними или внутренними конечными ендпоинтами.&lt;/p>
&lt;ul>
&lt;li>Балансировщик нагрузки (Layer 4), поддерживающий распределение на основе хэшей и переадресацию портов.&lt;/li>
&lt;li>Шлюз приложений (Layer 7) поддерживает такие функции, как разгрузка SSL, сопоставление сеансов на основе файлов cookie и маршрутизация контента на основе URL-адресов.&lt;/li>
&lt;/ul>
&lt;p>Кроме того, с помощью шлюза приложений вы можете дополнительно использовать компонент брандмауэра веб-приложения.&lt;/p>
&lt;h2 id="средства-управления-azure">Средства управления Azure&lt;/h2>
&lt;p>Мы потратили большую часть нашего теоретического времени на изучение портала Azure, я бы предположил, что когда дело доходит до следования культуре DevOps и обработки многих этих задач, особенно связанных с подготовкой, будет выполняться через API или инструмент командной строки. Я хотел коснуться некоторых из тех других инструментов управления, которые у нас есть, поскольку нам нужно знать это, когда мы автоматизируем подготовку наших сред Azure.&lt;/p>
&lt;h3 id="портал-azure">Портал Azure&lt;/h3>
&lt;p>Портал Microsoft Azure — это веб-консоль, которая представляет собой альтернативу инструментам командной строки. Вы можете управлять своими подписками на портале Azure. Создавайте, управляйте и контролируйте все, от простого веб-приложения до сложных облачных развертываний. Еще одна вещь, которую вы найдете на портале, — это хлебные крошки. JSON, как упоминалось ранее, является основой всех ресурсов Azure. Возможно, вы начнете с портала, чтобы понять функции, службы и функциональные возможности, а затем позже поймете JSON внизу, чтобы включить в ваши автоматизированные рабочие процессы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Существует также портал Azure Preview, который можно использовать для просмотра и тестирования новых и предстоящих услуг и улучшений.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="powershell">PowerShell&lt;/h3>
&lt;p>Прежде чем мы перейдем к Azure PowerShell, стоит сначала познакомиться с PowerShell. PowerShell — это среда автоматизации задач и управления конфигурацией, оболочка командной строки и язык сценариев. Мы могли бы и осмелились сказать это, сравнив это с тем, что мы рассмотрели в разделе Linux, посвященном сценариям оболочки. PowerShell впервые появился в ОС Windows, но теперь он кроссплатформенный.&lt;/p>
&lt;p>Azure PowerShell — это набор командлетов для управления ресурсами Azure непосредственно из командной строки PowerShell.&lt;/p>
&lt;p>При желании мы можеем подключиться к подписке с помощью команды PowerShell «Connect-AzAccount».&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Затем, если мы хотим найти некоторые конкретные команды, связанные с виртуальными машинами Azure, мы можем запустить следующую команду. Вы можете потратить часы на изучение и понимание этого языка программирования PowerShell.
&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Microsoft предлагает отличные краткие руководства по началу работы и подготовке служб из PowerShell &lt;a href="https://docs.microsoft.com/en-us/powershell/azure/get-started-azureps">здесь&lt;/a>&lt;/p>
&lt;h3 id="visual-studio-code">Visual Studio Code&lt;/h3>
&lt;p>Visual Studio Code — это бесплатный редактор исходного кода, созданный Microsoft для Windows, Linux и macOS.&lt;/p>
&lt;p>В Visual Studio Code встроено множество интеграций и инструментов, которые вы можете использовать для взаимодействия с Microsoft Azure и службами внутри.
&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="cloud-shell">Cloud Shell&lt;/h3>
&lt;p>Azure Cloud Shell — это интерактивная, аутентифицированная, доступная через браузер оболочка для управления ресурсами Azure. Это обеспечивает гибкость выбора оболочки, которая лучше всего подходит для вашей работы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как видно из рисунка ниже, когда мы впервые запускаем Cloud Shell на портале, мы можем выбирать между Bash и PowerShell.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы использовать облачную оболочку, вам нужно будет предоставить немного места в своей подписке.&lt;/p>
&lt;p>Когда вы выбираете использование облачной оболочки, она запускает компьютер, эти компьютеры являются временными, но ваши файлы сохраняются двумя способами; через образ диска и подключенный файловый обменник.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Cloud Shell работает на временном хосте, предоставляемом для каждого сеанса и каждого пользователя.&lt;/li>
&lt;li>Время ожидания Cloud Shell истекает через 20 минут без интерактивной активности.&lt;/li>
&lt;li>Cloud Shell требует подключения общего файлового ресурса Azure.
— Cloud Shell использует один и тот же файловый ресурс Azure как для Bash, так и для PowerShell.&lt;/li>
&lt;li>Cloud Shell назначается по одному компьютеру для каждой учетной записи пользователя.&lt;/li>
&lt;li>Cloud Shell сохраняет $HOME, используя образ размером 5 ГБ, хранящийся в вашей общей папке.&lt;/li>
&lt;li>Разрешения установлены как у обычного пользователя Linux в Bash&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://docs.microsoft.com/ru-ru/azure/cloud-shell/overview">Подробнее о Cloud Shell&lt;/a>&lt;/p>
&lt;h3 id="azure-cli">Azure CLI&lt;/h3>
&lt;p>Azure CLI можно установить в Windows, Linux и macOS. После установки вы можете ввести «az», а затем другие команды для создания, обновления, удаления и просмотра ресурсов Azure.&lt;/p>
&lt;p>Когда я впервые приступил к изучению Azure, меня немного смутило наличие Azure PowerShell и Azure CLI.&lt;/p>
&lt;p>Я также хотел бы получить отзывы от сообщества по этому поводу. Но я вижу, что Azure PowerShell — это модуль, добавленный в Windows PowerShell или PowerShell Core (также доступен в других ОС, но не во всех), тогда как Azure CLI — это кроссплатформенная программа командной строки, которая подключается к Azure и выполняет эти команды. .&lt;/p>
&lt;p>Обе эти опции имеют разный синтаксис, хотя, насколько я вижу и что я сделал, они могут выполнять очень похожие задачи.&lt;/p>
&lt;p>Например, для создания виртуальной машины из PowerShell будет использоваться командлет New-AzVM, а в Azure CLI — az VM create.&lt;/p>
&lt;p>Ранее вы видели, что в моей системе установлен модуль Azure PowerShell, но затем у меня также установлен Azure CLI, который можно вызывать через PowerShell на моем компьютере с Windows.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day33_Cloud10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вывод здесь, как мы уже упоминали, заключается в выборе правильного инструмента. Azure работает на основе автоматизации. Каждое действие, которое вы совершаете внутри портала, где-то преобразуется в код, выполняемый для чтения, создания, изменения или удаления ресурсов.&lt;/p>
&lt;h3 id="сравнение">Сравнение&lt;/h3>
&lt;h4 id="azure-cli-1">Azure CLI&lt;/h4>
&lt;ul>
&lt;li>Кроссплатформенный интерфейс командной строки, устанавливаемый на Windows, macOS, Linux&lt;/li>
&lt;li>Работает в Windows PowerShell, Cmd или Bash и других оболочках Unix.&lt;/li>
&lt;/ul>
&lt;h4 id="azure-powershell">Azure PowerShell&lt;/h4>
&lt;ul>
&lt;li>Кроссплатформенный модуль PowerShell, работает на Windows, macOS, Linux&lt;/li>
&lt;li>Требуется Windows PowerShell или PowerShell&lt;/li>
&lt;/ul>
&lt;p>Если по какой-то причине вы не можете использовать PowerShell в своей среде, но можете использовать .mdor bash, тогда Azure CLI будет вашим выбором.&lt;/p>
&lt;p>Завтра попробуем создать несколько сценариев и приступим к работе в Azure.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qkj5W98Xdvw">Hybrid Cloud and MultiCloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=NKEFWyqJ5XA&amp;amp;list=WL&amp;amp;index=130&amp;amp;t=12s">Microsoft Azure Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UGRDM86MBIQ&amp;amp;list=WL&amp;amp;index=131&amp;amp;t=10s">Google Cloud Digital Leader Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ulprqHHWlng&amp;amp;t=5352s">AWS Basics for Beginners - Full Course&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>34. Практические скрипты Microsoft Azure</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day34/</link><pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day34/</guid><description>&lt;h2 id="практические-скрипты-microsoft-azure">Практические скрипты Microsoft Azure&lt;/h2>
&lt;p>Последние 6 дней были сосредоточены на Microsoft Azure и общедоступном облаке в целом, большая часть этой основы должна была содержать много теории, чтобы понять строительные блоки Azure, но также это будет хорошо перенесено на других крупных облачных провайдеров. .&lt;/p>
&lt;p>В самом начале я упомянул о базовых знаний об общедоступном облаке и выборе одного провайдера, по крайней мере, для начала. Если вы танцуете между разными облаками, я считаю, что вы можете довольно легко заблудиться, тогда как выбрав одно, вы поймете основы. и когда они у вас есть, довольно легко прыгнуть в другие облака и ускорить свое обучение.&lt;/p>
&lt;p>На этом заключительном занятии я буду выбирать свои практические скрипты с этой страницы, которая является справочной информацией, созданной Microsoft и используемой для подготовки к &lt;a href="https://microsoftlearning.github.io/AZ-104-MicrosoftAzureAdministrator/">AZ-104 Администратор Microsoft Azure&lt;/a>&lt;/p>
&lt;p>Здесь есть некоторые из них, такие как контейнеры и Kubernetes, которые мы еще не рассмотрели подробно, поэтому я не хочу пока вдаваться в них.&lt;/p>
&lt;p>В предыдущих постах мы создали большинство модулей 1,2 и 3.&lt;/p>
&lt;h3 id="виртуальная-сеть">Виртуальная сеть&lt;/h3>
&lt;p>Мы пройдем пройти &lt;a href="https://microsoftlearning.github.io/AZ-104-MicrosoftAzureAdministrator/Instructions/Labs/LAB_04-Implement_Virtual_Networking.html">модуль 04&lt;/a>:&lt;/p>
&lt;p>Я прошел по инструкции и изменил несколько названий на #90DaysOfDevOps. Я также вместо использования Cloud Shell вошел в систему с моим новым пользователем, созданным в предыдущие дни с помощью Azure CLI на моем компьютере с Windows.&lt;/p>
&lt;p>Вы можете сделать это, используя &lt;code>az login&lt;/code>, который откроет браузер и позволит вам аутентифицировать свою учетную запись.&lt;/p>
&lt;p>Затем я создал сценарий PowerShell и несколько ссылок из модуля, чтобы использовать их для выполнения некоторых из приведенных ниже задач. Вы можете найти связанные файлы в этой папке.
(Облако\01Виртуальная сеть)&lt;/p>
&lt;details>
&lt;summary>
Mod04_90DaysOfDevOps-vms-loop-parameters.json
&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;$schema&amp;#34;: &amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;contentVersion&amp;#34;: &amp;#34;1.0.0.0&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;parameters&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;vmSize&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;value&amp;#34;: &amp;#34;Standard_D2s_v3&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;adminUsername&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;value&amp;#34;: &amp;#34;Student&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;adminPassword&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;value&amp;#34;: &amp;#34;Pa55w.rd1234&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/details>
&lt;details>
&lt;summary>
Mod04_90DaysOfDevOps-vms-loop-template.json
&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;$schema&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;contentVersion&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;1.0.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;parameters&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;vmSize&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;string&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;defaultValue&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Standard_D2s_v3&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;VM size&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;vmName&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;string&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;defaultValue&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;90day-vm&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;VM name Prefix&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;vmCount&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;int&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;defaultValue&amp;#34;&lt;/span>: &lt;span style="color:#40a070">2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Number of VMs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;adminUsername&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;string&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Admin username&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;adminPassword&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;securestring&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Admin password&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;virtualNetworkName&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;string&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;defaultValue&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;90daysofdevops&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;metadata&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Virtual network name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;variables&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;nic&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;90daysofdevops&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;virtualNetworkName&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[parameters(&amp;#39;virtualNetworkName&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;subnetName&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;subnet&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;subnet0Name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;subnet0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;subnet1Name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;subnet1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;computeApiVersion&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;2018-06-01&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;networkApiVersion&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;2018-08-01&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;resources&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[concat(parameters(&amp;#39;vmName&amp;#39;),copyIndex())]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;copy&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;VMcopy&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;count&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[parameters(&amp;#39;vmCount&amp;#39;)]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Microsoft.Compute/virtualMachines&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[variables(&amp;#39;computeApiVersion&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;location&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;comments&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Creating VMs&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;dependsOn&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;[concat(variables(&amp;#39;nic&amp;#39;),copyIndex())]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;osProfile&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;computerName&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[concat(parameters(&amp;#39;vmName&amp;#39;),copyIndex())]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;adminUsername&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[parameters(&amp;#39;adminUsername&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;adminPassword&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[parameters(&amp;#39;adminPassword&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;windowsConfiguration&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;provisionVmAgent&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;hardwareProfile&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;vmSize&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[parameters(&amp;#39;vmSize&amp;#39;)]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;storageProfile&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;imageReference&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;publisher&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;MicrosoftWindowsServer&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;offer&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;WindowsServer&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;sku&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;2019-Datacenter&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;latest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;osDisk&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;createOption&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;fromImage&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;dataDisks&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;networkProfile&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;networkInterfaces&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;primary&amp;#34;&lt;/span>: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[resourceId(&amp;#39;Microsoft.Network/networkInterfaces&amp;#39;, concat(variables(&amp;#39;nic&amp;#39;),copyIndex()))]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Microsoft.Network/virtualNetworks&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[variables(&amp;#39;virtualNetworkName&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[variables(&amp;#39;networkApiVersion&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;location&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;comments&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Virtual Network&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;addressSpace&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;addressPrefixes&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;10.40.0.0/22&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;subnets&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[variables(&amp;#39;subnet0Name&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;addressPrefix&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;10.40.0.0/24&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[variables(&amp;#39;subnet1Name&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;addressPrefix&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;10.40.1.0/24&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[concat(variables(&amp;#39;nic&amp;#39;),copyIndex())]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;copy&amp;#34;&lt;/span>:{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;nicCopy&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;count&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[parameters(&amp;#39;vmCount&amp;#39;)]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Microsoft.Network/networkInterfaces&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[variables(&amp;#39;networkApiVersion&amp;#39;)]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;location&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[resourceGroup().location]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;comments&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Primary NIC&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;dependsOn&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;[concat(&amp;#39;Microsoft.Network/virtualNetworks/&amp;#39;, variables(&amp;#39;virtualNetworkName&amp;#39;))]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;ipConfigurations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;ipconfig1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;subnet&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;[resourceId(&amp;#39;Microsoft.Network/virtualNetworks/subnets&amp;#39;, variables(&amp;#39;virtualNetworkName&amp;#39;), concat(variables(&amp;#39;subnetName&amp;#39;),copyIndex()))]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;privateIPAllocationMethod&amp;#34;&lt;/span>: &lt;span style="color:#4070a0">&amp;#34;Dynamic&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;outputs&amp;#34;&lt;/span>: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/details>
&lt;details>
&lt;summary>
Module4_90DaysOfDevOps.ps1
&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>$rgName = &amp;#39;90DaysOfDevOps&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>New-AzResourceGroupDeployment `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-ResourceGroupName $rgName `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-TemplateFile C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\01VirtualNetworking\Mod04_90DaysOfDevOps-vms-loop-template.json `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-TemplateParameterFile C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\01VirtualNetworking\Mod04_90DaysOfDevOps-vms-loop-parameters.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/details>
&lt;p>Убедитесь, что вы изменили расположение файла в скрипте в соответствии с вашей средой.&lt;/p>
&lt;p>На этом первом этапе у нас нет виртуальной сети или виртуальных машин, созданных в нашей среде, у меня есть только место хранения облачной оболочки, настроенное в моей группе ресурсов.&lt;/p>
&lt;p>Сначала я запускаю свой &lt;a href="https://github.com/MichaelCade/90DaysOfDevOps/blob/main/Days/Cloud/01VirtualNetworking/Module4_90DaysOfDevOps.ps1">скрипт в PowerShell&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-ps" data-lang="ps">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#06287e">$rgName&lt;/span> &lt;span style="color:#06287e">=&lt;/span> &lt;span style="color:#06287e">&amp;#39;90DaysOfDevOps&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#06287e">New-AzResourceGroupDeployment&lt;/span> &lt;span style="color:#06287e">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#06287e">-ResourceGroupName&lt;/span> &lt;span style="color:#06287e">$rgName&lt;/span> &lt;span style="color:#06287e">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#06287e">-TemplateFile&lt;/span> &lt;span style="color:#06287e">C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\01VirtualNetworking\Mod04_90DaysOfDevOps-vms-loop-template.json&lt;/span> &lt;span style="color:#06287e">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#06287e">-TemplateParameterFile&lt;/span> &lt;span style="color:#06287e">C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\01VirtualNetworking\Mod04_90DaysOfDevOps-vms-loop-parameters.json&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Задача 1: Создать и настроить виртуальную сеть&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Задача 2. Развернуть виртуальные машины в виртуальной сети.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Задача 3. Настройка частных и общедоступных IP-адресов виртуальных машин Azure.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Задача 4: Настройка групп безопасности сети&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 5. Настройка Azure DNS для внутреннего разрешения имен.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="управление-сетевым-трафиком">Управление сетевым трафиком&lt;/h3>
&lt;p>Переходим к &lt;a href="https://microsoftlearning.github.io/AZ-104-MicrosoftAzureAdministrator/Instructions/Labs/LAB_06-Implement_Network_Traffic_Management.html">модулю 06&lt;/a>:&lt;/p>
&lt;p>Для этого практического занятия я создал сценарий PowerShell и несколько ссылок из модуля, чтобы использовать их для создания некоторых из приведенных ниже задач.&lt;/p>
&lt;ul>
&lt;li>Задача 1: Обеспечение лабораторной среды&lt;/li>
&lt;/ul>
&lt;p>Запустим &lt;a href="https://github.com/MichaelCade/90DaysOfDevOps/blob/main/Days/Cloud/02TrafficManagement/Mod06_90DaysOfDevOps.ps1">PowerShell скрипт&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>$rgName = &amp;#39;90DaysOfDevOps&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>New-AzResourceGroupDeployment `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -ResourceGroupName $rgName `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -TemplateFile C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\02TrafficManagement\Mod06_90DaysOfDevOps-vms-loop-template.json `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -TemplateParameterFile C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\02TrafficManagement\Mod06_90DaysOfDevOps-vms-loop-parameters.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $location = (Get-AzResourceGroup -ResourceGroupName $rgName).location
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $vmNames = (Get-AzVM -ResourceGroupName $rgName).Name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foreach ($vmName in $vmNames) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set-AzVMExtension `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -ResourceGroupName $rgName `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Location $location `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -VMName $vmName `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Name &amp;#39;networkWatcherAgent&amp;#39; `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Publisher &amp;#39;Microsoft.Azure.NetworkWatcher&amp;#39; `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Type &amp;#39;NetworkWatcherAgentWindows&amp;#39; `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -TypeHandlerVersion &amp;#39;1.4&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Задача 2. Настройка топологии узловой сети
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Задача 3. Проверка транзитивности пиринга виртуальной сети.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Для этого моя группа 90DaysOfDevOps не имела доступа к Network Watcher из-за разрешений, я ожидаю, что это связано с тем, что Network Watcher — это один из тех ресурсов, которые не привязаны к группе ресурсов, где наш RBAC был покрыт для этого пользователя. Я добавил в группу 90DaysOfDevOps роль участника Network Watcher из восточной части США.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;blockquote>
&lt;p>Это ожидаемо, поскольку виртуальные сети с двумя лучами не связаны друг с другом (пиринг виртуальных сетей не является транзитивным).&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>Задача 4. Настройка маршрутизации в топологии «концентратор-луч».&lt;/li>
&lt;/ul>
&lt;p>У меня была еще одна проблема: моя учетная запись не могла запустить скрипт от имени моего пользователя в группе 90DaysOfDevOps, в чем я не уверен, поэтому я вернулся в свою основную учетную запись администратора. Группа 90DaysOfDevOps является владельцем всего в группе ресурсов 90DaysOfDevOps, поэтому хотелось бы понять, почему я не могу запустить команду внутри виртуальной машины?&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Task 5: Подключаем Azure Load Balancer&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Task 6: Подключаем Azure Application Gateway&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="хранищиле-azure">Хранищиле Azure&lt;/h3>
&lt;p>Переходим к &lt;a href="https://microsoftlearning.github.io/AZ-104-MicrosoftAzureAdministrator/Instructions/Labs/LAB_07-Manage_Azure_Storage.html">модулю 07&lt;/a>:&lt;/p>
&lt;p>Для этого практического занятия я также создал сценарий PowerShell и несколько ссылок из модуля, чтобы использовать их для создания некоторых из приведенных ниже задач.&lt;/p>
&lt;ul>
&lt;li>Задача 1: Обеспечение лабораторной среды&lt;/li>
&lt;/ul>
&lt;p>Сначала запускаем PowerShell script&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-ps1" data-lang="ps1">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bb60d5">$rgName&lt;/span> = &lt;span style="color:#4070a0">&amp;#39;90DaysOfDevOps&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">New-AzResourceGroupDeployment&lt;/span> `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -ResourceGroupName &lt;span style="color:#bb60d5">$rgName&lt;/span> `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -TemplateFile C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\03Storage\&lt;span style="color:#007020">Mod07_90DaysOfDevOps-vm&lt;/span>-template.json `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -TemplateParameterFile C:\Users\micha\demo\90DaysOfDevOps\Days\Cloud\03Storage\&lt;span style="color:#007020">Mod07_90DaysOfDevOps-vm&lt;/span>-parameters.json `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -AsJob
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;details>
&lt;summary>Файл `Mod07_90DaysOfDevOps-vm-template.json`&lt;/summary>
```
{
"$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
"contentVersion": "1.0.0.0",
"parameters": {
"vmSize": {
"type": "string",
"defaultValue": "Standard_D2s_v3",
"metadata": {
"description": "Virtual machine size"
}
},
"adminUsername": {
"type": "string",
"metadata": {
"description": "Admin username"
}
},
"adminPassword": {
"type": "securestring",
"metadata": {
"description": "Admin password"
}
}
},
"variables": {
"vmName": "90Days-vm0",
"nicName": "90Days-nic0",
"virtualNetworkName": "90Days-vnet0",
"publicIPAddressName": "90Days-pip0",
"nsgName": "90Days-nsg0",
"vnetIpPrefix": "10.70.0.0/22",
"subnetIpPrefix": "10.70.0.0/24",
"subnetName": "subnet0",
"subnetRef": "[resourceId('Microsoft.Network/virtualNetworks/subnets', variables('virtualNetworkName'), variables('subnetName'))]",
"computeApiVersion": "2018-06-01",
"networkApiVersion": "2018-08-01"
},
"resources": [
{
"name": "[variables('vmName')]",
"type": "Microsoft.Compute/virtualMachines",
"apiVersion": "[variables('computeApiVersion')]",
"location": "[resourceGroup().location]",
"dependsOn": [
"[variables('nicName')]"
],
"properties": {
"osProfile": {
"computerName": "[variables('vmName')]",
"adminUsername": "[parameters('adminUsername')]",
"adminPassword": "[parameters('adminPassword')]",
"windowsConfiguration": {
"provisionVmAgent": "true"
}
},
"hardwareProfile": {
"vmSize": "[parameters('vmSize')]"
},
"storageProfile": {
"imageReference": {
"publisher": "MicrosoftWindowsServer",
"offer": "WindowsServer",
"sku": "2019-Datacenter",
"version": "latest"
},
"osDisk": {
"createOption": "fromImage"
},
"dataDisks": []
},
"networkProfile": {
"networkInterfaces": [
{
"properties": {
"primary": true
},
"id": "[resourceId('Microsoft.Network/networkInterfaces', variables('nicName'))]"
}
]
}
}
},
{
"type": "Microsoft.Network/virtualNetworks",
"name": "[variables('virtualNetworkName')]",
"apiVersion": "[variables('networkApiVersion')]",
"location": "[resourceGroup().location]",
"comments": "Virtual Network",
"properties": {
"addressSpace": {
"addressPrefixes": [
"[variables('vnetIpPrefix')]"
]
},
"subnets": [
{
"name": "[variables('subnetName')]",
"properties": {
"addressPrefix": "[variables('subnetIpPrefix')]"
}
}
]
}
},
{
"name": "[variables('nicName')]",
"type": "Microsoft.Network/networkInterfaces",
"apiVersion": "[variables('networkApiVersion')]",
"location": "[resourceGroup().location]",
"comments": "Primary NIC",
"dependsOn": [
"[variables('publicIpAddressName')]",
"[variables('nsgName')]",
"[variables('virtualNetworkName')]"
],
"properties": {
"ipConfigurations": [
{
"name": "ipconfig1",
"properties": {
"subnet": {
"id": "[variables('subnetRef')]"
},
"privateIPAllocationMethod": "Dynamic",
"publicIpAddress": {
"id": "[resourceId('Microsoft.Network/publicIpAddresses', variables('publicIpAddressName'))]"
}
}
}
],
"networkSecurityGroup": {
"id": "[resourceId('Microsoft.Network/networkSecurityGroups', variables('nsgName'))]"
}
}
},
{
"name": "[variables('publicIpAddressName')]",
"type": "Microsoft.Network/publicIpAddresses",
"apiVersion": "[variables('networkApiVersion')]",
"location": "[resourceGroup().location]",
"comments": "Public IP for Primary NIC",
"properties": {
"publicIpAllocationMethod": "Dynamic"
}
},
{
"name": "[variables('nsgName')]",
"type": "Microsoft.Network/networkSecurityGroups",
"apiVersion": "[variables('networkApiVersion')]",
"location": "[resourceGroup().location]",
"comments": "Network Security Group (NSG) for Primary NIC",
"properties": {
"securityRules": [
{
"name": "default-allow-rdp",
"properties": {
"priority": 1000,
"sourceAddressPrefix": "*",
"protocol": "Tcp",
"destinationPortRange": "3389",
"access": "Allow",
"direction": "Inbound",
"sourcePortRange": "*",
"destinationAddressPrefix": "*"
}
}
]
}
}
],
"outputs": {}
}
```
&lt;/details>
&lt;details>
&lt;summary>Файл `Mod07_90DaysOfDevOps-vm-parameters.json`&lt;/summary>
```
{
"$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
"contentVersion": "1.0.0.0",
"parameters": {
"vmSize": {
"value": "Standard_D2s_v3"
},
"adminUsername": {
"value": "Student"
},
"adminPassword": {
"value": "Pa55w.rd1234"
}
}
}
```
&lt;/details>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 2. Создание и настройка учетных записей хранения Azure.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 3. Управление хранилищем BLOB-объектов&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 4. Управление проверкой подлинности и авторизацией для службы хранилища Azure.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud24.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud25.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я был немного нетерпелив, ожидая, что это все сработает, но в конце концов это сработало.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud26.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 5. Создание и настройка общих папок Azure Files.&lt;/li>
&lt;/ul>
&lt;p>В команде запуска это не сработает с &lt;a href="mailto:michael.cade@90DaysOfDevOps.com">michael.cade@90DaysOfDevOps.com&lt;/a>, поэтому я использовал свою учетную запись с повышенными правами.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud27.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud28.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud29.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 6. Управление сетевым доступом для службы хранилища Azure.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud30.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="serverless-внедрение-веб-приложений">Serverless (внедрение веб-приложений)&lt;/h3>
&lt;p>Переходим к &lt;a href="https://microsoftlearning.github.io/AZ-104-MicrosoftAzureAdministrator/Instructions/Labs/LAB_09a-Implement_Web_Apps.html">модулю 09a&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>Задача 1. Создание веб-приложения Azure.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud31.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 2. Создание промежуточного слота развертывания.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud34.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 3. Настройка параметров развертывания веб-приложений.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud33.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 4. Развертывание кода в промежуточном слоте развертывания.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud32.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 5: Поменять промежуточные слоты местами&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud35.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;ul>
&lt;li>Задача 6. Настройка и тестирование автоматического масштабирования веб-приложения Azure.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>$rgName = &amp;#39;90DaysOfDevOps&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$webapp = Get-AzWebApp -ResourceGroupName $rgName
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#The following following will start an infinite loop that sends the HTTP requests to the web app
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>while ($true) { Invoke-WebRequest -Uri $webapp.DefaultHostName }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day34_Cloud36.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На этом мы завершаем раздел о Microsoft Azure и public cloud в целом.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qkj5W98Xdvw">Hybrid Cloud and MultiCloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=NKEFWyqJ5XA&amp;amp;list=WL&amp;amp;index=130&amp;amp;t=12s">Microsoft Azure Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=UGRDM86MBIQ&amp;amp;list=WL&amp;amp;index=131&amp;amp;t=10s">Google Cloud Digital Leader Certification Course&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Далее мы углубимся в системы контроля версий, особенно в git, а затем также рассмотрим обзоры репозиториев кода, и мы выберем GitHub, так как это мой предпочтительный вариант.&lt;/p></description></item><item><title>35. Git — контроль версий</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day35/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day35/</guid><description>&lt;h2 id="общая-картина-git--контроль-версий">Общая картина: Git — контроль версий&lt;/h2>
&lt;p>Прежде чем мы перейдем к git, нам нужно понять, что такое контроль версий? В этой статье мы рассмотрим, что такое контроль версий и основы git.&lt;/p>
&lt;h3 id="что-такое-контроль-версий">Что такое контроль версий?&lt;/h3>
&lt;p>Git — не единственная система контроля версий, поэтому рассмотрим, какие варианты и какие методологии доступны для контроля версий.&lt;/p>
&lt;p>Наиболее очевидным и большим преимуществом контроля версий является возможность отслеживать историю проекта. Мы можем посмотреть на этот репозиторий с помощью &lt;code>git log&lt;/code> и увидеть, что у нас есть много коммитов и много комментариев, а также то, что произошло на данный момент в проекте. Не волнуйтесь, мы перейдем к командам позже. А теперь подумайте, если бы это был настоящий программный проект, полный исходного кода, и несколько человек в разное время принимают участие в нашем программном обеспечении, разные авторы, а затем и рецензенты, все регистрируются здесь, чтобы мы знали, что произошло, когда, кем и кто рецензировал.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Управление версиями, прежде чем это стало крутым, было чем-то вроде ручного создания копии вашей версии, прежде чем вы вносили изменения. Возможно, вы также закомментируете старый бесполезный код на всякий случай.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Тем не менее, &lt;strong>Управление версиями не является резервной копией!&lt;/strong>&lt;/p>
&lt;p>Еще одним преимуществом контроля версий является возможность управления несколькими версиями проекта. Давайте создадим пример, у нас есть бесплатное приложение, доступное во всех операционных системах, а затем у нас есть платное приложение, также доступное во всех операционных системах. БОльшая часть кода используется обоими приложениями. Мы могли бы копировать и вставлять наш код при каждом коммите в каждое приложение, но это будет очень грязно, особенно если вы масштабируете свою разработку более чем на одного человека, а также будут допущены ошибки.&lt;/p>
&lt;p>В премиум-приложении у нас будут дополнительные функции, назовем их премиальными коммитами, бесплатная версия будет содержать только обычные коммиты.&lt;/p>
&lt;p>Способ, которым это достигается в системе управления версиями, — это ветвление (branching).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Ветвление позволяет использовать два потока кода для одного и того же приложения, как мы указали выше. Но мы по-прежнему хотим, чтобы новые функции, которые появляются в нашей бесплатной версии исходного кода, были в нашей премиум-версии, и для этого у нас есть то, что называется слиянием.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь это такое же простое, но слияние может быть сложным, потому что у вас может быть команда, работающая над бесплатной версией, и другая команда, работающая над платной премиальной версией, и что, если обе они изменят код, который влияет на аспекты общего кода. Может быть, переменная обновляется и что-то ломает. Тогда у вас есть конфликт, который нарушает одну из функций. Контроль версий не может устранить конфликты, которые зависят от вас. Но контроль версий позволяет легко управлять этим.&lt;/p>
&lt;p>Основная причина, по которой вы до сих пор не взялись за управление версиями, — это возможность совместной работы. Возможность делиться кодом между разработчиками, и когда я говорю код, как я уже говорил раньше, все чаще и чаще мы видим гораздо больше вариантов использования по другим причинам для использования системы управления версиями, может быть, это совместная презентация, над которой вы работаете с коллегой, или вызов 90DaysOfDevOps. где у вас есть сообщество, предлагающее свои исправления и обновления на протяжении всего проекта.&lt;/p>
&lt;p>Без контроля версий, как команды разработчиков программного обеспечения вообще справлялись с этим? Когда я работаю над своими проектами, мне достаточно трудно следить за вещами. Я ожидаю, что они разделят код на каждый функциональный модуль. Возможно, небольшая часть головоломки заключалась в том, чтобы собрать воедино кусочки, а затем решить проблемы и проблемы, прежде чем что-либо было выпущено.&lt;/p>
&lt;p>С контролем версий у нас есть единственный источник правды. Мы все еще можем работать над разными модулями, но это позволяет нам лучше взаимодействовать.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Еще одна вещь, которую следует упомянуть здесь, это то, что не только разработчики могут извлечь выгоду из контроля версий. Все члены команды должны иметь представление, но также и инструменты управления проектом и т.д.
У нас также может быть build машина, например Jenkins, о которой мы поговорим в другом модуле. Зада подобных инструментов - создать и упаковывать систему, автоматизируя тесты и предоставляя метрики.&lt;/p>
&lt;h3 id="что-такое-git">Что такое Git?&lt;/h3>
&lt;p>Git — это инструмент, который отслеживает изменения в исходном коде или любом файле, или мы могли бы также сказать, что Git — это распределенная система контроля версий с открытым исходным кодом.&lt;/p>
&lt;p>Есть много способов, которыми git можно использовать в наших системах, чаще всего или, по крайней мере, для меня я видел его в командной строке, но у нас также есть графические пользовательские интерфейсы и инструменты, такие как Visual Studio Code, которые имеют операции с поддержкой git, которые мы может воспользоваться.&lt;/p>
&lt;p>Теперь мы пройдемся по общему обзору еще до того, как установим Git на нашу локальную машину.&lt;/p>
&lt;p>Возьмем папку, которую мы создали ранее.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы использовать эту папку с контролем версий, нам сначала нужно инициировать этот каталог с помощью команды `git init. А пока представьте, что эта команда помещает наш каталог в качестве репозитория в базу данных где-то на нашем компьютере.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем создать несколько файлов и папок, и наш исходный код может начаться, или, может быть, он уже есть, и у нас уже есть что-то здесь. Мы можем использовать команду &lt;code>git add .&lt;/code>, которая помещает все файлы и папки в нашем каталоге в снимок, но мы еще ничего не зафиксировали в этой базе данных. Мы просто говорим, что все файлы с &lt;code>.&lt;/code> готовы к добавлению.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы хотим продолжить и зафиксировать наши файлы, мы делаем это с помощью команды &lt;code>git commit -m &amp;quot;My First Commit&amp;quot;&lt;/code>. Мы можем указать причину нашей фиксации, и это предлагается, чтобы мы знали, что произошло для каждой фиксации.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем увидеть, что произошло в истории проекта. С помощью команды &lt;code>git log&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем проверить состояние нашего репозитория с помощью &lt;code>git status&lt;/code>, это показывает, что нам нечего коммитить, и мы можем добавить новый файл с именем samplecode.ps1. Если мы затем запустим тот же статус `git, вы увидите, что мы файл для фиксации.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Добавьте наш новый файл с помощью команды &lt;code>git add samplecode.ps1&lt;/code>, а затем мы снова запустим &lt;code>git status&lt;/code> и увидим, что наш файл готов к фиксации.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем выполните команду git commit -m &amp;ldquo;My Second Commit&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Другой &lt;code>git status&lt;/code> теперь показывает, что все снова чисто.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем использовать команду &lt;code>git log&lt;/code>, которая показывает последние изменения и первую фиксацию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы хотим увидеть изменения между нашими коммитами, то есть какие файлы были добавлены или изменены, мы можем использовать &lt;code>git diff b8f8 709a&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем отображается то, что изменилось, в нашем случае мы добавили новый файл.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем, и мы углубимся в это позже, но мы можем прыгать вокруг наших коммитов, то есть мы можем путешествовать во времени! Используя наш номер фиксации, мы можем использовать команду &lt;code>git checkout 709a&lt;/code>, чтобы вернуться назад во времени, не теряя наш новый файл.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Но в равной степени мы также захотим двигаться вперед, и мы можем сделать это таким же образом с номером коммита, или вы можете видеть здесь, что мы используем команду &lt;code>git switch -&lt;/code>, чтобы отменить нашу операцию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day35_Git18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;a href="https://ru.wikipedia.org/wiki/TL;DR">TLDR&lt;/a>;&lt;/p>
&lt;ul>
&lt;li>Отслеживание истории проектов&lt;/li>
&lt;li>Управление несколькими версиями проекта&lt;/li>
&lt;li>Обмен кодом между разработчиками и более широкий круг команд и инструментов&lt;/li>
&lt;li>Координация работы в команде&lt;/li>
&lt;/ul>
&lt;p>Это могло показаться прыжком, но, надеюсь, вы можете увидеть, даже не зная, что команды использовали возможности и общую картину, лежащую в основе контроля версий.&lt;/p>
&lt;p>Далее мы установим и настроим git на вашем локальном компьютере и немного углубимся в некоторые другие варианты использования и команды, которые мы можем реализовать в Git.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Yc8sCSeMhi4">What is Version Control?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kr62e_n6QuQ">Types of Version Control System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8JJ101D3knE&amp;amp;t=52s">Git Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Uszj_k0DGsg">Git for Professionals Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RGOj5yH7evk&amp;amp;t=8s">Git and GitHub for Beginners - Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=apGV9Kg7ics">Complete Git and GitHub Tutorial&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>36. Установка и настройка Git</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day36/</link><pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day36/</guid><description>&lt;h2 id="установка-и-настройка-git">Установка и настройка Git&lt;/h2>
&lt;p>Git — это кроссплатформенный инструмент с открытым исходным кодом для контроля версий. Если я нравлюсь вам, вы используете Ubuntu или большинство сред Linux, вы можете обнаружить, что у вас уже установлен git, но мы собираемся выполнить установку и настройку.&lt;/p>
&lt;p>Даже если у вас уже установлен git в вашей системе, также рекомендуется убедиться, что мы в курсе последних событий.&lt;/p>
&lt;h3 id="установка-git">Установка Git&lt;/h3>
&lt;p>Мы будем работать с Windows и Linux, но вы также можете найти macOS в списке &lt;a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">здесь&lt;/a>&lt;/p>
&lt;p>Для &lt;a href="https://git-scm.com/download/win">Windows&lt;/a> мы можем загрузить наши установщики с официального сайта.&lt;/p>
&lt;p>Вы также можете использовать &lt;code>winget&lt;/code> на своем компьютере с Windows, думайте об этом как о своем диспетчере пакетов приложений Windows.&lt;/p>
&lt;p>Прежде чем мы что-либо установим, давайте посмотрим, какая версия у нас есть на нашей машине с Windows. Откройте окно PowerShell и запустите &lt;code>git --version&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем проверить нашу версию Git для Ubuntu.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Загружаем последнюю версию установщика. Важно отметить, что git удалит предыдущие версии перед установкой последней.&lt;/p>
&lt;p>Это означает, что процесс, показанный ниже, по большей части такой же, как если бы вы устанавливали не из git.&lt;/p>
&lt;p>Это очень простая установка. После загрузки дважды щелкните и начните. Прочтите лицензионное соглашение GNU. Но помните, что это бесплатное программное обеспечение с открытым исходным кодом.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем выбрать дополнительные компоненты, которые мы хотели бы также установить, но также связать с git. В Windows я всегда устанавливаю Git Bash, так как это позволяет нам запускать сценарии bash в Windows.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем выбрать, какой исполняемый файл SSH мы хотим использовать. IN оставьте это как пакетный OpenSSH, который вы могли видеть в разделе Linux.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем у нас есть экспериментальные функции, которые мы можем захотеть включить, мне они не нужны, поэтому я не включаю, вы всегда можете вернуться во время установки и включить их позже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Установка завершена, теперь мы можем открыть Git Bash или последние примечания к выпуску.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Последняя проверка — посмотреть в нашем окне PowerShell, какая у нас сейчас версия git.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Супер простые вещи, и теперь мы на последней версии. На нашей машине с Linux мы немного отстали, поэтому мы также можем пройти этот процесс обновления.&lt;/p>
&lt;p>Я просто запускаю команду &lt;code>sudo apt-get install git&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы также можете запустить следующее, которое добавит репозиторий git для установки программного обеспечения.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>sudo add-apt-repository ppa:git-core/ppa -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install git -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="настройка-git">Настройка Git&lt;/h3>
&lt;p>Когда мы впервые используем git, нам нужно определить некоторые настройки,&lt;/p>
&lt;ul>
&lt;li>Имя&lt;/li>
&lt;li>Эл. адрес&lt;/li>
&lt;li>Редактор по умолчанию&lt;/li>
&lt;li>Окончание строки&lt;/li>
&lt;/ul>
&lt;p>Это можно сделать на трех уровнях&lt;/p>
&lt;ul>
&lt;li>System = Все пользователи&lt;/li>
&lt;li>Global = все репозитории текущего пользователя&lt;/li>
&lt;li>Local = текущий репозиторий&lt;/li>
&lt;/ul>
&lt;p>Пример:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git config --global user.name &lt;span style="color:#4070a0">&amp;#34;My Name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git config --global user.email email@example.com&lt;span style="color:#4070a0">&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В зависимости от вашей операционной системы будет определять текстовый редактор по умолчанию. На моей машине с Ubuntu без настройки следующая команда использует Тano. Приведенная ниже команда изменит это на код Visual Studio.&lt;/p>
&lt;p>&lt;code>git config --global core.editor &amp;quot;code --wait&amp;quot;&lt;/code>&lt;/p>
&lt;p>Чтобы увидеть всю конфигурацию git, мы можем использовать команду &lt;code>git config --global -e&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На любом компьютере этот файл будет называться &lt;code>.gitconfig&lt;/code>, на моем компьютере с Windows вы найдете его в каталоге своей учетной записи пользователя.
&lt;p class="md__image">
&lt;img
src="../images/Day36_Git11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="теория-git">Теория Git&lt;/h3>
&lt;p>Я упомянул во вчерашнем посте, что существуют и другие типы контроля версий, и мы можем разделить их на два разных типа. Один клиент-сервер, а другой распределенный.&lt;/p>
&lt;h3 id="клиент-серверный-контроль-версий">Клиент-серверный контроль версий&lt;/h3>
&lt;p>До появления git клиент-сервер был де-факто методом контроля версий. Примером этого может быть &lt;a href="https://subversion.apache.org/">Apache Subversion&lt;/a>, которая представляет собой систему управления версиями с открытым исходным кодом, основанную в 2000 году.&lt;/p>
&lt;p>В этой модели управления версиями клиент-сервер на первом этапе разработчик загружает исходный код, фактические файлы с сервера. Это не устраняет конфликты, но устраняет сложность конфликтов и способы их разрешения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, например, скажем, у нас есть два разработчика, работающих над одними и теми же файлами, и один из них выигрывает гонку и первым фиксирует или загружает свой файл обратно на сервер со своими новыми изменениями. Когда второй разработчик идет на обновление, у них возникает конфликт.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Итак, теперь разработчику нужно вывести первое изменение кода разработчика рядом с его проверкой, а затем зафиксировать, как только эти конфликты будут урегулированы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="распределенный-контроль-версий">Распределенный контроль версий&lt;/h3>
&lt;p>Git — не единственная распределенная система контроля версий. Но это очень де-факто.&lt;/p>
&lt;p>Некоторые из основных преимуществ Git:&lt;/p>
&lt;ul>
&lt;li>Быстрый&lt;/li>
&lt;li>Гибкий&lt;/li>
&lt;li>Безопасный и надежный&lt;/li>
&lt;/ul>
&lt;p>В отличие от модели управления версиями клиент-сервер, каждый разработчик загружает исходный репозиторий, то есть все. История коммитов, все ветки и т.д. и т.п.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day36_Git16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Yc8sCSeMhi4">What is Version Control?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kr62e_n6QuQ">Types of Version Control System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8JJ101D3knE&amp;amp;t=52s">Git Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Uszj_k0DGsg">Git for Professionals Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RGOj5yH7evk&amp;amp;t=8s">Git and GitHub for Beginners - Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=apGV9Kg7ics">Complete Git and GitHub Tutorial&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>37. Шпаргалка по Git</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day37/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day37/</guid><description>&lt;h2 id="знакомство-с-git">Знакомство с Git&lt;/h2>
&lt;p>В последних двух постах мы узнали о системах контроля версий и некоторых основных рабочих процессах git как системы контроля версий &lt;a href="../day35">День 35&lt;/a>. Затем мы установили git в нашу систему, обновили и настроили. Мы также немного углубились в теорию между системой контроля версий клиент-сервер и Git, которая является распределенной системой контроля версий &lt;a href="../day36">День 36&lt;/a>.&lt;/p>
&lt;p>Теперь мы пройдемся по некоторым командам и вариантам использования, которые мы все обычно видим в git.&lt;/p>
&lt;h3 id="где-получить-помощь-по-git">Где получить помощь по git?&lt;/h3>
&lt;p>Будут времена, когда вы просто не сможете вспомнить или просто не знаете команду, которая вам нужна для работы с git. Вам понадобится помощь.&lt;/p>
&lt;p>Само собой разумеется, что Google или любая другая поисковая система, вероятно, будет вашим первым портом захода при поиске помощи.&lt;/p>
&lt;p>Во-вторых, следующим местом будет официальный сайт git и документация. &lt;a href="http://git-scm.com/docs">git-scm.com/docs&lt;/a> Здесь вы найдете не только подробные ссылки на все доступные команды, но и множество различных ресурсов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day37_Git1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем получить доступ к этой же документации, которая очень полезна, если у вас нет подключения к терминалу. Например, если мы выбрали команду &lt;code>git add&lt;/code>, мы можем запустить &lt;code>git add --help&lt;/code>, и мы увидим ниже руководство.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day37_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем в оболочке использовать &lt;code>git add -h&lt;/code>, который даст нам краткий обзор доступных опций.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day37_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;p class="md__image">
&lt;img
src="../images/Day37_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="мифы-git">Мифы Git&lt;/h3>
&lt;p>«У Git нет контроля доступа» — вы можете уполномочить &amp;ldquo;лидера&amp;rdquo; поддерживать исходный код.&lt;/p>
&lt;p>«Git слишком тяжелый» — у Git есть возможность предоставлять неглубокие репозитории, что в основном означает меньший объем истории, если у вас большие проекты.&lt;/p>
&lt;h3 id="недостатки">Недостатки&lt;/h3>
&lt;p>Не идеально подходит для двоичных файлов. Отлично подходит для исходного кода, но не подходит, например, для исполняемых файлов или видео.&lt;/p>
&lt;p>Git не удобен для пользователя, тот факт, что нам приходится тратить время на обсуждение команд и функций инструмента, вероятно, является ключевым признаком этого.&lt;/p>
&lt;p>В целом, git сложно освоить, но легко использовать.&lt;/p>
&lt;h3 id="экосистема-git">Экосистема git&lt;/h3>
&lt;p>Я хочу кратко рассказать об экосистеме вокруг git, но не углубляться в некоторые из этих областей, но я думаю, что важно отметить их здесь на высоком уровне.&lt;/p>
&lt;p>Почти все современные инструменты разработки поддерживают Git.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Инструменты разработчика. Мы уже упоминали код Visual Studio, но вы найдете плагины git и интеграции в возвышенный текст и другие текстовые редакторы и IDE.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Командные инструменты. Также упоминаются такие инструменты, как &lt;a href="https://www.jenkins.io/">Jenkins&lt;/a> с точки зрения CI/CD, &lt;a href="https://slack.com/features">Slack&lt;/a> из среды обмена сообщениями и &lt;a href="https://www.atlassian.com/ru/software/jira">Jira&lt;/a> для управления проектами и отслеживания проблем.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Облачные провайдеры. Все крупные облачные провайдеры поддерживают git, Microsoft Azure, Amazon AWS, Google Cloud Platform.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Сервисы на основе Git. Затем у нас есть GitHub, GitLab и BitBucket, о которых мы поговорим более подробно позже. Я слышал об этих сервисах как о социальной сети для кода!&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="шпаргалка-по-git">Шпаргалка по Git&lt;/h3>
&lt;p>Мы не рассмотрели большинство этих команд, но просмотрев некоторые шпаргалки, доступные в Интернете, я хотел задокументировать некоторые из команд git и их назначение. Нам не нужно запоминать все это, и с большей практикой и использованием вы выберете, по крайней мере, основы git.&lt;/p>
&lt;h3 id="основы-git">Основы Git&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git init&lt;/td>
&lt;td>&lt;code>git init &amp;lt;directory&amp;gt;&lt;/code>&lt;/td>
&lt;td>создает пустой репозиторий git в указанном каталоге.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git clone&lt;/td>
&lt;td>&lt;code>git clone &amp;lt;repo&amp;gt;&lt;/code>&lt;/td>
&lt;td>клонирует репозиторий, расположенный в &lt;repo>, на локальный компьютер.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git config&lt;/td>
&lt;td>&lt;code>git config user.name&lt;/code>&lt;/td>
&lt;td>определяет имя автора, которое будет использоваться для всех коммитов в текущем репозитории, &lt;code>system&lt;/code>, &lt;code>global&lt;/code>, &lt;code>local&lt;/code> флаг для установки параметров конфигурации.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git add&lt;/td>
&lt;td>&lt;code>git add &amp;lt;directory&amp;gt;&lt;/code>&lt;/td>
&lt;td>он подготовит все изменения в &lt;directory> для следующего коммита. Мы также можем добавить &lt;files> и &amp;lt;.&amp;gt; для добавления всех изменененных файлов всего.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git commit -m&lt;/td>
&lt;td>&lt;code>git commit -m &amp;quot;&amp;lt;message&amp;gt;&amp;quot;&lt;/code>&lt;/td>
&lt;td>фиксирует промежуточный коммит, запишет &lt;message>, чтобы подробно описать, что точно сохраняем.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git status&lt;/td>
&lt;td>&lt;code>git status&lt;/code>&lt;/td>
&lt;td>выведит список файлов, которые помещены в архив, не помещены в архив и не отслеживаются.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git log&lt;/td>
&lt;td>&lt;code>git log&lt;/code>&lt;/td>
&lt;td>Отображение всей истории коммитов в формате по умолчанию. У этой команды есть дополнительные параметры.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git diff&lt;/td>
&lt;td>&lt;code>git diff&lt;/code>&lt;/td>
&lt;td>Показать неустановленные изменения между вашим индексом и рабочим каталогом.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-отмена-изменений">Git Отмена изменений&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git revert&lt;/td>
&lt;td>&lt;code>git revert &amp;lt;commit&amp;gt;&lt;/code>&lt;/td>
&lt;td>создает новую фиксацию, которая отменяет все изменения, сделанные в &lt;commit>, а затем примените ее к текущей ветке.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git reset&lt;/td>
&lt;td>&lt;code>git reset &amp;lt;file&amp;gt;&lt;/code>&lt;/td>
&lt;td>убрать &lt;file> из индекса коммита (изменения не теряются).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git clean&lt;/td>
&lt;td>&lt;code>git clean -n&lt;/code>&lt;/td>
&lt;td>увидеть, какие файлы являются лишними, перед их непосредственным удалением&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git clean&lt;/td>
&lt;td>&lt;code>git clean -f&lt;/code>&lt;/td>
&lt;td>удалить неотслеживаемые файлы и папки из рабочей копии&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git clean&lt;/td>
&lt;td>&lt;code>git clean -fd&lt;/code>&lt;/td>
&lt;td>удалить их&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-переписать-историю">Git переписать историю&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git commit&lt;/td>
&lt;td>&lt;code>git commit --amend&lt;/code>&lt;/td>
&lt;td>Заменяет последний коммит поэтапными изменениями и последним коммитом. Используйте без статуса &lt;em>stage&lt;/em>, чтобы отредактировать сообщение последнего коммита.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git rebase&lt;/td>
&lt;td>&lt;code>git rebase &amp;lt;base&amp;gt;&lt;/code>&lt;/td>
&lt;td>Перебазировать текущую ветку на &lt;base>. &lt;base> может быть идентификатором фиксации, именем ветки, тегом или относительной ссылкой на HEAD.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git reflog&lt;/td>
&lt;td>&lt;code>git reflog&lt;/code>&lt;/td>
&lt;td>Показать журнал изменений в HEAD локального репозитория. Добавьте флаг &amp;ndash;relative-date для отображения информации о дате или &amp;ndash;all для отображения всех ссылок.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-branches">Git Branches&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git branch&lt;/td>
&lt;td>&lt;code>git branch&lt;/code>&lt;/td>
&lt;td>Перечислите все ветки в вашем репо. Добавьте аргумент &lt;branch>, чтобы создать новую ветку с именем &lt;branch>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git checkout&lt;/td>
&lt;td>&lt;code>git checkout -b &amp;lt;branch&amp;gt;&lt;/code>&lt;/td>
&lt;td>Создайте и извлеките новую ветку с именем &lt;branch>. Отбросьте флаг -b, чтобы проверить существующую ветку.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git merge&lt;/td>
&lt;td>&lt;code>git merge &amp;lt;branch&amp;gt;&lt;/code>&lt;/td>
&lt;td>Объединить ветку &lt;branch> с текущей веткой.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-remote-repositories">Git Remote Repositories&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git remote add&lt;/td>
&lt;td>&lt;code>git remote add &amp;lt;name&amp;gt; &amp;lt;url&amp;gt;&lt;/code>&lt;/td>
&lt;td>Создайте новое подключение к удаленному репозиторию. После добавления пульта вы можете использовать &lt;name> в качестве ярлыка для &lt;url> в других командах.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git fetch&lt;/td>
&lt;td>&lt;code>git fetch &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/code>&lt;/td>
&lt;td>Выбирает конкретную &amp;lt;ветку&amp;gt; из репозитория. Оставьте &lt;branch>, чтобы получить все удаленные ссылки.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git pull&lt;/td>
&lt;td>&lt;code>git pull &amp;lt;remote&amp;gt;&lt;/code>&lt;/td>
&lt;td>Получить указанную удаленную копию текущей ветки и немедленно объединить ее с локальной копией.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git push&lt;/td>
&lt;td>&lt;code>git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/code>&lt;/td>
&lt;td>Отправьте ветку на &lt;remote> вместе с необходимыми коммитами и объектами. Создает именованную ветку в удаленном репо, если она не существует.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-diff">Git Diff&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git diff HEAD&lt;/td>
&lt;td>&lt;code>git diff HEAD&lt;/code>&lt;/td>
&lt;td>Показать разницу между рабочим каталогом и последним коммитом.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git diff &amp;ndash;cached&lt;/td>
&lt;td>&lt;code>git diff --cached&lt;/code>&lt;/td>
&lt;td>Показать разницу между поэтапными изменениями и последней фиксацией&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-config">Git Config&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git config &amp;ndash;global user.name &amp;lt;имя&amp;gt;&lt;/td>
&lt;td>&lt;code>git config --global user.name &amp;lt;имя&amp;gt;&lt;/code>&lt;/td>
&lt;td>Определите имя автора, которое будет использоваться для всех коммитов текущим пользователем.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git config &amp;ndash;global user.email &lt;email>&lt;/td>
&lt;td>&lt;code>git config --global user.email &amp;lt;email&amp;gt;&lt;/code>&lt;/td>
&lt;td>Определите адрес электронной почты автора, который будет использоваться для всех коммитов текущего пользователя.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git config &amp;ndash;global alias &amp;lt;алиас-имя&amp;gt; &lt;git-command>&lt;/td>
&lt;td>&lt;code>git config --global alias &amp;lt;alias-name&amp;gt; &amp;lt;git-command&amp;gt;&lt;/code>&lt;/td>
&lt;td>Создать ярлык для команды git.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git config &amp;ndash;system core.editor &amp;lt;редактор&amp;gt;&lt;/td>
&lt;td>&lt;code>git config --system core.editor &amp;lt;редактор&amp;gt;&lt;/code>&lt;/td>
&lt;td>Установите текстовый редактор, который будет использоваться командами для всех пользователей на машине. Аргумент &lt;editor> должен быть командой, запускающей нужный редактор.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git config &amp;ndash;global &amp;ndash;edit&lt;/td>
&lt;td>&lt;code>git config --global --edit&lt;/code>&lt;/td>
&lt;td>Откройте файл глобальной конфигурации в текстовом редакторе для редактирования вручную.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-rebase">Git Rebase&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git rebase -i &lt;base>&lt;/td>
&lt;td>&lt;code>git rebase -i &amp;lt;base&amp;gt;&lt;/code>&lt;/td>
&lt;td>Интерактивно перебазировать текущую ветку на &lt;base>. Запускает редактор для ввода команд того, как каждый коммит будет перенесен в новую базу.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-pull">Git Pull&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git pull &amp;ndash;rebase &lt;remote>&lt;/td>
&lt;td>&lt;code>git pull --rebase &amp;lt;remote&amp;gt;&lt;/code>&lt;/td>
&lt;td>Получить удаленную копию текущей ветки и перебазировать ее в локальную копию. Использует git rebase вместо слияния для интеграции веток.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-reset">Git Reset&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git reset&lt;/td>
&lt;td>&lt;code>git reset&lt;/code>&lt;/td>
&lt;td>Сбросьте промежуточную область, чтобы она соответствовала самой последней фиксации, но оставьте рабочий каталог без изменений.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git reset &amp;ndash;hard&lt;/td>
&lt;td>&lt;code>git reset --hard&lt;/code>&lt;/td>
&lt;td>Сбросить промежуточную область и рабочий каталог, чтобы они соответствовали самой последней фиксации, и перезаписать все изменения в рабочем каталоге&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git reset &lt;commit>&lt;/td>
&lt;td>&lt;code>git reset &amp;lt;commit&amp;gt;&lt;/code>&lt;/td>
&lt;td>Переместите конец текущей ветки назад к &lt;commit>, сбросьте промежуточную область, чтобы она соответствовала, но оставьте рабочий каталог в покое&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git reset &amp;ndash;hard &lt;commit>&lt;/td>
&lt;td>&lt;code>git reset --hard &amp;lt;commit&amp;gt;&lt;/code>&lt;/td>
&lt;td>То же, что и предыдущее, но сбрасывает и промежуточную область, и рабочий каталог, чтобы они совпадали. Удаляет незафиксированные изменения и все фиксации после &lt;commit>.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git-push">Git Push&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Example&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>git push &lt;remote> &amp;ndash;force&lt;/td>
&lt;td>&lt;code>git push &amp;lt;remote&amp;gt; --force&lt;/code>&lt;/td>
&lt;td>Делает git push, даже если это приводит к слиянию без быстрой перемотки вперед. Не используйте флаг &amp;ndash;force, если вы абсолютно не уверены, что знаете, что делаете.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git push &lt;remote> &amp;ndash;all&lt;/td>
&lt;td>&lt;code>git push &amp;lt;remote&amp;gt; --all&lt;/code>&lt;/td>
&lt;td>Переместите все свои локальные ветки на указанный удаленный сервер.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>git push &lt;remote> &amp;ndash;tags&lt;/td>
&lt;td>&lt;code>git push &amp;lt;remote&amp;gt; --tags&lt;/code>&lt;/td>
&lt;td>Теги не добавляются автоматически при отправке ветки или использовании флага &amp;ndash;all. Флаг &amp;ndash;tags отправляет все ваши локальные теги в удаленное репо.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Yc8sCSeMhi4">What is Version Control?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kr62e_n6QuQ">Types of Version Control System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8JJ101D3knE&amp;amp;t=52s">Git Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Uszj_k0DGsg">Git for Professionals Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RGOj5yH7evk&amp;amp;t=8s">Git and GitHub for Beginners - Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=apGV9Kg7ics">Complete Git and GitHub Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet">Git cheatsheet&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>38. Staging и Изменения</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day38/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day38/</guid><description>&lt;h2 id="working-directory">Working directory&lt;/h2>
&lt;p>Git - это система трёх основных стадий: working directory, staging area и repository.
&lt;p class="md__image">
&lt;img
src="../images/day38_git01.ru.png"
id="zoom-default"
alt="day38_git01"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Пройдем поэтапно каждую стадию.&lt;/p>
&lt;p>Создадим пустую папку.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir my_fodler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">cd&lt;/span> my_folder
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Сделаем инициализацию git проекта.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git1.ru.png"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
(../images/Day38_Git1.ru.png)
После инициализации git репозитория создается скрытая папка &lt;code>.git&lt;/code>
&lt;p class="md__image">
&lt;img
src="./images/Day38_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Здесь хранятся сведения о репозитории git, а также информация о наших ветках и коммитах.&lt;/p>
&lt;h3 id="stagingstage">Staging/Stage&lt;/h3>
&lt;p>Сейчас у нас пустая папка. Создадим пустой файл &lt;code>README.md&lt;/code> и выполним команду&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git status
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Git знает о новом файле, но этот файл еще не зафиксирован в &lt;em>staging&lt;/em>. Текущее расположение файла - &lt;em>Working directory&lt;/em>, директория, где проиниализирован .git проект.&lt;/p>
&lt;p>&lt;em>staging&lt;/em> - это хранилище для файлов с изменениями, информация о которых попадет в единый коммит&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы файл перешел в &lt;em>staging&lt;/em>, необходимо его добавить. Для этого выполним команду&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git add README.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>После добавления файла в &lt;em>staging area&lt;/em>, цвет поменялся на зеленый&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Можно добавить все измененные файлы с помощью команды&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Знак &lt;code>.&lt;/code> означает, что мы хотим добавить все обновленные файлы и папки.&lt;/p>
&lt;p>Далее необходимо зафиксировать изменения в репозитории. Для этого выполним команду&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#4070a0">&amp;#34;Add README.md (или другой значимый комментарий)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="коммит-изменений">Коммит изменений&lt;/h3>
&lt;p>В процессе работы мы добавляем много различных файлов. Если мы захотим добавить более длинный и осмысленный коммит, то можно запусть команду без комментария&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git commit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Откроется стандартный редактор текста. Записываем комментарий и сохраняем.
&lt;p class="md__image">
&lt;img
src="../images/Day38_Git7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Проверим результат&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git status
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="требования-к-именам-коммитов">Требования к именам коммитов&lt;/h3>
&lt;p>У каждой компании/проекта есть свои требования к именам коммитов. В компании может быть несколько проектов, каждый из которых должен иметь свои требования к именам коммитов. В проекте может быть несколько веток, каждая из которых должна иметь свои требования к именам коммитов.&lt;/p>
&lt;p>Существует &lt;a href="https://www.conventionalcommits.org/ru/v1.0.0/">гайдлайн&lt;/a>, на который можно ориентироваться. Такой подход точно будет понятен для всех новых проектов. Некоторые проекты, соблюдабщие данную конвенцию: &lt;a href="https://github.com/angular/angular/commits/main">angular&lt;/a>, &lt;a href="https://github.com/electron/electron/commits/">electron&lt;/a>&lt;/p>
&lt;p>Коммит:&lt;/p>
&lt;ul>
&lt;li>Должен использоваться present tense (&amp;ldquo;add feature&amp;rdquo; not &amp;ldquo;added feature&amp;rdquo;)&lt;/li>
&lt;li>Должен использоваться imperative mood (&amp;ldquo;move cursor to&amp;hellip;&amp;rdquo; not &amp;ldquo;moves cursor to&amp;hellip;&amp;rdquo;)&lt;/li>
&lt;/ul>
&lt;h4 id="примеры-имен-коммитов">Примеры имен коммитов&lt;/h4>
&lt;p>&lt;code>init:&lt;/code> - используется для начала проекта/таска. Примеры:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>init: start youtube-task
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>init: start mentor-dashboard task
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>feat:&lt;/code> - это реализованная новая функциональность из технического задания (добавил поддержку зумирования, добавил footer, добавил карточку продукта). Примеры:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>feat: add basic page layout
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: implement search box
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: implement request to youtube API
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: implement swipe for horizontal list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: add additional navigation button
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: add banner
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: add social links
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: add physical security section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>feat: add real social icons
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>fix:&lt;/code> - исправил ошибку в ранее реализованной функциональности. Примеры:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>fix: implement correct loading data from youtube
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fix: change layout &lt;span style="color:#007020;font-weight:bold">for&lt;/span> video items to fix bugs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fix: relayout header &lt;span style="color:#007020;font-weight:bold">for&lt;/span> firefox
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fix: adjust social links &lt;span style="color:#007020;font-weight:bold">for&lt;/span> mobile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>refactor:&lt;/code> - новой функциональности не добавлял / поведения не менял. Файлы в другие места положил, удалил, добавил. Изменил форматирование кода (white-space, formatting, missing semi-colons, etc). Улучшил алгоритм, без изменения функциональности. Примеры:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>refactor: изменение структуры проекта
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>refactor: переименование переменных для лучшей читабельности
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>refactor: применить eslint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>refactor: применить prettier
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>docs:&lt;/code> - используется при работе с документацией/readme проекта. Примеры:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>docs: обновить readme с дополнительной информацией
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docs: обновить описание метода run()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="пропуск-staging-area">Пропуск Staging Area&lt;/h3>
&lt;p>Можно сразу добавить коммит, добавив параметр &lt;code>-a&lt;/code> в &lt;code>git commit&lt;/code>:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="удаление-файлов">Удаление файлов&lt;/h3>
&lt;p>Фиксация удаления как и добавления файлов происхоит через комит&lt;/p>
&lt;p>Создадим файл -&amp;gt; Добавим в stage -&amp;gt; Удалим файл&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>touch old_file.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add old_file.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#4070a0">&amp;#34;add old_file to be removed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Удаляем файл&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git rm old_file.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git status
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="переименованиеперемещение-файлов">Переименование/Перемещение файлов&lt;/h3>
&lt;p>Мы можем переименовывать или перемещать файлы в проекте средствами операционной системы. Таке это можно делать командами git.&lt;/p>
&lt;p>Пример:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git mv old_file.txt new_file.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="пропускигнорирование-файлов">Пропуск/игнорирование файлов&lt;/h3>
&lt;p>В Git это можно сделать рзличными способами:&lt;/p>
&lt;ul>
&lt;li>Игнорировать изменения в неотслеченных файлах с помощью &lt;code>.gitignore&lt;/code> файла&lt;/li>
&lt;li>Игнорировать изменения в неотслеченных файлах с помощью &lt;code>exclude&lt;/code> файла&lt;/li>
&lt;li>Остановка отслеживания файла и пропуск изменений с помощью &lt;code>git update-index&lt;/code>&lt;/li>
&lt;li>Остановка отслеживания файла и пропуск изменений с помощью &lt;code>git rm&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="gitignore">.gitignore&lt;/h4>
&lt;p>Достаточно в файл &lt;code>.gitignore&lt;/code> добавить путь до файлов или папок, которые необходимо игнорировать&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После обновления файл переходит в категорию &lt;strong>Untracked files&lt;/strong>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если файлы уже добавлены в stage, но нужно убрать файл, то можно использовать команду &lt;code>git rm --cached&lt;/code>&lt;/p>
&lt;h3 id="status-сокращенно">Status сокращенно&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git status -s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day38_Git16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Yc8sCSeMhi4">What is Version Control?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kr62e_n6QuQ">Types of Version Control System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8JJ101D3knE&amp;amp;t=52s">Git Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Uszj_k0DGsg">Git for Professionals Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RGOj5yH7evk&amp;amp;t=8s">Git and GitHub for Beginners - Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=apGV9Kg7ics">Complete Git and GitHub Tutorial&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>39. Просмотр, удаление, отмена и восстановление</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day39/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day39/</guid><description>&lt;h2 id="git---просмотр-удаление-отмена-и-восстановление">GIT - Просмотр, удаление, отмена и восстановление&lt;/h2>
&lt;h3 id="просмотр-файлов-в-stagig-area-и-working-area">Просмотр файлов в Stagig area и Working area&lt;/h3>
&lt;p>Если некоторые файлы/папки уже добавлены в &lt;code>staging area&lt;/code>, то можно просмотреть их рахницу по отношению в главной ветке комадой: &lt;code>git diff --staged&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это покажет нам все внесенные изменения и все новые файлы, которые мы добавили или удалили.&lt;/p>
&lt;p>Изменения в измененных файлах обозначаются символами &lt;code>---&lt;/code> или &lt;code>+++&lt;/code> Вы можете видеть ниже, что мы только что добавили &lt;code>+add some text&lt;/code>, что означает, что это новые строки.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем запустить &lt;code>git diff&lt;/code>, чтобы сравнить наш staging area с нашим рабочим каталогом. Если мы внесем некоторые изменения в наш только что добавленный файл code.txt и добавим несколько строк текста.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="инструменты-для-визуального-отображения">Инструменты для визуального отображения&lt;/h3>
&lt;p>Вот несколько инструментов для визуального сравнения коммитов и веток:&lt;/p>
&lt;ul>
&lt;li>KDiff3&lt;/li>
&lt;li>P4Merge&lt;/li>
&lt;li>WinMerge (только для Windows)&lt;/li>
&lt;li>VSCode&lt;/li>
&lt;/ul>
&lt;p>Если запустим &lt;code>git difftool&lt;/code> то запустится визуальный инструмент сравнения по умолчанию.
&lt;p class="md__image">
&lt;img
src="../images/Day39_Git7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Проверить текущие настройки &lt;code>git config --global -e&lt;/code>
&lt;p class="md__image">
&lt;img
src="../images/Day39_Git6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Чтобы установить инструмент в git, выполним следующую команду &lt;code>git config --global diff.tool vscode&lt;/code>.
&lt;p class="md__image">
&lt;img
src="../images/Day39_Git5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Теперь при запуске &lt;code>git difftool&lt;/code> откроется vscode
После этого открывается редактор VScode на странице diff и сравнивает их, мы изменили только один файл, добавив строку кода с правой стороны.
&lt;p class="md__image">
&lt;img
src="../images/Day39_Git8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Можем использовать &lt;code>git difftool --staged&lt;/code> для сравнения файлов в &lt;code>staging area&lt;/code> с &amp;ldquo;прокомиченными&amp;rdquo; файлами.
&lt;p class="md__image">
&lt;img
src="../images/Day39_Git9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
VScode, как и большинство IDE, имеют встроенную функциональность, поэтому очень редко вам понадобится запускать эти команды из терминала, хотя это полезно, если у вас по какой-то причине не установлена IDE.&lt;/p>
&lt;h3 id="просмотр-истории-изменений">Просмотр истории изменений&lt;/h3>
&lt;p>Просмотреть историю изменений в Git можно командой &lt;code>git log&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Каждый коммит имеет свою шестнадцатеричную строку, уникальную для репозитория. Здесь вы можете увидеть, над какой веткой мы работаем, а также автора, дату и комментарий коммита.&lt;/p>
&lt;p>У нас также есть &lt;code>git log --oneline&lt;/code>, и это даёт нам гораздо меньшую версию шестнадцатеричной строки, которую мы можем использовать в других командах &lt;code>diff&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Чтобы просмотреть коммиты с самого первого, а не послденего, как по умолчанию, запустим &lt;code>git log --oneline --reverse&lt;/code>, и теперь мы видим наш первый коммит в верхней части страницы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="просмотр-коммита">Просмотр коммита&lt;/h3>
&lt;p>Можно просмотреть данные ко конкретном коммите более детально: &lt;code>git show&lt;/code> или &lt;code>git show &amp;lt;commit ID&amp;gt;&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем использовать &lt;code>git show HEAD~1&lt;/code>, где 1 - это количество шагов назад от текущей версии, к которой мы хотим вернуться.&lt;/p>
&lt;p>Это отличный вариант, если вам нужна подробная информация о файлах, но если мы хотим получить список всех файлов в дереве для всего каталога снимков. Мы можем добиться этого, используя команду &lt;code>git ls-tree HEAD~1&lt;/code>, снова вернувшись на один снимок назад от последнего коммита. Ниже мы видим два пятна, которые обозначают файлы, в то время как дерево обозначает каталог. В этой информации вы также можете увидеть коммиты и теги.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Проверим коммит&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="unstaging">Unstaging&lt;/h3>
&lt;p>Бывают случаи, когда вы, возможно, использовали &lt;code>git add .&lt;/code>, но на самом деле есть файлы, которые вы пока не хотите фиксировать в этом снапшоте. В этом примере ниже я добавил newfile.txt в область staging, но я не готов зафиксировать этот файл, поэтому я собираюсь использовать &lt;code>git restore --staged newfile.txt&lt;/code>, чтобы отменить шаг &lt;code>git add&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем сделать то же самое с изменёнными файлами, такими как main.js, и снять фиксацию, см. выше у нас есть greem M для modified, а ниже мы снимаем фиксацию этих изменений.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я нашел эту команду весьма полезной во время 90DaysOfDevOps, поскольку иногда я работаю заранее, когда чувствую, что хочу сделать заметки для следующего дня, но не хочу фиксировать и выкладывать в публичный репозиторий GitHub.&lt;/p>
&lt;h3 id="отмена-локальных-изменений">Отмена локальных изменений&lt;/h3>
&lt;p>Иногда мы можем вносить изменения, но эти изменения нас не устраивают, и мы хотим их отбросить. Мы снова воспользуемся командой &lt;code>git restore&lt;/code> и сможем восстановить файлы из наших снимков или предыдущих версий. Мы можем запустить команду &lt;code>git restore .&lt;/code> для нашего каталога, и мы восстановим все из нашего снимка, но обратите внимание, что наш неотслеживаемый файл все еще присутствует. Нет предыдущего отслеживаемого файла под названием newfile.txt.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, чтобы удалить newfile.txt или любой другой неотслеживаемый файл. Мы можем использовать &lt;code>git clean&lt;/code>, но получим только предупреждение.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Или, если мы знаем о последствиях, мы можем запустить &lt;code>git clean -fd&lt;/code>, чтобы принудительно удалить все каталоги.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="восстановление-файла-до-более-ранней-версии">Восстановление файла до более ранней версии&lt;/h3>
&lt;p>Как мы уже упоминали, большая часть того, чем может помочь Git, - это возможность восстановления копий файлов из снимков (это не резервное копирование, но это очень быстрая точка восстановления). Я советую вам также сохранять копии вашего кода в других местах, используя для этого решение для резервного копирования.&lt;/p>
&lt;p>В качестве примера давайте удалим наш самый важный файл в каталоге, обратите внимание, что мы используем команды на базе unix для удаления этого файла из каталога, а не команды git.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git24.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас нет readme.mdin в нашей рабочей директории. Мы могли бы использовать &lt;code>git rm readme.md&lt;/code> и тогда это было бы отражено в нашей базе данных git. Давайте также удалим его отсюда, чтобы имитировать его полное удаление.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git25.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь зафиксируем это с сообщением и докажем, что у нас больше нет ничего в рабочем каталоге или в области постановки.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git26.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Была допущена ошибка, и теперь нам нужно вернуть этот файл!&lt;/p>
&lt;p>Мы можем использовать команду &lt;code>git undo&lt;/code>, которая отменит последний коммит, но что если это было давно? Мы можем использовать команду &lt;code>git log&lt;/code>, чтобы найти наши коммиты, и тогда мы обнаружим, что наш файл находится в последнем коммите, но мы не хотим, чтобы все эти коммиты были отменены, поэтому мы можем использовать эту команду &lt;code>git restore --source=HEAD~1 README.md&lt;/code>, чтобы найти файл и восстановить его из нашего снимка.&lt;/p>
&lt;p>Вы можете видеть, что с помощью этого процесса мы вернули файл в наш рабочий каталог.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git27.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас есть новый неотслеживаемый файл, и мы можем использовать наши команды, упомянутые ранее, для отслеживания, этапа и фиксации наших файлов и изменений.&lt;/p>
&lt;h3 id="rebase--merge">Rebase / Merge&lt;/h3>
&lt;p>Это, кажется, самая большая головная боль, когда речь заходит о Git и о том, когда использовать rebase, а когда использовать merge в ваших git-репозиториях.&lt;/p>
&lt;p>Прежде всего, нужно знать, что и &lt;code>git rebase&lt;/code>, и &lt;code>git merge&lt;/code> решают одну и ту же задачу. Оба они интегрируют изменения из одной ветки в другую. Однако они делают это по-разному.&lt;/p>
&lt;p>Давайте начнем с новой функции в новой выделенной ветке. Основная ветку продолжает работу с новыми коммитами.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git28.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Простой вариант здесь - использовать &lt;code>git merge feature main&lt;/code>, который объединит основную ветку с веткую feature.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git29.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Слияние простое, потому что оно неразрушающее. Существующие ветви никак не изменяются. Однако это также означает, что функциональная ветку будет иметь неактуальный коммит слияния каждый раз, когда вам нужно будет включить изменения, внесённые выше по течению. Если main очень занят или активен, это может привести к загрязнению истории функциональной ветви.&lt;/p>
&lt;p>В качестве альтернативного варианта мы можем перебазировать функциональную ветку на основную ветку с помощью команды&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>git checkout feature
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git rebase main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Это перемещает ветку feature (всю ветку feature), эффективно включая все новые коммиты в main. Но вместо использования коммита слияния, rebasing переписывает историю проекта, создавая совершенно новые коммиты для каждого коммита в исходной ветке.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day39_Git30.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Самым большим преимуществом ребасинга является гораздо более чистая история проекта. Это также устраняет ненужные коммиты слияния. и если сравнить последние два изображения, то можно увидеть, что история проекта намного чище.&lt;/p>
&lt;p>Хотя это еще не окончательный вывод, потому что выбор более чистой истории также связан с компромиссами. Если вы не будете следовать &lt;a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing#the-golden-rule-of-rebasing">The Golden rule of rebasing&lt;/a>, переписывание истории проекта может стать потенциально катастрофой для вашего рабочего процесса совместной работы. И, что менее важно, при пересборке теряется контекст, предоставляемый коммитом слияния - вы не можете увидеть, когда изменения, внесенные выше по течению, были включены в функцию.&lt;/p>
&lt;h2 id="ссылки">Ссылки&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Yc8sCSeMhi4">What is Version Control?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kr62e_n6QuQ">Types of Version Control System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8JJ101D3knE&amp;amp;t=52s">Git Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Uszj_k0DGsg">Git for Professionals Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RGOj5yH7evk&amp;amp;t=8s">Git and GitHub for Beginners - Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=apGV9Kg7ics">Complete Git and GitHub Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet">Git cheatsheet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://veducate.co.uk/exploring-the-git-command-line/">Exploring the Git command line – A getting started guide&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>40. GitHub | GitLab | BitBucket</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day40/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day40/</guid><description>&lt;h2 id="социальная-сеть-для-кода">Социальная сеть для кода&lt;/h2>
&lt;p>Изучение GitHub | GitLab | BitBucket&lt;/p>
&lt;p>Сегодня я хочу рассказать о некоторых сервисах на основе git, о которых мы, вероятно, все слышали и ожидаем, что будем использовать их ежедневно.&lt;/p>
&lt;h3 id="github">GitHub&lt;/h3>
&lt;p>Наиболее распространенным, по крайней мере для меня, является GitHub, GitHub — это веб-хостинг для git. Чаще всего он используется разработчиками программного обеспечения для хранения своего кода. Управление исходным кодом с функциями контроля версий git, а также множеством дополнительных функций. Это позволяет командам или открытым участникам легко общаться и обеспечивает социальный аспект кодирования. (отсюда и название социальной сети) С 2018 года GitHub является частью Microsoft.&lt;/p>
&lt;p>GitHub существует уже довольно давно и был основан в 2007-2008 годах. Сегодня на платформе более 40 миллионов пользователей.&lt;/p>
&lt;p>Основные возможности GitHub&lt;/p>
&lt;ul>
&lt;li>Code Repository&lt;/li>
&lt;li>Pull Requests&lt;/li>
&lt;li>Project Management toolset - Issues&lt;/li>
&lt;li>CI / CD Pipeline - GitHub Actions&lt;/li>
&lt;/ul>
&lt;p>С точки зрения ценообразования GitHub предлагает различные уровни ценообразования для своих пользователей. Дополнительную информацию можно найти на странице &lt;a href="https://github.com/pricing">Цены&lt;/a>.&lt;/p>
&lt;p>Для этого мы рассмотрим бесплатный уровень.&lt;/p>
&lt;p>Я собираюсь использовать свою уже созданную учетную запись GitHub во время этого пошагового руководства, если у вас нет учетной записи, то на открывающейся странице GitHub есть вариант регистрации и несколько простых шагов для настройки.&lt;/p>
&lt;h3 id="github-opening-page">GitHub opening page&lt;/h3>
&lt;p>Когда вы впервые входите в свою учетную запись GitHub, вы получаете страницу, содержащую множество виджетов, дающих вам варианты того, где и что вы хотели бы увидеть или сделать. Во-первых, у нас есть «All Activity», это даст вам представление о том, что происходит с вашими репозиториями или действиями в целом, связанными с вашей организацией или учетной записью.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем у нас есть наши репозитории кода, либо наши собственные, либо репозитории, с которыми мы недавно взаимодействовали. Мы также можем быстро создавать новые репозитории или репозитории поиска.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем у нас есть наша недавняя активность, для меня это проблемы и pull requests, которые я недавно создал или в которых участвовал.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В правой части страницы есть несколько ссылок на репозитории, которые могут нас заинтересовать, скорее всего, на основе вашей недавней активности или собственных проектов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Честно говоря, я очень редко бываю на своей домашней странице, которую мы только что видели и описали, хотя теперь я вижу, что лента может быть действительно полезной, чтобы помочь взаимодействовать с сообществом немного лучше в определенных проектах.&lt;/p>
&lt;p>Далее, если мы хотим зайти в наш профиль на GitHub, мы можем перейти в правый верхний угол, и на вашем изображении будет выпадающий список, который позволит вам перемещаться по вашему аккаунту. Отсюда для доступа к своему профилю выберите &amp;ldquo;Ваш профиль&amp;rdquo;&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее появится страница вашего профиля, по умолчанию, если вы не измените свою конфигурацию, вы не увидите того, что есть у меня, я добавил некоторые функции, которые показывают мои последние записи в блоге на &lt;a href="https://vzilla.co.uk">vZilla&lt;/a>, а также мои последние видео на моем канале &lt;a href="https://m.youtube.com/c/MichaelCade1">YouTube&lt;/a>.&lt;/p>
&lt;p>Лично вы не собираетесь тратить много времени на просмотр своего профиля, но это хорошая страница профиля, которой можно поделиться со своей сетью, чтобы они могли увидеть крутые проекты, над которыми вы работаете.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем перейти к основному элементу GitHub - репозиториям. Здесь вы увидите свои собственные репозитории, а если у вас есть частные репозитории, они также будут показаны в этом длинном списке.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Поскольку этот репозиторий так важен для GitHub, позвольте мне выбрать довольно загруженный в последнее время и просмотреть некоторые основные функции, которые мы можем использовать здесь, в дополнение ко всему, что я уже использую, когда дело доходит до редактирования нашего кода в git. моя локальная система.&lt;/p>
&lt;p>Прежде всего, в предыдущем окне я выбрал репозиторий 90DaysOfDevOps, и мы видим это представление. Вы можете видеть из этого представления, что у нас есть много информации, у нас есть наша основная структура кода в середине, показывающая наши файлы и папки, которые хранятся в нашем репозитории. Наш файл readme.md отображается внизу. Справа от страницы у нас есть раздел о репозитории, где у репозитория есть описание и назначение. Затем у нас есть много информации под этим, показывающей, сколько людей отметили проект, разветвились и смотрят.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы прокрутим вниз немного дальше, вы также увидите, что у нас есть Releases, они относятся к части задачи golang. У нас нет никаких пакетов в нашем проекте, здесь перечислены наши соавторы. Затем у нас есть используемые языки, опять же из разных разделов задачи.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В верхней части страницы вы увидите список вкладок. Они могут различаться, и их можно изменить, чтобы отображались только те, которые вам нужны. Вы увидите здесь, что я не использую все это, и я должен удалить их, чтобы убедиться, что весь мой репозиторий в порядке.&lt;/p>
&lt;p>Во-первых, у нас была вкладка кода, которую мы только что обсуждали, но эти вкладки всегда доступны при навигации по репозиторию, что очень полезно, так что мы можем быстро и легко переходить между разделами. Далее у нас есть вкладка вопросов.&lt;/p>
&lt;p>Проблемы позволяют отслеживать вашу работу на GitHub, где происходит разработка. В этом конкретном репозитории вы можете увидеть, что у меня есть некоторые проблемы, связанные с добавлением диаграмм или опечаток, но также у нас есть проблема, указывающая на необходимость или требование для китайской версии репозитория.&lt;/p>
&lt;p>Если это был репозиторий кода, то это отличное место, чтобы сообщить о проблемах или проблемах с сопровождающими, но помните, будьте внимательны и подробны в отношении того, о чем вы сообщаете, давайте как можно больше подробностей.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Следующая вкладка — Pull Requests. Pull Requests позволяют вам сообщать другим об изменениях, которые вы отправили в ветку в репозитории. Здесь кто-то мог разветвить ваш репозиторий, внести изменения, такие как исправления ошибок или улучшения функций, или просто опечататься во многих случаях в этом репозитории.&lt;/p>
&lt;p>Мы рассмотрим разветвление позже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я считаю, что следующая вкладка совершенно новая? Но я подумал, что для такого проекта, как #90DaysOfDevOps, это может действительно помочь направить контент, а также помочь сообществу, когда они проходят свой собственный путь обучения. Я создал несколько дискуссионных групп для каждого раздела задачи, чтобы люди могли присоединиться и обсудить.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вкладка &amp;ldquo;Actions&amp;rdquo; позволит вам создавать, тестировать и развертывать код и многое другое прямо из GitHub. GitHub Actions будет чем-то, что мы рассмотрим в разделе задачи, посвященном CI/CD, но именно здесь мы можем установить некоторую конфигурацию, чтобы автоматизировать шаги для нас.&lt;/p>
&lt;p>В моем основном профиле GitHub я использую GitHub Actions для получения последних сообщений в блогах и видео на YouTube, чтобы обновлять информацию на этом домашнем экране.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я уже говорил о том, что GitHub - это не только хранилище исходного кода, но и инструмент управления проектами. Вкладка &amp;ldquo;Проект&amp;rdquo; позволяет нам создавать проектные таблицы типа канбан, чтобы мы могли связывать проблемы и PR для лучшего сотрудничества над проектом и иметь видимость этих задач.
&lt;p class="md__image">
&lt;img
src="../images/Day40_Git14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я знаю, что проблемы, как мне кажется, являются хорошим местом для регистрации запросов о возможностях, и это так, но страница вики позволяет составить полную дорожную карту проекта с указанием текущего состояния и в целом лучше документировать ваш проект, будь то устранение неполадок или контент типа how-to.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Не совсем применимо к этому проекту, но вкладка Security действительно существует для того, чтобы убедиться, что участники проекта знают, как обращаться с определенными задачами, здесь мы можем определить политику, а также дополнения для сканирования кода, чтобы убедиться, что ваш код, например, не содержит секретных переменных окружения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для меня вкладка insights очень важна, она предоставляет так много информации о репозитории, начиная от того, сколько активности происходило и заканчивая коммитами и проблемами, а также сообщает о посещаемости репозитория. В левой части вы можете увидеть список, который позволяет вам подробно ознакомиться с метриками репозитория.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Наконец, у нас есть вкладка Settings, где мы можем подробно описать, как мы управляем нашим репозиторием, в настоящее время я единственный сопровождающий репозитория, но мы можем разделить эту ответственность. Здесь мы можем определить интеграции и другие подобные задачи.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это был очень быстрый обзор GitHub, я думаю, что есть еще несколько областей, которые я, возможно, упомянул и которые нуждаются в более подробном объяснении. Как уже упоминалось, GitHub содержит миллионы репозиториев, в которых в основном хранится исходный код, и они могут быть общедоступными или частными.&lt;/p>
&lt;h3 id="forking">Forking&lt;/h3>
&lt;p>Я собираюсь больше рассказать об Open-Source на завтрашней сессии, но большая часть любого репозитория кода — это возможность сотрудничать с сообществом. Давайте подумаем о сценарии: мне нужна копия репозитория, потому что я хочу внести в него некоторые изменения, может быть, я хочу исправить ошибку или, может быть, я хочу что-то изменить, чтобы использовать его для моего варианта использования, который, возможно, не был предполагаемый вариант использования для первоначального сопровождающего кода. Это то, что мы бы назвали разветвлением репозитория. Форк — это копия репозитория. Разветвление репозитория позволяет вам свободно экспериментировать с изменениями, не затрагивая исходный проект.&lt;/p>
&lt;p>Позвольте мне вернуться на начальную страницу после входа в систему и увидеть один из предложенных репозиториев.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы нажмем на этот репозиторий, мы получим тот же вид, что и репозиторий 90DaysOfDevOps.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы обратим внимание, ниже у нас есть 3 варианта: watch, fork и star.&lt;/p>
&lt;ul>
&lt;li>Watch - обновление, когда что-то происходит с хранилищем.&lt;/li>
&lt;li>Fork - копия репозитория.&lt;/li>
&lt;li>Star - &amp;ldquo;Я думаю, что ваш проект крутой&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Учитывая наш сценарий, когда нам нужна копия репозитория для работы, мы воспользуемся опцией fork. Если вы являетесь членом нескольких организаций, то вам придётся выбрать, где будет происходить форк, я выберу свой профиль.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас есть собственная копия репозитория, над которой мы можем свободно работать и изменять по своему усмотрению. Это начало процесса подачи запросов на исправление, о котором мы уже вкратце упоминали, но более подробно рассмотрим завтра.
&lt;p class="md__image">
&lt;img
src="../images/Day40_Git23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хорошо, я слышу, как вы говорите, но как мне внести изменения в этот репозиторий и код, если он находится на веб-сайте, ну, вы можете просматривать и редактировать на веб-сайте, но это не будет таким же, как использование вашей любимой IDE в вашей локальной системе. с вашей любимой цветовой темой. Чтобы получить копию этого репозитория на нашем локальном компьютере, мы выполним клонирование репозитория. Это позволит нам работать над вещами локально, а затем отправлять наши изменения обратно в нашу разветвленную копию репозитория.&lt;/p>
&lt;p>У нас есть несколько вариантов получения копии этого кода, как вы можете видеть ниже.&lt;/p>
&lt;p>Доступна локальная версия GitHub Desktop, которая дает вам визуальное настольное приложение для отслеживания изменений и отправки и получения изменений между локальным и github.&lt;/p>
&lt;p>Для этой небольшой демонстрации я буду использовать URL-адрес HTTPS, который мы видим там.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git24.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь на нашей локальной машине я перейду в каталог, в который я хочу загрузить этот репозиторий, а затем выполню команду &lt;code>git clone url&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git25.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем обратиться к VScode, чтобы действительно внести некоторые изменения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git26.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь давайте сделаем некоторые изменения, я хочу изменить все эти ссылки и заменить их на что-то другое.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git27.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, если мы вернемся на GitHub и найдем наш readme.mdin в этом репозитории, вы сможете увидеть несколько изменений, которые я внес в файл.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git28.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На данном этапе это может быть завершено, и мы можем быть довольны нашим изменением, поскольку мы единственные люди, которые будут использовать наше новое изменение, но, возможно, это было изменение ошибки, и если это так, то мы захотим внести свой вклад через Pull Request чтобы уведомить сопровождающих исходного репозитория о наших изменениях и посмотреть, примут ли они наши изменения.&lt;/p>
&lt;p>Мы можем сделать это, используя кнопку вклада, выделенную ниже. Я расскажу об этом подробнее завтра, когда мы рассмотрим рабочие процессы с открытым исходным кодом.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day40_Git29.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я долго просматривал GitHub и слышал, как некоторые из вас плачут, но как насчет других вариантов!&lt;/p>
&lt;p>Ну, есть, и я собираюсь найти некоторые ресурсы, которые охватывают основы для некоторых из них. В своих путешествиях вы столкнетесь с GitLab и BitBucket, и хотя они основаны на git, у них есть свои отличия.&lt;/p>
&lt;p>Вы также столкнетесь с размещенными вариантами. Чаще всего здесь я видел GitLab как размещенную версию по сравнению с GitHub Enterprise (не верите, что есть бесплатный размещенный GitHub?)&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8aV5AxJrHDg">Learn GitLab in 3 Hours | GitLab Complete Tutorial For Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=OMLh-5O6Ub8&amp;amp;list=PLaD4FvsFdarSyyGl3ooAm-ZyAllgw_AM5">BitBucket Tutorials Playlist&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Yc8sCSeMhi4">What is Version Control?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kr62e_n6QuQ">Types of Version Control System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8JJ101D3knE&amp;amp;t=52s">Git Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Uszj_k0DGsg">Git for Professionals Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RGOj5yH7evk&amp;amp;t=8s">Git and GitHub for Beginners - Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=apGV9Kg7ics">Complete Git and GitHub Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet">Git cheatsheet&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>41. Рабочий процесс с открытым исходным кодом</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day41/</link><pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day41/</guid><description>&lt;h2 id="рабочий-процесс-с-открытым-исходным-кодом">Рабочий процесс с открытым исходным кодом&lt;/h2>
&lt;p>Когда мы изучали основы GitHub, мы проходили процесс форка произвольного проекта и внесения изменений в наш локальный репозиторий. Здесь мы хотим сделать еще один шаг вперед и внести свой вклад в проект с открытым исходным кодом. Помните, что вклад не обязательно должен заключаться в исправлении ошибок, кодировании функций, это может быть и документация. Каждая мелочь помогает, и это также позволит вам поработать с некоторыми функциями git, которые мы рассмотрели.&lt;/p>
&lt;h2 id="форк-проекта">Форк проекта&lt;/h2>
&lt;p>Первое, что нам нужно сделать, это найти проект, в который мы можем внести свой вклад. Я недавно выступал с презентациями в &lt;a href="https://github.com/kanisterio/kanister">Kanister Project&lt;/a> и хотел бы поделиться своими презентациями, которые теперь есть на YouTube, с основным readme.mdf-файлом проекта.&lt;/p>
&lt;p>Прежде всего, нам нужно форкнуть проект. Давайте проделаем этот процесс. Я собираюсь перейти по ссылке, указанной выше, и форкнуть репозиторий.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас есть наша копия всего репозитория.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для справки в файле Readme.mdfile в списке оригинальных Presenations указаны только эти два, поэтому нам нужно исправить это в нашем процессе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="клонирование-на-локальную-машину">Клонирование на локальную машину&lt;/h2>
&lt;p>Теперь у нас есть собственный форк, который мы можем перенести на локальную машину и начать вносить правки в файлы. Используя кнопку code на нашем репозитории, мы можем получить URL, а затем использовать &lt;code>git clone url&lt;/code> в каталоге, куда мы хотим поместить репозиторий.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="вносим-изменения">Вносим изменения&lt;/h2>
&lt;p>У нас есть локальный проект, поэтому мы можем открыть VSCode или IDE или текстовый редактор по вашему выбору, чтобы добавить свои изменения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Файл readme.mdfile написан на языке markdown, и поскольку я изменяю чужой проект, я собираюсь следовать существующему форматированию проекта для добавления нашего содержимого.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="тестируем-свои-изменения">Тестируем свои изменения&lt;/h2>
&lt;p>В качестве лучшей практики мы должны тестировать наши изменения, это совершенно логично, если бы это было изменение кода приложения, вы бы хотели убедиться, что приложение продолжает функционировать после изменения кода, но мы также должны убедиться, что документация отформатирована и выглядит правильно.&lt;/p>
&lt;p>В VScode у нас есть возможность добавить множество плагинов, одним из которых является возможность предварительного просмотра страниц в формате markdown.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="верните-изменения-в-наш-форкнутый-репозиторий">Верните изменения в наш форкнутый репозиторий&lt;/h2>
&lt;p>У нас нет аутентификации, чтобы отправить наши изменения непосредственно в репозиторий Kanister, поэтому мы должны пойти этим путем. Теперь, когда я доволен нашими изменениями, мы можем выполнить некоторые из этих хорошо известных команд git.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы возвращаемся в GitHub, чтобы еще раз проверить изменения и затем внести вклад в мастер-проект.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем вернуться в верхнюю часть нашего форкнутого репозитория для Kanister и увидеть, что мы на 1 коммит опережаем ветку kanisterio:master.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы нажимаем на кнопку &amp;ldquo;Внести вклад&amp;rdquo;, выделенную выше. Мы видим опцию &amp;ldquo;Open Pull Request&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="open-a-pull-request">Open a pull request&lt;/h2>
&lt;p>На следующем изображении происходит довольно много всего: слева вверху вы видите, что мы находимся в оригинальном или основном репозитории. Затем вы можете увидеть, что мы сравниваем, а это оригинальный основной и наш форкнутый репозиторий. Затем у нас есть кнопка создания запроса на притяжение, к которой мы скоро вернёмся. У нас есть единственный коммит, но если бы изменений было больше, то здесь могло бы быть несколько коммитов. Затем у нас есть изменения, которые мы внесли в readme.mdfile.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы просмотрели вышеуказанные изменения и готовы создать pull request, нажав на зеленую кнопку.&lt;/p>
&lt;p>Затем, в зависимости от того, как мейнтейнер проекта настроил функциональность Pull Request в своём репозитории, у вас может быть или не быть шаблона, который даст вам указания на то, что хочет видеть мейнтейнер.&lt;/p>
&lt;p>Здесь вам снова нужно составить содержательное описание того, что вы сделали, четкое и краткое, но достаточно подробное. Вы можете видеть, что я сделал простой обзор изменений и отметил документацию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="создайте-запрос-на-исправление">Создайте запрос на исправление&lt;/h2>
&lt;p>Теперь мы готовы к созданию запроса на исправление. После нажатия кнопки &amp;ldquo;Create Pull Request&amp;rdquo; в верхней части страницы вы получите краткое описание вашего запроса.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Прокручивая страницу вниз, вы, вероятно, увидите, что происходит автоматизация, в данном случае нам требуется рецензия, и происходят некоторые проверки. Мы видим, что Travis CI находится в процессе и началась сборка, которая проверит наше обновление и убедится, что перед тем, как что-то будет слито, мы не сломаем что-то своими добавлениями.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day41_Git15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Еще одна вещь, которую следует отметить, это то, что красный цвет на снимке экрана выше, может выглядеть немного пугающе и выглядеть так, как будто вы совершили ошибки! Не волнуйтесь, вы ничего не нарушили, мой главный совет - этот процесс поможет вам и сопровождающим проекта. Если вы допустили ошибку, по крайней мере, по моему опыту, сопровождающий свяжется с вами и посоветует, что делать дальше.&lt;/p>
&lt;p>Этот запрос на исправление теперь общедоступен для всех &lt;a href="https://github.com/kanisterio/kanister/pull/1237">added Kanister presentation/resource #1237&lt;/a>.&lt;/p>
&lt;p>Я собираюсь опубликовать это до того, как слияние и запрос на исправление будут приняты, так что, возможно, мы сможем получить небольшой приз для тех, кто всё ещё следит за развитием событий и сможет добавить картинку к успешному PR?&lt;/p>
&lt;ol>
&lt;li>Форкните этот репозиторий на свой собственный аккаунт GitHub&lt;/li>
&lt;li>Добавьте свою картинку и, возможно, текст&lt;/li>
&lt;li>Внесите изменения в свой форкнутый репозиторий.&lt;/li>
&lt;li>Создайте PR, который я увижу и одобрю.&lt;/li>
&lt;li>Я придумаю какой-нибудь приз.&lt;/li>
&lt;/ol>
&lt;p>На этом мы завершаем знакомство с Git и GitHub, далее мы погружаемся в контейнеры, что начинается с рассмотрения общей картины того, как, почему контейнеры, а также с рассмотрения виртуализации и того, как мы к ней пришли.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8aV5AxJrHDg">Learn GitLab in 3 Hours | GitLab Complete Tutorial For Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=OMLh-5O6Ub8&amp;amp;list=PLaD4FvsFdarSyyGl3ooAm-ZyAllgw_AM5">BitBucket Tutorials Playlist&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Yc8sCSeMhi4">What is Version Control?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=kr62e_n6QuQ">Types of Version Control System&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=8JJ101D3knE&amp;amp;t=52s">Git Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Uszj_k0DGsg">Git for Professionals Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=RGOj5yH7evk&amp;amp;t=8s">Git and GitHub for Beginners - Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=apGV9Kg7ics">Complete Git and GitHub Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet">Git cheatsheet&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>42. Контейнеры</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day42/</link><pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day42/</guid><description>&lt;h2 id="контейнеры">Контейнеры&lt;/h2>
&lt;p>Этот раздел будет посвящен контейнерам. Будем рассматривать Docker, вникая в некоторые ключевые области, чтобы понять больше о контейнерах.&lt;/p>
&lt;p>Я также попытаюсь провести практические занятия по созданию контейнера, который мы сможем использовать не только в этом разделе, но и в последующих.&lt;/p>
&lt;h3 id="почему-другой-способ-запуска-приложений">Почему другой способ запуска приложений?&lt;/h3>
&lt;p>Первое, на что мы должны обратить внимание, - зачем нам нужен другой способ запуска программ или приложений? Просто выбор велик, мы можем запускать наши приложения в разных формах, мы можем видеть приложения, развернутые на физическом оборудовании с операционной системой и одним приложением, мы можем видеть виртуальную машину или облачные IaaS экземпляры, запускающие наше приложение, которое затем интегрируется в базу данных снова в виртуальной машине или как PaaS предложение в публичном облаке. Или мы можем увидеть наши приложения, работающие в контейнерах.&lt;/p>
&lt;p>Ни один из перечисленных вариантов не является неправильным или правильным, но у каждого из них есть свои причины для существования, и я также твердо уверен, что ни один из них не исчезнет. Я видел много материалов, в которых обсуждаются контейнеры и виртуальные машины, и на самом деле здесь не должно быть спора, поскольку это больше похоже на спор между яблоками и грушами, где они оба являются фруктами (способы запуска наших приложений), но это не одно и то же.&lt;/p>
&lt;p>Я бы также сказал, что если вы начинаете и разрабатываете приложение, вам следует склониться к контейнерам просто потому, что мы рассмотрим некоторые из этих областей позже, но речь идет об эффективности, скорости и размере. Но за это тоже приходится платить, если вы не имеете представления о контейнерах, то вам придется учиться, чтобы понять, зачем это нужно, и вжиться в этот образ мышления. Если вы разрабатывали свои приложения особым образом или вы не работаете в новой среде, то у вас может быть больше болевых точек, с которыми нужно справиться, прежде чем рассматривать контейнеры.&lt;/p>
&lt;p>У нас есть много различных вариантов, когда нужно загрузить ту или иную часть программного обеспечения, есть множество различных операционных систем, которые мы можем использовать. И конкретные инструкции о том, что нам нужно сделать, чтобы установить наши приложения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day42_Containers1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В последнее время я все чаще замечаю, что приложения, для которых раньше требовалась полноценная серверная ОС, виртуальная машина, физический или облачный экземпляр, теперь выпускают версии своего программного обеспечения на основе контейнеров. Я нахожу это интересным, поскольку это открывает мир контейнеров и Kubernetes для всех, а не только для разработчиков приложений.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day42_Containers2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как вы уже, наверное, поняли, я не собираюсь утверждать, что ответ - это контейнеры, в чем вопрос! Но я хотел бы обсудить, что это еще один вариант, о котором мы должны знать при развертывании наших приложений.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day42_Containers4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>У нас уже давно существует контейнерная технология, так почему же именно сейчас, за последние 10 лет, она стала популярной, я бы сказал, даже более популярной в последние 5 лет. У нас были контейнеры в течение десятилетий. Все сводится к вызову контейнеров или, лучше сказать, образов, тому, как мы распространяем наше программное обеспечение, потому что если у нас будет только контейнерная технология, то у нас останется много тех же проблем, которые были с управлением программным обеспечением.&lt;/p>
&lt;p>Если мы подумаем о Docker как об инструменте, то причина его взлета заключается в экосистеме образов, которые легко найти и использовать. Их легко установить на свои системы и запустить в работу. Важной частью этого является согласованность во всем пространстве, во всех этих различных проблемах, с которыми мы сталкиваемся при работе с программным обеспечением. Неважно, MongoDB это или nodeJS, процесс запуска любого из них будет одинаковым. Процесс остановки любого из них одинаков. Все эти проблемы будут существовать, но самое приятное, что когда мы объединяем хорошие технологии контейнеров и образов, у нас появляется единый набор инструментов для решения всех этих различных проблем. Некоторые из этих проблем перечислены ниже:&lt;/p>
&lt;ul>
&lt;li>Сначала нам нужно найти программное обеспечение в Интернете.&lt;/li>
&lt;li>Затем мы должны загрузить это программное обеспечение.&lt;/li>
&lt;li>Доверяем ли мы источнику?&lt;/li>
&lt;li>Нужна ли нам лицензия? Какая лицензия?&lt;/li>
&lt;li>Совместима ли она с различными платформами?&lt;/li>
&lt;li>Что представляет собой пакет? Бинарный? Исполняемый? Менеджер пакетов?&lt;/li>
&lt;li>Как сконфигурировать программу?&lt;/li>
&lt;li>Зависимости? Были ли они учтены при загрузке или они нам тоже нужны?&lt;/li>
&lt;li>Зависимости зависимостей?&lt;/li>
&lt;li>Как нам запустить приложение?&lt;/li>
&lt;li>Как мы остановим приложение?&lt;/li>
&lt;li>Будет ли оно автозапускаться?&lt;/li>
&lt;li>Запускаться при загрузке?&lt;/li>
&lt;li>Конфликты ресурсов?&lt;/li>
&lt;li>Конфликтующие библиотеки?&lt;/li>
&lt;li>Конфликты портов&lt;/li>
&lt;li>Безопасность программного обеспечения?&lt;/li>
&lt;li>Обновления программного обеспечения?&lt;/li>
&lt;li>Как удалить программное обеспечение?&lt;/li>
&lt;/ul>
&lt;p>Мы можем разделить вышеперечисленное на 3 области сложности программного обеспечения, с которыми помогают справиться контейнеры и образы.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Распространение&lt;/th>
&lt;th>Установка&lt;/th>
&lt;th>Эксплуатация&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Найти&lt;/td>
&lt;td>Установить&lt;/td>
&lt;td>Запустить&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Скачать&lt;/td>
&lt;td>Конфигурация&lt;/td>
&lt;td>Безопасность&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Лицензия&lt;/td>
&lt;td>Деинсталляция&lt;/td>
&lt;td>Порты&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Пакет&lt;/td>
&lt;td>Зависимости&lt;/td>
&lt;td>Конфликты с ресурсами&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Доверие&lt;/td>
&lt;td>Платформа&lt;/td>
&lt;td>Автоперезагрузка&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Поиск&lt;/td>
&lt;td>Библиотеки&lt;/td>
&lt;td>Обновления&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Контейнеры и образы помогут нам устранить некоторые из этих проблем, с которыми мы сталкиваемся при работе с другими программами и приложениями.&lt;/p>
&lt;p>На высоком уровне мы можем перенести установку и эксплуатацию в один список: образы помогут нам с точки зрения распространения, а контейнеры помогут с установкой и эксплуатацией.&lt;/p>
&lt;p>Хорошо, возможно, звучит здорово и захватывающе, но нам все еще нужно понять, что такое контейнер, и теперь я упомянул образы, поэтому давайте рассмотрим эти области далее.&lt;/p>
&lt;p>Еще одна вещь, которую вы могли часто видеть, когда мы говорили о контейнерах для разработки программного обеспечения, - это аналогия с морскими контейнерами: морские контейнеры используются для перевозки различных товаров по морю с помощью больших судов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day42_Containers5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Какое отношение это имеет к нашей теме о контейнерах? Подумайте о коде, который пишут разработчики программного обеспечения, как мы можем перенести этот код с одной машины на другую?&lt;/p>
&lt;p>Если мы подумаем о том, что мы уже говорили о распространении программного обеспечения, установке и операциях, то теперь мы начнем выстраивать это в визуальную среду. У нас есть аппаратное обеспечение и операционная система, на которой вы будете запускать несколько приложений. Например, nodejs имеет определенные зависимости и нуждается в определенных библиотеках. Если вы хотите установить MySQL, то ему нужны необходимые библиотеки и зависимости. Каждое программное приложение будет иметь свою библиотеку и зависимость. Нам может крупно повезти, и у нас не будет конфликтов между приложениями, где определенные библиотеки и зависимости сталкиваются, вызывая проблемы, но чем больше приложений, тем больше вероятность или риск конфликтов. Однако речь не идет об одном развертывании, когда все исправления ваших программных приложений будут обновлены, и тогда мы также можем столкнуться с этими конфликтами.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day42_Containers6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Контейнеры могут помочь решить эту проблему. Контейнеры помогают &lt;strong>создать&lt;/strong> ваше приложение, &lt;strong>отправить&lt;/strong> приложение, &lt;strong>развернуть&lt;/strong> и &lt;strong>масштабировать&lt;/strong> эти приложения с легкостью самостоятельно. Давайте рассмотрим архитектуру, у вас есть аппаратное обеспечение и операционная система, а поверх них - контейнерный движок, такой как docker, который мы рассмотрим позже. Программное обеспечение контейнерного движка помогает создавать контейнеры, которые упаковывают библиотеки и зависимости вместе с ними, так что вы можете легко перемещать этот контейнер с одной машины на другую, не беспокоясь о библиотеках и зависимостях, поскольку они поставляются как часть пакета, который является ничем иным, как контейнером, так что вы можете иметь различные контейнеры, которые можно перемещать между системами, не беспокоясь о базовых зависимостях, которые необходимы приложению.
потому что все, что нужно приложению для работы, упаковано как
контейнер, который можно перемещать.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day42_Containers7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="преимущества-контейнеров">Преимущества контейнеров&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Контейнеры помогают упаковать все зависимости внутри контейнера и
изолировать его.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Контейнерами легко управлять&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Возможность перехода от одной системы к другой.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Контейнеры помогают упаковать программное обеспечение, и вы можете легко отправить его без каких-либо дублирующих усилий.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Контейнеры легко масштабируются.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Используя контейнеры, вы можете масштабировать независимые контейнеры и использовать балансировщик нагрузки
или сервис, который поможет разделить трафик, и вы сможете масштабировать приложения горизонтально. Контейнеры обеспечивают большую гибкость и облегчают управление приложениями.&lt;/p>
&lt;h3 id="что-такое-контейнер">Что такое контейнер?&lt;/h3>
&lt;p>Когда мы запускаем приложения на нашем компьютере, это может быть веб-браузер или VScode, который вы используете для чтения этого сообщения. Это приложение работает как процесс или то, что известно как процесс. На наших ноутбуках или системах мы обычно запускаем несколько приложений или, как мы сказали, процессов. Когда мы открываем новое приложение или нажимаем на значок приложения, это приложение, которое мы хотим запустить, иногда это приложение может быть службой, которую мы просто хотим запустить в фоновом режиме, наша операционная система полна служб, которые работают в фоновом режиме, предоставляя вам возможность пользоваться системой.&lt;/p>
&lt;p>Значок приложения представляет собой ссылку на исполняемый файл в файловой системе, после чего операционная система загружает этот файл в память. Интересно, что этот исполняемый файл иногда называют образом, когда речь идет о процессе.&lt;/p>
&lt;p>Контейнеры - это процессы, а контейнер - это стандартная единица программного обеспечения, которая упаковывает код и все его зависимости, чтобы приложение быстро и надежно работало в разных вычислительных средах.&lt;/p>
&lt;p>Контейнерное программное обеспечение всегда будет работать одинаково, независимо от инфраструктуры. Контейнеры изолируют программное обеспечение от его окружения и обеспечивают его единообразную работу, несмотря на различия, например, между разработкой и постановкой на хранение.&lt;/p>
&lt;p>Я упоминал образы в последнем разделе, когда речь шла о том, как и почему контейнеры и образы вместе сделали контейнеры популярными в нашей экосистеме.&lt;/p>
&lt;h3 id="что-такое-образ">Что такое образ?&lt;/h3>
&lt;p>Образ контейнера - это легкий, автономный, исполняемый пакет программного обеспечения, который включает все необходимое для запуска приложения: код, время выполнения, системные инструменты, системные библиотеки и настройки. Образы контейнеров становятся контейнерами во время выполнения.&lt;/p>
&lt;h3 id="что-такое-контейнер-1">Что такое контейнер?&lt;/h3>
&lt;p>Когда мы запускаем приложения на нашем компьютере, это может быть веб-браузер или VScode, который вы используете для чтения этого сообщения. Это приложение работает как процесс или то, что известно как процесс. На наших ноутбуках или системах мы склонны запускать несколько приложений или, как мы сказали, процессов. Когда мы открываем новое приложение или нажимаем на значок приложения, это приложение, которое мы хотели бы запустить, иногда это приложение может быть службой, которую мы просто хотим запустить в фоновом режиме, наша операционная система полна служб, которые работают в фон, предоставляющий вам пользовательский опыт, который вы получаете с вашей системой.&lt;/p>
&lt;p>Этот значок приложения представляет собой ссылку на исполняемый файл где-то в вашей файловой системе, затем операционная система загружает этот исполняемый файл в память. Интересно, что этот исполняемый файл иногда называют образом, когда мы говорим о процессе.&lt;/p>
&lt;p>Контейнеры — это процессы. Контейнер — это стандартная единица программного обеспечения, которая упаковывает код и все его зависимости, чтобы приложение быстро и надежно запускалось из одной вычислительной среды в другую.&lt;/p>
&lt;p>Контейнерное программное обеспечение всегда будет работать одинаково, независимо от инфраструктуры. Контейнеры изолируют программное обеспечение от его среды и обеспечивают его единую работу, несмотря на различия, например, между разработкой и промежуточной стадией.&lt;/p>
&lt;p>Я упомянул изображения в предыдущем разделе, когда речь шла о том, как и почему сочетание контейнеров и изображений сделало контейнеры популярными в нашей экосистеме.&lt;/p>
&lt;h2 id="ссылки">Ссылки&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=3c-iBn73dDE">TechWorld with Nana - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pTFZFxd4hOI">Programming with Mosh - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=17Bl31rlnRM&amp;amp;list=WL&amp;amp;index=128&amp;amp;t=61s">Docker Tutorial for Beginners - What is Docker? Introduction to Containers&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>43. Установка Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day43/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day43/</guid><description>&lt;h2 id="что-такое-docker-и-его-установка">Что такое Docker и его установка&lt;/h2>
&lt;p>В предыдущей статье я хотя бы раз упомянул Docker, и это потому, что Docker действительно является новатором в создании популярности контейнеров, несмотря на то, что они существуют уже очень давно.&lt;/p>
&lt;p>Здесь мы будем использовать и объяснять docker, но мы также должны упомянуть [Open Container Initiative (OCI)] (&lt;a href="https://www.opencontainers.org/">https://www.opencontainers.org/&lt;/a>), которая является организацией по отраслевым стандартам, поощряющей инновации и избегающей опасности блокировки поставщиков. Благодаря OCI у нас есть выбор при выборе инструментария для контейнеров, включая Docker, &lt;a href="https://cri-o.io/">CRI-O&lt;/a>, &lt;a href="http://podman.io/">Podman&lt;/a>, &lt;a href="https://linuxcontainers.org/">LXC&lt;/a> и другие.&lt;/p>
&lt;p>Docker - это программная среда для создания, запуска и управления контейнерами. Термин &amp;ldquo;docker&amp;rdquo; может относиться как к инструментам (командам и демону), так и к формату файлов Dockerfile.&lt;/p>
&lt;p>Мы будем использовать Docker Personal, который является бесплатным (для образования и обучения). Он включает в себя все самое необходимое, что нам нужно для получения хорошего фундамента знаний о контейнерах и инструментах.&lt;/p>
&lt;p>Возможно, стоит разделить некоторые инструменты &amp;ldquo;docker&amp;rdquo;, которые мы будем использовать и для чего они нужны. Термин docker может относиться к проекту docker в целом, который является платформой для разработчиков и администраторов для разработки, доставки и запуска приложений. Также это может быть ссылка на процесс docker daeemon, запущенный на хосте, который управляет образами и контейнерами и называется Docker Engine.&lt;/p>
&lt;h3 id="docker-engine">Docker Engine&lt;/h3>
&lt;p>Docker Engine - это технология контейнеризации с открытым исходным кодом для создания и контейнеризации приложений. Docker Engine действует как клиент-серверное приложение:&lt;/p>
&lt;ul>
&lt;li>Сервер с долго работающим процессом-демоном dockerd.&lt;/li>
&lt;li>API, определяющие интерфейсы, которые программы могут использовать для общения и обучения демона Docker.&lt;/li>
&lt;li>Клиент docker с интерфейсом командной строки (CLI).&lt;/li>
&lt;/ul>
&lt;p>Вышеизложенное было взято из официальной документации Docker и конкретного &lt;a href="https://docs.docker.com/engine/">Docker Engine Overview&lt;/a>&lt;/p>
&lt;h3 id="docker-desktop">Docker Desktop&lt;/h3>
&lt;p>У нас есть рабочий стол docker для систем Windows и macOS. Простая в установке, легковесная среда разработки docker. Нативное приложение для ОС, использующее возможности виртуализации на хостовой операционной системе.&lt;/p>
&lt;p>Это лучшее решение, если вы хотите создавать, отлаживать, тестировать, упаковывать и отправлять Docker-приложения на Windows или macOS.&lt;/p>
&lt;p>На Windows мы также можем воспользоваться преимуществами WSL2 и Microsoft Hyper-V. Мы рассмотрим некоторые преимущества WSL2 по ходу дела.&lt;/p>
&lt;p>Благодаря интеграции с возможностями гипервизора на хостовой операционной системе docker предоставляет возможность запускать ваши контейнеры с операционными системами Linux.&lt;/p>
&lt;h3 id="docker-compose">Docker Compose&lt;/h3>
&lt;p>Docker compose - это инструмент, позволяющий запускать более сложные приложения в нескольких контейнерах. Преимуществом является возможность использования одного файла и команды для запуска приложения.&lt;/p>
&lt;h3 id="docker-hub">Docker Hub&lt;/h3>
&lt;p>Централизованный ресурс для работы с Docker и его компонентами. Чаще всего он известен как реестр для размещения образов Docker. Но здесь есть множество дополнительных сервисов, которые можно использовать для автоматизации или интеграции в GitHub, а также для сканирования безопасности.&lt;/p>
&lt;h3 id="dockerfile">Dockerfile&lt;/h3>
&lt;p>Dockerfile - это текстовый файл, содержащий команды, которые обычно выполняются вручную для создания образа docker. Docker может собирать образы автоматически, читая инструкции, которые содержатся в нашем dockerfile.&lt;/p>
&lt;h2 id="установка-docker-desktop">Установка Docker Desktop&lt;/h2>
&lt;p>Документация &lt;a href="https://docs.docker.com/engine/install/">docker documenation&lt;/a> просто потрясающая, и если вы только начинаете в нее погружаться, то вам стоит ее просмотреть и прочитать. Мы будем использовать Docker Desktop на Windows с WSL2. Я уже выполнил установку на своей машине, которую мы используем здесь.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day43_Containers1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Обратите внимание перед установкой на системные требования, &lt;a href="https://docs.docker.com/desktop/windows/install/">Install Docker Desktop on Windows&lt;/a>, если вы используете macOS, включая архитектуру процессора на базе M1, вы также можете взглянуть на &lt;a href="https://docs.docker.com/desktop/mac/install/">Install Docker Desktop on macOS&lt;/a>.&lt;/p>
&lt;p>Я проведу установку Docker Desktop для Windows на другой машине Windows и запишу процесс ниже.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=3c-iBn73dDE">TechWorld with Nana - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pTFZFxd4hOI">Programming with Mosh - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=17Bl31rlnRM&amp;amp;list=WL&amp;amp;index=128&amp;amp;t=61s">Docker Tutorial for Beginners - What is Docker? Introduction to Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5RQbdMn04Oc">WSL 2 with Docker getting started&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>44. Установка образов Docker в Docker Desktop</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day44/</link><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day44/</guid><description>&lt;h2 id="образы-docker-и-практическая-работа-с-docker-desktop">Образы Docker и практическая работа с Docker Desktop&lt;/h2>
&lt;p>Теперь у нас в системе установлен Docker Desktop. (Если вы используете Linux, у вас все еще есть опции, но нет графического интерфейса, но docker, очевидно, работает на Linux)&lt;a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu&lt;/a> (Другие дистрибутивы также доступны).&lt;/p>
&lt;p>В этом посте мы собираемся начать с развертывания некоторых образов в нашей среде. Напомним, что такое образ Docker - образ Docker - это файл, используемый для выполнения кода в контейнере Docker. Образы Docker действуют как набор инструкций для создания контейнера Docker, как шаблон. Образы Docker также служат отправной точкой при использовании Docker.&lt;/p>
&lt;p>Сейчас самое время пойти и создать свой аккаунт на &lt;a href="https://hub.docker.com/">DockerHub&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>DockerHub - это централизованный ресурс для работы с Docker и его компонентами. Наиболее известен как реестр для размещения образов докеров. Но здесь есть множество дополнительных сервисов, которые можно использовать для автоматизации или интеграции в GitHub, а также для сканирования безопасности.&lt;/p>
&lt;p>Если вы прокрутите вниз после входа в систему, вы увидите список образов контейнеров, вы можете увидеть образы баз данных для mySQL, hello-world и т.д. и т.п. Рассматривайте их как отличные базовые образы, или вам может понадобиться просто образ базы данных, и вам лучше всего использовать официальный образ, что означает, что вам не нужно создавать свой собственный.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем углубиться в просмотр доступных изображений и осуществлять поиск по категориям, операционным системам и архитектурам. Единственное, что я выделил ниже, это Office Image, это должно дать вам уверенность в происхождении этого образа контейнера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем искать конкретное изображение, например, wordpress может быть хорошим базовым изображением, которое нам нужно, мы можем сделать это в верхней части и найти все изображения контейнеров, связанные с wordpress. Ниже обратите внимание, что у нас также есть проверенный издатель.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Официальные образы - Официальные образы Docker - это курируемый набор открытых исходных кодов Docker и репозиториев решений &amp;ldquo;drop-in&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Проверенный издатель - высококачественный контент Docker от проверенных издателей. Эти продукты публикуются и поддерживаются непосредственно коммерческой организацией.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="изучение-docker-desktop">Изучение Docker Desktop&lt;/h3>
&lt;p>У нас в системе установлен Docker Desktop, и если открыть его, то, если он у вас еще не установлен, вы увидите нечто похожее на изображение ниже. Как вы можете видеть, у нас нет запущенных контейнеров, но наш движок docker запущен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Поскольку это была не свежая установка для меня, у меня есть некоторые изображения, которые уже загружены и доступны в моей системе. Скорее всего, здесь вы ничего не увидите.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В разделе удаленных репозиториев вы найдете все образы контейнеров, которые хранятся в вашем хабе docker. Ниже показано, что у меня нет никаких образов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем уточнить это на нашем сайте dockerhub и подтвердить, что у нас там нет репозиториев.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее у нас есть вкладка Volumes, если у вас есть контейнеры, которым требуется постоянство, то здесь мы можем добавить эти тома в вашу локальную файловую систему или общую файловую систему.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На момент написания статьи также существует вкладка Dev Environments, которая поможет вам сотрудничать с вашей командой вместо того, чтобы перемещаться между различными ветками git. Мы не будем ее рассматривать.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вернувшись на первую вкладку, вы увидите, что там есть команда, которую мы можем запустить - это контейнер для запуска. Давайте запустим &lt;code>docker run -d -p 80:80 docker/getting-started&lt;/code> в нашем терминале.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы снова проверим окно рабочего стола docker, то увидим, что у нас есть запущенный контейнер.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы могли заметить, что я использую WSL2, и для того, чтобы вы могли использовать его, вам нужно убедиться, что он включен в настройках.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если теперь мы снова перейдем на вкладку Images, вы должны увидеть используемый образ под названием docker/getting-started.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вернитесь на вкладку Containers/Apps, нажмите на ваш запущенный контейнер. По умолчанию вы увидите журналы, а в верхней части есть несколько опций на выбор, в нашем случае я уверен, что это будет веб-страница, запущенная в этом контейнере, поэтому мы выберем опцию &amp;ldquo;Открыть в браузере&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда мы нажмем на кнопку выше, конечно же, откроется веб-страница на вашем локальном хосте и отобразится что-то похожее на то, что показано ниже.&lt;/p>
&lt;p>Этот контейнер также содержит более подробную информацию о том, что такое контейнеры и изображения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы запустили наш первый контейнер. Пока ничего страшного. А что если мы захотим вытащить один из образов контейнера из DockerHub? Может быть, там есть докер-контейнер &lt;code>hello world&lt;/code>, который мы могли бы использовать.&lt;/p>
&lt;p>Я остановил начальный контейнер, не то чтобы он занимал много ресурсов, но для аккуратности, пока мы проходим еще несколько шагов.&lt;/p>
&lt;p>Вернемся в терминал и выполним команду &lt;code>docker run hello-world&lt;/code> и посмотрим, что произойдет.&lt;/p>
&lt;p>Вы можете видеть, что у нас не было локального образа, поэтому мы стянули его, а затем получили сообщение, записанное в образ контейнера, с информацией о том, что он сделал, чтобы запуститься, и некоторые ссылки на точки отсчета.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Однако, если мы посмотрим в Docker Desktop, у нас нет запущенных контейнеров, но есть вышедший контейнер, который использовал сообщение hello-world, то есть он появился, передал сообщение и затем завершился.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>И в последний раз, давайте просто проверим вкладку images и увидим, что у нас есть новый образ hello-world локально в нашей системе, что означает, что если мы снова выполним команду &lt;code>docker run hello-world&lt;/code> в нашем терминале, нам не придется ничего вытаскивать, если только версия не изменится.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В сообщении от контейнера hello-world была поставлена задача запустить что-то более амбициозное.&lt;/p>
&lt;p>Вызов принят!&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Запустив &lt;code>docker run -it ubuntu bash&lt;/code> в нашем терминале, мы собираемся запустить контейнерную версию Ubuntu, а не полную копию операционной системы. Вы можете узнать больше об этом конкретном образе на &lt;a href="https://hub.docker.com/_/ubuntu">DockerHub&lt;/a>.&lt;/p>
&lt;p>Вы можете видеть ниже, когда мы выполним команду, у нас появится интерактивная подсказка (&lt;code>-it&lt;/code>) и мы запустим оболочку bash в нашем контейнере.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>У нас есть оболочка bash, но у нас не так много больше, поэтому образ этого контейнера занимает менее 30 мб.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Но мы все еще можем использовать этот образ, и мы все еще можем установить программное обеспечение, используя наш менеджер пакетов apt, мы можем обновить наш образ контейнера и обновить также.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Или, может быть, мы хотим установить какое-то программное обеспечение в наш контейнер, я выбрал очень плохой пример, поскольку pinta - это редактор изображений, и его размер превышает 200мб, но, надеюсь, вы поняли, к чему я веду. Это значительно увеличит размер нашего контейнера, но все же мы будем находиться в мб, а не в гб.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day44_Containers24.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я хотел, чтобы вы получили общее представление о Docker Desktop и не таком уж страшном мире контейнеров, когда вы разбиваете его на простые сценарии использования, но нам нужно рассказать о некоторых сетевых возможностях, безопасности и других вариантах, которые у нас есть по сравнению с просто загрузкой образов контейнеров и их использованием таким образом. К концу раздела мы хотим создать что-то, загрузить в наш репозиторий DockerHub и иметь возможность развернуть это.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=3c-iBn73dDE">TechWorld with Nana - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pTFZFxd4hOI">Programming with Mosh - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=17Bl31rlnRM&amp;amp;list=WL&amp;amp;index=128&amp;amp;t=61s">Docker Tutorial for Beginners - What is Docker? Introduction to Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5RQbdMn04Oc">WSL 2 with Docker getting started&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>45. Что из себя представляет оьбраз Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day45/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day45/</guid><description>&lt;h2 id="анатомия-образа-docker">Анатомия образа Docker&lt;/h2>
&lt;p>На прошлом занятии мы рассмотрели некоторые основы использования Docker Desktop в сочетании с DockerHub для развертывания и запуска некоторых проверенных образов. Вкратце о том, что такое образ, вы не забудете, если я продолжу упоминать.&lt;/p>
&lt;p>Образ Docker - это шаблон, доступный только для чтения, содержащий набор инструкций для создания контейнера, который может работать на платформе Docker. Это удобный способ упаковки приложений и предварительно сконфигурированных серверных сред, которые вы можете использовать для личного пользования или публично делиться ими с другими пользователями Docker. Образы Docker также являются отправной точкой для тех, кто впервые использует Docker.&lt;/p>
&lt;p>Что произойдет, если мы захотим создать свой собственный образ Docker? Для этого мы создадим Dockerfile. Вы видели, как мы могли взять образ контейнера Ubuntu и добавить наше программное обеспечение, и у нас получился образ контейнера с программным обеспечением, которое мы хотели, и все хорошо, но если этот контейнер выключить или выбросить, то все эти обновления и установки программного обеспечения пропадут, и не будет повторяющейся версии того, что мы сделали. Это отлично подходит для демонстрации возможностей, но не помогает при транспортировке образов в несколько сред с одним и тем же набором программного обеспечения, устанавливаемого при каждом запуске контейнера.&lt;/p>
&lt;hr>
&lt;h3 id="что-такое-dockerfile">Что такое Dockerfile&lt;/h3>
&lt;p>Dockerfile - это текстовый файл, содержащий команды, которые обычно выполняются вручную для создания образа docker. Docker может собирать образы автоматически, читая инструкции, содержащиеся в нашем dockerfile.&lt;/p>
&lt;p>Каждый из файлов, составляющих образ docker, называется слоем. Эти слои образуют серию образов, поэтапно создаваемых друг над другом. Каждый слой зависит от слоя, расположенного непосредственно под ним. Порядок расположения слоев является ключевым фактором эффективности управления жизненным циклом образов docker.&lt;/p>
&lt;p>Мы должны расположить слои, которые меняются чаще всего, как можно выше в стеке, потому что при внесении изменений в слой образа Docker перестраивает не только этот слой, но и все слои, созданные на его основе. Поэтому изменение слоя на самом верху требует наименьшего объема работы по пересборке всего образа.&lt;/p>
&lt;p>Каждый раз, когда docker запускает контейнер из образа (как мы делали вчера), он добавляет слой, доступный для записи, известный как слой контейнера. В нем хранятся все изменения, вносимые в контейнер в течение всего времени его работы. Этот слой - единственное различие между работающим контейнером и исходным образом. Любое количество подобных контейнеров может иметь общий доступ к одному и тому же базовому образу, сохраняя при этом свое индивидуальное состояние.&lt;/p>
&lt;p>Вернемся к примеру, который мы использовали вчера с образом Ubuntu. Мы можем выполнить одну и ту же команду несколько раз и на первый контейнер установить pinta, а на второй - figlet. Это два разных приложения, разного назначения, разного размера и т.д. и т.п.. Каждый контейнер, который мы установили, имеет один и тот же образ, но не одно и то же состояние, и это состояние исчезает, когда мы удаляем контейнер.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В приведенном выше примере используется образ Ubuntu, но также существует множество других готовых образов контейнеров, доступных на DockerHub и в других сторонних репозиториях. Эти образы обычно называют родительским образом. Это фундамент, на котором строятся все остальные слои, и базовые строительные блоки для наших контейнерных сред.&lt;/p>
&lt;p>Наряду с набором отдельных файлов слоев, образ Docker также включает дополнительный файл, известный как манифест. Это, по сути, описание образа в формате JSON, содержащее такую информацию, как теги образа, цифровая подпись и подробные сведения о том, как настроить контейнер для различных типов хост-платформ.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="как-создать-образ-docker">Как создать образ docker&lt;/h3>
&lt;p>Есть два способа создания образа docker. Мы можем сделать это на лету, используя процесс, который мы начали вчера, мы выбираем наш базовый образ, раскручиваем контейнер, устанавливаем все программное обеспечение и депенансы, которые мы хотим иметь на нашем контейнере.&lt;/p>
&lt;p>Затем мы можем использовать команду &lt;code>docker commit container name&lt;/code>, после чего у нас будет локальная копия этого образа в разделе docker images и на вкладке docker desktop images.&lt;/p>
&lt;p>Супер просто, я бы не рекомендовал этот метод, если вы не хотите понять процесс, будет очень сложно управлять жизненным циклом таким образом и много ручной настройки/переконфигурации. Но это самый быстрый и простой способ создания образа docker. Отлично подходит для тестирования, устранения неполадок, проверки зависимостей и т.д.&lt;/p>
&lt;p>Мы собираемся создать наш образ с помощью dockerfile. Это дает нам чистый, компактный и повторяемый способ создания образов. Намного проще управлять жизненным циклом и легко интегрировать в процессы непрерывной интеграции и непрерывной доставки. Но, как вы уже поняли, это немного сложнее, чем первый упомянутый процесс.&lt;/p>
&lt;p>Использование метода dockerfile гораздо больше соответствует реальным развертываниям контейнеров корпоративного уровня.&lt;/p>
&lt;p>Создание dockerfile - это трехэтапный процесс, в ходе которого вы создаете dockerfile и добавляете команды, необходимые для сборки образа.&lt;/p>
&lt;p>В следующей таблице приведены некоторые из утверждений dockerfile, которые мы будем использовать или которые вы, скорее всего, будете использовать.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Команда&lt;/th>
&lt;th>Задача&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>FROM&lt;/td>
&lt;td>Чтобы указать родительский образ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>WORKDIR&lt;/td>
&lt;td>Чтобы задать рабочий каталог для всех последующих команд в Dockerfile.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RUN&lt;/td>
&lt;td>Для установки любых приложений и пакетов, необходимых для контейнера.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>COPY&lt;/td>
&lt;td>Для копирования файлов или каталогов из определенного места.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ADD&lt;/td>
&lt;td>Как COPY, но также может работать с удаленными URL и распаковывать сжатые файлы.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ENTRYPOINT&lt;/td>
&lt;td>Команда, которая всегда будет выполняться при запуске контейнера. Если она не указана, по умолчанию используется /bin/sh -c. Аргументы, передаваемые точке входа. Если ENTRYPOINT не задан (по умолчанию /bin/sh -c), .md будут командами, которые выполняет контейнер.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EXPOSE&lt;/td>
&lt;td>Для определения порта, через который будет осуществляться доступ к вашему контейнерному приложению.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LABEL&lt;/td>
&lt;td>Чтобы добавить метаданные к образу.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Теперь у нас есть подробная информация о том, как создать наш первый dockerfile, мы можем создать рабочий каталог и создать наш dockerfile. Я создал рабочий каталог в этом репозитории, где вы можете увидеть файлы и папки, которые мне предстоит пройти. &lt;a href="https://github.com/MichaelCade/90DaysOfDevOps/tree/main/Days/Containers">Containers&lt;/a>&lt;/p>
&lt;p>В этом каталоге я собираюсь создать файл .dockerignore, аналогичный .gitignore, который мы использовали в предыдущем разделе. В этом файле будут перечислены все файлы, которые могут быть созданы в процессе сборки Docker и которые вы хотите исключить из окончательной сборки.&lt;/p>
&lt;p>Помните, что все, что связано с контейнерами, - это компактность, максимальная скорость и отсутствие лишнего объема.&lt;/p>
&lt;p>Создадим простой Dockerfile с приведенной ниже схемой, которую также можно найти в папке по ссылке выше.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Use the official Ubuntu 18.04 as base&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FROM ubuntu:&lt;span style="color:#40a070">18.04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Install nginx and curl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUN apt&lt;span style="color:#666">-&lt;/span>get update &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> apt&lt;span style="color:#666">-&lt;/span>get upgrade &lt;span style="color:#666">-&lt;/span>y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUN apt&lt;span style="color:#666">-&lt;/span>get install &lt;span style="color:#666">-&lt;/span>y nginx curl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUN rm &lt;span style="color:#666">-&lt;/span>rf &lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span>&lt;span style="color:#666">/&lt;/span>lib&lt;span style="color:#666">/&lt;/span>apt&lt;span style="color:#666">/&lt;/span>lists&lt;span style="color:#666">/*&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Перейдите в этот каталог в терминале, а затем выполните команду &lt;code>docker build -t 90daysofdevops:0.1 .&lt;/code> мы используем &lt;code>-t&lt;/code>, а затем задаем имя и тег изображения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда мы создали наш образ, мы можем запустить его с помощью Docker Desktop или командной строки docker. Я использовал Docker Desktop Я запустил контейнер, и вы можете видеть, что у нас есть &lt;code>curl&lt;/code>, доступный нам в cli контейнера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В Docker Desktop также есть возможность использовать пользовательский интерфейс для выполнения некоторых других задач с этим новым образом.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем проинспектировать наш образ, при этом очень хорошо виден dockerfile и строки кода, которые мы хотели запустить в нашем контейнере.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>У нас есть опция pull, теперь она не работает, потому что это изображение нигде не размещено, поэтому мы получим ошибку. Однако у нас есть Push to hub, который позволит нам отправить наш образ на DockerHub.&lt;/p>
&lt;p>Если вы используете ту же &lt;code>docker build&lt;/code>, которую мы запустили ранее, то это тоже не сработает, вам понадобится команда сборки &lt;code>docker build -t {{username}}/{{imagename}}:{{version}}&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы посмотрим на наш репозиторий DockerHub, то увидим, что мы только что выложили новый образ. Теперь в Docker Desktop мы сможем использовать эту вкладку pull.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day45_Containers8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=3c-iBn73dDE">TechWorld with Nana - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pTFZFxd4hOI">Programming with Mosh - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=17Bl31rlnRM&amp;amp;list=WL&amp;amp;index=128&amp;amp;t=61s">Docker Tutorial for Beginners - What is Docker? Introduction to Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5RQbdMn04Oc">WSL 2 with Docker getting started&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackify.com/docker-build-a-beginners-guide-to-building-docker-images/">Blog on gettng started building a docker image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Docker documentation for building an image&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>46. Docker Compose</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day46/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day46/</guid><description>&lt;h2 id="docker-compose">Docker Compose&lt;/h2>
&lt;p>Возможность запуска одного контейнера может быть отличной, если у вас есть самодостаточный образ, в котором есть все, что вам нужно для одного случая использования, но все становится интересным, когда вы ищете возможность создания нескольких приложений между различными образами контейнеров. Например, если у меня есть фронт-энд сайта, но есть потребность в базе данных бэкенда, я могу поместить все в один контейнер, но лучше и эффективнее было бы иметь собственный контейнер для базы данных.&lt;/p>
&lt;p>Именно здесь на помощь приходит Docker compose - инструмент, позволяющий запускать более сложные приложения в нескольких контейнерах. Преимущество заключается в том, что для запуска приложения можно использовать один файл и команду. Пример, который я собираюсь рассмотреть в этой заметке, взят из [Docker QuickStart sample apps (Quickstart: Compose and WordPress)] (&lt;a href="https://docs.docker.com/samples/wordpress/">https://docs.docker.com/samples/wordpress/&lt;/a>).&lt;/p>
&lt;p>В этом первом примере мы собираемся:&lt;/p>
&lt;ul>
&lt;li>Использовать Docker compose для создания WordPress и отдельного экземпляра MySQL.&lt;/li>
&lt;li>Использовать YAML файл, который будет называться &lt;code>docker-compose.yml&lt;/code>.&lt;/li>
&lt;li>Соберите проект&lt;/li>
&lt;li>Настроить WordPress через браузер&lt;/li>
&lt;li>Выключение и очистка&lt;/li>
&lt;/ul>
&lt;h3 id="установка-docker-compose">Установка Docker Compose&lt;/h3>
&lt;p>Как уже упоминалось, Docker Compose - это инструмент, если вы работаете на macOS или Windows, то compose включен в вашу установку Docker Desktop. Однако вы можете захотеть запустить свои контейнеры на сервере Windows или Linux, и в этом случае вы можете установить их, используя эти инструкции &lt;a href="https://docs.docker.com/compose/install/">Install Docker Compose&lt;/a>.&lt;/p>
&lt;p>Чтобы убедиться, что &lt;code>docker-compose&lt;/code> установлен в нашей системе, мы можем открыть терминал и просто ввести приведенную выше команду.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="docker-composeyml-yaml">Docker-Compose.yml (YAML)&lt;/h3>
&lt;p>Следующее, о чем нужно поговорить, это docker-compose.yml, который вы можете найти в папке container репозитория. Но что более важно, нам нужно немного обсудить YAML в целом.&lt;/p>
&lt;p>YAML можно было бы посвятить отдельную сессию, поскольку вы можете встретить его в самых разных местах. Но по большей части&lt;/p>
&lt;p>&amp;ldquo;YAML - это удобный для человека язык сериализации данных для всех языков программирования&amp;rdquo;.&lt;/p>
&lt;p>Он обычно используется для файлов конфигурации и в некоторых приложениях, где данные хранятся или передаются. Вы, несомненно, сталкивались с XML-файлами, которые обычно предлагают тот самый файл конфигурации. YAML предоставляет минимальный синтаксис, но нацелен на те же случаи использования.&lt;/p>
&lt;p>YAML Ain&amp;rsquo;t Markup Language (YAML) - это язык сериализации, популярность которого неуклонно растет в течение последних нескольких лет. Возможности сериализации объектов делают его реальной заменой таким языкам, как JSON.&lt;/p>
&lt;p>Аббревиатура YAML была сокращением от Yet Another Markup Language. Но сопровождающие переименовали его в YAML Ain&amp;rsquo;t Markup Language, чтобы сделать больший акцент на его функциях, ориентированных на данные.&lt;/p>
&lt;p>В любом случае, вернемся к файлу docker-compose.yml. Это файл конфигурации того, что мы хотим сделать, когда речь идет о развертывании нескольких контейнеров на нашей единой системе.&lt;/p>
&lt;p>Прямо из приведенного выше руководства вы можете увидеть, что содержимое файла выглядит следующим образом:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>version: &lt;span style="color:#4070a0">&amp;#34;3.9&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>services:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: mysql:&lt;span style="color:#40a070">5.7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volumes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> db_data:&lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span>&lt;span style="color:#666">/&lt;/span>lib&lt;span style="color:#666">/&lt;/span>mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> restart: always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MYSQL_ROOT_PASSWORD: somewordpress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MYSQL_DATABASE: wordpress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MYSQL_USER: wordpress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MYSQL_PASSWORD: wordpress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wordpress:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> depends_on:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: wordpress:latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volumes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> wordpress_data:&lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span>&lt;span style="color:#666">/&lt;/span>www&lt;span style="color:#666">/&lt;/span>html
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ports:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#4070a0">&amp;#34;8000:80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> restart: always
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WORDPRESS_DB_HOST: db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WORDPRESS_DB_USER: wordpress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WORDPRESS_DB_PASSWORD: wordpress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WORDPRESS_DB_NAME: wordpress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>volumes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db_data: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wordpress_data: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Мы объявляем версию, а затем большая часть этого файла docker-compose.yml состоит из наших служб, у нас есть служба db и служба wordpress. Вы можете видеть, что для каждого из них определено изображение, с которым связан тег версии. В отличие от наших первых прохождений, сейчас мы также вводим состояние в нашу конфигурацию, но теперь мы собираемся создать тома, чтобы мы могли хранить там наши базы данных.&lt;/p>
&lt;p>Затем у нас есть некоторые переменные окружения, такие как пароли и имена пользователей. Очевидно, что эти файлы могут стать очень сложными, но конфигурационный файл YAML упрощает то, как они выглядят в целом.&lt;/p>
&lt;h3 id="сборка-проекта">Сборка проекта&lt;/h3>
&lt;p>Далее мы можем вернуться в терминал и использовать некоторые команды с помощью нашего инструмента docker-compose. Перейдите в каталог, где находится ваш файл docker-compose.yml.&lt;/p>
&lt;p>В терминале мы можем просто выполнить команду &lt;code>docker-compose up -d&lt;/code>, которая запустит процесс извлечения образов и создания вашего многоконтейнерного приложения.&lt;/p>
&lt;p>Символ &lt;code>-d&lt;/code> в этой команде означает отделенный режим, что означает, что команда Run выполняется или будет выполняться в фоновом режиме.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если теперь мы выполним команду &lt;code>docker ps&lt;/code>, вы увидите, что у нас запущено 2 контейнера, один из которых - wordpress, а другой - mySQL.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы можем проверить, что у нас запущен WordPress, открыв браузер и перейдя по адресу &lt;code>http://localhost:8000&lt;/code>, вы должны увидеть страницу установки wordpress.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем выполнить настройку WordPress, а затем начать создавать наш сайт по своему усмотрению в консоли ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы откроем новую вкладку и перейдем по тому же адресу, что и раньше &lt;code>http://localhost:8000&lt;/code>, то увидим простую тему по умолчанию с названием нашего сайта &amp;ldquo;90DaysOfDevOps&amp;rdquo;, а затем образец поста.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Прежде чем мы сделаем какие-либо изменения, откройте Docker Desktop и перейдите на вкладку volumes, здесь вы увидите два тома, связанных с нашими контейнерами, один для wordpress и один для db.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Моя текущая тема для wordpress - &amp;ldquo;Twenty Twenty-Two&amp;rdquo;, и я хочу изменить ее на &amp;ldquo;Twenty Twenty&amp;rdquo; Вернувшись в панель управления, мы можем внести эти изменения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я также собираюсь добавить новый пост на свой сайт, и здесь ниже вы видите последнюю версию нашего нового сайта.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="очищать-или-нет">Очищать или нет&lt;/h3>
&lt;p>Если мы сейчас используем команду &lt;code>docker-compose down&lt;/code>, это приведет к остановке наших контейнеров. Но наши тома останутся на месте.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем просто подтвердить в Docker Desktop, что наши тома все еще там.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы захотим вернуть все обратно, мы можем выполнить команду &lt;code>docker up -d&lt;/code> из той же директории, и наше приложение снова будет запущено.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы переходим в браузере по тому же адресу &lt;code>http://localhost:8000&lt;/code> и замечаем, что наш новый пост и смена темы все еще на месте.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы хотим избавиться от контейнеров и этих томов, то выполнение команды &lt;code>docker-compose down --volumes&lt;/code> также уничтожит тома.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда мы снова используем &lt;code>docker-compose up -d&lt;/code>, мы начнем все сначала, однако образы все еще будут локальными в нашей системе, поэтому вам не нужно будет повторно брать их из репозитория DockerHub.&lt;/p>
&lt;p>Я знаю, что когда я начал погружаться в docker-compose и его возможности, я был в замешательстве относительно того, где он находится рядом с инструментами оркестровки контейнеров, такими как Kubernetes, ну, все, что мы сделали здесь в этой короткой демонстрации, сосредоточено на одном хосте, у нас есть wordpress и db, запущенные на локальной настольной машине. У нас нет нескольких виртуальных машин или нескольких физических машин, у нас также нет возможности легко увеличивать и уменьшать требования нашего приложения.&lt;/p>
&lt;p>В следующем разделе мы рассмотрим Kubernetes, но сначала у нас есть еще несколько дней, посвященных контейнерам в целом.&lt;/p>
&lt;p>Это также отличный ресурс для примеров приложений docker compose с множеством интеграций. &lt;a href="https://github.com/docker/awesome-compose">Awesome-Compose&lt;/a>.&lt;/p>
&lt;p>В вышеупомянутом репозитории есть отличный пример, который развернет Elasticsearch, Logstash и Kibana (ELK) на одном узле.&lt;/p>
&lt;p>Я загрузил файлы в папку &lt;a href="https://github.com/MichaelCade/90DaysOfDevOps/tree/main/Days/Containers/elasticsearch-logstash-kibana">Containers&lt;/a> Когда у вас есть эта папка локально, перейдите туда и вы можете просто использовать &lt;code>docker-compose up -d&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем проверить наличие запущенных контейнеров с помощью &lt;code>docker ps&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем открыть браузер для каждого из контейнеров:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day46_Containers17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы удалить все, мы можем использовать команду &lt;code>docker-compose down&lt;/code>.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=3c-iBn73dDE">TechWorld with Nana - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pTFZFxd4hOI">Programming with Mosh - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=17Bl31rlnRM&amp;amp;list=WL&amp;amp;index=128&amp;amp;t=61s">Docker Tutorial for Beginners - What is Docker? Introduction to Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5RQbdMn04Oc">WSL 2 with Docker getting started&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackify.com/docker-build-a-beginners-guide-to-building-docker-images/">Blog on gettng started building a docker image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Docker documentation for building an image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cloudbees.com/blog/yaml-tutorial-everything-you-need-get-started">YAML Tutorial: Everything You Need to Get Started in Minute&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>47. Сетевое взаимодействие Docker и безопасность</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day47/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day47/</guid><description>&lt;h2 id="docker-networking--security">Docker Networking &amp;amp; Security&lt;/h2>
&lt;p>Во время этой сессии по контейнерам мы уже кое-что сделали, но не рассмотрели, как все работает за кулисами с точки зрения сетевых технологий, а также не затронули безопасность, поэтому мы планируем эту сессию.&lt;/p>
&lt;h3 id="основы-сетевого-взаимодействия-docker">Основы сетевого взаимодействия Docker&lt;/h3>
&lt;p>Откройте терминал и введите команду &lt;code>docker network&lt;/code> - это основная команда для настройки и управления сетями контейнеров.&lt;/p>
&lt;p>Ниже показано, как мы можем использовать эту команду и все доступные подкоманды. Мы можем создавать новые сети, составлять список существующих, проверять и удалять сети.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Давайте посмотрим на существующие сети, которые у нас есть с момента установки, поэтому из коробки Docker networking выглядит как использование команды &lt;code>docker network list&lt;/code>.&lt;/p>
&lt;p>Каждая сеть получает уникальный ID и NAME. Каждая сеть также связана с одним драйвером. Обратите внимание, что сеть &amp;ldquo;bridge&amp;rdquo; и сеть &amp;ldquo;host&amp;rdquo; имеют те же имена, что и их соответствующие драйверы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы можем более детально рассмотреть наши сети с помощью команды &lt;code>docker network inspect&lt;/code>.&lt;/p>
&lt;p>Запустив команду &lt;code>docker network inspect bridge&lt;/code>, я могу получить все детали конфигурации конкретного имени сети. Сюда входят имя, ID, драйверы, подключенные контейнеры и, как вы можете видеть, многое другое.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="docker-bridge-networking">Docker: Bridge Networking&lt;/h3>
&lt;p>Как вы видели выше, стандартная установка Docker Desktop дает нам предварительно созданную сеть под названием &lt;code>bridge&lt;/code> Если вы обратитесь к команде &lt;code>docker network list&lt;/code>, то увидите, что сеть под названием bridge связана с драйвером &lt;code>bridge&lt;/code>. То, что у них одинаковое имя, не означает, что это одно и то же. Связаны, но не одно и то же.&lt;/p>
&lt;p>Вывод выше также показывает, что сеть bridge имеет локальную привязку. Это означает, что сеть существует только на этом хосте Docker. Это справедливо для всех сетей, использующих драйвер моста - драйвер моста обеспечивает работу сети на одном хосте.&lt;/p>
&lt;p>Все сети, созданные с помощью драйвера моста, основаны на мосте Linux (он же виртуальный коммутатор).&lt;/p>
&lt;h3 id="подключение-контейнера">Подключение контейнера&lt;/h3>
&lt;p>По умолчанию новым контейнерам назначается сеть bridge, то есть, если вы не укажете сеть, все контейнеры будут подключены к сети bridge.&lt;/p>
&lt;p>Давайте создадим новый контейнер командой &lt;code>docker run -dt ubuntu sleep infinity&lt;/code>.&lt;/p>
&lt;p>Команда sleep выше просто будет поддерживать работу контейнера в фоновом режиме, чтобы мы могли возиться с ним.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы затем проверим нашу сеть моста с помощью &lt;code>docker network inspect bridge&lt;/code>, вы увидите, что у нас есть контейнер, соответствующий тому, что мы только что развернули, потому что мы не указали сеть.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем погрузиться в контейнер, используя &lt;code>docker exec -it 3a99af449ca2 bash&lt;/code>, вам придется использовать &lt;code>docker ps&lt;/code>, чтобы получить идентификатор контейнера.&lt;/p>
&lt;p>Отсюда наш образ не имеет ничего для пинга, поэтому нам нужно выполнить следующую команду.&lt;code>apt-get update &amp;amp;&amp;amp; apt-get install -y iputils-ping&lt;/code> затем пингуем внешний адрес интерфеса. &lt;code>ping -c5 www.90daysofdevops.com&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы устранить эту проблему, мы можем запустить &lt;code>docker stop 3a99af449ca2&lt;/code> и снова использовать &lt;code>docker ps&lt;/code> для поиска ID вашего контейнера, но это приведет к удалению нашего контейнера.&lt;/p>
&lt;h3 id="настройте-nat-для-внешнего-подключения">Настройте NAT для внешнего подключения&lt;/h3>
&lt;p>На этом шаге мы запустим новый контейнер NGINX и назначим порт 8080 на хосте Docker на порт 80 внутри контейнера. Это означает, что трафик, поступающий на хост Docker по порту 8080, будет передаваться на порт 80 внутри контейнера.&lt;/p>
&lt;p>Запустите новый контейнер на основе официального образа NGINX, выполнив команду &lt;code>docker run --name web1 -d -p 8080:80 nginx&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Просмотрите состояние контейнера и сопоставление портов, выполнив команду &lt;code>docker ps&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Верхняя строка показывает новый контейнер web1, запущенный NGINX. Обратите внимание на команду, которую запускает контейнер, а также на сопоставление портов - &lt;code>0.0.0.0:8080-&amp;gt;80/tcp&lt;/code> сопоставляет порт 8080 на всех интерфейсах хоста с портом 80 внутри контейнера web1. Это сопоставление портов делает веб-сервис контейнера доступным из внешних источников (через IP-адрес хоста Docker на порту 8080).&lt;/p>
&lt;p>Теперь нам нужен IP-адрес нашего реального хоста, мы можем сделать это, зайдя в терминал WSL и используя команду &lt;code>ip addr&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем взять этот IP, открыть браузер и перейти по адресу &lt;code>http://172.25.218.154:8080/&lt;/code> Ваш IP может быть другим. Это подтверждает, что NGINX доступен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я взял эти инструкции с этого сайта с далекого 2017 DockerCon, но они актуальны и сегодня. Однако остальная часть руководства посвящена Docker Swarm, и я не собираюсь рассматривать его здесь. &lt;a href="https://github.com/docker/labs/tree/master/dockercon-us-2017/docker-networking">Docker Networking - DockerCon 2017&lt;/a>&lt;/p>
&lt;h3 id="обеспечение-безопасности-контейнеров">Обеспечение безопасности контейнеров&lt;/h3>
&lt;p>Контейнеры обеспечивают безопасную среду для рабочих нагрузок по сравнению с полной конфигурацией сервера. Они позволяют разбить ваши приложения на более мелкие, слабо связанные компоненты, изолированные друг от друга, что помогает уменьшить поверхность атаки в целом.&lt;/p>
&lt;p>Но они не застрахованы от хакеров, которые хотят использовать системы в своих целях. Нам по-прежнему необходимо понимать подводные камни безопасности этой технологии и придерживаться лучших практик.&lt;/p>
&lt;h3 id="откажитесь-от-прав-root">Откажитесь от прав root&lt;/h3>
&lt;p>Все контейнеры, которые мы развернули, использовали права root для процессов внутри контейнеров. Это означает, что они имеют полный административный доступ к вашим контейнерам и хост-средам. Теперь для целей прохождения мы знали, что эти системы не будут работать долго. Но вы видели, как легко их запустить.&lt;/p>
&lt;p>Мы можем добавить несколько шагов к нашему процессу, чтобы дать возможность не root-пользователям быть предпочтительной лучшей практикой. При создании нашего dockerfile мы можем создать учетные записи пользователей. Вы можете найти этот пример также в папке containers в репозитории.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span># Используем официальную версию Ubuntu 18.04 в качестве базовой
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FROM ubuntu:18.04
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUN apt-get update &amp;amp;&amp;amp; apt-get upgrade -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUN groupadd -g 1000 basicuser &amp;amp;&amp;amp; useradd -r -u 1000 -g basicuser basicuser
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>пользователь basicuser
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Мы также можем использовать &lt;code>docker run --user 1009 ubuntu&lt;/code> Команда Docker run переопределяет любого пользователя, указанного в вашем Dockerfile. Поэтому в следующем примере ваш контейнер всегда будет запускаться с наименьшими привилегиями при условии, что идентификатор пользователя 1009 также имеет самый низкий уровень прав.&lt;/p>
&lt;p>Однако этот метод не устраняет основной недостаток безопасности самого образа. Поэтому лучше указать в Dockerfile пользователя, не являющегося root, чтобы ваши контейнеры всегда запускались безопасно.&lt;/p>
&lt;h3 id="частный-репозитории">Частный репозитории&lt;/h3>
&lt;p>Еще одна область, которую мы активно используем, - это публичные реестры в DockerHub, а частный реестр образов контейнеров, созданный вашей организацией, означает, что вы можете размещать их там, где пожелаете, или же для этого существуют управляемые сервисы, но в целом это дает вам полный контроль над образами, доступными для вас и вашей команды.&lt;/p>
&lt;p>DockerHub отлично подходит для создания базового уровня, но он предоставляет только базовый сервис, где вам придется во многом доверять издателю образа.&lt;/p>
&lt;h3 id="lean--clean">Lean &amp;amp; Clean&lt;/h3>
&lt;p>Мы уже упоминали об этом, хотя это и не связано с безопасностью. Но размер вашего контейнера также может влиять на безопасность с точки зрения поверхности атаки, если у вас есть ресурсы, которые вы не используете в своем приложении, то они не нужны в вашем контейнере.&lt;/p>
&lt;p>Это также является моей основной проблемой при использовании &lt;code>последних&lt;/code> образов, потому что это может принести много лишнего в ваши образы. DockerHub показывает сжатый размер для каждого образа в хранилище.&lt;/p>
&lt;p>&lt;code>docker image&lt;/code> - отличная команда для просмотра размера ваших образов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day47_Containers11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=3c-iBn73dDE">TechWorld with Nana - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pTFZFxd4hOI">Programming with Mosh - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=17Bl31rlnRM&amp;amp;list=WL&amp;amp;index=128&amp;amp;t=61s">Docker Tutorial for Beginners - What is Docker? Introduction to Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5RQbdMn04Oc">WSL 2 with Docker getting started&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackify.com/docker-build-a-beginners-guide-to-building-docker-images/">Blog on gettng started building a docker image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Docker documentation for building an image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cloudbees.com/blog/yaml-tutorial-everything-you-need-get-started">YAML Tutorial: Everything You Need to Get Started in Minute&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>48. Альтернативы Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day48/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day48/</guid><description>&lt;h2 id="альтернативы-docker">Альтернативы Docker&lt;/h2>
&lt;p>В самом начале этого раздела я говорил, что мы будем использовать Docker, просто потому, что ресурсов очень много, а сообщество очень большое, но также именно с него начался толчок к популярности контейнеров. Я бы посоветовал вам пойти и посмотреть немного истории о Docker и о том, как он появился, я нашел это очень полезным.&lt;/p>
&lt;p>Но, как я уже упоминал, существуют и другие альтернативы Docker. Если мы подумаем о том, что такое Docker и что мы уже рассмотрели. Это платформа для разработки, тестирования, развертывания и управления приложениями.&lt;/p>
&lt;p>Я хочу выделить несколько альтернатив Docker, которые вы можете увидеть или увидите в будущем.&lt;/p>
&lt;h3 id="podman">Podman&lt;/h3>
&lt;p>Что такое Podman? Podman - это контейнерный движок без демонов для разработки, управления и запуска OCI-контейнеров в вашей системе Linux. Контейнеры могут быть запущены от имени root или в режиме rootless.&lt;/p>
&lt;p>Я буду рассматривать это с точки зрения Windows, но знаю, что, как и в случае с Docker, здесь не требуется виртуализация, поскольку он будет использовать базовую ОС, чего нельзя сделать в мире Windows.&lt;/p>
&lt;p>Podman может быть запущен под WSL2, хотя и не так гладко, как в случае с Docker Desktop. Существует также удаленный клиент Windows, с помощью которого можно подключиться к виртуальной машине Linux, где будут запущены ваши контейнеры.&lt;/p>
&lt;p>Мой Ubuntu на WSL2 - это версия 20.04. Следуя следующим шагам, вы сможете установить Podman на свой экземпляр WSL.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#4070a0">&amp;#34;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /&amp;#34;&lt;/span> &lt;span style="color:#666">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo tee &lt;span style="color:#666">/&lt;/span>etc&lt;span style="color:#666">/&lt;/span>apt&lt;span style="color:#666">/&lt;/span>sources&lt;span style="color:#666">.&lt;/span>list&lt;span style="color:#666">.&lt;/span>d&lt;span style="color:#666">/&lt;/span>devel:kubic:libcontainers:stable&lt;span style="color:#666">.&lt;/span>list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Добавим ключ GPG&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>curl &lt;span style="color:#666">-&lt;/span>L &lt;span style="color:#4070a0">&amp;#34;https://download.opensuse.org/repositories/devel:/kubic:&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0;font-weight:bold">&lt;/span>&lt;span style="color:#4070a0">/libcontainers:/stable/xUbuntu_20.04/Release.key&amp;#34;&lt;/span> &lt;span style="color:#666">|&lt;/span> sudo apt&lt;span style="color:#666">-&lt;/span>key add &lt;span style="color:#666">-&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Запустите обновление системы с помощью команды &lt;code>sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade&lt;/code>. Наконец, мы можем установить podman с помощью команды &lt;code>sudo apt install podman&lt;/code>.&lt;/p>
&lt;p>Теперь мы можем использовать многие из тех же команд, которые мы использовали для docker, однако обратите внимание, что у нас нет красивого пользовательского интерфейса рабочего стола docker. Вы можете видеть ниже, я использовал &lt;code>podman images&lt;/code> и у меня ничего не появилось после установки, затем я использовал &lt;code>podman pull ubuntu&lt;/code> для извлечения образа контейнера ubuntu.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day48_Containers1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем запустить наш образ Ubuntu с помощью &lt;code>podman run -dit ubuntu&lt;/code> и &lt;code>podman ps&lt;/code>, чтобы увидеть наш запущенный образ.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day48_Containers2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы попасть в этот контейнер, мы можем выполнить команду &lt;code>podman attach dazzling_darwin&lt;/code>, имя вашего контейнера, скорее всего, будет другим.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day48_Containers3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы переходите от docker к podman, то обычно также необходимо изменить ваш конфигурационный файл на &lt;code>alias docker=podman&lt;/code>, тогда любая команда, запущенная с помощью docker, будет использовать podman.&lt;/p>
&lt;h3 id="lxc">LXC&lt;/h3>
&lt;p>LXC - это механизм контейнеризации, который позволяет пользователям снова создавать несколько изолированных контейнерных сред Linux. В отличие от Docker LXC действует как гипервизор для создания нескольких Linux-машин с отдельными системными файлами, сетевыми функциями. Появился еще до Docker, а затем сделал короткое возвращение из-за недостатков Docker.&lt;/p>
&lt;p>LXC такой же легкий, как и docker, и легко развертывается.&lt;/p>
&lt;h3 id="containerd">Containerd&lt;/h3>
&lt;p>Автономная среда выполнения контейнеров. Containerd обеспечивает простоту и надежность, а также, конечно, переносимость. Ранее Containerd был инструментом, работающим как часть контейнерных сервисов Docker, пока Docker не решил вывести свои компоненты в самостоятельные.&lt;/p>
&lt;p>Проект в Cloud Native Computing Foundation, что ставит его в один ряд с такими популярными контейнерными инструментами, как Kubernetes, Prometheus и CoreDNS.&lt;/p>
&lt;h3 id="другие-инструменты-docker">Другие инструменты Docker&lt;/h3>
&lt;p>Мы могли бы также упомянуть инструменты и опции вокруг Rancher, VirtualBox, но мы можем рассказать о них более подробно в другой раз.&lt;/p>
&lt;p>&lt;a href="https://gradle.org/">&lt;strong>Gradle&lt;/strong>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Сканирование сборки позволяет командам совместно отлаживать свои скрипты и отслеживать историю всех сборок.&lt;/li>
&lt;li>Опции выполнения дают командам возможность непрерывной сборки так, чтобы при каждом вводе изменений задание выполнялось автоматически.&lt;/li>
&lt;li>Настраиваемый макет репозитория дает командам возможность рассматривать любую структуру файловых каталогов как хранилище артефактов.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://packer.io/">&lt;strong>Packer&lt;/strong>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Возможность параллельного создания нескольких машинных образов для экономии времени разработчиков и повышения эффективности.&lt;/li>
&lt;li>Команды могут легко отлаживать сборки с помощью отладчика Packer, который проверяет сбои и позволяет командам опробовать решения перед перезапуском сборки.&lt;/li>
&lt;li>Поддержка многих платформ с помощью плагинов, что позволяет командам настраивать свои сборки.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/gliderlabs/logspout">&lt;strong>Logspout&lt;/strong>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Инструмент для ведения логов - настраиваемость инструмента позволяет командам отправлять одни и те же логи в несколько мест назначения.&lt;/li>
&lt;li>Команды могут легко управлять своими файлами, поскольку инструмент требует только доступа к сокету Docker.&lt;/li>
&lt;li>Полностью с открытым исходным кодом и прост в развертывании.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.elastic.co/products/logstash">&lt;strong>Logstash&lt;/strong>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Настройте свой конвейер с помощью подключаемой структуры Logstash.&lt;/li>
&lt;li>Легко анализируйте и преобразуйте данные для анализа и повышения ценности бизнеса.&lt;/li>
&lt;li>Разнообразие выходов Logstash позволяет направлять данные туда, куда вам нужно.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.portainer.io/">&lt;strong>Portainer&lt;/strong>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Используйте готовые шаблоны или создавайте свои собственные для развертывания приложений.&lt;/li>
&lt;li>Создавайте команды и назначайте роли и разрешения для членов команды.&lt;/li>
&lt;li>Узнайте, что запущено в каждой среде, используя приборную панель инструмента.&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=3c-iBn73dDE">TechWorld with Nana - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pTFZFxd4hOI">Programming with Mosh - Docker Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=17Bl31rlnRM&amp;amp;list=WL&amp;amp;index=128&amp;amp;t=61s">Docker Tutorial for Beginners - What is Docker? Introduction to Containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5RQbdMn04Oc">WSL 2 with Docker getting started&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackify.com/docker-build-a-beginners-guide-to-building-docker-images/">Blog on gettng started building a docker image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Docker documentation for building an image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cloudbees.com/blog/yaml-tutorial-everything-you-need-get-started">YAML Tutorial: Everything You Need to Get Started in Minute&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Za2BqzeZjBk">Podman | Daemonless Docker | Getting Started with Podman&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=cqOtksmsxfg">LXC - Guide to building a LXC Lab&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>49. Основы Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day49/</link><pubDate>Wed, 08 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day49/</guid><description>&lt;h2 id="общая-картина-kubernetes">Общая картина: Kubernetes&lt;/h2>
&lt;p>В предыдущем разделе мы рассмотрели контейнеры. Контейнеры не справляются с задачей масштабирования и оркестровки. Лучшее, что мы можем сделать, это использовать docker-compose для объединения нескольких контейнеров. Когда речь заходит о Kubernetes, который является оркестратором контейнеров, это дает нам возможность масштабирования в автоматическом режиме или в зависимости от нагрузки ваших приложений и сервисов.&lt;/p>
&lt;p>Как платформа Kubernetes предлагает возможность оркестровки контейнеров в соответствии с вашими требованиями и желаемым состоянием. Мы рассмотрим Kubernetes в этом разделе, поскольку она быстро развивается как следующая волна инфраструктуры. С точки зрения DevOps, Kubernetes - это лишь одна из платформ, базовое понимание которой вам понадобится. Вам также потребуется понимание &amp;ldquo;голого металла&amp;rdquo;, виртуализации и, скорее всего, облачных сервисов. Kubernetes - это просто еще один вариант запуска наших приложений.&lt;/p>
&lt;h3 id="что-такое-оркестровка-контейнеров">Что такое оркестровка контейнеров?&lt;/h3>
&lt;p>Я упомянул Kubernetes и упомянул оркестровку контейнеров, Kubernetes - это технология, а оркестровка контейнеров - это концепция или процесс, стоящий за технологией. Kubernetes - не единственная платформа для оркестровки контейнеров, у нас также есть Docker Swarm, HashiCorp Nomad и другие. Но Kubernetes набирает силу, поэтому я хочу рассказать о Kubernetes, но хочу сказать, что она не единственная.&lt;/p>
&lt;h3 id="что-такое-kubernetes">Что такое Kubernetes?&lt;/h3>
&lt;p>Первое, что вам следует прочитать, если вы новичок в Kubernetes, - это официальная документация. Мой опыт глубокого погружения в Kubernetes чуть больше года назад показал, что это будет крутая кривая обучения. Будучи выходцем из сферы виртуализации и хранения данных, я думал о том, насколько пугающим это кажется.&lt;/p>
&lt;p>Но на самом деле сообщество, бесплатные учебные ресурсы и документация просто потрясающие. &lt;a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">Kubernetes.io&lt;/a>&lt;/p>
&lt;p>&lt;em>Kubernetes - это портативная, расширяемая платформа с открытым исходным кодом для управления контейнерными рабочими нагрузками и сервисами, которая облегчает как декларативную конфигурацию, так и автоматизацию. Она имеет большую, быстро развивающуюся экосистему. Услуги, поддержка и инструменты Kubernetes широко доступны&lt;/em>.&lt;/p>
&lt;p>Важные моменты, которые следует отметить из вышеприведенного цитаты: Kubernetes является открытым исходным кодом с богатой историей, восходящей к Google, который передал проект в фонд Cloud Native computing Foundation (CNCF), и в настоящее время он развивается сообществом открытого исходного кода, а также крупными корпоративными поставщиками, которые внесли свой вклад, чтобы сделать Kubernetes тем, чем он является сегодня.&lt;/p>
&lt;p>Я уже упоминал, что контейнеры - это здорово, и в предыдущем разделе мы говорили о том, как контейнеры и образы контейнеров изменили и ускорили внедрение облачных нативных систем. Но сами по себе контейнеры не дадут вам готового к производству опыта, который необходим вашему приложению. Kubernetes дает нам следующее:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Обнаружение сервисов и балансировка нагрузки Kubernetes может открыть контейнер, используя DNS-имя или собственный IP-адрес. Если трафик на контейнер высок, Kubernetes может сбалансировать нагрузку и распределить сетевой трафик так, чтобы развертывание было стабильным.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Оркестровка хранилищ Kubernetes позволяет автоматически монтировать системы хранения по вашему выбору, например, локальные хранилища, общедоступные облачные провайдеры и многое другое.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Автоматизированное развертывание и откат Вы можете описать желаемое состояние для развернутых контейнеров с помощью Kubernetes, и он может изменить фактическое состояние на желаемое с контролируемой скоростью. Например, вы можете автоматизировать Kubernetes для создания новых контейнеров для развертывания, удаления существующих контейнеров и переноса всех их ресурсов в новый контейнер.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Автоматическая упаковка контейнеров Вы предоставляете Kubernetes кластер узлов, которые он может использовать для выполнения контейнерных задач. Вы сообщаете Kubernetes, сколько процессора и памяти (RAM) требуется каждому контейнеру. Kubernetes может разместить контейнеры на ваших узлах, чтобы наилучшим образом использовать ваши ресурсы.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Самовосстановление Kubernetes перезапускает вышедшие из строя контейнеры, заменяет контейнеры, уничтожает контейнеры, которые не отвечают на заданную пользователем проверку работоспособности, и не рекламирует их клиентам, пока они не будут готовы к обслуживанию.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Управление секретами и конфигурациями Kubernetes позволяет хранить и управлять конфиденциальной информацией, такой как пароли, токены OAuth и ключи SSH. Вы можете развертывать и обновлять секреты и конфигурацию приложений, не перестраивая образы контейнеров и не раскрывая секреты в конфигурации стека.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Kubernetes предоставляет вам основу для отказоустойчивого запуска распределенных систем.&lt;/p>
&lt;p>Container Orchestration управляет развертыванием, размещением и жизненным циклом контейнеров.&lt;/p>
&lt;p>На нее также возложено множество других обязанностей:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Управление кластером объединяет узлы в одну цель.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Управление расписанием распределяет контейнеры по узлам с помощью планировщика.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Обнаружение сервисов знает, где находятся контейнеры, и распределяет между ними запросы клиентов.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Репликация обеспечивает наличие необходимого количества узлов и контейнеров для требуемой рабочей нагрузки.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Управление здоровьем обнаруживает и заменяет нездоровые контейнеры и узлы.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="основные-компоненты-kubernetes">Основные компоненты Kubernetes&lt;/h3>
&lt;p>Kubernetes - это контейнерный оркестратор для обеспечения, управления и масштабирования приложений. Вы можете использовать его для управления жизненным циклом контейнерных приложений в кластере узлов, который представляет собой набор рабочих машин, таких как виртуальные машины или физические машины.&lt;/p>
&lt;p>Для работы вашим приложениям может понадобиться множество других ресурсов, таких как тома, сети и секреты, которые помогут вам подключаться к базам данных, общаться с бэкграундом и защищать ключи. С помощью Kubernetes вы можете добавить эти ресурсы в свое приложение. Инфраструктурные ресурсы, необходимые вашим приложениям, управляются декларативно.&lt;/p>
&lt;p>Ключевой парадигмой Kubernetes является ее декларативная модель. Вы предоставляете нужное вам состояние, а Kubernetes его реализует. Если вам нужно пять экземпляров, вы не запускаете пять отдельных экземпляров самостоятельно. Вместо этого вы сообщаете Kubernetes, что вам нужно пять экземпляров, и Kubernetes автоматически согласовывает состояние. Если с одним из ваших экземпляров что-то пойдет не так и он выйдет из строя, Kubernetes все равно будет знать нужное вам состояние и создаст экземпляры на доступном узле.&lt;/p>
&lt;h3 id="узел">Узел&lt;/h3>
&lt;p>&lt;strong>План управления&lt;/strong>&lt;/p>
&lt;p>Каждый кластер Kubernetes требует наличия узла Control Plane, компоненты которого принимают глобальные решения относительно кластера (например, планирование), а также обнаруживают и реагируют на события кластера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>Рабочий узел&lt;/strong>
Рабочая машина, на которой выполняются рабочие нагрузки Kubernetes. Это может быть физическая (bare metal) машина или виртуальная машина (VM). На каждом узле может размещаться один или несколько стручков. Узлы Kubernetes управляются плоскостью управления&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Существуют и другие типы узлов, но я не буду их здесь рассматривать.&lt;/p>
&lt;p>&lt;strong>kubelet&lt;/strong>&lt;/p>
&lt;p>Агент, который запускается на каждом узле кластера. Он следит за тем, чтобы контейнеры запускались в Pod.&lt;/p>
&lt;p>Куплет принимает набор PodSpecs, которые предоставляются через различные механизмы, и гарантирует, что контейнеры, описанные в этих PodSpecs, запущены и здоровы. Куплет не управляет контейнерами, которые не были созданы Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>kube-proxy&lt;/strong>&lt;/p>
&lt;p>kube-proxy - это сетевой прокси, который работает на каждом узле вашего кластера, реализуя часть концепции Kubernetes Service.&lt;/p>
&lt;p>kube-proxy поддерживает сетевые правила на узлах. Эти сетевые правила позволяют сетевое взаимодействие с вашими Pods из сетевых сессий внутри или вне вашего кластера.&lt;/p>
&lt;p>kube-proxy использует уровень фильтрации пакетов операционной системы, если он есть и доступен. В противном случае kube-proxy сам перенаправляет трафик.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>Время выполнения контейнера&lt;/strong>&lt;/p>
&lt;p>Время выполнения контейнеров - это программное обеспечение, которое отвечает за запуск контейнеров.&lt;/p>
&lt;p>Kubernetes поддерживает несколько сред выполнения контейнеров: Docker, containerd, CRI-O и любую реализацию Kubernetes CRI (Container Runtime Interface).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
​&lt;/p>
&lt;h3 id="кластер">Кластер&lt;/h3>
&lt;p>Кластер - это группа узлов, где узлом может быть физическая машина или виртуальные машины. На каждом из узлов будет установлена среда выполнения контейнеров (Docker), а также будет запущен сервис kubelet, который является агентом, принимающим команды от главного контроллера (подробнее об этом позже), и прокси, который используется для прокси-соединений с Pods от другого компонента (сервисы, которые мы рассмотрим позже).&lt;/p>
&lt;p>На нашей плоскости управления, которую можно сделать высокодоступной, будет несколько уникальных ролей по сравнению с рабочими узлами, самой важной из них будет сервер kube API, именно с ним будет происходить любое взаимодействие для получения информации или отправки информации в наш кластер Kubernetes.&lt;/p>
&lt;p>&lt;strong>Kube API-Server&lt;/strong>&lt;/p>
&lt;p>Сервер API Kubernetes проверяет и настраивает данные для объектов api, которые включают стручки, сервисы, контроллеры репликации и другие. API-сервер обслуживает REST-операции и предоставляет фронтенд к общему состоянию кластера, через который взаимодействуют все остальные компоненты.&lt;/p>
&lt;p>&lt;strong>Планировщик&lt;/strong>&lt;/p>
&lt;p>Планировщик Kubernetes - это процесс в плоскости управления, который назначает Pods узлам. Планировщик определяет, какие узлы являются допустимыми для размещения каждого Pod в очереди планирования в соответствии с ограничениями и доступными ресурсами. Затем планировщик ранжирует каждый допустимый узел и привязывает Pod к подходящему узлу.&lt;/p>
&lt;p>&lt;strong>Менеджер контроллера&lt;/strong>&lt;/p>
&lt;p>Менеджер контроллеров Kubernetes - это демон, который встраивает основные контуры управления, поставляемые с Kubernetes. В приложениях робототехники и автоматизации контур управления - это не завершающийся цикл, который регулирует состояние системы. В Kubernetes контроллер - это контур управления, который следит за общим состоянием кластера через apiserver и вносит изменения, пытаясь переместить текущее состояние в желаемое.&lt;/p>
&lt;p>&lt;strong>etcd&lt;/strong>.&lt;/p>
&lt;p>Последовательное и высокодоступное хранилище значений ключей, используемое в качестве резервного хранилища Kubernetes для всех данных кластера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;strong>kubectl&lt;/strong>&lt;/p>
&lt;p>Для управления этим с точки зрения CLI у нас есть kubectl, kubectl взаимодействует с сервером API.&lt;/p>
&lt;p>Инструмент командной строки Kubernetes, kubectl, позволяет выполнять команды для кластеров Kubernetes. Вы можете использовать kubectl для развертывания приложений, проверки и управления ресурсами кластера, а также для просмотра журналов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="pods">Pods&lt;/h3>
&lt;p>Pod - это группа контейнеров, которые образуют логическое приложение. Например, если у вас есть веб-приложение, в котором запущен контейнер NodeJS, а также контейнер MySQL, то оба этих контейнера будут находиться в одном Pod. Pod также может иметь общие тома данных, а также разделять одно и то же сетевое пространство имен. Помните, что Pods являются эфемерными и могут быть подняты и опущены главным контроллером. Kubernetes использует простое, но эффективное средство идентификации Pods с помощью концепции Labels (имя - значения).&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Подсистемы управляют томами, секретами и конфигурацией контейнеров.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Подсистемы являются эфемерными. Они предназначены для автоматического перезапуска после смерти.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pods реплицируются при горизонтальном масштабировании приложения с помощью ReplicationSet. Каждый Pod будет выполнять один и тот же код контейнера.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pods живут на рабочих узлах (Worker Nodes).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="развертывания">Развертывания&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Вы можете просто решить запустить Pods, но когда они умирают, они умирают.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Развертывание позволит вашему стручку работать непрерывно.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Развертывания позволяют вам обновлять работающее приложение без простоя.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Развертывания также определяют стратегию перезапуска стручков, когда они умирают&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="replicasets">ReplicaSets&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Развертывание также может создать набор реплик.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ReplicaSet гарантирует, что ваше приложение имеет необходимое количество Pods.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ReplicaSets будет создавать и масштабировать Pods на основе развертывания&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Развертывание, наборы реплик, подсистемы не являются исключительными, но могут быть&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="statefulsets">StatefulSets&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Требуется ли вашему приложению хранить информацию о его состоянии?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>База данных нуждается в состоянии&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Подсистемы StatefulSet не являются взаимозаменяемыми.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Каждый Pod имеет уникальный постоянный идентификатор, который контроллер сохраняет при любом перепланировании.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Каждый Pod имеет уникальный, постоянный идентификатор, который контроллер сохраняет при любом перепланировании.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="daemonsets">DaemonSets&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>DaemonSets предназначены для непрерывного процесса.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Они запускают по одному Pod на узел.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Каждый новый узел, добавленный в кластер, получает запущенный pod.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Полезны для фоновых задач, таких как мониторинг и сбор логов.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Каждый Pod имеет уникальный, постоянный идентификатор, который контроллер сохраняет при любом перепланировании.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="сервисы">Сервисы&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>единая конечная точка для доступа к Pods&lt;/p>
&lt;/li>
&lt;li>
&lt;p>унифицированный способ маршрутизации трафика к кластеру и, в конечном итоге, к списку Pods.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Используя сервис, Pods можно поднимать и опускать, не затрагивая ничего.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Это лишь краткий обзор и заметки о фундаментальных строительных блоках Kubernetes, мы можем использовать эти знания и добавить некоторые другие области, такие как Storage и Ingress, чтобы улучшить наши приложения, но у нас также есть большой выбор, где будет работать наш кластер Kubernetes. Следующая сессия будет посвящена этим вариантам, где я могу запустить кластер Kubernetes, а также изучению некоторых особенностей хранения данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day49_Kubernetes12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/home/">Kubernetes Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=X48VuDVv0do">TechWorld with Nana - Kubernetes Tutorial for Beginners [FULL COURSE in 4 Hours]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=s_o8dwzRlu4">TechWorld with Nana - Kubernetes Crash Course for Absolute Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KVBON1lA9N8">Kunal Kushwaha - Kubernetes Tutorial for Beginners | What is Kubernetes? Architecture Simplified!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>50. Выбор платформы Kubernetes для проекта</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day50/</link><pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day50/</guid><description>&lt;h2 id="выбор-платформы-kubernetes">Выбор платформы Kubernetes&lt;/h2>
&lt;p>Я хотел бы использовать эту сессию для разбора некоторых платформ или, может быть, дистрибутивов - более подходящий термин для этого, одна вещь, которая была проблемой в мире Kubernetes - это устранение сложности.&lt;/p>
&lt;p>Kubernetes the hard way рассказывает о том, как построить из ничего полноценный функциональный кластер Kubernetes, очевидно, что это крайность, но все больше и больше людей, по крайней мере, тех, с кем я общаюсь, хотят устранить эту сложность и запустить управляемый кластер Kubernetes. Проблема в том, что это стоит больше денег, но преимущества могут быть следующими: если вы используете управляемый сервис, действительно ли вам нужно знать архитектуру узлов и то, что происходит с точки зрения плоскости управления узлов, когда обычно у вас нет к этому доступа.&lt;/p>
&lt;p>Затем у нас есть локальные дистрибутивы для разработки, которые позволяют нам использовать наши собственные системы и запускать локальную версию Kubernetes, чтобы разработчики могли иметь полную рабочую среду для запуска своих приложений на платформе, для которой они предназначены.&lt;/p>
&lt;p>Общая основа всех этих концепций заключается в том, что все они являются разновидностью Kubernetes, что означает, что мы должны иметь возможность свободно мигрировать и перемещать наши рабочие нагрузки туда, куда нам нужно, в соответствии с нашими требованиями.&lt;/p>
&lt;p>Во многом наш выбор будет зависеть от того, какие инвестиции были сделаны. Я уже упоминал об опыте разработчиков, но некоторые из локальных сред Kubernetes, в которых работают наши ноутбуки, отлично подходят для ознакомления с технологией без затрат денег.&lt;/p>
&lt;h3 id="bare-metal-clusters">Bare-Metal Clusters&lt;/h3>
&lt;p>Вариантом для многих может быть запуск ОС Linux прямо на нескольких физических серверах для создания кластера, это также может быть Windows, но я не слышал о темпах внедрения Windows, контейнеров и Kubernetes. Очевидно, что если вы - компания, и вы приняли решение о покупке физических серверов, то это может быть способом создания кластера Kubernetes, но управление и администрирование здесь означает, что вам придется создавать и управлять всем с нуля.&lt;/p>
&lt;h3 id="виртуализация">Виртуализация&lt;/h3>
&lt;p>Независимо от тестовых и учебных сред или готовых корпоративных кластеров Kubernetes виртуализация является отличным способом продвижения, обычно это возможность запускать виртуальные машины в качестве узлов и затем объединять их в кластер. Вы получаете базовую архитектуру, эффективность и скорость виртуализации, а также возможность эффективно использовать существующие затраты. Например, VMware предлагает отличное решение для виртуальных машин и Kubernetes в различных вариантах.&lt;/p>
&lt;p>Мой первый кластер Kubernetes был создан на основе виртуализации с использованием Microsoft Hyper-V на старом сервере, который был способен запускать несколько виртуальных машин в качестве узлов.&lt;/p>
&lt;h3 id="варианты-локального-рабочего-стола">Варианты локального рабочего стола&lt;/h3>
&lt;p>Существует несколько вариантов запуска локального кластера Kubernetes на вашем настольном компьютере или ноутбуке. Как уже говорилось ранее, это дает разработчикам возможность увидеть, как будет выглядеть их приложение, без необходимости создавать несколько дорогостоящих или сложных кластеров. Лично я часто использую этот кластер, в частности, я использую minikube. Он обладает отличной функциональностью и дополнениями, которые меняют способ создания и запуска приложений.&lt;/p>
&lt;h3 id="kubernetes-managed-services">Kubernetes Managed Services&lt;/h3>
&lt;p>Я уже упоминал о виртуализации, и это может быть достигнуто с помощью гипервизоров локально, но мы знаем из предыдущих разделов, что мы также можем использовать виртуальные машины в публичном облаке в качестве узлов. Я говорю об управляемых сервисах Kubernetes - это предложения, которые мы видим у крупных гипермасштабирующих компаний, а также у MSP, которые убирают уровни управления и контроля от конечного пользователя; это может быть удаление плоскости управления от конечного пользователя, что происходит с Amazon EKS, Microsoft AKS и Google Kubernetes Engine. (GKE)&lt;/p>
&lt;h3 id="непреодолимый-выбор">Непреодолимый выбор&lt;/h3>
&lt;p>Выбор - это здорово, но есть момент, когда он становится чрезмерным, и это не глубокий обзор всех вариантов в каждой из перечисленных выше категорий. В дополнение к вышеперечисленному у нас есть OpenShift от Red Hat, и этот вариант действительно может быть использован во всех вышеперечисленных вариантах у всех основных облачных провайдеров и, вероятно, сегодня обеспечивает наилучшее общее удобство для администраторов независимо от того, где развернуты кластеры.&lt;/p>
&lt;p>Итак, с чего вы начнете свое обучение, как я уже сказал, я начал с пути виртуализации, но это было потому, что у меня был доступ к физическому серверу, который я мог использовать для этой цели, я ценю и фактически с тех пор у меня больше нет такой возможности.&lt;/p>
&lt;p>Сейчас я бы посоветовал использовать Minikube в качестве первого варианта или Kind (Kubernetes в Docker), но Minikube дает нам некоторые дополнительные преимущества, которые почти абстрагируют сложность, так как мы можем просто использовать дополнительные модули и быстро создавать вещи, а затем разрушать их, когда мы закончим, мы можем запускать несколько кластеров, мы можем запускать их почти везде, кросс-платформенные и аппаратно-агностические.&lt;/p>
&lt;p>Я проделал небольшой путь в изучении Kubernetes, поэтому я собираюсь оставить выбор платформы и конкретику здесь, чтобы перечислить варианты, которые я пробовал, чтобы дать мне лучшее понимание платформы Kubernetes и того, где она может работать. Что я мог бы сделать с нижеприведенными записями в блоге, так это еще раз взглянуть на них, обновить их и перенести сюда, вместо того, чтобы они были ссылками на записи в блоге.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/building-the-home-lab-kubernetes-playground-part-1">Kubernetes playground – How to choose your platform&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/building-the-home-lab-kubernetes-playground-part-2">Kubernetes playground – Setting up your cluster&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-amazon-elastic-kubernetes-service-amazon-eks">Getting started with Amazon Elastic Kubernetes Service (Amazon EKS)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-microsoft-azure-kubernetes-service-aks">Getting started with Microsoft Azure Kubernetes Service (AKS)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-microsoft-aks-azure-powershell-edition">Getting Started with Microsoft AKS – Azure PowerShell Edition&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-google-kubernetes-service-gke">Getting started with Google Kubernetes Service (GKE)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/kubernetes-how-to-aws-bottlerocket-amazon-eks">Kubernetes, How to – AWS Bottlerocket + Amazon EKS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-civo-cloud">Getting started with CIVO Cloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/project_pace-kasten-k10-demo-environment-for-everyone">Minikube - Kubernetes Demo Environment For Everyone&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>51. Установка minikube</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day51/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day51/</guid><description>&lt;h2 id="развертывание-первого-кластера-kubernetes">Развертывание первого кластера Kubernetes&lt;/h2>
&lt;p>В этом посте мы собираемся запустить кластер Kubernetes на нашей локальной машине с помощью minikube, это даст нам базовый кластер Kubernetes для остальной части раздела Kubernetes, хотя позже мы рассмотрим развертывание кластера Kubernetes и в VirtualBox. Причина, по которой мы выбрали этот метод, а не развертывание управляемого кластера Kubernetes в публичном облаке, заключается в том, что это будет стоить денег даже при бесплатном уровне, однако я поделился некоторыми блогами, если вы захотите развернуть такую среду в предыдущем разделе &lt;a href="../day50">День 50&lt;/a>.&lt;/p>
&lt;h3 id="что-такое-minikube">Что такое Minikube?&lt;/h3>
&lt;p>Minikube быстро создает локальный кластер Kubernetes на macOS, Linux и Windows.&lt;/p>
&lt;p>Для начала, независимо от ОС вашей рабочей станции, вы можете запустить minikube. Сначала перейдите на &lt;a href="https://minikube.sigs.k8s.io/docs/start/">страницу проекта&lt;/a>. Первая опция, которая у вас есть, это выбор метода установки. Я не использовал этот метод, но вы можете выбрать мой способ (о моем способе речь впереди).&lt;/p>
&lt;p>Ниже упоминается, что вам необходимо иметь &amp;ldquo;Менеджер контейнеров или виртуальных машин, такой как: Docker, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox или VMware&amp;rdquo; - это то, где будет работать MiniKube, и это простой вариант, и если не указано в репозитории, я использую Docker. Вы можете установить Docker на свою систему, используя следующую &lt;a href="https://docs.docker.com/get-docker/">ссылку&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://kubernetes.io/ru/tracks/tasks/tools/install-minikube/">Понятное руководство по установке minikube&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="мой-способ-установки-minikube">Мой способ установки minikube&lt;/h3>
&lt;p>Я уже некоторое время использую arkade, чтобы получить все эти инструменты Kubernetes и CLI, вы можете посмотреть шаги установки на этом &lt;a href="https://github.com/alexellis/arkade">github репозитории&lt;/a> для начала работы с Arkade. Я также упоминал об этом в других записях блога, когда мне нужно было что-то установить. Простота установки: достаточно нажать arkade get и посмотреть, доступен ли ваш инструмент или cli, очень удобна. В разделе Linux мы говорили о менеджере пакетов и процессе получения нашего программного обеспечения, вы можете думать об Arkade как о рынке для всех ваших приложений и clis для Kubernetes. Очень удобный инструмент, который нужно иметь в своих системах, написанный на Golang и кроссплатформенный.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В длинном списке доступных приложений в arkade minikube является одним из них, поэтому с помощью простой команды &lt;code>arkade get minikube&lt;/code> мы загружаем бинарник и можем приступать.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нам также понадобится kubectl как часть нашего инструментария, поэтому вы можете получить его через arkade или, как я полагаю, в документации по minikube он представлен как часть команд curl, упомянутых выше. Подробнее о kubectl мы расскажем позже в этом посте.&lt;/p>
&lt;h3 id="получение-и-запуск-кластера-kubernetes">Получение и запуск кластера Kubernetes&lt;/h3>
&lt;p>В этом конкретном разделе я хочу рассказать о доступных нам вариантах запуска кластера Kubernetes на вашей локальной машине. Мы можем просто выполнить следующую команду, и она запустит кластер для использования.&lt;/p>
&lt;p>minikube используется в командной строке, и, проще говоря, после того как вы все установили, вы можете выполнить команду &lt;code>minikube start&lt;/code> для развертывания вашего первого кластера Kubernetes. Ниже вы увидите, что драйвер Docker по умолчанию является местом, где мы будем запускать наш вложенный узел виртуализации. В начале статьи я упомянул о других доступных опциях, которые помогут вам расширить вид локального кластера Kubernetes.&lt;/p>
&lt;p>Один кластер Minikube будет состоять из одного контейнера docker, в котором будут находиться узел плоскости управления и рабочий узел в одном экземпляре. Обычно вы разделяете эти узлы по отдельности. Об этом мы расскажем в следующем разделе, где мы рассмотрим домашние лабораторные среды Kubernetes, но немного ближе к производственной архитектуре.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я уже несколько раз говорил об этом, мне очень нравится minikube из-за доступных дополнений, возможность развернуть кластер с помощью простой команды, включающей все необходимые дополнения с самого начала, действительно помогает мне каждый раз развертывать одну и ту же необходимую установку.&lt;/p>
&lt;p>Ниже представлен список этих аддонов, я обычно использую аддоны &lt;code>csi-hostpath-driver&lt;/code> и &lt;code>volumesnapshots&lt;/code>, но вы можете увидеть длинный список ниже. Конечно, эти аддоны могут быть развернуты с помощью Helm, о чем мы расскажем позже в разделе Kubernetes, но это значительно упрощает работу.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я также определяю в нашем проекте некоторые дополнительные конфигурации, apiserver установлен на 6433 вместо случайного порта API, я определяю время выполнения контейнера также на containerd, однако docker используется по умолчанию, и CRI-O также доступен. Я также устанавливаю определенную версию Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы готовы развернуть наш первый кластер Kubernetes с помощью minikube. Я уже упоминал, что вам также понадобится &lt;code>kubectl&lt;/code> для взаимодействия с вашим кластером. Вы можете установить kubectl с помощью arkade, выполнив команду &lt;code>arkade get kubectl&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>или вы можете загрузить кросс-платформенную версию со следующих сайтов&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux">Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-macos">macOS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-windows">Windows&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>После установки kubectl мы можем взаимодействовать с нашим кластером с помощью простой команды &lt;code>kubectl get nodes&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day51_Kubernetes8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="что-такое-kubectl">Что такое kubectl?&lt;/h3>
&lt;p>Теперь у нас есть наш кластер minikube | Kubernetes, и я попросил вас установить Minikube, где я объяснил, что он делает, но я не объяснил, что такое kubectl и что он делает.&lt;/p>
&lt;p>kubectl - это программа, которая используется или позволяет вам взаимодействовать с кластерами Kubernetes, мы используем ее здесь для взаимодействия с нашим кластером minikube, но мы также используем kubectl для взаимодействия с нашими корпоративными кластерами в публичном облаке.&lt;/p>
&lt;p>Мы используем kubectl для развертывания приложений, проверки и управления ресурсами кластера. Гораздо лучший &lt;a href="https://kubernetes.io/docs/reference/kubectl/overview/">Обзор kubectl&lt;/a> можно найти здесь, в официальной документации Kubernetes.&lt;/p>
&lt;p>kubectl взаимодействует с сервером API, расположенным на узле Control Plane, о котором мы вкратце рассказывали в одном из предыдущих постов.&lt;/p>
&lt;h3 id="kubectl-шпаргалка">kubectl шпаргалка&lt;/h3>
&lt;p>Наряду с официальной документацией я также обнаружил, что при поиске команд kubectl у меня постоянно открыта эта страница. &lt;a href="https://unofficial-kubernetes.readthedocs.io/en/latest/">Unofficial Kubernetes&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Listing Resources&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>kubectl get nodes&lt;/td>
&lt;td>List all nodes in cluster&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>kubectl get namespaces&lt;/td>
&lt;td>List all namespaces in cluster&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>kubectl get pods&lt;/td>
&lt;td>List all pods in default namespace cluster&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>kubectl get pods -n name&lt;/td>
&lt;td>List all pods in &amp;ldquo;name&amp;rdquo; namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>kubectl get pods -n name&lt;/td>
&lt;td>List all pods in &amp;ldquo;name&amp;rdquo; namespace&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Creating Resources&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>kubectl create namespace name&lt;/td>
&lt;td>Create a namespace called &amp;ldquo;name&amp;rdquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>kubectl create -f [filename]&lt;/td>
&lt;td>Create a resource from a JSON or YAML file:&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Editing Resources&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>kubectl edit svc/servicename&lt;/td>
&lt;td>To edit a service&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>More detail on Resources&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>kubectl describe nodes&lt;/td>
&lt;td>display the state of any number of resources in detail,&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Delete Resources&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>kubectl delete pod&lt;/td>
&lt;td>Remove resources, this can be from stdin or file&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Вы захотите узнать краткие названия некоторых команд kubectl, например, &lt;code>-n&lt;/code> - это краткое название для &lt;code>namespace&lt;/code>, что облегчает ввод команды, а также, если вы пишете скрипты, вы можете получить гораздо более аккуратный код.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Short name&lt;/th>
&lt;th>Full name&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>csr&lt;/td>
&lt;td>certificatesigningrequests&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cs&lt;/td>
&lt;td>componentstatuses&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cm&lt;/td>
&lt;td>configmaps&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ds&lt;/td>
&lt;td>daemonsets&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>deploy&lt;/td>
&lt;td>deployments&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ep&lt;/td>
&lt;td>endpoints&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ev&lt;/td>
&lt;td>events&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hpa&lt;/td>
&lt;td>horizontalpodautoscalers&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ing&lt;/td>
&lt;td>ingresses&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>limits&lt;/td>
&lt;td>limitranges&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ns&lt;/td>
&lt;td>namespaces&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>no&lt;/td>
&lt;td>nodes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pvc&lt;/td>
&lt;td>persistentvolumeclaims&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pv&lt;/td>
&lt;td>persistentvolumes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>po&lt;/td>
&lt;td>pods&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pdb&lt;/td>
&lt;td>poddisruptionbudgets&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>psp&lt;/td>
&lt;td>podsecuritypolicies&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rs&lt;/td>
&lt;td>replicasets&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rc&lt;/td>
&lt;td>replicationcontrollers&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>quota&lt;/td>
&lt;td>resourcequotas&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sa&lt;/td>
&lt;td>serviceaccounts&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>svc&lt;/td>
&lt;td>services&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>В заключение хочу добавить, что я создал еще один проект на основе minikube, чтобы помочь мне быстро развернуть демонстрационные среды для демонстрации сервисов данных и защиты этих рабочих нагрузок с помощью Kasten K10, &lt;a href="https://github.com/MichaelCade/project_pace">Project Pace&lt;/a> можно найти там и буду рад вашим отзывам или взаимодействию, он также показывает или включает некоторые автоматизированные способы развертывания кластеров minikube и создания различных приложений сервисов данных.&lt;/p>
&lt;p>Далее мы перейдем к развертыванию нескольких узлов в виртуальные машины с помощью VirtualBox, но здесь мы будем действовать проще, как мы делали в разделе Linux, где мы использовали vagrant для быстрого запуска машин и развертывания нашего программного обеспечения, как мы хотим.&lt;/p>
&lt;p>Я добавил этот список к вчерашнему посту, который представляет собой блоги с описанием развертывания различных кластеров Kubernetes.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/building-the-home-lab-kubernetes-playground-part-1">Kubernetes playground – How to choose your platform&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/building-the-home-lab-kubernetes-playground-part-2">Kubernetes playground – Setting up your cluster&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-amazon-elastic-kubernetes-service-amazon-eks">Getting started with Amazon Elastic Kubernetes Service (Amazon EKS)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-microsoft-azure-kubernetes-service-aks">Getting started with Microsoft Azure Kubernetes Service (AKS)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-microsoft-aks-azure-powershell-edition">Getting Started with Microsoft AKS – Azure PowerShell Edition&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-google-kubernetes-service-gke">Getting started with Google Kubernetes Service (GKE)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/kubernetes-how-to-aws-bottlerocket-amazon-eks">Kubernetes, How to – AWS Bottlerocket + Amazon EKS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-civo-cloud">Getting started with CIVO Cloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/project_pace-kasten-k10-demo-environment-for-everyone">Minikube - Kubernetes Demo Environment For Everyone&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/home/">Kubernetes Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=X48VuDVv0do">TechWorld with Nana - Kubernetes Tutorial for Beginners [FULL COURSE in 4 Hours]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=s_o8dwzRlu4">TechWorld with Nana - Kubernetes Crash Course for Absolute Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KVBON1lA9N8">Kunal Kushwaha - Kubernetes Tutorial for Beginners | What is Kubernetes? Architecture Simplified!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>52. Настройка многоузлового кластера Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day52/</link><pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day52/</guid><description>&lt;h2 id="настройка-многоузлового-кластера-kubernetes">Настройка многоузлового кластера Kubernetes&lt;/h2>
&lt;p>Я хотел назвать эту статью &amp;ldquo;Настройка многоузлового кластера Kubernetes с помощью Vagrant&amp;rdquo;, но подумал, что это будет слишком длинно!&lt;/p>
&lt;p>На вчерашней сессии мы использовали классный проект для развертывания нашего первого кластера Kubernetes и немного поработали с самым важным инструментом CLI, с которым вы столкнетесь при использовании Kubernetes (kubectl).&lt;/p>
&lt;p>Здесь мы будем использовать VirtualBox в качестве основы, но, как мы уже говорили о Vagrant в разделе Linux, мы можем использовать любой гипервизор или инструмент виртуализации. Это был &lt;a href="../day14">День 14&lt;/a>, когда мы прошли и развернули машину Ubuntu для раздела Linux.&lt;/p>
&lt;h3 id="краткая-информация-о-vagrant">Краткая информация о Vagrant&lt;/h3>
&lt;p>Vagrant - это утилита CLI, которая управляет жизненным циклом ваших виртуальных машин. Мы можем использовать vagrant для запуска и разворачивания виртуальных машин на различных платформах, включая vSphere, Hyper-v, Virtual Box и Docker. У него есть и другие поставщики, но мы будем придерживаться этого, мы используем Virtual Box, так что все готово.&lt;/p>
&lt;p>Я собираюсь использовать базовый уровень этого &lt;a href="https://devopscube.com/kubernetes-cluster-vagrant/">блога и репозитория&lt;/a>, чтобы пройтись по конфигурации. Однако я бы посоветовал, если вы впервые развертываете кластер Kubernetes, посмотреть, как это делается вручную, и тогда вы хотя бы будете знать, как это выглядит. Хотя я должен сказать, что эти операции и усилия дня 0 становятся все более эффективными с каждым выпуском Kubernetes. Я сравниваю это с временами VMware и ESX, когда для развертывания 3 серверов ESX требовался по меньшей мере день, а теперь мы можем сделать это за час. Мы движемся в этом направлении, когда речь идет о Kubernetes&amp;quot;.&lt;/p>
&lt;h3 id="лабораторная-среда-kubernetes">Лабораторная среда Kubernetes&lt;/h3>
&lt;p>Я загрузил в &lt;a href="../kubernetes">папку Kubernetes&lt;/a> vagrantfile, который мы будем использовать для создания нашей среды. Возьмите его и перейдите в этот каталог в терминале. Я снова использую Windows, поэтому я буду использовать PowerShell для выполнения команд рабочей станции с vagrant. Если у вас нет vagrant, вы можете использовать arkade, о котором мы говорили вчера при установке minikube и других инструментов. Простая команда &lt;code>arkade get vagrant&lt;/code> должна заставить вас загрузить и установить последнюю версию vagrant.&lt;/p>
&lt;p>Когда вы окажетесь в своей директории, вы можете просто запустить &lt;code>vagrant up&lt;/code>, и если все настроено правильно, вы должны увидеть в терминале следующее.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В терминале вы увидите ряд шагов, но тем временем давайте посмотрим, что мы на самом деле создаем.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Из приведенного выше изображения видно, что мы собираемся создать 3 виртуальные машины, у нас будет узел плоскости управления и два рабочих узла. Если вы вернетесь к &lt;a href=".../day49">День 49&lt;/a>, вы увидите более подробное описание этих областей, которые мы видим на изображении.&lt;/p>
&lt;p>Также на изображении мы указываем, что наш доступ к kubectl будет происходить извне кластера и попадать в kube apiserver, в то время как на самом деле в рамках инициализации vagrant мы развертываем kubectl на каждом из этих узлов, чтобы мы могли получить доступ к кластеру изнутри каждого из наших узлов.&lt;/p>
&lt;p>Процесс создания этой лаборатории может занять от 5 до 30 минут в зависимости от вашей установки.&lt;/p>
&lt;p>Я собираюсь в ближайшее время рассказать о скриптах, но если вы посмотрите в файл vagrant, то заметите, что мы вызываем 3 скрипта как часть развертывания, и именно здесь создается кластер. Мы видели, как легко использовать vagrant для развертывания наших виртуальных машин и установки ОС с помощью боксов vagrant, но возможность запуска скрипта оболочки как часть процесса развертывания - это то, что становится довольно интересным в автоматизации этих лабораторных сборок.&lt;/p>
&lt;p>После завершения мы можем подключиться по ssh к одному из наших узлов &lt;code>vagrant ssh master&lt;/code> из терминала должен получить доступ, имя пользователя и пароль по умолчанию - &lt;code>vagrant/vagrant&lt;/code>.&lt;/p>
&lt;p>Вы также можете использовать &lt;code>vagrant ssh node01&lt;/code> и &lt;code>vagrant ssh node02&lt;/code> для получения доступа к рабочим узлам, если хотите.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы находимся на одном из вышеуказанных узлов нашего нового кластера, мы можем выдать команду &lt;code>kubectl get nodes&lt;/code>, чтобы показать наш 3-узловой кластер и его статус.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На данный момент у нас есть запущенный 3-узловой кластер, с 1 узлом плоскости управления и 2 рабочими узлами.&lt;/p>
&lt;h3 id="vagrantfile-и-shell-script-walkthrough">Vagrantfile и Shell Script walkthrough&lt;/h3>
&lt;p>Если мы посмотрим на наш vagrantfile, вы увидите, что мы определяем количество рабочих узлов, сетевые IP-адреса для мостовой сети в VirtualBox, а также некоторые именования. Еще вы заметите, что мы также вызываем некоторые скрипты, которые мы хотим запустить на определенных хостах.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>NUM_WORKER_NODES=2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP_NW=&amp;#34;10.0.0.&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP_START=10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Vagrant.configure(&amp;#34;2&amp;#34;) do |config|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.vm.provision &amp;#34;shell&amp;#34;, inline: &amp;lt;&amp;lt;-SHELL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apt-get update -y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#34;$IP_NW$((IP_START)) master-node&amp;#34; &amp;gt;&amp;gt; /etc/hosts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#34;$IP_NW$((IP_START+1)) worker-node01&amp;#34; &amp;gt;&amp;gt; /etc/hosts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#34;$IP_NW$((IP_START+2)) worker-node02&amp;#34; &amp;gt;&amp;gt; /etc/hosts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SHELL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.vm.box = &amp;#34;bento/ubuntu-21.10&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.vm.box_check_update = true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.vm.define &amp;#34;master&amp;#34; do |master|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> master.vm.hostname = &amp;#34;master-node&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> master.vm.network &amp;#34;private_network&amp;#34;, ip: IP_NW + &amp;#34;#{IP_START}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> master.vm.provider &amp;#34;virtualbox&amp;#34; do |vb|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vb.memory = 4048
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vb.cpus = 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vb.customize [&amp;#34;modifyvm&amp;#34;, :id, &amp;#34;--natdnshostresolver1&amp;#34;, &amp;#34;on&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> master.vm.provision &amp;#34;shell&amp;#34;, path: &amp;#34;scripts/common.sh&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> master.vm.provision &amp;#34;shell&amp;#34;, path: &amp;#34;scripts/master.sh&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (1..NUM_WORKER_NODES).each do |i|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.vm.define &amp;#34;node0#{i}&amp;#34; do |node|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node.vm.hostname = &amp;#34;worker-node0#{i}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node.vm.network &amp;#34;private_network&amp;#34;, ip: IP_NW + &amp;#34;#{IP_START + i}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node.vm.provider &amp;#34;virtualbox&amp;#34; do |vb|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vb.memory = 2048
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vb.cpus = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vb.customize [&amp;#34;modifyvm&amp;#34;, :id, &amp;#34;--natdnshostresolver1&amp;#34;, &amp;#34;on&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node.vm.provision &amp;#34;shell&amp;#34;, path: &amp;#34;scripts/common.sh&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node.vm.provision &amp;#34;shell&amp;#34;, path: &amp;#34;scripts/node.sh&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Давайте разберем эти выполняемые скрипты. У нас есть три скрипта, перечисленные в вышеуказанном VAGRANTFILE для запуска на определенных узлах.&lt;/p>
&lt;p>&lt;code>master.vm.provision &amp;quot;shell&amp;quot;, path: &amp;quot;scripts/common.sh&amp;quot;&lt;/code>&lt;/p>
&lt;p>Приведенный выше скрипт будет направлен на подготовку узлов, он будет запущен на всех трех наших узлах и удалит все существующие компоненты Docker и переустановит Docker и ContainerD, а также kubeadm, kubelet и kubectl. Этот скрипт также обновит существующие пакеты программного обеспечения в системе.&lt;/p>
&lt;p>&lt;code>master.vm.provision &amp;quot;shell&amp;quot;, path: &amp;quot;scripts/master.sh&amp;quot;&lt;/code>&lt;/p>
&lt;p>Скрипт master.sh будет выполняться только на узле плоскости управления, этот скрипт создаст кластер Kubernetes с помощью команд kubeadm. Он также подготовит контекст конфигурации для доступа к этому кластеру, о чем мы расскажем далее.&lt;/p>
&lt;p>&lt;code>node.vm.provision &amp;quot;shell&amp;quot;, path: &amp;quot;scripts/node.sh&amp;quot;&lt;/code>&lt;/p>
&lt;p>Это просто возьмет конфиг, созданный мастером, и присоединит наши узлы к кластеру Kubernetes, этот процесс присоединения снова использует kubeadm и другой скрипт, который можно найти в папке config.&lt;/p>
&lt;h3 id="доступ-к-кластеру-kubernetes">Доступ к кластеру Kubernetes&lt;/h3>
&lt;p>Теперь у нас есть два развернутых кластера: кластер minikube, который мы развернули в предыдущем разделе, и новый 3-узловой кластер, который мы только что развернули на VirtualBox.&lt;/p>
&lt;p>Также в этом конфигурационном файле, к которому у вас будет доступ на машине, с которой вы запускали vagrant, описано, как мы можем получить доступ к нашему кластеру с нашей рабочей станции.&lt;/p>
&lt;p>Прежде чем мы покажем это, позвольте мне коснуться контекста.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Контекст важен, необходима возможность доступа к кластеру Kubernetes с рабочего стола или ноутбука. Существует множество различных вариантов, и люди используют различные операционные системы в качестве повседневных драйверов.&lt;/p>
&lt;p>По умолчанию клиент Kubernetes CLI (kubectl) использует папку C:\Users\username.kube\config для хранения информации о кластере Kubernetes, такой как конечная точка и учетные данные. Если вы развернули кластер, вы сможете увидеть этот файл в этом месте. Но если вы до сих пор использовали главный узел для выполнения всех команд kubectl через SSH или другими способами, то эта статья, надеюсь, поможет вам освоить возможность подключения к рабочей станции.&lt;/p>
&lt;p>Затем нам нужно получить файл kubeconfig из кластера или мы также можем получить его из нашего файла конфигурации после развертывания, получить содержимое этого файла либо через SCP, либо просто открыть консольный сеанс на главном узле и скопировать на локальную машину windows.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы хотим взять копию этого файла конфигурации и переместить в место &lt;code>$HOME/.kube/config&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь с локальной рабочей станции вы сможете запустить &lt;code>kubectl cluster-info&lt;/code> и &lt;code>kubectl get nodes&lt;/code>, чтобы убедиться, что у вас есть доступ к вашему кластеру.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day52_Kubernetes8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это не только обеспечивает подключение и управление с вашей windows-машины, но и позволяет нам выполнить проброс портов для доступа к определенным сервисам с нашей windows-машины.&lt;/p>
&lt;p>Если вам интересно, как управлять несколькими кластерами на рабочей станции, у меня есть более подробное описание &lt;a href="https://vzilla.co.uk/vzilla-blog/building-the-home-lab-kubernetes-playground-part-6">здесь&lt;/a>.&lt;/p>
&lt;p>Я добавил этот список, в котором представлены блоги, посвященные различным развертываемым кластерам Kubernetes.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/building-the-home-lab-kubernetes-playground-part-1">Kubernetes playground – How to choose your platform&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/building-the-home-lab-kubernetes-playground-part-2">Kubernetes playground – Setting up your cluster&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-amazon-elastic-kubernetes-service-amazon-eks">Getting started with Amazon Elastic Kubernetes Service (Amazon EKS)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-microsoft-azure-kubernetes-service-aks">Getting started with Microsoft Azure Kubernetes Service (AKS)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-microsoft-aks-azure-powershell-edition">Getting Started with Microsoft AKS – Azure PowerShell Edition&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-google-kubernetes-service-gke">Getting started with Google Kubernetes Service (GKE)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/kubernetes-how-to-aws-bottlerocket-amazon-eks">Kubernetes, How to – AWS Bottlerocket + Amazon EKS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/getting-started-with-civo-cloud">Getting started with CIVO Cloud&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://vzilla.co.uk/vzilla-blog/project_pace-kasten-k10-demo-environment-for-everyone">Minikube - Kubernetes Demo Environment For Everyone&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/home/">Kubernetes Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=X48VuDVv0do">TechWorld with Nana - Kubernetes Tutorial for Beginners [FULL COURSE in 4 Hours]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=s_o8dwzRlu4">TechWorld with Nana - Kubernetes Crash Course for Absolute Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KVBON1lA9N8">Kunal Kushwaha - Kubernetes Tutorial for Beginners | What is Kubernetes? Architecture Simplified!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>53. Обзор Rancher</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day53/</link><pubDate>Sun, 12 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day53/</guid><description>&lt;h2 id="обзор-rancher---практическое-применение">Обзор Rancher - практическое применение&lt;/h2>
&lt;p>В этом разделе мы рассмотрим Rancher, до сих пор все, что мы делали, было в cli и с использованием kubectl, но у нас есть несколько действительно хороших пользовательских интерфейсов и инструментов управления несколькими кластерами, чтобы дать нашим операционным командам хорошую видимость управления кластером.&lt;/p>
&lt;p>Rancher, согласно их &lt;a href="https://rancher.com/">сайту&lt;/a>&lt;/p>
&lt;p>&lt;em>Rancher - это полный программный стек для команд, внедряющих контейнеры. Он решает операционные проблемы и проблемы безопасности при управлении несколькими кластерами Kubernetes в любой инфраструктуре, обеспечивая команды DevOps интегрированными инструментами для запуска контейнерных рабочих нагрузок&lt;/em>.&lt;/p>
&lt;p>Rancher позволяет нам развертывать кластеры Kubernetes производственного уровня практически из любого места, а затем обеспечивает централизованную аутентификацию, контроль доступа и наблюдаемость. Я упоминал в предыдущем разделе, что существует почти непреодолимый выбор, когда речь идет о Kubernetes и о том, где вы должны или можете их запустить, но с Rancher действительно не имеет значения, где они находятся.&lt;/p>
&lt;h3 id="развертывание-rancher">Развертывание Rancher&lt;/h3>
&lt;p>Первое, что нам нужно сделать, это развернуть Rancher на нашей локальной рабочей станции, есть несколько способов и мест, которые вы можете выбрать для выполнения этого шага, я хочу использовать свою локальную рабочую станцию и запустить Rancher как контейнер docker. Выполнив приведенную ниже команду, мы получим образ контейнера и доступ к пользовательскому интерфейсу rancher.&lt;/p>
&lt;p>Доступны и другие методы развертывания rancher &lt;a href="https://rancher.com/docs/rancher/v2.6/en/quick-start-guide/deployment/">Rancher Quick-Start-Guide&lt;/a>
&lt;code>sudo docker run -d --restart=unless-stopped -p 80:80 -p 443:443 --privileged rancher/rancher&lt;/code>.&lt;/p>
&lt;p>Как вы можете видеть на нашем рабочем столе Docker, у нас есть запущенный контейнер rancher.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="доступ-к-пользовательскому-интерфейсу-rancher">Доступ к пользовательскому интерфейсу Rancher&lt;/h3>
&lt;p>Запустив вышеуказанный контейнер, мы должны иметь возможность перейти к нему через веб-страницу. По адресу &lt;code>https://localhost&lt;/code> откроется страница входа в систему, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Следуйте инструкциям ниже, чтобы получить требуемый пароль. Поскольку я использую Windows, я решил использовать bash для Windows, так как для этого требуется команда grep.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем взять указанный выше пароль и войти в систему, на следующей странице мы можем задать новый пароль.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После выполнения вышеуказанных действий мы войдем в систему и увидим наш начальный экран. В рамках развертывания Rancher мы также увидим локальный кластер K3s.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="краткий-экскурс-по-rancher">Краткий экскурс по rancher&lt;/h3>
&lt;p>Первое, на что мы посмотрим, это наш локально развернутый кластер K3S. Вы можете видеть ниже, что мы получаем хорошее представление о том, что происходит внутри нашего кластера. Это развертывание по умолчанию, и мы еще ничего не развертывали в этом кластере. Видно, что он состоит из 1 узла и имеет 5 развертываний. Также вы можете видеть, что есть некоторые статистические данные по стручкам, ядрам и памяти.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В меню слева есть вкладка Apps &amp;amp; Marketplace, которая позволяет нам выбрать приложения, которые мы хотели бы запустить на наших кластерах. Как уже упоминалось ранее, Rancher дает нам возможность запускать и управлять несколькими различными кластерами. С помощью рынка мы можем очень легко развернуть наши приложения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Еще одна вещь, о которой стоит упомянуть, это то, что если вам понадобится получить доступ к любому кластеру, управляемому Rancher, в правом верхнем углу есть возможность открыть оболочку kubectl для выбранного кластера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="создание-нового-кластера">Создание нового кластера&lt;/h3>
&lt;p>На последних двух занятиях мы создали кластер minikube локально и использовали Vagrant с VirtualBox для создания 3-узлового кластера Kubernetes, с помощью Rancher мы также можем создавать кластеры. В папке &lt;a href="../Kubernetes/Rancher">Rancher Folder&lt;/a> вы найдете дополнительные файлы vagrant, которые создадут те же 3 узла, но без шагов по созданию нашего кластера Kubernetes (мы хотим, чтобы Rancher сделал это за нас).&lt;/p>
&lt;p>Тем не менее, мы хотим установить docker и обновить ОС, поэтому вы увидите скрипт &lt;code>common.sh&lt;/code>, запускаемый на каждом из наших узлов. Это также установит Kubeadm, Kubectl и т.д. Но он не запустит команды Kubeadm для создания и объединения наших узлов в кластер.&lt;/p>
&lt;p>Мы можем перейти в папку vagrant и просто запустить &lt;code>vagrant up&lt;/code>, и это начнет процесс создания наших 3 виртуальных машин в virtualbox.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда у нас есть наши узлы или ВМ на месте и готовы, мы можем использовать Rancher для создания нашего нового кластера Kubernetes. Первый экран для создания кластера дает вам несколько вариантов того, где находится ваш кластер, то есть используете ли вы службы Kubernetes, управляемые публичным облаком, vSphere или что-то еще.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы выберем &amp;ldquo;custom&amp;rdquo;, так как не используем ни одну из интегрированных платформ. На открывшейся странице вы определяете имя вашего кластера (ниже написано local, но вы не можете использовать local, наш кластер называется vagrant). Здесь вы можете определить версии Kubernetes, сетевых провайдеров и некоторые другие параметры конфигурации, чтобы запустить ваш кластер Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На следующей странице вы найдете регистрационный код, который необходимо запустить на каждом из узлов и включить соответствующие службы: etcd, controlplane и worker. Для нашего главного узла нам нужны etcd и controlplane, поэтому команду можно увидеть ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run -d --privileged --restart&lt;span style="color:#666">=&lt;/span>unless-stopped --net&lt;span style="color:#666">=&lt;/span>host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.6.3 --server https://10. 0.0.1 --token mpq8cbjjwrj88z4xmf7blqxcfmwdsmq92bmwjpphdkklfckk5hfwc2 --ca-checksum a81944423cbfeeb92be0784edebba1af799735ebc30ba8cbe5cc5f996094f30b --etcd --controlplane
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Если сетевое взаимодействие настроено правильно, то вы должны довольно быстро увидеть следующее на приборной панели rancher, указывающее на то, что первый мастер-узел сейчас регистрируется и кластер создается.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем повторить процесс регистрации для каждого из рабочих узлов с помощью следующей команды, и через некоторое время вы получите свой кластер, способный использовать рынок для развертывания приложений.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo docker run -d --privileged --restart&lt;span style="color:#666">=&lt;/span>unless-stopped --net&lt;span style="color:#666">=&lt;/span>host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.6.3 --server https://10. 0.0.1 --token mpq8cbjjwrj88z4xmf7blqxcfmwdsmq92bmwjpphdkklfckk5hfwc2 --ca-checksum a81944423cbfeeb92be0784edebba1af799735ebc30ba8cbe5cc5f996094f30b --worker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day53_Kubernetes14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>За последние 3 занятия мы использовали несколько различных способов запуска кластера Kubernetes, в оставшиеся дни мы рассмотрим прикладную сторону платформы, вероятно, самую важную. Мы рассмотрим сервисы и возможность предоставления и использования наших сервисов в Kubernetes.&lt;/p>
&lt;p>Мне сказали, что требования к загрузке узлов rancher требуют, чтобы эти виртуальные машины имели 4 ГБ оперативной памяти, иначе они будут работать с ошибками, с тех пор я обновил информацию, так как наши рабочие узлы имели 2 ГБ.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/home/">Kubernetes Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=X48VuDVv0do">TechWorld with Nana - Kubernetes Tutorial for Beginners [FULL COURSE in 4 Hours]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=s_o8dwzRlu4">TechWorld with Nana - Kubernetes Crash Course for Absolute Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KVBON1lA9N8">Kunal Kushwaha - Kubernetes Tutorial for Beginners | What is Kubernetes? Architecture Simplified!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>54. Развертывание приложений Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day54/</link><pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day54/</guid><description>&lt;h2 id="развертывание-приложений-kubernetes">Развертывание приложений Kubernetes&lt;/h2>
&lt;p>Теперь мы, наконец, переходим к реальному развертыванию некоторых приложений в наших кластерах, некоторые говорят, что именно для этого существует Kubernetes - для доставки приложений.&lt;/p>
&lt;p>Идея заключается в том, что мы можем взять наши образы контейнеров и развернуть их в виде стручков в нашем кластере Kubernetes, чтобы воспользоваться преимуществами Kubernetes как контейнерного оркестратора.&lt;/p>
&lt;h3 id="развертывание-приложений-в-kubernetes">Развертывание приложений в Kubernetes&lt;/h3>
&lt;p>Существует несколько способов развертывания наших приложений в кластере Kubernetes, мы рассмотрим два наиболее распространенных подхода - YAML-файлы и диаграммы Helm.&lt;/p>
&lt;p>Для развертывания приложений мы будем использовать кластер minikube. Мы рассмотрим некоторые из ранее упомянутых компонентов или строительных блоков Kubernetes.&lt;/p>
&lt;p>На протяжении всего этого раздела и раздела о контейнерах мы говорили об образах и преимуществах Kubernetes, а также о том, как мы можем легко справляться с масштабированием на этой платформе.&lt;/p>
&lt;p>В этом первом шаге мы просто создадим приложение без статических данных в нашем кластере minikube. Мы будем использовать дефакто стандартное приложение без статики в нашей первой демонстрации &lt;code>nginx&lt;/code>. Мы настроим Deployment, который предоставит нам наши стручки, а затем мы также создадим службу, которая позволит нам перейти к простому веб-серверу, размещенному в стручке nginx. Все это будет содержаться в пространстве имен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="создание-yaml">Создание YAML&lt;/h3>
&lt;p>В первом демо мы хотим определить все, что мы делаем с YAML, мы могли бы создать целый раздел о YAML, но я собираюсь пропустить это и оставить некоторые ресурсы в конце, которые расскажут о YAML более подробно.&lt;/p>
&lt;p>Мы можем создать следующее как один YAML-файл или разбить его на части для каждого аспекта нашего приложения, то есть это могут быть отдельные файлы для пространства имен, развертывания и создания сервисов, но в этом файле ниже мы разделили их с помощью &lt;code>---&lt;/code> в одном файле. Вы можете найти этот файл, расположенный &lt;a href="../days%5CKubernetes%5Cnginx-stateless-demo.yaml">здесь&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Namespace
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;labels&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;name&amp;#34;: &amp;#34;nginx&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apiVersion: apps/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: nginx-deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app: nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replicas: 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app: nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> containers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ports:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - containerPort: 80
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: nginx-service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app: nginx-deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ports:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - protocol: TCP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port: 80
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetPort: 80
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="проверка-нашего-кластера">Проверка нашего кластера&lt;/h3>
&lt;p>Перед тем как развернуть что-либо, мы должны убедиться, что у нас нет существующих пространств имен с названием &lt;code>nginx&lt;/code>. Мы можем сделать это, выполнив команду &lt;code>kubectl get namespace&lt;/code>, и как вы можете видеть ниже, у нас нет пространства имен с названием &lt;code>nginx&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="время-развернуть-наше-приложение">Время развернуть наше приложение&lt;/h3>
&lt;p>Теперь мы готовы развернуть наше приложение на нашем кластере minikube, этот же процесс будет работать на любом другом кластере Kubernetes.&lt;/p>
&lt;p>Нам нужно перейти к расположению нашего yaml файла, а затем мы можем выполнить команду &lt;code>kubectl create -f nginx-stateless-demo.yaml&lt;/code>, после чего вы увидите, что было создано 3 объекта, у нас есть пространство имен, развертывание и сервис.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Давайте снова выполним команду, чтобы увидеть доступные пространства имен в нашем кластере &lt;code>kubectl get namespace&lt;/code>, и теперь вы можете увидеть, что у нас есть наше новое пространство имен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы затем проверим наше пространство имен на наличие стручков с помощью &lt;code>kubectl get pods -n nginx&lt;/code>, вы увидите, что у нас есть 1 стручок в готовом и запущенном состоянии.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем проверить, что наш сервис создан, выполнив команду &lt;code>kubectl get service -n nginx&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Наконец, мы можем пойти и проверить наше развертывание, развертывание - это то, где и как мы сохраняем нашу желаемую конфигурацию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Выше приведено несколько команд, которые стоит знать, но вы также можете использовать &lt;code>kubectl get all -n nginx&lt;/code>, чтобы увидеть все, что мы развернули с помощью одного YAML-файла.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете заметить, что у нас также есть replicaset, в нашем развертывании мы определяем, сколько копий нашего образа мы хотим развернуть. Изначально мы установили значение 1, но если мы хотим быстро масштабировать наше приложение, мы можем сделать это несколькими способами.&lt;/p>
&lt;p>Мы можем отредактировать наш файл с помощью команды &lt;code>kubectl edit deployment nginx-deployment -n nginx&lt;/code>, которая откроет текстовый редактор в вашем терминале и позволит вам изменить развертывание.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После сохранения в текстовом редакторе в терминале, если не возникло проблем и было использовано правильное форматирование, вы должны увидеть дополнительное развертывание в вашем пространстве имен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем изменить количество реплик с помощью kubectl и команды &lt;code>kubectl scale deployment nginx-deployment --replicas=10 -n nginx&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем использовать этот метод для уменьшения масштаба нашего приложения до 1 снова, если захотим, используя любой метод. Я использовал опцию edit, но вы также можете использовать команду scale выше.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Надеюсь, здесь вы можете увидеть пример использования: не только все очень быстро запускается и выключается, но у нас есть возможность быстро увеличивать и уменьшать масштаб наших приложений. Если бы это был веб-сервер, мы могли бы увеличивать масштаб в периоды загруженности и уменьшать, когда нагрузка снижается.&lt;/p>
&lt;h3 id="раскрытие-нашего-приложения">Раскрытие нашего приложения&lt;/h3>
&lt;p>Но как нам получить доступ к нашему веб-серверу?&lt;/p>
&lt;p>Если вы посмотрите выше на наш сервис, вы увидите, что там нет внешнего IP, поэтому мы не можем просто открыть веб-браузер и ожидать, что он будет там волшебным образом. Для доступа у нас есть несколько вариантов.&lt;/p>
&lt;p>&lt;strong>ClusterIP&lt;/strong> - IP, который вы видите, является кластерным IP, он находится во внутренней сети кластера. Только объекты внутри кластера могут достичь этого IP.&lt;/p>
&lt;p>&lt;strong>NodePort&lt;/strong> - Выставляет службу на один и тот же порт каждого из выбранных узлов в кластере с помощью NAT.&lt;/p>
&lt;p>&lt;strong>LoadBalancer&lt;/strong> - Создает внешний балансировщик нагрузки в текущем облаке, мы используем minikube, но если вы создали свой собственный кластер Kubernetes, т.е. то, что мы сделали в VirtualBox, вам нужно будет развернуть LoadBalancer, такой как metallb, в вашем кластере, чтобы обеспечить эту функциональность.&lt;/p>
&lt;p>&lt;strong>Port-Forward&lt;/strong> - У нас также есть возможность Port Forward, которая позволяет вам получить доступ и взаимодействовать с внутренними процессами кластера Kubernetes с вашего localhost. На самом деле эта опция используется только для тестирования и поиска неисправностей.&lt;/p>
&lt;p>Теперь у нас есть несколько вариантов на выбор, Minikube имеет некоторые ограничения или отличия от полноценного кластера Kubernetes.&lt;/p>
&lt;p>Мы можем просто выполнить следующую команду, чтобы перенаправить порт для доступа, используя нашу локальную рабочую станцию.&lt;/p>
&lt;p>&lt;code>kubectl port-forward deployment/nginx-deployment -n nginx 8090:80&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Обратите внимание, что при выполнении вышеуказанной команды терминал становится непригодным для использования, поскольку он действует как проброс порта на вашу локальную машину и порт.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Наконец, в новом терминале запустите &lt;code>minikube --profile='mc-demo' service nginx-service --url -n nginx&lt;/code>, чтобы создать туннель для нашего сервиса.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day54_Kubernetes16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Откройте браузер или программу управления и нажмите на ссылку в терминале.&lt;/p>
&lt;h3 id="helm">Helm&lt;/h3>
&lt;p>Helm - это еще один способ, с помощью которого мы можем развернуть наши приложения. Известен как &amp;ldquo;менеджер пакетов для Kubernetes&amp;rdquo;. Вы можете узнать больше &lt;a href="https://helm.sh/">здесь&lt;/a>.&lt;/p>
&lt;p>Helm - это менеджер пакетов для Kubernetes. Helm можно считать аналогом yum или apt для Kubernetes. Helm развертывает диаграммы, которые можно представить как упакованное приложение. Это чертеж предварительно сконфигурированных ресурсов приложения, которые можно развернуть в виде одной простой в использовании диаграммы. Затем вы можете развернуть другую версию диаграммы с другим набором конфигураций.&lt;/p>
&lt;p>У компании есть сайт, на котором можно просмотреть все доступные диаграммы Helm и, конечно, создать свою собственную. Документация также понятна и лаконична и не так пугает, как когда я впервые услышал термин Helm среди всех других новых слов в этой области.&lt;/p>
&lt;p>Запустить или установить Helm очень просто. Просто. Здесь вы можете найти двоичные файлы и ссылки на загрузку практически для всех дистрибутивов, включая устройства RaspberryPi arm64.&lt;/p>
&lt;p>Или вы можете использовать скрипт установщика, преимущество которого в том, что будет загружена и установлена последняя версия Helm.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chmod 700 get_helm.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./get_helm.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Наконец, есть также возможность использовать менеджер пакетов для менеджера приложений, homebrew для mac, chocolatey для windows, apt с Ubuntu/Debian, snap и pkg также.&lt;/p>
&lt;p>Пока что Helm кажется наиболее удобным способом загрузки и установки различных тестовых приложений в кластере.&lt;/p>
&lt;p>Хорошим ресурсом для ссылки здесь будет &lt;a href="https://artifacthub.io/">ArtifactHUB&lt;/a>, который является ресурсом для поиска, установки и публикации пакетов Kubernetes. Я также порекомендую &lt;a href="https://kubeapps.com/">KubeApps&lt;/a>, который представляет собой пользовательский интерфейс для отображения диаграмм штурвала.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/docs/home/">Kubernetes Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=X48VuDVv0do">TechWorld with Nana - Kubernetes Tutorial for Beginners [FULL COURSE in 4 Hours]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=s_o8dwzRlu4">TechWorld with Nana - Kubernetes Crash Course for Absolute Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KVBON1lA9N8">Kunal Kushwaha - Kubernetes Tutorial for Beginners | What is Kubernetes? Architecture Simplified!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>55. State и Ingress в Kubernetes</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/</link><pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/</guid><description>&lt;h2 id="state-и-ingress-в-kubernetes">State и Ingress в Kubernetes&lt;/h2>
&lt;p>В этом заключительном разделе, посвященном Kubernetes, мы рассмотрим State и ingress.&lt;/p>
&lt;p>Все, о чем мы говорили до сих пор, касается stateless, stateless - это когда нашим приложениям не важно, какую сеть они используют, и им не нужно постоянное хранение данных. В то время как приложения с состоянием, например, базы данных, чтобы такое приложение функционировало правильно, вам нужно убедиться, что стручки могут обращаться друг к другу через уникальную идентификацию, которая не меняется (имена хостов, IP&amp;hellip; и т.д.). Примерами stateful-приложений являются кластеры MySQL, Redis, Kafka, MongoDB и другие. В принципе, любое приложение, которое хранит данные.&lt;/p>
&lt;h3 id="stateful-application">Stateful Application&lt;/h3>
&lt;p>StatefulSets представляют собой набор Pods с уникальными, постоянными идентификаторами и стабильными именами хостов, которые Kubernetes поддерживает независимо от того, где они запланированы. Информация о состоянии и другие устойчивые данные для любого данного StatefulSet Pod хранятся в постоянном дисковом хранилище, связанном с StatefulSet.&lt;/p>
&lt;h3 id="развертывание-против-statefulset">Развертывание против StatefulSet&lt;/h3>
&lt;ul>
&lt;li>Репликация stateful-приложений является более сложной задачей.&lt;/li>
&lt;li>Репликация наших стручков в развертывании (Stateless Application) идентична и взаимозаменяема.&lt;/li>
&lt;li>Создаем капсулы в случайном порядке со случайными хэшами&lt;/li>
&lt;li>Один сервис, который балансирует нагрузку на любой стручок.&lt;/li>
&lt;/ul>
&lt;p>Когда дело доходит до StatefulSets или Stateful Applications, вышеописанное становится сложнее.&lt;/p>
&lt;ul>
&lt;li>Невозможно одновременно создавать и удалять.&lt;/li>
&lt;li>Не может быть случайного обращения.&lt;/li>
&lt;li>реплики Pods не являются идентичными.&lt;/li>
&lt;/ul>
&lt;p>То, что вы увидите в нашей демонстрации в ближайшее время, заключается в том, что каждая копия имеет свою собственную идентичность. В приложении без статического состояния вы увидите случайные имена. Например, &lt;code>app-7469bbb6d7-9mhxd&lt;/code>, в то время как Stateful Application будет иметь имя &lt;code>mongo-0&lt;/code>, а затем при масштабировании создаст новую капсулу под названием &lt;code>mongo-1&lt;/code>.&lt;/p>
&lt;p>Эти стручки создаются на основе одной и той же спецификации, но они не взаимозаменяемы. Каждая капсула StatefulSet имеет постоянный идентификатор при любом повторном планировании. Это необходимо, потому что когда нам требуются нагрузки с учетом состояния, такие как база данных, где требуется запись и чтение в базу данных, мы не можем иметь две капсулы, пишущие в одно и то же время без осведомленности, так как это приведет к несогласованности данных. Нам нужно убедиться, что в любой момент времени только один из наших стручков записывает данные в базу данных, однако мы можем иметь несколько стручков, читающих эти данные.&lt;/p>
&lt;p>Каждый стручок в StatefulSet будет иметь доступ к своему собственному постоянному тому и копии базы данных для чтения, которая постоянно обновляется с главного сервера. Также интересно отметить, что каждый pod будет хранить свое состояние pod в этом постоянном томе, если &lt;code>mongo-0&lt;/code> умрет, то при инициализации нового pod он возьмет состояние pod, хранящееся в хранилище.&lt;/p>
&lt;p>TLDR; StatefulSets vs Deployments&lt;/p>
&lt;ul>
&lt;li>Predicatable pod name = &lt;code>mongo-0&lt;/code>&lt;/li>
&lt;li>Fixed individual DNS name&lt;/li>
&lt;li>Pod Identity - Retain State, Retain Role&lt;/li>
&lt;li>Replicating stateful apps is complex
&lt;ul>
&lt;li>There are lots of things you must do:
&lt;ul>
&lt;li>Configure cloning and data synchronisation.&lt;/li>
&lt;li>Make remote shared storage available.&lt;/li>
&lt;li>Management &amp;amp; backup&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Как сохранять данные в Kubernetes?&lt;/p>
&lt;p>Мы упоминали выше, что когда у нас есть приложение с состоянием, нам нужно где-то хранить состояние, и именно здесь возникает необходимость в томе, поскольку из коробки Kubernetes не обеспечивает постоянство данных.&lt;/p>
&lt;p>Нам нужен уровень хранения, который не зависит от жизненного цикла стручка. Это хранилище должно быть доступно со всех наших узлов Kubernetes. Хранилище также должно находиться вне кластера Kubernetes, чтобы иметь возможность выжить, даже если кластер Kubernetes потерпит крах.&lt;/p>
&lt;h3 id="постоянный-том">Постоянный том&lt;/h3>
&lt;ul>
&lt;li>Ресурс кластера (например, процессор и оперативная память) для хранения данных.&lt;/li>
&lt;li>Создается с помощью файла YAML.&lt;/li>
&lt;li>Требуется реальное физическое хранилище (NAS)&lt;/li>
&lt;li>Внешняя интеграция в ваш кластер Kubernetes.&lt;/li>
&lt;li>В вашем хранилище могут быть доступны различные типы хранилищ.&lt;/li>
&lt;li>PV не имеют пространства имен&lt;/li>
&lt;li>Локальное хранилище доступно, но оно будет специфично для одного узла в кластере&lt;/li>
&lt;li>Персистентность базы данных должна использовать удаленное хранилище (NAS)&lt;/li>
&lt;/ul>
&lt;h3 id="утверждение-о-постоянном-томе">Утверждение о постоянном томе&lt;/h3>
&lt;p>Постоянный том, как описано выше, может существовать и быть доступным, но пока он не заявлен приложением, он не используется.&lt;/p>
&lt;ul>
&lt;li>Создается с помощью файла YAML&lt;/li>
&lt;li>Утверждение постоянного тома используется в конфигурации стручка (атрибут volumes)&lt;/li>
&lt;li>PVC находятся в том же пространстве имен, что и pod&lt;/li>
&lt;li>Том монтируется в капсулу&lt;/li>
&lt;li>Стручки могут иметь несколько различных типов томов (ConfigMap, Secret, PVC).&lt;/li>
&lt;/ul>
&lt;p>Другой способ представить PVs и PVCs заключается в следующем&lt;/p>
&lt;p>PVs создаются администратором Kubernetes Admin
PVC создаются пользователем или разработчиком приложения.&lt;/p>
&lt;p>У нас также есть два других типа томов, которые мы не будем подробно описывать, но о которых стоит упомянуть:&lt;/p>
&lt;h3 id="configmaps--secrets">ConfigMaps | Secrets&lt;/h3>
&lt;ul>
&lt;li>Конфигурационный файл для вашего стручка.&lt;/li>
&lt;li>Файл сертификата для вашей капсулы.&lt;/li>
&lt;/ul>
&lt;h3 id="storageclass">StorageClass&lt;/h3>
&lt;ul>
&lt;li>Создается с помощью файла YAML&lt;/li>
&lt;li>Предоставляет постоянные тома динамически, когда PVC заявляет об этом.&lt;/li>
&lt;li>Каждый бэкенд хранилища имеет свой собственный провизор&lt;/li>
&lt;li>Бэкенд хранилища определяется в YAML (через атрибут provisioner)&lt;/li>
&lt;li>Абстракции базового провайдера хранения&lt;/li>
&lt;li>Определяет параметры для этого хранилища&lt;/li>
&lt;/ul>
&lt;h3 id="время-просмотра">Время просмотра&lt;/h3>
&lt;p>Во вчерашней сессии мы рассмотрели создание приложения без статических данных, здесь мы хотим сделать то же самое, но использовать наш кластер minikube для развертывания рабочей нагрузки с статическими данными.&lt;/p>
&lt;p>Напомним команду minikube, которую мы используем, чтобы иметь возможность и аддоны для использования персистентности: &lt;code>minikube start --addons volumesnapshots,csi-hostpath-driver --apiserver-port=6443 --container-runtime=containerd -p mc-demo --kubernetes-version=1.21.2&lt;/code>.&lt;/p>
&lt;p>Эта команда использует драйвер csi-hostpath-driver, который дает нам наш класс хранилища, что я покажу позже.&lt;/p>
&lt;p>Сборка приложения выглядит следующим образом:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете найти файл конфигурации YAML для этого приложения здесь &lt;a href="../Kubernetes/pacman-stateful-demo.yaml">pacman-stateful-demo.yaml&lt;/a>&lt;/p>
&lt;h3 id="конфигурация-класса-хранилища">Конфигурация класса хранилища&lt;/h3>
&lt;p>Есть еще один шаг, который мы должны выполнить перед началом развертывания нашего приложения, а именно убедиться, что наш класс хранилища (csi-hostpath-sc) является классом по умолчанию. Сначала мы можем проверить это, выполнив команду &lt;code>kubectl get storageclass&lt;/code>, но из коробки кластер minikube будет показывать стандартный класс хранения по умолчанию, поэтому мы должны изменить его с помощью следующих команд.&lt;/p>
&lt;p>Первая команда сделает наш класс хранилища csi-hostpath-sc классом по умолчанию.&lt;/p>
&lt;p>&lt;code>kubectl patch storageclass csi-hostpath-sc -p '{&amp;quot;metadata&amp;quot;: {&amp;quot;annotations&amp;quot;:{&amp;quot;storageclass.kubernetes.io/is-default-class&amp;quot;: &amp;quot;true&amp;quot;}}}'&lt;/code>}''&lt;/p>
&lt;p>Эта команда удалит аннотацию по умолчанию из стандартного StorageClass.&lt;/p>
&lt;p>&lt;code>kubectl patch storageclass standard -p '{&amp;quot;metadata&amp;quot;: {&amp;quot;annotations&amp;quot;:{&amp;quot;storageclass.kubernetes.io/is-default-class&amp;quot;: &amp;quot;false&amp;quot;}}}'&lt;/code>}''&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Начнем с того, что в нашем кластере нет пространства имен pacman. &lt;code>kubectl get namespace&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы развернем наш YAML-файл. &lt;code>kubectl create -f pacman-stateful-demo.yaml&lt;/code> Из этой команды видно, что мы создаем ряд объектов в нашем кластере Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь у нас есть наше только что созданное пространство имен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Из следующего изображения и команды &lt;code>kubectl get all -n pacman&lt;/code> видно, что в нашем пространстве имен происходит несколько вещей. У нас есть pods, запускающий наш NodeJS web front end, у нас есть mongo, запускающий нашу backend базу данных. Есть сервисы для pacman и mongo для доступа к этим стручкам. У нас есть развертывание для pacman и statefulset для mongo.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>У нас также есть наши постоянные тома и утверждения постоянных томов. Выполнив команду &lt;code>kubectl get pv&lt;/code>, мы получим наши постоянные тома, не связанные с именами, а выполнив команду &lt;code>kubectl get pvc -n pacman&lt;/code>, мы получим наши утверждения постоянных томов, связанные с именами.
&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="играем-в-игру--я-имею-в-виду-доступ-к-нашему-критически-важному-приложению">Играем в игру | Я имею в виду доступ к нашему критически важному приложению&lt;/h3>
&lt;p>Поскольку мы используем Minikube, как уже упоминалось в приложении без статических данных, нам предстоит преодолеть несколько препятствий, когда дело доходит до доступа к нашему приложению. Однако если бы у нас был доступ к ingress или балансировщику нагрузки в нашем кластере, служба настроена на автоматическое получение IP-адреса от него для получения доступа извне. (Вы можете видеть это выше на изображении всех компонентов в пространстве имен pacman).&lt;/p>
&lt;p>В данном демонстрационном примере мы будем использовать метод проброса портов для доступа к нашему приложению. Открыв новый терминал и выполнив следующую команду &lt;code>kubectl port-forward svc/pacman 9090:80 -n pacman&lt;/code>, открыв браузер, мы получим доступ к нашему приложению. Если вы запускаете это в AWS или в определенных местах, то это также сообщит об облаке и зоне, а также о хосте, который равен вашему стручку в Kubernetes, опять же, вы можете оглянуться назад и увидеть это имя стручка на наших скриншотах выше.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем пойти и создать высокий балл, который затем будет сохранен в нашей базе данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хорошо, у нас есть высокий балл, но что произойдет, если мы удалим наш &lt;code>mongo-0&lt;/code> pod? Выполнив команду &lt;code>kubectl delete pod mongo-0 -n pacman&lt;/code>, я могу удалить его, и если вы все еще находитесь в приложении, вы увидите, что высокий балл недоступен, по крайней мере, в течение нескольких секунд.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, если я вернусь в свою игру, я смогу создать новую игру и увидеть свои высокие баллы. Единственный способ поверить мне в это - попробовать и поделиться в социальных сетях своими высокими результатами!&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>С развертыванием мы можем увеличить масштаб с помощью команд, которые мы рассматривали в предыдущей сессии, но в частности здесь, особенно если вы хотите устроить огромную вечеринку pacman, вы можете увеличить масштаб с помощью &lt;code>kubectl scale deployment pacman --replicas=10 -n pacman&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="ingress-объяснено">Ingress объяснено&lt;/h3>
&lt;p>Прежде чем мы закончим с Kubernetes, я также хотел бы затронуть важный аспект Kubernetes, и это - ingress.&lt;/p>
&lt;h3 id="что-такое-ingress">Что такое ingress?&lt;/h3>
&lt;p>До сих пор в наших примерах мы использовали port-forward или определенные команды в minikube, чтобы получить доступ к нашим приложениям, но в производстве это не сработает. Нам нужен лучший способ доступа к нашим приложениям в масштабе с множеством пользователей.&lt;/p>
&lt;p>Мы также говорили о возможности использования NodePort, но это опять же должно быть только в тестовых целях.&lt;/p>
&lt;p>Ingress дает нам лучший способ открыть наши приложения, он позволяет нам определить правила маршрутизации в нашем кластере Kubernetes.&lt;/p>
&lt;p>Для ingress мы создадим запрос на внутреннюю службу нашего приложения.&lt;/p>
&lt;h3 id="когда-вам-нужен-ingress">Когда вам нужен ingress?&lt;/h3>
&lt;p>Если вы используете облачный провайдер, управляемое предложение Kubernetes, то, скорее всего, у них будет своя опция ingress для вашего кластера или они предоставят вам свой собственный балансировщик нагрузки. Вам не придется реализовывать это самостоятельно, что является одним из преимуществ управляемого Kubernetes.&lt;/p>
&lt;p>Если вы управляете собственным кластером, вам необходимо настроить точку входа.&lt;/p>
&lt;h3 id="настройка-ingress-на-minikube">Настройка Ingress на Minikube&lt;/h3>
&lt;p>На моем конкретном запущенном кластере под названием mc-demo я могу выполнить следующую команду, чтобы включить ingress на моем кластере.&lt;/p>
&lt;p>&lt;code>minikube --profile='mc-demo' addons enable ingress&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если теперь мы проверим наши пространства имен, то увидим, что у нас есть новое пространство имен ingress-nginx. &lt;code>kubectl get ns&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы должны создать YAML-конфигурацию ingress для запуска нашего сервиса Pacman. Я добавил этот файл в репозиторий &lt;a href="../Kubernetes/pacman-ingress.yaml">pacman-ingress.yaml&lt;/a>.&lt;/p>
&lt;p>Затем мы можем создать его в нашем пространстве имен ingress с помощью &lt;code>kubectl create -f pacman-ingress.yaml&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем, если мы запустим &lt;code>kubectl get ingress -n pacman&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мне говорят, что поскольку мы используем minikube, работающий на WSL2 в Windows, мы должны создать туннель minikube, используя &lt;code>minikube tunnel --profile=mc-demo&lt;/code>.&lt;/p>
&lt;p>Но я все еще не могу получить доступ к 192.168.49.2 и играть в свою игру pacman.&lt;/p>
&lt;p>Если у кого-нибудь есть или есть возможность заставить это работать под Windows и WSL, я буду благодарен за отзывы. Я подниму вопрос об этом в репозитории и вернусь к нему, как только у меня появится время и исправление.&lt;/p>
&lt;p>UPDATE: Мне кажется, что этот блог помогает определить причину того, что игра не работает на WSL &lt;a href="https://hellokube.dev/posts/configure-minikube-ingress-on-wsl2/">Configuring Ingress to run Minikube on WSL2 using Docker runtime&lt;/a>&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=pPQKAR1pA9U">Kubernetes StatefulSet simply explained&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=0swOh5C3OVM">Kubernetes Volumes explained&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=80Ew_fsV4rM">Kubernetes Ingress Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://kubernetes.io/docs/home/">Kubernetes Documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=X48VuDVv0do">TechWorld with Nana - Kubernetes Tutorial for Beginners [FULL COURSE in 4 Hours]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=s_o8dwzRlu4">TechWorld with Nana - Kubernetes Crash Course for Absolute Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=KVBON1lA9N8">Kunal Kushwaha - Kubernetes Tutorial for Beginners | What is Kubernetes? Architecture Simplified!&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>На этом мы завершаем раздел Kubernetes. Существует так много дополнительных материалов, которые мы могли бы осветить на тему Kubernetes, и 7 дней дают нам базовые знания, но есть люди, которые проходят &lt;a href="https://100daysofkubernetes.io/overview.html">100DaysOfKubernetes&lt;/a>, где вы можете погрузиться в самую гущу событий.&lt;/p>
&lt;p>Далее мы рассмотрим инфраструктуру как код и ту важную роль, которую она играет с точки зрения DevOps.&lt;/p></description></item><item><title>56. Обзор IaC</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day56/</link><pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day56/</guid><description>&lt;h2 id="обзор-iac">Обзор IaC&lt;/h2>
&lt;p>Люди совершают ошибки! Автоматизация - это путь к успеху!&lt;/p>
&lt;p>Как вы строите свои системы сегодня?&lt;/p>
&lt;p>Каков был бы ваш план, если бы вы потеряли все, физические машины, виртуальные машины, облачные виртуальные машины, облачные PaaS и т.д. и т.п.?&lt;/p>
&lt;p>Сколько времени у вас уйдет на замену всего?&lt;/p>
&lt;p>Инфраструктура как код предоставляет решение, позволяющее сделать это и одновременно протестировать, не путайте это с резервным копированием и восстановлением, но что касается вашей инфраструктуры и сред, ваших платформ, мы должны быть в состоянии раскрутить их и обращаться с ними как со скотом и домашними животными.&lt;/p>
&lt;p>TLDR; заключается в том, что мы можем использовать код для восстановления всей нашей среды.&lt;/p>
&lt;p>Если мы также вспомним, что с самого начала мы говорили о DevOps в целом - это способ преодоления барьеров для безопасной и быстрой доставки систем в производство.&lt;/p>
&lt;p>Infrastructure as code помогает нам поставлять системы, мы говорили о множестве процессов и инструментов. IaC предлагает нам больше инструментов, с которыми мы должны быть знакомы, чтобы обеспечить эту часть процесса.&lt;/p>
&lt;p>В этом разделе мы сосредоточимся на инфраструктуре как коде. Вы также можете услышать упоминание этого термина как &amp;ldquo;инфраструктура из кода&amp;rdquo; или &amp;ldquo;конфигурация как код&amp;rdquo;. Я думаю, что наиболее известным термином является Инфраструктура как код.&lt;/p>
&lt;h3 id="домашние-животные-против-крупного-рогатого-скота">Домашние животные против крупного рогатого скота&lt;/h3>
&lt;p>Если мы посмотрим на до DevOps, то при необходимости создания нового приложения мы должны были подготовить наши серверы вручную.&lt;/p>
&lt;ul>
&lt;li>Развернуть виртуальные машины | физические серверы и установить операционную систему&lt;/li>
&lt;li>Настроить сеть&lt;/li>
&lt;li>Создать таблицы маршрутизации&lt;/li>
&lt;li>Установить программное обеспечение и обновления&lt;/li>
&lt;li>Настроить программное обеспечение&lt;/li>
&lt;li>Установка базы данных&lt;/li>
&lt;/ul>
&lt;p>Это ручной процесс, выполняемый системными администраторами. Чем больше приложение, тем больше ресурсов и серверов требуется, тем больше ручных усилий потребуется для создания этих систем. Это потребует огромного количества человеческих усилий и времени, но, кроме того, как компания, вы должны будете заплатить за эти ресурсы, чтобы создать эту среду. Как я уже говорил в начале раздела &amp;ldquo;Люди совершают ошибки! Автоматизация - это путь к успеху!&amp;rdquo;.&lt;/p>
&lt;p>После вышеупомянутой фазы начальной установки вам предстоит обслуживание этих серверов.&lt;/p>
&lt;ul>
&lt;li>Обновление версий&lt;/li>
&lt;li>Развертывание новых релизов&lt;/li>
&lt;li>Управление данными&lt;/li>
&lt;li>Восстановление приложений&lt;/li>
&lt;li>Добавление, удаление и масштабирование серверов&lt;/li>
&lt;li>Конфигурация сети&lt;/li>
&lt;/ul>
&lt;p>Добавьте сюда сложность нескольких сред тестирования и разработки.&lt;/p>
&lt;p>Именно здесь на помощь приходит Infrastructure as Code. Выше было время, когда мы заботились об этих серверах, как о домашних животных, люди даже называли их домашними именами или, по крайней мере, давали им какие-то имена, потому что они должны были находиться рядом какое-то время, они должны были стать частью &amp;ldquo;семьи&amp;rdquo; на какое-то время.&lt;/p>
&lt;p>С Infrastructure as Code у нас есть возможность автоматизировать все эти задачи от конца до конца. Инфраструктура как код - это концепция, и есть инструменты, которые выполняют автоматическое обеспечение инфраструктуры. На данный момент, если с сервером случается что-то плохое, вы выбрасываете его и запускаете новый. Этот процесс автоматизирован, и сервер точно такой же, как определено в коде. В этот момент нам не важно, как они называются, они находятся в поле и служат своей цели до тех пор, пока их больше нет в поле, и нам нужно заменить их либо из-за сбоя, либо из-за обновления части или всего нашего приложения.&lt;/p>
&lt;p>Это может быть использовано практически во всех платформах, виртуализации, облачных рабочих нагрузках, а также в облачной нативной инфраструктуре, такой как Kubernetes и контейнеры.&lt;/p>
&lt;h3 id="обеспечение-инфраструктуры">Обеспечение инфраструктуры&lt;/h3>
&lt;p>Не все IaC охватывают все перечисленное ниже, вы увидите, что инструмент, который мы будем использовать в этом разделе, охватывает только первые две области; Terraform - это тот инструмент, который мы будем рассматривать, и он позволяет нам начать с нуля и определить в коде, как должна выглядеть наша инфраструктура, а затем развернуть ее, он также позволит нам управлять этой инфраструктурой и первоначально развернуть приложение, но в этот момент он потеряет контроль над приложением, и здесь на помощь приходит следующий раздел, и что-то вроде Ansible как инструмент управления конфигурацией может работать лучше на этом фронте.&lt;/p>
&lt;p>Без забегания вперед такие инструменты, как chef, puppet и ansible, лучше всего подходят для начальной установки приложений, а затем для управления этими приложениями и их конфигурацией.&lt;/p>
&lt;p>Первоначальная установка и настройка программного обеспечения&lt;/p>
&lt;ul>
&lt;li>Развертывание новых серверов&lt;/li>
&lt;li>Конфигурация сети&lt;/li>
&lt;li>Создание балансировщиков нагрузки&lt;/li>
&lt;li>Конфигурация на уровне инфраструктуры&lt;/li>
&lt;/ul>
&lt;h3 id="конфигурация-инфраструктуры-с-провизией">Конфигурация инфраструктуры с провизией&lt;/h3>
&lt;ul>
&lt;li>Установка приложения на серверы&lt;/li>
&lt;li>Подготовьте серверы для развертывания приложения.&lt;/li>
&lt;/ul>
&lt;h3 id="развертывание-приложения">Развертывание приложения&lt;/h3>
&lt;ul>
&lt;li>Развертывание и управление приложением&lt;/li>
&lt;li>Этап обслуживания&lt;/li>
&lt;li>Обновления программного обеспечения&lt;/li>
&lt;li>Реконфигурация&lt;/li>
&lt;/ul>
&lt;h3 id="различия-инструментов-iac">Различия инструментов IaC&lt;/h3>
&lt;p>Декларативный и процедурный&lt;/p>
&lt;p>Процедурный&lt;/p>
&lt;ul>
&lt;li>Пошаговая инструкция&lt;/li>
&lt;li>Создайте сервер &amp;gt; Добавьте сервер &amp;gt; Внесите это изменение&lt;/li>
&lt;/ul>
&lt;p>Декларативный&lt;/p>
&lt;ul>
&lt;li>объявить конечный результат&lt;/li>
&lt;li>2 сервера&lt;/li>
&lt;/ul>
&lt;p>Изменяемые (домашние животные) против неизменяемых (крупный рогатый скот)&lt;/p>
&lt;p>Мутабельный&lt;/p>
&lt;ul>
&lt;li>Изменение вместо замены&lt;/li>
&lt;li>Как правило, долгоживущие&lt;/li>
&lt;/ul>
&lt;p>Неизменяемые&lt;/p>
&lt;ul>
&lt;li>Замена вместо изменения&lt;/li>
&lt;li>Возможно, недолговечна&lt;/li>
&lt;/ul>
&lt;p>Именно поэтому у нас есть множество различных вариантов Infrastructure as Code, потому что не существует одного инструмента, который бы управлял всеми.&lt;/p>
&lt;p>Мы будем в основном использовать terraform и работать с ним, поскольку это лучший способ начать видеть преимущества инфраструктуры как кода в действии. Практическая работа - это также лучший способ приобрести навыки, так как вы будете писать код.&lt;/p>
&lt;p>Далее мы начнем изучать Terraform со 101-го урока, прежде чем приступим к практическому использованию.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=POPP2WTJ8es">What is Infrastructure as Code? Difference of Infrastructure as Code Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=m3cKkYXl-8o">Terraform Tutorial | Terraform Course Overview 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=l5k1ai_GBDE">Terraform explained in 15 mins | Terraform Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;amp;list=WL&amp;amp;index=141&amp;amp;t=16s">Terraform Course - From BEGINNER to PRO!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V4waklkBC38&amp;amp;list=WL&amp;amp;index=55&amp;amp;t=111s">HashiCorp Terraform Associate Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EJ3N-hhiWv0&amp;amp;list=WL&amp;amp;index=39&amp;amp;t=27s">Terraform Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YcJ9IeukJL8&amp;amp;list=WL&amp;amp;index=16&amp;amp;t=11s">KodeKloud - Terraform for DevOps Beginners + Labs: Complete Step by Step Guide!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://terraform.joshuajebaraj.com/">Terraform Simple Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oA-pPa0vfks">Terraform Tutorial - The Best Project Ideas&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/shuaibiyy/awesome-terraform">Awesome Terraform&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>57. Введение в Terraform</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day57/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day57/</guid><description>&lt;p>&amp;ldquo;Terraform - это инструмент для безопасного и эффективного создания, изменения и управления версиями инфраструктуры&amp;rdquo;.
«Приведенная выше цитата взята из HashiCorp, HashiCorp - это компания, стоящая за Terraform.&lt;/p>
&lt;p>&amp;ldquo;Terraform - это программный инструмент &amp;ldquo;инфраструктура как код&amp;rdquo; с открытым исходным кодом, который обеспечивает последовательный рабочий процесс CLI для управления сотнями облачных сервисов. Terraform кодирует облачные API в декларативные конфигурационные файлы&amp;rdquo;.&lt;/p>
&lt;p>У HashiCorp есть отличный ресурс &lt;a href="https://learn.hashicorp.com/terraform?utm_source=terraform_io&amp;amp;utm_content=terraform_io_hero">HashiCorp Learn&lt;/a>, который охватывает все их продукты и дает несколько отличных демонстрационных примеров, когда вы пытаетесь достичь чего-то с помощью инфраструктуры как кода.&lt;/p>
&lt;p>Все облачные провайдеры и локальные платформы обычно предоставляют нам доступ к консолям управления, которые позволяют нам создавать наши ресурсы с помощью пользовательского интерфейса, обычно эти платформы также предоставляют доступ к CLI или API для создания тех же ресурсов, но с API у нас есть возможность быстрого предоставления ресурсов.&lt;/p>
&lt;p>Инфраструктура как код позволяет нам подключаться к этим API для развертывания наших ресурсов в нужном состоянии.&lt;/p>
&lt;p>Ниже перечислены и другие инструменты, но они не являются исключительными или исчерпывающими. Если у вас есть другие инструменты, пожалуйста, поделитесь с нами через PR.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Cloud Specific&lt;/th>
&lt;th>Cloud Agnostic&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>AWS CloudFormation&lt;/td>
&lt;td>Terraform&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Azure Resource Manager&lt;/td>
&lt;td>Pulumi&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Google Cloud Deployment Manager&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Это еще одна причина, почему мы используем Terraform, мы хотим быть независимыми от облаков и платформ, которые мы хотим использовать для наших демонстраций, а также в целом.&lt;/p>
&lt;h2 id="обзор-terraform">Обзор Terraform&lt;/h2>
&lt;p>Terraform - это инструмент, ориентированный на обеспечение, Terraform - это CLI, который предоставляет возможности для обеспечения сложных инфраструктурных сред. С помощью Terraform мы можем определить сложные требования к инфраструктуре, существующей локально или удаленно (облако). Terraform позволяет нам не только создавать вещи на начальном этапе, но и поддерживать и обновлять эти ресурсы в течение всего срока их службы.&lt;/p>
&lt;p>Здесь мы рассмотрим основные моменты, но для получения более подробной информации и множества ресурсов вы можете посетить сайт &lt;a href="https://www.terraform.io/">terraform.io&lt;/a>.&lt;/p>
&lt;h3 id="запись">Запись&lt;/h3>
&lt;p>Terraform позволяет нам создавать декларативные конфигурационные файлы, которые будут создавать наше окружение. Файлы пишутся с помощью языка HashiCorp Configuration Language (HCL), который позволяет кратко описывать ресурсы с помощью блоков, аргументов и выражений. Мы, конечно, будем подробно рассматривать их при развертывании виртуальных машин, контейнеров и в Kubernetes.&lt;/p>
&lt;h3 id="план">План&lt;/h3>
&lt;p>Возможность проверить, что вышеуказанные конфигурационные файлы развернут то, что мы хотим видеть, используя определенные функции terraform cli, чтобы иметь возможность протестировать этот план перед развертыванием чего-либо или изменением чего-либо. Помните, что Terraform - это инструмент для продолжения вашей инфраструктуры, если вы хотите изменить аспект вашей инфраструктуры, вы должны сделать это через terraform, чтобы все это было зафиксировано в коде.&lt;/p>
&lt;h3 id="применить">Применить&lt;/h3>
&lt;p>Очевидно, что когда вы будете довольны, вы сможете применить эту конфигурацию к множеству провайдеров, доступных в Terraform. Вы можете увидеть большое количество доступных провайдеров &lt;a href="https://registry.terraform.io/browse/providers">здесь&lt;/a>.&lt;/p>
&lt;p>Еще одна вещь, о которой следует упомянуть, это то, что также доступны модули, и это похоже на образы контейнеров в том, что эти модули были созданы и выложены в открытый доступ, так что вам не придется создавать их снова и снова, просто используйте лучшую практику развертывания определенного ресурса инфраструктуры одинаковым способом везде. Вы можете найти доступные модули &lt;a href="https://registry.terraform.io/browse/modules">здесь&lt;/a>.&lt;/p>
&lt;p>Рабочий процесс Terraform выглядит следующим образом: (&lt;em>взято с сайта terraform&lt;/em>)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day57_IAC3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="terraform-vs-vagrant">Terraform vs Vagrant&lt;/h3>
&lt;p>Во время этого испытания мы использовали Vagrant, который является еще одним инструментом с открытым исходным кодом от Hashicorp, сконцентрированным на средах разработки.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Vagrant - это инструмент, ориентированный на управление средами разработки.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Terraform - это инструмент для создания инфраструктуры.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Отличное сравнение этих двух инструментов можно найти здесь на официальном сайте &lt;a href="https://www.vagrantup.com/intro/vs/terraform">Hashicorp&lt;/a>&lt;/p>
&lt;h2 id="установка-terraform">Установка Terraform&lt;/h2>
&lt;p>В установке Terraform нет ничего сложного.&lt;/p>
&lt;p>Terraform является кроссплатформенным, и вы можете видеть ниже на моей Linux машине у нас есть несколько вариантов загрузки и установки CLI&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day57_IAC2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Использование &lt;code>arkade&lt;/code> для установки Terraform, arkade - это удобный инструмент для получения необходимых инструментов, приложений и clis на вашу систему. Простая команда &lt;code>arkade get terraform&lt;/code> позволит обновить terraform, если он доступен, или эта же команда также установит Terraform CLI&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day57_IAC1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы собираемся больше узнать о HCL, а также начать использовать Terraform для создания некоторых инфраструктурных ресурсов на различных платформах.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=POPP2WTJ8es">What is Infrastructure as Code? Difference of Infrastructure as Code Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=m3cKkYXl-8o">Terraform Tutorial | Terraform Course Overview 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=l5k1ai_GBDE">Terraform explained in 15 mins | Terraform Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;amp;list=WL&amp;amp;index=141&amp;amp;t=16s">Terraform Course - From BEGINNER to PRO!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V4waklkBC38&amp;amp;list=WL&amp;amp;index=55&amp;amp;t=111s">HashiCorp Terraform Associate Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EJ3N-hhiWv0&amp;amp;list=WL&amp;amp;index=39&amp;amp;t=27s">Terraform Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YcJ9IeukJL8&amp;amp;list=WL&amp;amp;index=16&amp;amp;t=11s">KodeKloud - Terraform for DevOps Beginners + Labs: Complete Step by Step Guide!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://terraform.joshuajebaraj.com/">Terraform Simple Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oA-pPa0vfks">Terraform Tutorial - The Best Project Ideas&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/shuaibiyy/awesome-terraform">Awesome Terraform&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>58. Язык конфигурации HashiCorp (HCL)</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day58/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day58/</guid><description>&lt;h2 id="язык-конфигурации-hashicorp-hcl">Язык конфигурации HashiCorp (HCL)&lt;/h2>
&lt;p>Прежде чем мы начнем создавать вещи с помощью Terraform, мы должны немного погрузиться в язык HashiCorp Configuration Language (HCL). До сих пор в ходе нашей задачи мы рассмотрели несколько различных языков скриптов и программирования, и вот еще один. Мы затронули &lt;a href=".../day07">язык программирования Go&lt;/a>, затем &lt;a href="../day19">скрипты bash&lt;/a>, мы даже немного затронули python, когда дело дошло до &lt;a href="../day27">автоматизации сети&lt;/a>.&lt;/p>
&lt;p>Теперь мы должны рассмотреть язык конфигурации HashiCorp (HCL), если вы впервые видите этот язык, он может показаться немного пугающим, но он довольно прост и очень мощный.&lt;/p>
&lt;p>По мере продвижения по этому разделу мы будем использовать примеры, которые мы можем запустить локально на нашей системе, независимо от того, какую ОС вы используете, мы будем использовать virtualbox, хотя и не инфраструктурную платформу, которую вы обычно используете с Terraform. Тем не менее, запуск этого локально, он бесплатный и позволит нам достичь того, что мы ищем в этой заметке. Мы также можем расширить концепцию этого поста на docker или Kubernetes.&lt;/p>
&lt;p>В целом, вы будете или должны использовать Terraform для развертывания инфраструктуры в публичном облаке (AWS, Google, Microsoft Azure), а также в средах виртуализации, таких как (VMware, Microsoft Hyper-V, Nutanix AHV). В публичном облаке Terraform позволяет нам делать гораздо больше, чем просто автоматическое развертывание виртуальных машин, мы можем создавать всю необходимую инфраструктуру, такую как рабочие нагрузки PaaS, и все необходимые сетевые ресурсы, такие как VPC и группы безопасности.&lt;/p>
&lt;p>В Terraform есть два важных аспекта: код, который мы рассмотрим в этой статье, и состояние. Оба этих аспекта вместе можно назвать ядром Terraform. Затем у нас есть среда, в которую мы хотим обратиться и развернуть, которая выполняется с помощью провайдеров Terraform, кратко упомянутых на прошлом занятии, но у нас есть провайдеры AWS, есть провайдеры Azure и т.д. Их сотни. Их сотни.&lt;/p>
&lt;h3 id="базовое-использование-terraform">Базовое использование Terraform&lt;/h3>
&lt;p>Давайте посмотрим на файл Terraform &lt;code>.tf&lt;/code>, чтобы увидеть, как они создаются. Первый пример, который мы рассмотрим, будет кодом для развертывания ресурсов на AWS, для этого также потребуется установить AWS CLI на вашей системе и настроить его для вашей учетной записи.&lt;/p>
&lt;h3 id="providers">Providers&lt;/h3>
&lt;p>В верхней части нашей файловой структуры &lt;code>.tf&lt;/code>, обычно называемой &lt;code>main.tf&lt;/code>, по крайней мере до тех пор, пока мы не сделаем все более сложным. Здесь мы определим провайдеров, о которых мы упоминали ранее. Наш источник провайдера aws, как вы видите, &lt;code>hashicorp/aws&lt;/code>, это означает, что провайдер поддерживается или был опубликован самой компанией hashicorp. По умолчанию вы будете ссылаться на провайдеров, доступных в &lt;a href="https://registry.terraform.io/">Terraform Registry&lt;/a>, у вас также есть возможность написать свои собственные провайдеры и использовать их локально или самостоятельно опубликовать в Terraform Registry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-terraform" data-lang="terraform">&lt;span style="display:flex;">&lt;span>terraform {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required_providers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">aws&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">source&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;hashicorp/aws&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;~&amp;gt; 3.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Здесь мы также можем добавить регион, чтобы определить, какой регион AWS мы хотим предоставить, мы можем сделать это, добавив следующее:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>provider &amp;#34;aws&amp;#34; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> region = &amp;#34;ap-southeast-1&amp;#34; //region where resources need to be deployed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="resources">Resources&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Другой важный компонент конфигурационного файла terraform, который описывает один или несколько объектов инфраструктуры, таких как EC2, Load Balancer, VPC и т.д.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Блок ресурсов объявляет ресурс заданного типа (&amp;ldquo;aws_instance&amp;rdquo;) с заданным локальным именем (&amp;ldquo;90daysofdevops&amp;rdquo;).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Тип ресурса и имя вместе служат идентификатором для данного ресурса.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>resource &lt;span style="color:#4070a0">&amp;#34;aws_instance&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;90daysofdevops&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ami &lt;span style="color:#666">=&lt;/span> data&lt;span style="color:#666">.&lt;/span>aws_ami&lt;span style="color:#666">.&lt;/span>instance_id&lt;span style="color:#666">.&lt;/span>id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance_type &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;t2.micro&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> availability_zone &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;us-west-2a&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> security_groups &lt;span style="color:#666">=&lt;/span> [aws_security_group&lt;span style="color:#666">.&lt;/span>allow_web&lt;span style="color:#666">.&lt;/span>name]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user_data &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">&amp;lt;&amp;lt;-&lt;/span>EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">#! /bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo yum update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo yum install &lt;span style="color:#666">-&lt;/span>y httpd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo systemctl start httpd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo systemctl enable httpd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">&amp;lt;&lt;/span>h1&lt;span style="color:#666">&amp;gt;&lt;/span>Deployed via Terraform&lt;span style="color:#666">&amp;lt;/&lt;/span>h1&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0">&amp;#34; | sudo tee /var/www/html/index.html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EOF
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags &lt;span style="color:#666">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Created by Terraform&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Из вышеприведенного видно, что мы также запускаем обновление &lt;code>yum&lt;/code> и устанавливаем &lt;code>httpd&lt;/code> в наш экземпляр ec2.&lt;/p>
&lt;p>Если мы теперь посмотрим на полный файл main.tf, он может выглядеть примерно так.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-terraform" data-lang="terraform">&lt;span style="display:flex;">&lt;span>terraform {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required_providers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">aws&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">source&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;hashicorp/aws&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;~&amp;gt; 3.27&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">required_version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;&amp;gt;= 0.14.9&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">provider&lt;/span> &lt;span style="color:#4070a0">&amp;#34;aws&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">profile&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">region&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;us-west-2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;aws_instance&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;90daysofdevops&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">ami&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;ami-830c94e3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">instance_type&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;t2.micro&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">availability_zone&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;us-west-2a&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">user_data&lt;/span> = &lt;span style="color:#666">&amp;lt;&amp;lt;-EOF&lt;/span>&lt;span style="color:#4070a0">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> #! /bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> sudo yum update
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> sudo yum install -y httpd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> sudo systemctl start httpd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> sudo systemctl enable httpd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> echo &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0">&amp;lt;h1&amp;gt;Deployed via Terraform&amp;lt;/h1&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0">&amp;#34; | sudo tee /var/www/html/index.html
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> &lt;/span>&lt;span style="color:#666">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">tags&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">Name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;Created by Terraform&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">tags&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">Name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;ExampleAppServerInstance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Приведенный выше код позволит развернуть очень простой веб-сервер в качестве экземпляра ec2 в AWS. Самое замечательное в этой и любой другой подобной конфигурации то, что мы можем повторить ее и каждый раз получать один и тот же результат. Кроме вероятности того, что я испортил код, нет никакого взаимодействия с человеком.&lt;/p>
&lt;p>Мы можем рассмотреть суперпростой пример, который вы, скорее всего, никогда не будете использовать, но давайте все равно пошутим. Как и во всех хороших скриптах и языках программирования, мы должны начать со скрипта приветствия мира.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-terraform" data-lang="terraform">&lt;span style="display:flex;">&lt;span>terraform {&lt;span style="color:#60a0b0;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"> # This module is now only being tested with Terraform 0.13.x. However, to make upgrading easier, we are setting
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"> # 0.12.26 as the minimum version, as that version added support for required_providers with source URLs, making it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"> # forwards compatible with 0.13.x code.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#4070a0">required_version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;&amp;gt;= 0.12.26&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#60a0b0;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># website::tag::1:: The simplest possible Terraform module: it just outputs &amp;#34;Hello, World!&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">output&lt;/span> &lt;span style="color:#4070a0">&amp;#34;hello_world&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">value&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;Hello, 90DaysOfDevOps from Terraform&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вы найдете этот файл в папке IAC в разделе hello-world, но из коробки он не будет просто работать, есть несколько команд, которые необходимо выполнить, чтобы использовать наш код терраформы.&lt;/p>
&lt;p>В терминале перейдите в папку, где был создан файл main.tf, он может быть из этого репозитория или вы можете создать новый, используя код выше.&lt;/p>
&lt;p>Находясь в этой папке, выполните команду &lt;code>terraform init&lt;/code>.&lt;/p>
&lt;p>Мы должны выполнить эту команду в любой директории, где у нас есть или перед запуском любого кода terraform. Инициализация каталога конфигурации загружает и устанавливает провайдеров, определенных в конфигурации, в данном случае у нас нет провайдеров, но в примере выше это загрузит провайдера aws для этой конфигурации.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day58_IAC1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Следующей командой будет &lt;code>terraform plan&lt;/code>.&lt;/p>
&lt;p>Команда &lt;code>terraform plan&lt;/code> создает план выполнения, который позволяет вам предварительно просмотреть изменения, которые Terraform планирует внести в вашу инфраструктуру.&lt;/p>
&lt;p>Вы можете видеть ниже, что на нашем примере hello-world мы увидим результат, если бы это был экземпляр AWS ec2, мы бы увидели все шаги, которые мы будем создавать.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day58_IAC2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На данном этапе мы инициализировали наш репозиторий, загрузили провайдеров, где это необходимо, запустили тестовый проход, чтобы убедиться, что это то, что мы хотим видеть, теперь мы можем запустить и развернуть наш код.&lt;/p>
&lt;p>Команда &lt;code>terraform apply&lt;/code> позволяет нам это сделать, в нее встроена мера безопасности, и это снова даст вам представление о том, что произойдет, что требует от вас ответа &amp;ldquo;да&amp;rdquo;, чтобы продолжить.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day58_IAC3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда мы вводим &amp;ldquo;да&amp;rdquo;, чтобы ввести значение, наш код развертывается. Очевидно, это не так интересно, но вы можете видеть, что у нас есть вывод, который мы определили в нашем коде.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day58_IAC4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы ничего не развернули, мы ничего не добавили, не изменили и не уничтожили, но если бы мы это сделали, то мы бы увидели, что это также указано выше. Однако если мы что-то развернули и хотим избавиться от всего, что развернули, мы можем использовать команду &lt;code>terraform destroy&lt;/code>. Опять же, это имеет ту безопасность, когда вы должны ввести &amp;ldquo;да&amp;rdquo;, хотя вы можете использовать &lt;code>--auto-approve&lt;/code> в конце ваших команд &lt;code>apply&lt;/code> и &lt;code>destroy&lt;/code>, чтобы обойти это ручное вмешательство. Но я бы посоветовал использовать это сокращение только в процессе обучения и тестирования, так как все будет исчезать иногда быстрее, чем было создано.&lt;/p>
&lt;p>Таким образом, мы рассмотрели всего 4 команды из Terraform CLI.&lt;/p>
&lt;ul>
&lt;li>&lt;code>terraform init&lt;/code> = подготовить папку проекта с провайдерами&lt;/li>
&lt;li>&lt;code>terraform plan&lt;/code> = показать, что будет создано, изменено во время следующей команды на основе нашего кода.&lt;/li>
&lt;li>&lt;code>terraform apply&lt;/code> = развернет ресурсы, определенные в нашем коде.&lt;/li>
&lt;li>&lt;code>terraform destroy&lt;/code> = уничтожит ресурсы, которые мы создали в нашем проекте.&lt;/li>
&lt;/ul>
&lt;p>Мы также рассмотрели два важных аспекта наших кодовых файлов.&lt;/p>
&lt;ul>
&lt;li>providers = как terraform общается с конечной платформой через API-интерфейсы&lt;/li>
&lt;li>resources = что именно мы хотим развернуть с помощью кода&lt;/li>
&lt;/ul>
&lt;p>Еще одна вещь, которую следует отметить, когда мы запускаем &lt;code>terraform init&lt;/code>, посмотрите на дерево в папке до и после, чтобы увидеть, что происходит и где мы храним провайдеры и модули.&lt;/p>
&lt;h3 id="terraform-state">Terraform state&lt;/h3>
&lt;p>Нам также необходимо знать о файле состояния, который создается также внутри нашей директории, и для этого примера hello world наш файл состояния прост. Это JSON-файл, который является представлением мира в соответствии с Terraform. Состояние будет радостно демонстрировать ваши конфиденциальные данные, поэтому будьте осторожны и в качестве лучшей практики помещайте файлы &lt;code>.tfstate&lt;/code> в папку &lt;code>.gitignore&lt;/code> перед загрузкой на GitHub.&lt;/p>
&lt;p>По умолчанию файл состояния, как вы видите, находится в том же каталоге, что и код вашего проекта, но его можно хранить и удаленно. В производственной среде это, скорее всего, будет общее место, например, ведро S3.&lt;/p>
&lt;p>Другим вариантом может быть Terraform Cloud, это платная управляемая услуга. (Бесплатно до 5 пользователей)&lt;/p>
&lt;p>Плюсы хранения состояния в удаленном месте заключаются в том, что мы получаем:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;version&amp;#34;: 4,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;terraform_version&amp;#34;: &amp;#34;1.1.6&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;serial&amp;#34;: 1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;lineage&amp;#34;: &amp;#34;a74296e7-670d-0cbb-a048-f332696ca850&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;outputs&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;hello_world&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;value&amp;#34;: &amp;#34;Hello, 90DaysOfDevOps from Terraform&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;resources&amp;#34;: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=POPP2WTJ8es">What is Infrastructure as Code? Difference of Infrastructure as Code Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=m3cKkYXl-8o">Terraform Tutorial | Terraform Course Overview 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=l5k1ai_GBDE">Terraform explained in 15 mins | Terraform Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;amp;list=WL&amp;amp;index=141&amp;amp;t=16s">Terraform Course - From BEGINNER to PRO!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V4waklkBC38&amp;amp;list=WL&amp;amp;index=55&amp;amp;t=111s">HashiCorp Terraform Associate Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EJ3N-hhiWv0&amp;amp;list=WL&amp;amp;index=39&amp;amp;t=27s">Terraform Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YcJ9IeukJL8&amp;amp;list=WL&amp;amp;index=16&amp;amp;t=11s">KodeKloud - Terraform for DevOps Beginners + Labs: Complete Step by Step Guide!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://terraform.joshuajebaraj.com/">Terraform Simple Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oA-pPa0vfks">Terraform Tutorial - The Best Project Ideas&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/shuaibiyy/awesome-terraform">Awesome Terraform&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>59. Создание виртуальной машины с помощью Terraform</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day59/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day59/</guid><description>&lt;h2 id="создание-виртуальной-машины-с-помощью-terraform-и-переменных">Создание виртуальной машины с помощью Terraform и переменных&lt;/h2>
&lt;p>В этой сессии мы будем создавать виртуальную машину или две виртуальные машины с помощью Terraform внутри VirtualBox. Это не совсем обычно, VirtualBox - это вариант виртуализации рабочих станций, и на самом деле это не было бы вариантом использования Terraform, но я сейчас нахожусь на высоте 36 000 футов в воздухе, и как бы я ни развертывал ресурсы публичного облака так высоко в облаках, гораздо быстрее сделать это локально на моем ноутбуке.&lt;/p>
&lt;p>Чисто демонстрационная цель, но концепция та же, мы собираемся иметь наш желаемый код конфигурации состояния, а затем мы собираемся запустить его против провайдера virtualbox. В прошлом мы использовали здесь vagrant, и я рассказал о различиях между vagrant и terraform в начале раздела.&lt;/p>
&lt;h3 id="создание-виртуальной-машины-в-virtualbox">Создание виртуальной машины в VirtualBox&lt;/h3>
&lt;p>Первое, что мы сделаем, это создадим новую папку под названием virtualbox, затем мы можем создать файл virtualbox.tf, в котором мы определим наши ресурсы. Приведенный ниже код, который можно найти в папке VirtualBox под названием virtualbox.tf, создаст 2 виртуальные машины в Virtualbox.&lt;/p>
&lt;p>Вы можете узнать больше о сообществе провайдера Virtualbox &lt;a href="https://registry.terraform.io/providers/terra-farm/virtualbox/latest/docs/resources/vm">здесь&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-terraform" data-lang="terraform">&lt;span style="display:flex;">&lt;span>terraform {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required_providers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">virtualbox&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">source&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;terra-farm/virtualbox&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;0.2.2-alpha.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#60a0b0;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># В настоящее время нет никаких опций конфигурации для самого провайдера.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;virtualbox_vm&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;node&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">count&lt;/span> = &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#007020">format&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;node-%02d&amp;#34;&lt;/span>, &lt;span style="color:#007020">count&lt;/span>.index &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">image&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;https://app.vagrantup.com/ubuntu/boxes/bionic64/versions/20180903.0.0/providers/virtualbox.box&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">cpus&lt;/span> = &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">memory&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;512 mib&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> network_adapter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">type&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;hostonly&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">host_interface&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;vboxnet1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">output&lt;/span> &lt;span style="color:#4070a0">&amp;#34;IPAddr&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">value&lt;/span> =&lt;span style="color:#007020"> element&lt;/span>(virtualbox_vm.node.&lt;span style="color:#666">*&lt;/span>.network_adapter.&lt;span style="color:#40a070">0&lt;/span>.ipv4_address, &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">output&lt;/span> &lt;span style="color:#4070a0">&amp;#34;IPAddr_2&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">value&lt;/span> =&lt;span style="color:#007020"> element&lt;/span>(virtualbox_vm.node.&lt;span style="color:#666">*&lt;/span>.network_adapter.&lt;span style="color:#40a070">0&lt;/span>.ipv4_address, &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь, когда мы определили наш код, мы можем выполнить &lt;code>terraform init&lt;/code> для нашей папки, чтобы загрузить провайдер для virtualbox.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day59_IAC1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Очевидно, что в вашей системе также должен быть установлен virtualbox. Затем мы можем запустить &lt;code>terraform plan&lt;/code>, чтобы посмотреть, что наш код создаст для нас. Затем следует &lt;code>terraform apply&lt;/code>. На рисунке ниже показан завершенный процесс.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day59_IAC2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь в Virtualbox вы увидите две виртуальные машины.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day59_IAC3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="изменение-конфигурации">Изменение конфигурации&lt;/h3>
&lt;p>Давайте добавим еще один узел в наше развертывание. Мы можем просто изменить строку count, чтобы показать новое желаемое количество узлов. Когда мы запустим нашу &lt;code>terraform apply&lt;/code>, она будет выглядеть примерно так, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day59_IAC4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После завершения работы в virtualbox вы можете увидеть, что у нас теперь есть 3 узла.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day59_IAC5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда мы закончим, мы можем очистить все это с помощью команды &lt;code>terraform destroy&lt;/code>, и наши машины будут удалены.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day59_IAC6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="переменные-и-выходные-данные">Переменные и выходные данные&lt;/h3>
&lt;p>Мы упоминали о выводах, когда выполняли пример hello-world на прошлом занятии. Но здесь мы можем остановиться на этом более подробно.&lt;/p>
&lt;p>Но есть много других переменных, которые мы можем использовать здесь, также есть несколько различных способов, которыми мы можем определить переменные.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Мы можем вручную ввести наши переменные с помощью команды &lt;code>terraform plan&lt;/code> или &lt;code>terraform apply&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Мы можем определить их в .tf-файле внутри блока&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Мы можем использовать переменные окружения в нашей системе, используя &lt;code>TF_VAR_NAME&lt;/code> в качестве формата.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Я предпочитаю использовать файл terraform.tfvars в папке нашего проекта.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Существует опция *auto.tfvars файла&lt;/p>
&lt;/li>
&lt;li>
&lt;p>или мы можем определить, когда запускаем &lt;code>terraform plan&lt;/code> или &lt;code>terraform apply&lt;/code> с помощью &lt;code>var&lt;/code> или &lt;code>var-file&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Порядок определения переменных будет начинаться снизу вверх.&lt;/p>
&lt;p>Мы также упоминали, что файл состояния будет содержать конфиденциальную информацию. Мы можем определить нашу чувствительную информацию как переменную и определить ее как чувствительную.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>variable &lt;span style="color:#4070a0">&amp;#34;some resource&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;something important&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sensitive &lt;span style="color:#666">=&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=POPP2WTJ8es">What is Infrastructure as Code? Difference of Infrastructure as Code Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=m3cKkYXl-8o">Terraform Tutorial | Terraform Course Overview 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=l5k1ai_GBDE">Terraform explained in 15 mins | Terraform Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;amp;list=WL&amp;amp;index=141&amp;amp;t=16s">Terraform Course - From BEGINNER to PRO!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V4waklkBC38&amp;amp;list=WL&amp;amp;index=55&amp;amp;t=111s">HashiCorp Terraform Associate Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EJ3N-hhiWv0&amp;amp;list=WL&amp;amp;index=39&amp;amp;t=27s">Terraform Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YcJ9IeukJL8&amp;amp;list=WL&amp;amp;index=16&amp;amp;t=11s">KodeKloud - Terraform for DevOps Beginners + Labs: Complete Step by Step Guide!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://terraform.joshuajebaraj.com/">Terraform Simple Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oA-pPa0vfks">Terraform Tutorial - The Best Project Ideas&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/shuaibiyy/awesome-terraform">Awesome Terraform&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>60. Контейнеры, провайдеры и модули Docker</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day60/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day60/</guid><description>&lt;h2 id="контейнеры-и-модули-docker">Контейнеры и модули Docker&lt;/h2>
&lt;p>&lt;a href="../day59">Вчера&lt;/a> мы развернули виртуальную машину с помощью Terraform в нашей локальной среде FREE virtualbox. В этом разделе мы собираемся развернуть контейнер Docker с некоторой конфигурацией в нашей локальной среде Docker.&lt;/p>
&lt;h3 id="docker-demo">Docker Demo&lt;/h3>
&lt;p>Для начала мы используем приведенный ниже блок кода, суть которого заключается в том, что мы хотим развернуть простое веб-приложение в docker и опубликовать его, чтобы оно было доступно в нашей сети. Мы будем использовать nginx и сделаем его доступным извне на нашем ноутбуке через localhost и порт 8000. Мы используем провайдера docker из сообщества, и вы можете видеть образ docker, который мы используем, также указанный в нашей конфигурации.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-terraform" data-lang="terraform">&lt;span style="display:flex;">&lt;span>terraform {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required_providers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">docker&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">source&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;kreuzwerker/docker&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;2.16.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">provider&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker&amp;#34;&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker_image&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;nginx&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;nginx:latest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">keep_locally&lt;/span> = &lt;span style="color:#007020;font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker_container&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;nginx&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">image&lt;/span> = docker_image.nginx.latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;tutorial&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ports {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">internal&lt;/span> = &lt;span style="color:#40a070">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">external&lt;/span> = &lt;span style="color:#40a070">8000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Первой задачей является использование команды &lt;code>terraform init&lt;/code> для загрузки провайдера на нашу локальную машину.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day60_IAC1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы запускаем команду &lt;code>terraform apply&lt;/code>, а затем &lt;code>docker ps&lt;/code>, и вы можете увидеть, что у нас есть запущенный контейнер.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day60_IAC2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы откроем браузер, то перейдем по адресу &lt;a href="http://localhost:8000/">http://localhost:8000/&lt;/a> и увидим, что у нас есть доступ к нашему контейнеру NGINX.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day60_IAC3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете узнать больше информации о &lt;a href="https://registry.terraform.io/providers/kreuzwerker/docker/latest/docs/resources/container">Docker Provider&lt;/a>.&lt;/p>
&lt;p>Выше приведена очень простая демонстрация того, что можно сделать с помощью Terraform плюс Docker и как мы теперь можем управлять этим в состоянии Terraform. Мы рассматривали docker compose в разделе о контейнерах, и есть небольшое пересечение между этим, инфраструктурой как код, а также Kubernetes.&lt;/p>
&lt;p>Для демонстрации того, как Terraform может справиться с более сложными задачами, мы возьмем файл docker compose для wordpress и mysql, который мы создали с помощью docker compose, и поместим его в Terraform. Вы можете найти &lt;a href="https://romankurnovskii.com/Days/IaC/Docker-Wordpress/docker-wordpress.tf">docker-wordpress.tf&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-tf" data-lang="tf">&lt;span style="display:flex;">&lt;span>terraform {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required_providers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">docker&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">source&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;kreuzwerker/docker&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;2.16.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">provider&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker&amp;#34;&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">variable&lt;/span> wordpress_port {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">default&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;8080&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker_volume&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;db_data&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;db_data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker_network&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;wordpress_net&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;wordpress_net&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker_container&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;db&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;db&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">image&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;mysql:5.7&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">restart&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;always&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">network_mode&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;wordpress_net&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">env&lt;/span> = [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;MYSQL_ROOT_PASSWORD=wordpress&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;MYSQL_PASSWORD=wordpress&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;MYSQL_USER=wordpress&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;MYSQL_DATABASE=wordpress&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mounts {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">type&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;volume&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">target&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;/var/lib/mysql&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">source&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;db_data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;docker_container&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;wordpress&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;wordpress&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">image&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;wordpress:latest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">restart&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;always&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">network_mode&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;wordpress_net&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">env&lt;/span> = [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;WORDPRESS_DB_HOST=db:3306&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;WORDPRESS_DB_USER=wordpress&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;WORDPRESS_DB_NAME=wordpress&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;WORDPRESS_DB_PASSWORD=wordpress&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ports {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">internal&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">external&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#70a0d0">${&lt;/span>&lt;span style="color:#007020">var&lt;/span>.wordpress_port&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Мы снова помещаем это в новую папку и затем запускаем команду &lt;code>terraform init&lt;/code>, чтобы извлечь необходимые нам провайдеры.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day60_IAC4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы запускаем команду &lt;code>terraform apply&lt;/code> и смотрим на вывод docker ps, мы должны увидеть наши только что созданные контейнеры.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day60_IAC5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем перейти к нашему фронт-энду WordPress. Точно так же, как мы проходили этот процесс с docker-compose в разделе о контейнерах, теперь мы можем выполнить установку, и наши посты wordpress будут жить в нашей базе данных MySQL.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day60_IAC6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Очевидно, что теперь мы рассмотрели контейнеры и Kubernetes в некоторых деталях, мы, вероятно, знаем, что это подходит для тестирования, но если бы вы действительно собирались запустить веб-сайт, вы бы не стали делать это только с помощью контейнеров и рассмотрели бы использование Kubernetes для достижения этой цели, Далее мы рассмотрим использование Terraform с Kubernetes.&lt;/p>
&lt;h3 id="provisioners">Provisioners&lt;/h3>
&lt;p>Провайдеры существуют для того, чтобы если что-то не может быть декларировано, у нас был способ разобрать это для нашего развертывания.&lt;/p>
&lt;p>Если у вас нет другой альтернативы, и добавление такой сложности в ваш код - это то, что вам нужно, то вы можете сделать это, выполнив что-то похожее на следующий блок кода.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>ресурс &amp;#34;docker_container&amp;#34; &amp;#34;db&amp;#34; { # ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> provisioner &amp;#34;local-exec&amp;#34; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command = &amp;#34;echo The server&amp;#39;s IP address is ${self.private_ip}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Удаленный исполнительный провайдер вызывает скрипт на удаленном ресурсе после его создания. Это может быть использовано для чего-то специфического для ОС, или это может быть использовано для обертывания в инструмент управления конфигурацией. Хотя заметьте, что некоторые из них мы уже рассмотрели в собственных провайдерах.&lt;/p>
&lt;p>Средство подготовки удаленных исполняемых файлов вызывает скрипт на удаленном ресурсе после его создания. Это может быть использовано для чего-то определенного для ОС или может быть использовано для включения инструмента управления конфигурацией. Хотя обратите внимание, что у нас есть некоторые из них, покрытые их собственными провизорами.
Подробнее о провизорах](&lt;a href="https://www.terraform.io/language/resources/provisioners/syntax">https://www.terraform.io/language/resources/provisioners/syntax&lt;/a>)&lt;/p>
&lt;ul>
&lt;li>file&lt;/li>
&lt;li>local-exec&lt;/li>
&lt;li>remote-exec&lt;/li>
&lt;li>vendor
&lt;ul>
&lt;li>ansible&lt;/li>
&lt;li>chef&lt;/li>
&lt;li>puppet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="модули">Модули&lt;/h3>
&lt;p>Модули - это контейнеры для нескольких ресурсов, которые используются вместе. Модуль состоит из коллекции файлов .tf в одном каталоге.&lt;/p>
&lt;p>Модули - это хороший способ разделить ресурсы инфраструктуры, а также возможность использовать уже созданные сторонние модули, чтобы не изобретать колесо.&lt;/p>
&lt;p>Например, если бы мы хотели использовать один и тот же проект для создания нескольких виртуальных машин, VPC, групп безопасности, а затем кластера Kubernetes, мы бы, вероятно, захотели разделить наши ресурсы на модули, чтобы лучше определить наши ресурсы и их группировку.&lt;/p>
&lt;p>Еще одним преимуществом модулей является то, что вы можете взять эти модули и использовать их в других проектах или публично поделиться ими, чтобы помочь сообществу.&lt;/p>
&lt;p>Мы разбиваем нашу инфраструктуру на компоненты, компоненты известны здесь как модули.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=POPP2WTJ8es">What is Infrastructure as Code? Difference of Infrastructure as Code Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=m3cKkYXl-8o">Terraform Tutorial | Terraform Course Overview 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=l5k1ai_GBDE">Terraform explained in 15 mins | Terraform Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;amp;list=WL&amp;amp;index=141&amp;amp;t=16s">Terraform Course - From BEGINNER to PRO!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V4waklkBC38&amp;amp;list=WL&amp;amp;index=55&amp;amp;t=111s">HashiCorp Terraform Associate Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EJ3N-hhiWv0&amp;amp;list=WL&amp;amp;index=39&amp;amp;t=27s">Terraform Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YcJ9IeukJL8&amp;amp;list=WL&amp;amp;index=16&amp;amp;t=11s">KodeKloud - Terraform for DevOps Beginners + Labs: Complete Step by Step Guide!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://terraform.joshuajebaraj.com/">Terraform Simple Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oA-pPa0vfks">Terraform Tutorial - The Best Project Ideas&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/shuaibiyy/awesome-terraform">Awesome Terraform&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>61. Kubernetes и множественные среды</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day61/</link><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day61/</guid><description>&lt;h2 id="kubernetes-и-множественные-среды">Kubernetes и множественные среды&lt;/h2>
&lt;p>До сих пор в этом разделе, посвященном инфраструктуре как коду, мы рассматривали развертывание виртуальных машин, хотя и с помощью virtualbox, но суть одна и та же: мы определяем в коде, как должна выглядеть наша виртуальная машина, а затем развертываем ее. То же самое касается контейнеров Docker, и на этом занятии мы рассмотрим, как Terraform можно использовать для взаимодействия с ресурсами, поддерживаемыми Kubernetes.&lt;/p>
&lt;p>Я использовал Terraform для развертывания своих кластеров Kubernetes в демонстрационных целях на трех основных облачных провайдерах, и вы можете найти репозиторий &lt;a href="https://github.com/MichaelCade/tf_k8deploy">tf_k8deploy&lt;/a>.&lt;/p>
&lt;p>Однако вы также можете использовать Terraform для взаимодействия с объектами внутри кластера Kubernetes, это может быть использование &lt;a href="https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs">Kubernetes provider&lt;/a> или &lt;a href="https://registry.terraform.io/providers/hashicorp/helm/latest">Helm provider&lt;/a> для управления развертыванием диаграмм.&lt;/p>
&lt;p>Теперь мы можем использовать &lt;code>kubectl&lt;/code>, как мы показывали в предыдущих разделах. Но есть некоторые преимущества использования Terraform в вашей среде Kubernetes.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Унифицированный рабочий процесс - если вы использовали Terraform для развертывания кластеров, вы можете использовать тот же рабочий процесс и инструмент для развертывания в кластерах Kubernetes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Управление жизненным циклом - Terraform - это не просто инструмент инициализации, он позволяет вносить изменения, обновления и удаления.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="простая-демонстрация-kubernetes">Простая демонстрация Kubernetes&lt;/h3>
&lt;p>Подобно демо, которое мы создали на прошлом занятии, мы можем развернуть nginx в нашем кластере Kubernetes, я снова буду использовать minikube в демонстрационных целях. Мы создаем наш файл Kubernetes.tf, который вы можете найти в &lt;a href="https://romankurnovskii.com/Days/IaC/Kubernetes/kubernetes.tf">папке&lt;/a>.&lt;/p>
&lt;p>В этом файле мы определим нашего провайдера Kubernetes, укажем на наш файл kubeconfig, создадим пространство имен nginx, затем создадим развертывание, содержащее 2 реплики и, наконец, сервис.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-terraform" data-lang="terraform">&lt;span style="display:flex;">&lt;span>terraform {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> required_providers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">kubernetes&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">source&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;hashicorp/kubernetes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">version&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;&amp;gt;= 2.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">provider&lt;/span> &lt;span style="color:#4070a0">&amp;#34;kubernetes&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">config_path&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;~/.kube/config&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;kubernetes_namespace&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;test&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;kubernetes_deployment&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;test&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">namespace&lt;/span> = kubernetes_namespace.test.metadata.&lt;span style="color:#40a070">0&lt;/span>.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">replicas&lt;/span> = &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">match_labels&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">app&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;MyTestApp&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">labels&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">app&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;MyTestApp&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> container {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">image&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;nginx-container&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">container_port&lt;/span> = &lt;span style="color:#40a070">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">resource&lt;/span> &lt;span style="color:#4070a0">&amp;#34;kubernetes_service&amp;#34;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;test&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">name&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">namespace&lt;/span> = kubernetes_namespace.test.metadata.&lt;span style="color:#40a070">0&lt;/span>.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">selector&lt;/span> = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">app&lt;/span> = kubernetes_deployment.test.spec.&lt;span style="color:#40a070">0&lt;/span>.template.&lt;span style="color:#40a070">0&lt;/span>.metadata.&lt;span style="color:#40a070">0&lt;/span>.labels.app
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">type&lt;/span> = &lt;span style="color:#4070a0">&amp;#34;NodePort&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">node_port&lt;/span> = &lt;span style="color:#40a070">30201&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">port&lt;/span> = &lt;span style="color:#40a070">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">target_port&lt;/span> = &lt;span style="color:#40a070">80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Первое, что мы должны сделать в папке нашего нового проекта, это выполнить команду &lt;code>terraform init&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day61_IAC1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>А затем, прежде чем мы выполним команду &lt;code>terraform apply&lt;/code>, позвольте мне показать вам, что у нас нет пространств имен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day61_IAC2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда мы запустим нашу команду apply, она создаст эти 3 новых ресурса, пространство имен, развертывание и сервис в нашем кластере Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day61_IAC3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем взглянуть на развернутые ресурсы в нашем кластере.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day61_IAC4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, поскольку мы используем minikube, и вы видели в предыдущем разделе, это имеет свои собственные ограничения, когда мы пытаемся играть с сетью docker для ingress. Но если мы просто выполним команду &lt;code>kubectl port-forward -n nginx svc/nginx 30201:80&lt;/code> и откроем браузер на &lt;a href="http://localhost:30201/">http://localhost:30201/&lt;/a>, мы увидим нашу страницу NGINX.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day61_IAC5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы хотите попробовать более подробные демонстрации с Terraform и Kubernetes, то на сайте &lt;a href="https://learn.hashicorp.com/tutorials/terraform/kubernetes-provider">HashiCorp Learn site&lt;/a> вы сможете ознакомиться с ними.&lt;/p>
&lt;h3 id="множественные-окружения">Множественные окружения&lt;/h3>
&lt;p>Если мы хотим взять любой из демонстрационных примеров, которые мы проверили, но теперь хотим, чтобы определенные среды производства, постановки и разработки выглядели одинаково и использовали этот код, есть два подхода для достижения этого с помощью Terraform&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>терраформенные рабочие пространства&lt;/code> - несколько именованных разделов в рамках одного бэкенда&lt;/p>
&lt;/li>
&lt;li>
&lt;p>файловая структура - расположение каталогов обеспечивает разделение, модули обеспечивают повторное использование.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Каждый из этих подходов имеет свои плюсы и минусы.&lt;/p>
&lt;h3 id="terraform-workspaces">terraform workspaces&lt;/h3>
&lt;p>Плюсы&lt;/p>
&lt;ul>
&lt;li>Легко начать работу&lt;/li>
&lt;li>Удобное выражение terraform.workspace&lt;/li>
&lt;li>Минимизирует дублирование кода&lt;/li>
&lt;/ul>
&lt;p>Минусы&lt;/p>
&lt;ul>
&lt;li>Склонность к человеческим ошибкам (мы пытались устранить это, используя TF)&lt;/li>
&lt;li>Состояние хранится в одном бэкенде&lt;/li>
&lt;li>Кодовая база не показывает однозначно конфигурации развертывания.&lt;/li>
&lt;/ul>
&lt;h3 id="файловая-структура">Файловая структура&lt;/h3>
&lt;p>Плюсы&lt;/p>
&lt;ul>
&lt;li>Изоляция бэкендов
&lt;ul>
&lt;li>повышенная безопасность&lt;/li>
&lt;li>снижен потенциал для человеческих ошибок&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Кодовая база полностью представляет развернутое состояние&lt;/li>
&lt;/ul>
&lt;p>Минусы&lt;/p>
&lt;ul>
&lt;li>Требуется многократное применение terraform для обеспечения окружения&lt;/li>
&lt;li>больше дублирования кода, но его можно минимизировать с помощью модулей.&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=POPP2WTJ8es">What is Infrastructure as Code? Difference of Infrastructure as Code Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=m3cKkYXl-8o">Terraform Tutorial | Terraform Course Overview 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=l5k1ai_GBDE">Terraform explained in 15 mins | Terraform Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;amp;list=WL&amp;amp;index=141&amp;amp;t=16s">Terraform Course - From BEGINNER to PRO!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V4waklkBC38&amp;amp;list=WL&amp;amp;index=55&amp;amp;t=111s">HashiCorp Terraform Associate Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EJ3N-hhiWv0&amp;amp;list=WL&amp;amp;index=39&amp;amp;t=27s">Terraform Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YcJ9IeukJL8&amp;amp;list=WL&amp;amp;index=16&amp;amp;t=11s">KodeKloud - Terraform for DevOps Beginners + Labs: Complete Step by Step Guide!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://terraform.joshuajebaraj.com/">Terraform Simple Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oA-pPa0vfks">Terraform Tutorial - The Best Project Ideas&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/shuaibiyy/awesome-terraform">Awesome Terraform&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>62. Terraform - Тестирование, инструменты и альтернативы</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day62/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day62/</guid><description>&lt;h2 id="тестирование-инструменты-и-альтернативы">Тестирование, инструменты и альтернативы&lt;/h2>
&lt;p>Завершая этот раздел об инфраструктуре как коде, мы должны упомянуть о тестировании нашего кода, различных доступных инструментах, а также о некоторых альтернативах Terraform для достижения этой цели. Как я уже говорил в начале раздела, я остановился на Terraform, поскольку он, во-первых, бесплатный и с открытым исходным кодом, во-вторых, он кроссплатформенный и не зависит от окружения. Но есть и альтернативы, которые следует рассмотреть, но общая цель состоит в том, чтобы донести до людей, что это способ развертывания инфраструктуры.&lt;/p>
&lt;h3 id="code-rot">Code Rot&lt;/h3>
&lt;p>Первая область, которую я хочу затронуть в этой сессии, - это гниение кода. В отличие от кода приложений, инфраструктура как код может использоваться, а затем не использоваться в течение очень долгого времени. Возьмем пример: мы собираемся использовать Terraform для развертывания нашей среды VM в AWS, все идеально, все работает с первого раза, и у нас есть наша среда, но эта среда не меняется слишком часто, поэтому код остается в состоянии, возможно, или, надеюсь, хранится в центральном месте, но код не меняется.&lt;/p>
&lt;p>А что если что-то изменится в инфраструктуре? Но это делается вне диапазона, или другие вещи меняются в нашей среде.&lt;/p>
&lt;ul>
&lt;li>Внеполосные изменения (Out of band changes)&lt;/li>
&lt;li>Неприкрепленные версии (Unpinned versions)&lt;/li>
&lt;li>Утратившие актуальность зависимости (Deprecated dependancies)&lt;/li>
&lt;li>Неприменимые изменения (Unapplied changes)&lt;/li>
&lt;/ul>
&lt;h3 id="тестирование">Тестирование&lt;/h3>
&lt;p>Еще одна огромная область, которая следует за гниением кода и в целом, это возможность протестировать ваш IaC и убедиться, что все области работают так, как должны.&lt;/p>
&lt;p>Прежде всего, есть несколько встроенных команд тестирования, на которые мы можем взглянуть:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>terraform fmt&lt;/code>&lt;/td>
&lt;td>Rewrite Terraform configuration files to a canonical format and style.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>terraform validate&lt;/code>&lt;/td>
&lt;td>Validates the configuration files in a directory, referring only to the configuration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>terraform plan&lt;/code>&lt;/td>
&lt;td>Creates an execution plan, which lets you preview the changes that Terraform plans to make&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Custom validation&lt;/td>
&lt;td>Validation of your input variables to ensure they match what you would expect them to be&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>У нас также есть некоторые инструменты тестирования, доступные вне Terraform:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/terraform-linters/tflint">tflint&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Найти возможные ошибки (Find possible errors)&lt;/li>
&lt;li>Предупреждать об устаревшем синтаксисе, неиспользуемых объявлениях. (Warn about deprecated syntax, unused declarations.)&lt;/li>
&lt;li>Применять лучшие практики, соглашения об именовании. (Enforce best practices, naming conventions.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Инструменты сканирования&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.checkov.io/">checkov&lt;/a> - сканирование конфигураций облачной инфраструктуры для поиска неправильных конфигураций до их развертывания.&lt;/li>
&lt;li>&lt;a href="https://aquasecurity.github.io/tfsec/v1.4.2/">tfsec&lt;/a> - сканер безопасности статического анализа для кода Terraform.&lt;/li>
&lt;li>&lt;a href="https://github.com/accurics/terrascan">terrascan&lt;/a> - статический анализатор кода для Infrastructure as Code.&lt;/li>
&lt;li>&lt;a href="https://terraform-compliance.com/">terraform-compliance&lt;/a> - легковесный тестовый фреймворк, ориентированный на безопасность и соответствие требованиям, для terraform, позволяющий проводить негативное тестирование вашей инфраструктуры как кода.&lt;/li>
&lt;li>&lt;a href="https://docs.snyk.io/products/snyk-infrastructure-as-code/scan-terraform-files/scan-and-fix-security-issues-in-terraform-files">snyk&lt;/a> - сканирует код Terraform на предмет неправильной конфигурации и проблем безопасности.&lt;/li>
&lt;/ul>
&lt;p>Управляемое облачное предложение&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.terraform.io/cloud-docs/sentinel">Terraform Sentinel&lt;/a> - встроенный фреймворк политики как кода, интегрированный с продуктами HashiCorp Enterprise. Она позволяет принимать решения о политике на основе логики и может быть расширена для использования информации из внешних источников.&lt;/li>
&lt;/ul>
&lt;p>Автоматизированное тестирование&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://terratest.gruntwork.io/">Terratest&lt;/a> - Terratest - это библиотека Go, которая предоставляет шаблоны и вспомогательные функции для инфраструктуры тестирования.&lt;/li>
&lt;/ul>
&lt;p>Стоит упомянуть&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://cloud.hashicorp.com/products/terraform">Terraform Cloud&lt;/a> - Terraform Cloud - это управляемый сервис компании HashiCorp. Оно устраняет необходимость в ненужных инструментах и документации для практиков, команд и организаций для использования Terraform в производстве.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://terragrunt.gruntwork.io/">Terragrunt&lt;/a> - Terragrunt - это тонкая обертка, которая предоставляет дополнительные инструменты для сохранения DRY конфигураций, работы с несколькими модулями Terraform и управления удаленным состоянием.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.runatlantis.io/">Atlantis&lt;/a> - Terraform Pull Request Automation.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="альтернативы">Альтернативы&lt;/h3>
&lt;p>В день 57, когда мы начали этот раздел, мы упоминали, что есть некоторые альтернативы, и я очень планирую изучить их после завершения этой задачи.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Cloud Specific&lt;/th>
&lt;th>Cloud Agnostic&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>AWS CloudFormation&lt;/td>
&lt;td>Terraform&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Azure Resource Manager&lt;/td>
&lt;td>Pulumi&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Google Cloud Deployment Manager&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Я использовал AWS CloudFormation, вероятно, больше всего из вышеперечисленного списка, он является родным для AWS, но я не использовал другие, кроме Terraform. Как вы можете себе представить, версии для конкретных облаков очень хороши для конкретного облака, но если у вас несколько облачных сред, то вам будет сложно перенести эти конфигурации или у вас будет несколько плоскостей управления для ваших усилий IaC.&lt;/p>
&lt;p>Я думаю, что следующим интересным шагом для меня будет уделить некоторое время и узнать больше о &lt;a href="https://www.pulumi.com/">Pulumi&lt;/a>.&lt;/p>
&lt;p>Из сравнения Pulumi на их сайте&lt;/p>
&lt;p>&lt;em>&amp;ldquo;И Terraform, и Pulumi предлагают модель инфраструктуры желаемого состояния как кода, где код представляет желаемое состояние инфраструктуры, а механизм развертывания сравнивает это желаемое состояние с текущим состоянием стека и определяет, какие ресурсы должны быть созданы, обновлены или удалены&amp;rdquo;.&lt;/em>&lt;/p>
&lt;p>Самое большое отличие, которое я вижу, заключается в том, что в отличие от HashiCorp Configuration Language (HCL) Pulumi позволяет использовать языки общего назначения, такие как Python, TypeScript, JavaScript, Go и .NET.&lt;/p>
&lt;p>Краткий обзор &lt;a href="https://www.youtube.com/watch?v=QfJTJs24-JM">Introduction to Pulumi: Modern Infrastructure as Code&lt;/a> Мне нравится простота и возможность выбора, которую вам предлагают, и я хочу разобраться в этом немного подробнее.&lt;/p>
&lt;p>На этом мы завершаем раздел &amp;ldquo;Инфраструктура как код&amp;rdquo; и переходим к тому, что немного пересекается с управлением конфигурацией, и, в частности, по мере того, как мы переходим к общей картине управления конфигурацией, мы будем использовать Ansible для некоторых из этих задач и демонстраций.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=POPP2WTJ8es">What is Infrastructure as Code? Difference of Infrastructure as Code Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=m3cKkYXl-8o">Terraform Tutorial | Terraform Course Overview 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=l5k1ai_GBDE">Terraform explained in 15 mins | Terraform Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;amp;list=WL&amp;amp;index=141&amp;amp;t=16s">Terraform Course - From BEGINNER to PRO!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=V4waklkBC38&amp;amp;list=WL&amp;amp;index=55&amp;amp;t=111s">HashiCorp Terraform Associate Certification Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EJ3N-hhiWv0&amp;amp;list=WL&amp;amp;index=39&amp;amp;t=27s">Terraform Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YcJ9IeukJL8&amp;amp;list=WL&amp;amp;index=16&amp;amp;t=11s">KodeKloud - Terraform for DevOps Beginners + Labs: Complete Step by Step Guide!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://terraform.joshuajebaraj.com/">Terraform Simple Projects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oA-pPa0vfks">Terraform Tutorial - The Best Project Ideas&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/shuaibiyy/awesome-terraform">Awesome Terraform&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=vIjeiDcsR3Q&amp;amp;t=51s">Pulumi - IaC in your favorite programming language!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>63. Инструменты управления конфигурацией - Ansible/Terraform</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day63/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day63/</guid><description>&lt;h2 id="введение-управление-конфигурацией">Введение: Управление конфигурацией&lt;/h2>
&lt;p>Сразу после раздела, посвященного инфраструктуре как коду, мы, вероятно, будем говорить об управлении конфигурацией или управлении конфигурацией приложений.&lt;/p>
&lt;p>Управление конфигурацией - это процесс поддержания приложений, систем и серверов в требуемом состоянии. Пересечение с Infrastructure as code заключается в том, что IaC гарантирует, что ваша инфраструктура находится в желаемом состоянии, но после этого, особенно terraform, не будет заботиться о желаемом состоянии настроек вашей ОС или приложений, и именно здесь на помощь приходят инструменты управления конфигурацией. Убедитесь, что система и приложения работают так, как ожидается, поскольку изменения происходят в Deane.&lt;/p>
&lt;p>Управление конфигурацией убережет вас от внесения мелких или крупных изменений, которые останутся недокументированными.&lt;/p>
&lt;h3 id="почему-вы-хотите-использовать-управление-конфигурацией">Почему вы хотите использовать управление конфигурацией&lt;/h3>
&lt;p>Сценарий или почему вы хотите использовать управление конфигурацией, познакомьтесь с Дином. Он наш системный администратор, и Дин - счастливый турист, который работает над всеми своими системами.
работает над всеми системами в своем окружении.&lt;/p>
&lt;p>Что произойдет, если их система выйдет из строя, если случится пожар, сервер выйдет из строя? Дин точно знает, что делать, он может легко устранить пожар, но если несколько серверов начнут выходить из строя, особенно если у вас большая и расширяющаяся среда, вот почему Дину действительно необходимо иметь инструмент управления конфигурацией. Инструменты управления конфигурацией могут помочь Дину выглядеть как рок-звезда, все, что ему нужно сделать, это настроить правильные коды, которые позволят ему быстро, эффективно и масштабно передать инструкции по настройке каждого из серверов.&lt;/p>
&lt;h3 id="инструменты-управления-конфигурацией">Инструменты управления конфигурацией&lt;/h3>
&lt;p>Существует множество инструментов управления конфигурацией, и каждый из них имеет специфические особенности, которые делают его лучше для одних ситуаций, чем для других.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day63_config1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На этом этапе мы быстро рассмотрим варианты, показанные на рисунке выше, прежде чем сделать выбор, какой из них мы будем использовать и почему.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Chef&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Chef обеспечивает последовательное применение конфигурации в любой среде, в любом масштабе с помощью автоматизации инфраструктуры.&lt;/li>
&lt;li>Chef - это инструмент с открытым исходным кодом, разработанный компанией OpsCode и написанный на Ruby и Erlang.&lt;/li>
&lt;li>Chef лучше всего подходит для организаций, которые имеют гетерогенную инфраструктуру и ищут зрелые решения.&lt;/li>
&lt;li>Рецепты и Cookbooks определяют код конфигурации для ваших систем.&lt;/li>
&lt;li>Pro - Доступна большая коллекция рецептов&lt;/li>
&lt;li>Pro - Хорошо интегрируется с Git, что обеспечивает надежный контроль версий.&lt;/li>
&lt;li>Против - Крутая кривая обучения, требуется значительное количество времени.&lt;/li>
&lt;li>Против - Главный сервер не имеет большого контроля.&lt;/li>
&lt;li>Архитектура - сервер / клиенты&lt;/li>
&lt;li>Простота настройки - Умеренная&lt;/li>
&lt;li>Язык - Процедурный - Указать, как выполнить задачу&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Puppet&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Puppet - это инструмент управления конфигурацией, который поддерживает автоматическое развертывание.&lt;/li>
&lt;li>Puppet построен на Ruby и использует DSL для написания манифестов.&lt;/li>
&lt;li>Puppet также хорошо работает с гетерогенной инфраструктурой, где основное внимание уделяется масштабируемости.&lt;/li>
&lt;li>За - Большое сообщество поддержки.&lt;/li>
&lt;li>За - Хорошо развитый механизм отчетности.&lt;/li>
&lt;li>Против - Продвинутые задачи требуют знания языка Ruby.&lt;/li>
&lt;li>Против - Главный сервер не имеет большого контроля.&lt;/li>
&lt;li>Архитектура - сервер / клиенты&lt;/li>
&lt;li>Простота установки - Умеренная&lt;/li>
&lt;li>Язык - Декларативный - указывать только то, что нужно делать&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Ansible&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Ansible - это инструмент автоматизации ИТ, который автоматизирует управление конфигурацией, предоставление облака, развертывание и оркестровку.&lt;/li>
&lt;li>Ядро плейбуков Ansible написано на языке YAML. (Следует сделать раздел о YAML, так как мы уже несколько раз сталкивались с этим).&lt;/li>
&lt;li>Ansible хорошо работает в средах, где основное внимание уделяется быстрой настройке и запуску.&lt;/li>
&lt;li>Работает на основе плейбуков, которые предоставляют инструкции вашим серверам.&lt;/li>
&lt;li>Pro - Не нужны агенты на удаленных узлах.&lt;/li>
&lt;li>Pro - YAML легко изучить.&lt;/li>
&lt;li>Против - Скорость работы часто ниже, чем у других инструментов (быстрее, чем Дин делает это сам вручную).&lt;/li>
&lt;li>Против - YAML не такой мощный, как Ruby, но его легче освоить.&lt;/li>
&lt;li>Архитектура - Только клиент&lt;/li>
&lt;li>Простота настройки - Очень просто&lt;/li>
&lt;li>Язык - Процедурный - Указать, как выполнить задачу&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SaltStack&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>SaltStack - это инструмент на основе CLI, который автоматизирует управление конфигурацией и удаленное выполнение.&lt;/li>
&lt;li>SaltStack основан на Python, а инструкции написаны на YAML или собственном DSL.&lt;/li>
&lt;li>Идеально подходит для сред, где приоритетом является масштабируемость и отказоустойчивость.&lt;/li>
&lt;li>Плюсы - Простота использования при запуске&lt;/li>
&lt;li>Плюсы - Хороший механизм отчетности&lt;/li>
&lt;li>Против - Фаза установки сложная&lt;/li>
&lt;li>Против - Новый веб-уи, который гораздо менее проработан, чем другие.&lt;/li>
&lt;li>Архитектура - сервер / клиенты&lt;/li>
&lt;li>Простота установки - Умеренная&lt;/li>
&lt;li>Язык - Декларативный - указывайте только то, что нужно делать&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="ansible-vs-terraform">Ansible vs Terraform&lt;/h3>
&lt;p>Инструментом, который мы будем использовать для этого раздела, будет Ansible. (Простой в использовании и требуются основы языка).&lt;/p>
&lt;p>| Я думаю, что важно коснуться некоторых различий между Ansible и Terraform, прежде чем мы рассмотрим инструментарий немного подробнее. | | Ansible | Terraform |
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |
| Type | Ansible is a configuration management tool | Terraform is a an orchestration tool |
| Infrastructure | Ansible provides support for mutable infrastructure | Terraform provides support for immutable infrastructure |
| Language | Ansible follows procedural language | Terraform follows a declartive language |
| Provisioning | Ansible provides partial provisioning (VM, Network, Storage) | Terraform provides extensive provisioning (VM, Network, Storage) |
| Packaging | Ansible provides complete support for packaging &amp;amp; templating | Terraform provides partial support for packaging &amp;amp; templating |
| Lifecycle Mgmt | Ansible does not have lifecycle management | Terraform is heavily dependant on lifecycle and state mgmt |&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1id6ERvfozo">What is Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=goclfp6a2IQ">Ansible 101 - Episode 1 - Introduction to Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5hycyr-8EKs&amp;amp;t=955s">NetworkChuck - You need to learn Ansible right now!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>64. Ansible Введение</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day64/</link><pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day64/</guid><description>&lt;p>Основы Ansible&lt;/p>
&lt;h2 id="ansible-начало-работы">Ansible: Начало работы&lt;/h2>
&lt;p>Мы немного рассказали о том, что такое Ansible, на вчерашней &lt;a href="../day63">большой сессии&lt;/a>, но здесь мы собираемся начать с более подробной информации. Во-первых, Ansible поставляется компанией RedHat. Во-вторых, это агент, подключается через SSH и выполняет команды. В-третьих, он кроссплатформенный (Linux &amp;amp; macOS, WSL2) и с открытым исходным кодом (есть также платный корпоративный вариант) Ansible толкает конфигурацию по сравнению с другими моделями.&lt;/p>
&lt;h3 id="установка-ansible">Установка Ansible&lt;/h3>
&lt;p>Как вы можете себе представить, RedHat и команда Ansible проделали фантастическую работу по документированию Ansible. Обычно это начинается с шагов по установке, которые вы можете найти &lt;a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html">здесь&lt;/a>. Помните, мы говорили, что Ansible - это инструмент автоматизации без агентов, инструмент развертывается на системе, называемой &amp;ldquo;узел управления&amp;rdquo;, с этого узла управления осуществляется управление машинами и другими устройствами (возможно, сетевыми) по SSH.&lt;/p>
&lt;p>В документации по ссылке выше говорится, что ОС Windows не может использоваться в качестве узла управления.&lt;/p>
&lt;p>Для моего узла управления и, по крайней мере, для этой демонстрации я собираюсь использовать виртуальную машину Linux, которую мы создали еще в &lt;a href="../day20">разделе Linux&lt;/a> в качестве узла управления.&lt;/p>
&lt;p>Эта система работала под управлением Ubuntu, и для ее установки достаточно выполнить следующие команды.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install software-properties-common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo add-apt-repository --yes --update ppa:ansible/ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install ansible
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь у нас должна быть установлена ansible на нашем узле управления, вы можете проверить это, запустив &lt;code>ansible --version&lt;/code>, и вы должны увидеть что-то похожее на это ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Прежде чем мы перейдем к управлению другими узлами в нашей среде, мы также можем проверить функциональность ansible, выполнив команду на нашей локальной машине &lt;code>ansible localhost -m ping&lt;/code> будет использовать &lt;a href="https://docs.ansible.com/ansible/2.9/user_guide/modules_intro.html">Ansible Module&lt;/a>, и это быстрый способ выполнить одну задачу на многих различных системах. Я имею в виду, что это не очень весело только с локальным хостом, но представьте, что вы хотите получить что-то или убедиться, что все ваши системы работают, а у вас 1000+ серверов и устройств.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Или реальное использование модуля в реальной жизни может быть чем-то вроде &lt;code>ansible webservers --m service -a &amp;quot;name=httpd state=started&amp;quot;&lt;/code>, это скажет нам, запущена ли служба httpd на всех наших веб-серверах. Я привел термин webservers, используемый в этой команде.&lt;/p>
&lt;h3 id="hosts">hosts&lt;/h3>
&lt;p>Как я использовал localhost выше для запуска простого модуля ping против системы, я не могу указать другую машину в моей сети, например, в среде, которую я использую, мой хост Windows, на котором работает VirtualBox, имеет сетевой адаптер с IP 10.0.0.1, но вы можете видеть ниже, что я могу связаться с ним с помощью ping, но я не могу использовать ansible для выполнения этой задачи.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Для того чтобы указать наши узлы или узлы, которые мы хотим автоматизировать с помощью этих задач, нам необходимо их определить. Мы можем определить их, перейдя в каталог /etc/ansible в вашей системе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Файл, который мы хотим отредактировать - это файл hosts, используя текстовый редактор, мы можем зайти в него и определить наши хосты. Файл hosts содержит множество отличных инструкций по использованию и изменению файла. Мы хотим прокрутить вниз и создать новую группу под названием [windows] и добавить наш IP-адрес &lt;code>10.0.0.1&lt;/code> для этого хоста. Сохраните файл.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Однако помните, я говорил, что вам понадобится SSH, чтобы Ansible мог подключиться к вашей системе. Как вы можете видеть ниже, когда я запускаю &lt;code>ansible windows -m ping&lt;/code>, мы получаем недостижимый результат, потому что не удалось подключиться через SSH.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь я также начал добавлять дополнительные хосты в наш инвентарь, другое название для этого файла, так как здесь вы собираетесь определить все ваши устройства, это могут быть сетевые устройства, например, коммутаторы и маршрутизаторы, которые также будут добавлены сюда и сгруппированы. В нашем файле hosts я также добавил свои учетные данные для доступа к группе систем linux.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, если мы запустим &lt;code>ansible linux -m ping&lt;/code>, мы получим успех, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day64_config8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее у нас есть требования к узлам, это целевые системы, на которых вы хотите автоматизировать конфигурацию. Мы не устанавливаем на них ничего для Ansible (то есть, мы можем установить программное обеспечение, но нам не нужен клиент Ansible). Ansible будет устанавливать соединение по SSH и отправлять все по SFTP (если вы хотите и у вас настроен SSH, вы можете использовать SCP против SFTP).&lt;/p>
&lt;h3 id="команды-ansible">Команды Ansible&lt;/h3>
&lt;p>Вы видели, что мы смогли запустить &lt;code>ansible linux -m ping&lt;/code> на нашей Linux машине и получить ответ, в принципе, с Ansible у нас есть возможность запускать множество специальных команд. Но очевидно, что вы можете запустить это против группы систем и получить эту информацию обратно. &lt;a href="https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html">ad hoc commands&lt;/a>&lt;/p>
&lt;p>Если вы сталкиваетесь с повторением команд или, что еще хуже, вам приходится входить в отдельные системы для выполнения этих команд, то Ansible может помочь в этом случае. Например, простая команда ниже даст нам вывод всех сведений об операционной системе для всех систем, которые мы добавим в нашу группу linux.
&lt;code>ansible linux -a &amp;quot;cat /etc/os-release&amp;quot;&lt;/code>.&lt;/p>
&lt;p>Другими вариантами использования могут быть перезагрузка систем, копирование файлов, управление упаковщиками и пользователями. Вы также можете объединить специальные команды с модулями Ansible.&lt;/p>
&lt;p>Специальные команды используют декларативную модель, рассчитывая и выполняя действия, необходимые для достижения заданного конечного состояния. Они достигают идемпотентности, проверяя текущее состояние перед началом работы и ничего не делая, если текущее состояние не отличается от заданного конечного состояния.&lt;/p>
&lt;h1 id="ресурсы">Ресурсы&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1id6ERvfozo">What is Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=goclfp6a2IQ">Ansible 101 - Episode 1 - Introduction to Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5hycyr-8EKs&amp;amp;t=955s">NetworkChuck - You need to learn Ansible right now!&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>65. Ansible Playbooks - Часть 1</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day65/</link><pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day65/</guid><description>&lt;h3 id="ansible-playbooks">Ansible Playbooks&lt;/h3>
&lt;p>В этом разделе мы рассмотрим основную причину, которую я вижу, по крайней мере, для Ansible. Я имею в виду, что это здорово - взять одну команду и обратиться ко многим различным серверам для выполнения простых команд, таких как перезагрузка длинного списка серверов и избавление от необходимости подключаться к каждому из них по отдельности.&lt;/p>
&lt;p>Но как насчет того, чтобы взять голую операционную систему, объявить программное обеспечение и службы, которые мы хотим запустить на этой системе, и убедиться, что все они работают в нужном состоянии.&lt;/p>
&lt;p>Здесь на помощь приходят учебники Ansible. Плейбук позволяет нам взять группу серверов и выполнить задачи конфигурации и установки для этой группы.&lt;/p>
&lt;h3 id="формат-плейбука">Формат плейбука&lt;/h3>
&lt;p>Плейбук &amp;gt; Игры &amp;gt; Задачи&lt;/p>
&lt;p>Если вы занимаетесь спортом, вы, возможно, сталкивались с термином &amp;ldquo;плейбук&amp;rdquo;. Плейбук рассказывает команде о том, как вы будете играть, состоящий из различных пьес и задач. Если мы считаем пьесы декорациями в спорте или игре, а задачи связаны с каждой пьесой, у вас может быть несколько задач, составляющих пьесу, а в плейбуке может быть несколько различных пьес.&lt;/p>
&lt;p>Эти плейбуки написаны на YAML (YAML - это не язык разметки), вы найдете много разделов, которые мы уже рассмотрели, особенно контейнеры и Kubernetes, в которых используются файлы конфигурации в формате YAML.&lt;/p>
&lt;p>Давайте рассмотрим простой плейбук под названием playbook.yml.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>- name: Simple Play
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hosts: localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connection: local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tasks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Ping me
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ping:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: print os
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> debug:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg: &amp;#34;{{ ansible_os_family }}&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вы найдете вышеуказанный файл &lt;a href="../../Configmgmt/simple_play.yml">simple_play&lt;/a>. Если мы затем используем команду &lt;code>ansible-playbook simple_play.yml&lt;/code>, то пройдем следующие шаги.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы видите, что первая задача &amp;ldquo;сбор шагов&amp;rdquo; произошла, но мы не вызывали или не просили об этом? Этот модуль автоматически вызывается плейбуками для сбора полезных переменных об удаленных хостах. &lt;a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html">ansible.builtin.setup&lt;/a>&lt;/p>
&lt;p>Нашей второй задачей было установить ping, это не ICMP ping, а python скрипт, который сообщает &lt;code>pong&lt;/code> об успешном соединении с удаленным или локальным хостом. &lt;a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ping_module.html">ansible.builtin.ping&lt;/a>&lt;/p>
&lt;p>Затем наша третья или на самом деле вторая определенная задача, так как первая будет выполняться, если вы не отключите печать сообщения, сообщающего нам о нашей ОС. В этой задаче мы используем условия, мы можем запустить этот плейбук на всех различных типах операционных систем, и это вернет нам имя ОС. Мы просто передаем этот вывод для удобства, но мы могли бы добавить задачу, чтобы сказать что-то вроде:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>tasks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: &amp;#34;shut down Debian flavoured systems&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command: /sbin/shutdown -t now
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> when: ansible_os_family == &amp;#34;Debian&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="vagrant-для-настройки-нашего-окружения">Vagrant для настройки нашего окружения&lt;/h3>
&lt;p>Мы будем использовать Vagrant для настройки нашего узлового окружения, я собираюсь оставить разумные 4 узла, но вы, надеюсь, увидите, что их может быть 300 или 3000. В этом и заключается сила Ansible и других инструментов управления конфигурацией, чтобы иметь возможность настраивать ваши серверы.&lt;/p>
&lt;p>Вы можете найти этот файл здесь (&lt;a href="https://romankurnovskii.com/Days/Configmgmt/Vagrantfile">Vagrantfile&lt;/a>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>Vagrant&lt;span style="color:#666">.&lt;/span>configure(&lt;span style="color:#4070a0">&amp;#34;2&amp;#34;&lt;/span>) &lt;span style="color:#007020;font-weight:bold">do&lt;/span> &lt;span style="color:#666">|&lt;/span>config&lt;span style="color:#666">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> servers&lt;span style="color:#666">=&lt;/span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :hostname &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;db01&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :box &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;bento/ubuntu-21.10&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ip &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;192.168.169.130&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ssh_port &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#39;2210&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :hostname &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;web01&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :box &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;bento/ubuntu-21.10&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ip &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;192.168.169.131&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ssh_port &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#39;2211&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :hostname &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;web02&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :box &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;bento/ubuntu-21.10&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ip &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;192.168.169.132&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ssh_port &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#39;2212&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :hostname &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;loadbalancer&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :box &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;bento/ubuntu-21.10&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ip &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#34;192.168.169.134&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> :ssh_port &lt;span style="color:#666">=&amp;gt;&lt;/span> &lt;span style="color:#4070a0">&amp;#39;2213&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>config&lt;span style="color:#666">.&lt;/span>vm&lt;span style="color:#666">.&lt;/span>base_address &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">600&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> servers&lt;span style="color:#666">.&lt;/span>each &lt;span style="color:#007020;font-weight:bold">do&lt;/span> &lt;span style="color:#666">|&lt;/span>machine&lt;span style="color:#666">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config&lt;span style="color:#666">.&lt;/span>vm&lt;span style="color:#666">.&lt;/span>define machine[:hostname] &lt;span style="color:#007020;font-weight:bold">do&lt;/span> &lt;span style="color:#666">|&lt;/span>node&lt;span style="color:#666">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#666">.&lt;/span>vm&lt;span style="color:#666">.&lt;/span>box &lt;span style="color:#666">=&lt;/span> machine[:box]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#666">.&lt;/span>vm&lt;span style="color:#666">.&lt;/span>hostname &lt;span style="color:#666">=&lt;/span> machine[:hostname]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#666">.&lt;/span>vm&lt;span style="color:#666">.&lt;/span>network :public_network, bridge: &lt;span style="color:#4070a0">&amp;#34;Intel(R) Ethernet Connection (7) I219-V&amp;#34;&lt;/span>, ip: machine[:ip]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#666">.&lt;/span>vm&lt;span style="color:#666">.&lt;/span>network &lt;span style="color:#4070a0">&amp;#34;forwarded_port&amp;#34;&lt;/span>, guest: &lt;span style="color:#40a070">22&lt;/span>, host: machine[:ssh_port], id: &lt;span style="color:#4070a0">&amp;#34;ssh&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#666">.&lt;/span>vm&lt;span style="color:#666">.&lt;/span>provider :virtualbox &lt;span style="color:#007020;font-weight:bold">do&lt;/span> &lt;span style="color:#666">|&lt;/span>v&lt;span style="color:#666">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v&lt;span style="color:#666">.&lt;/span>customize [&lt;span style="color:#4070a0">&amp;#34;modifyvm&amp;#34;&lt;/span>, :id, &lt;span style="color:#4070a0">&amp;#34;--memory&amp;#34;&lt;/span>, &lt;span style="color:#40a070">2048&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v&lt;span style="color:#666">.&lt;/span>customize [&lt;span style="color:#4070a0">&amp;#34;modifyvm&amp;#34;&lt;/span>, :id, &lt;span style="color:#4070a0">&amp;#34;--name&amp;#34;&lt;/span>, machine[:hostname]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Используйте команду &lt;code>vagrant up&lt;/code>, чтобы запустить эти машины в VirtualBox, Вы можете добавить больше памяти, а также определить разные частные_сетевые адреса для каждой машины, но это работает в моей среде. Помните, что наш блок управления - это рабочий стол Ubuntu, который мы установили в разделе Linux.&lt;/p>
&lt;p>Если вы ограничены в ресурсах, вы также можете запустить &lt;code>vagrant up web01 web02&lt;/code>, чтобы поднять только веб-серверы, которые мы используем здесь.&lt;/p>
&lt;h3 id="конфигурация-хоста-ansible">Конфигурация хоста Ansible&lt;/h3>
&lt;p>Теперь, когда наша среда готова, мы можем проверить ansible, и для этого мы будем использовать наш рабочий стол Ubuntu (вы можете использовать его, но вы также можете использовать любую машину на базе Linux в вашей сети, доступную для сети ниже) в качестве нашего управления, давайте также добавим новые узлы в нашу группу в файле ansible hosts, Вы можете считать этот файл инвентаризацией, альтернативой этому может быть другой файл инвентаризации, который вызывается как часть вашей команды ansible с &lt;code>-i filename&lt;/code>, это может быть полезно по сравнению с использованием файла host, так как вы можете иметь разные файлы для разных сред, например, production, test и staging. Поскольку мы используем стандартный файл hosts, нам не нужно его указывать, так как он будет использоваться по умолчанию.&lt;/p>
&lt;p>Я добавил следующее в файл hosts по умолчанию.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>[control]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ansible&lt;span style="color:#666">-&lt;/span>control
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[proxy]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>loadbalancer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[webservers]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>web01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>web02
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[database]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db01
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Прежде чем двигаться дальше, мы хотим убедиться, что можем выполнить команду для наших узлов, давайте выполним &lt;code>ansible nodes -m command -a hostname&lt;/code>, эта простая команда проверит, что у нас есть подключение и сообщит имена наших узлов.&lt;/p>
&lt;p>Также обратите внимание, что я добавил эти узлы и IP на мой узел управления Ubuntu в файл /etc/hosts для обеспечения подключения. Нам также может понадобиться выполнить конфигурацию SSH для каждого узла с блока Ubuntu.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">192.168&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">169.140&lt;/span> ansible&lt;span style="color:#666">-&lt;/span>control
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">192.168&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">169.130&lt;/span> db01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">192.168&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">169.131&lt;/span> web01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">192.168&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">169.132&lt;/span> web02
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">192.168&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">169.133&lt;/span> loadbalancer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На этом этапе мы хотим выполнить настройку SSH ключей между узлами управления и сервера. Это то, что мы будем делать дальше, другим способом здесь может быть добавление переменных в ваш файл hosts для указания имени пользователя и пароля. Я бы не советовал этого делать, так как это никогда не будет лучшей практикой.&lt;/p>
&lt;p>Чтобы настроить SSH и общий доступ между узлами, выполните следующие шаги, вам будет предложено ввести пароль (&lt;code>vagrant&lt;/code>), и вам, вероятно, придется нажать &lt;code>y&lt;/code> несколько раз, чтобы согласиться.&lt;/p>
&lt;p>&lt;code>ssh-keygen&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;code>ssh-copy-id localhost&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, если все ваши ВМ включены, вы можете запустить команду &lt;code>ssh-copy-id web01 &amp;amp;&amp;amp; ssh-copy-id web02 &amp;amp;&amp;amp; ssh-copy-id loadbalancer &amp;amp;&amp;amp; ssh-copy-id db01&lt;/code>, которая запросит у вас пароль, в нашем случае пароль &lt;code>vagrant&lt;/code>.&lt;/p>
&lt;p>Я не запускаю все свои виртуальные машины, а запускаю только веб-серверы, поэтому я выдал команду &lt;code>sh-copy-id web01 &amp;amp;&amp;amp; ssh-copy-id web02&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Перед запуском любых плейбуков я хочу убедиться, что у меня есть простое соединение с моими группами, поэтому я запустил &lt;code>ansible webservers -m ping&lt;/code> для проверки соединения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="наш-первый-настоящий-плейбук-ansible">Наш первый &amp;ldquo;настоящий&amp;rdquo; плейбук Ansible&lt;/h3>
&lt;p>Наш первый плейбук Ansible будет настраивать наши веб-серверы, мы сгруппировали их в нашем файле hosts под группировкой [webservers].&lt;/p>
&lt;p>Перед запуском нашего плейбука мы можем убедиться, что на web01 и web02 не установлен apache. В верхней части скриншота ниже показано расположение папок и файлов, которые я создал в моей системе управления ansible для запуска этого плейбука, у нас есть &lt;code>playbook1.yml&lt;/code>, затем в папке templates у нас есть файлы &lt;code>index.html.j2&lt;/code> и &lt;code>ports.conf.j2&lt;/code>. Вы можете найти эти файлы в папке, указанной выше в репозитории.&lt;/p>
&lt;p>Затем мы подключаемся по SSH к web01, чтобы проверить, установлен ли у нас apache?&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Из вышеприведенного видно, что у нас не установлен apache на web01, поэтому мы можем исправить это, запустив следующий плейбук.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: webservers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vars:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http_port: &lt;span style="color:#40a070">8000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https_port: &lt;span style="color:#40a070">4443&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> html_welcome_msg: &lt;span style="color:#4070a0">&amp;#34;Hello 90DaysOfDevOps&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tasks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> name: ensure apache is at the latest version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apt:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> name: write the apache2 ports&lt;span style="color:#666">.&lt;/span>conf config file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> src: templates&lt;span style="color:#666">/&lt;/span>ports&lt;span style="color:#666">.&lt;/span>conf&lt;span style="color:#666">.&lt;/span>j2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dest: &lt;span style="color:#666">/&lt;/span>etc&lt;span style="color:#666">/&lt;/span>apache2&lt;span style="color:#666">/&lt;/span>ports&lt;span style="color:#666">.&lt;/span>conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notify:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> restart apache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> name: write a basic index&lt;span style="color:#666">.&lt;/span>html file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> src: templates&lt;span style="color:#666">/&lt;/span>index&lt;span style="color:#666">.&lt;/span>html&lt;span style="color:#666">.&lt;/span>j2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dest: &lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span>&lt;span style="color:#666">/&lt;/span>www&lt;span style="color:#666">/&lt;/span>html&lt;span style="color:#666">/&lt;/span>index&lt;span style="color:#666">.&lt;/span>html
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notify:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> restart apache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> name: ensure apache is running
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: started
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handlers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> name: restart apache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: restarted
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Разбираем вышеприведенный плейбук:&lt;/p>
&lt;ul>
&lt;li>&lt;code>- hosts: webservers&lt;/code> означает, что наша группа, на которой будет запущен этот плейбук, называется webservers.&lt;/li>
&lt;li>&lt;code>become: yes&lt;/code> означает, что наш пользователь, запускающий плейбук, станет root на наших удаленных системах. Вам будет предложено ввести пароль root.&lt;/li>
&lt;li>Затем у нас есть &lt;code>vars&lt;/code>, и это определяет некоторые переменные окружения, которые мы хотим использовать на наших веб-серверах.&lt;/li>
&lt;/ul>
&lt;p>После этого мы приступаем к выполнению наших задач,&lt;/p>
&lt;ul>
&lt;li>Задача 1 - убедиться, что apache работает на последней версии.&lt;/li>
&lt;li>Задача 2 - написать файл ports.conf из нашего исходного файла, который находится в папке templates.&lt;/li>
&lt;li>Задача 3 - создание базового файла index.html&lt;/li>
&lt;li>Задача 4 - убедиться, что apache запущен.&lt;/li>
&lt;/ul>
&lt;p>Наконец, у нас есть раздел обработчиков, &lt;a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html">Handlers: Running operations on change&lt;/a>&lt;/p>
&lt;p>&amp;ldquo;Иногда вы хотите, чтобы задача выполнялась только тогда, когда на машине происходят изменения. Например, вы можете захотеть перезапустить службу, если задача обновляет конфигурацию этой службы, но не перезапускать ее, если конфигурация не изменилась. Для решения этой задачи в Ansible используются обработчики. Обработчики - это задачи, которые выполняются только при получении уведомления. Каждый обработчик должен иметь глобально уникальное имя&amp;rdquo;.&lt;/p>
&lt;p>На этом этапе вы можете подумать, но мы развернули 5 виртуальных машин (включая нашу машину Ubuntu Desktop, которая действует как наш Ansible Control) Остальные системы будут задействованы в оставшейся части раздела.&lt;/p>
&lt;h3 id="запуск-нашего-плейбука">Запуск нашего плейбука&lt;/h3>
&lt;p>Теперь мы готовы запустить наш учебник на наших узлах. Для запуска нашего плейбука мы можем использовать &lt;code>ansible-playbook playbook1.yml&lt;/code> Мы определили наши узлы, на которых будет работать наш учебник, и это позволит выполнить наши задачи, которые мы определили.&lt;/p>
&lt;p>После завершения команды мы получим результат, показывающий наши пьесы и задачи, это может занять некоторое время, вы можете видеть на изображении ниже, что это заняло некоторое время, чтобы пойти и установить наше желаемое состояние.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем дважды проверить это, зайдя в узел и проверив, что на нашем узле установлено программное обеспечение.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда мы развернули два автономных веб-сервера, мы можем перейти на соответствующие IP, которые мы определили, и получить наш новый веб-сайт.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day65_config11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы будем опираться на это руководство по ходу работы над остальной частью этого раздела. Мне также интересно взять наш рабочий стол Ubuntu и посмотреть, сможем ли мы загрузить наши приложения и конфигурацию с помощью Ansible, поэтому мы также можем коснуться этого. Вы видели, что мы можем использовать локальный хост в наших командах, мы также можем запускать плейбуки, например, на нашем локальном хосте.&lt;/p>
&lt;p>Еще одна вещь, которую следует добавить, заключается в том, что мы работаем только с виртуальными машинами Ubuntu, но Ansible не зависит от целевых систем. Альтернативы, которые мы уже упоминали ранее для управления системами, могут быть сервер за сервером (не масштабируемый, когда вы получаете большое количество серверов, плюс боль даже с 3 узлами), мы также можем использовать скрипты оболочки, которые мы рассматривали в разделе Linux, но эти узлы потенциально разные, так что да, это можно сделать, но тогда кто-то должен поддерживать и управлять этими скриптами. Ansible бесплатна и позволяет легко справиться с этой задачей по сравнению с необходимостью иметь специализированный скрипт.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1id6ERvfozo">What is Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=goclfp6a2IQ">Ansible 101 - Episode 1 - Introduction to Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5hycyr-8EKs&amp;amp;t=955s">NetworkChuck - You need to learn Ansible right now!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLnFWJCugpwfzTlIJ-JtuATD2MBBD7_m3u">Your complete guide to Ansible&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Этот последний плейлист, приведенный выше, является тем местом, откуда было взято много кода и идей для этого раздела, отличным ресурсом и руководством в видеоформате.&lt;/p></description></item><item><title>66. Ansible Playbooks - Часть 2</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day66/</link><pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day66/</guid><description>&lt;h2 id="ansible-playbooks-продолжение">Ansible Playbooks Продолжение&lt;/h2>
&lt;p>В нашем последнем разделе мы начали с создания небольшой лаборатории, используя файл Vagrant для развертывания 4 машин, и мы использовали нашу Linux-машину, которую мы создали в этом разделе, в качестве нашей системы управления Ansible.&lt;/p>
&lt;p>Мы также проверили несколько скриптов плейбуков, и в конце у нас был плейбук, который сделал наши web01 и web02 отдельными веб-серверами.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="наведение-порядка">Наведение порядка&lt;/h3>
&lt;p>Прежде чем перейти к дальнейшей автоматизации и развертыванию, мы должны рассказать о том, как сохранить наш плейбук аккуратным и опрятным и как мы можем разделить наши такты и обработчики по подпапкам.&lt;/p>
&lt;p>В основном мы собираемся копировать наши задачи в их собственный файл в папке.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> name: ensure apache is at the latest version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apt: name&lt;span style="color:#666">=&lt;/span>apache2 state&lt;span style="color:#666">=&lt;/span>latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> name: write the apache2 ports&lt;span style="color:#666">.&lt;/span>conf config file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> src&lt;span style="color:#666">=&lt;/span>templates&lt;span style="color:#666">/&lt;/span>ports&lt;span style="color:#666">.&lt;/span>conf&lt;span style="color:#666">.&lt;/span>j2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dest&lt;span style="color:#666">=/&lt;/span>etc&lt;span style="color:#666">/&lt;/span>apache2&lt;span style="color:#666">/&lt;/span>ports&lt;span style="color:#666">.&lt;/span>conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notify: restart apache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> name: write a basic index&lt;span style="color:#666">.&lt;/span>html file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> src: templates&lt;span style="color:#666">/&lt;/span>index&lt;span style="color:#666">.&lt;/span>html&lt;span style="color:#666">.&lt;/span>j2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dest: &lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span>&lt;span style="color:#666">/&lt;/span>www&lt;span style="color:#666">/&lt;/span>html&lt;span style="color:#666">/&lt;/span>index&lt;span style="color:#666">.&lt;/span>html
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notify:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> restart apache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> name: ensure apache is running
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: started
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>и то же для обработчиков.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>- name: restart apache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: restarted
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Затем в нашем плейбуке, который теперь называется &lt;code>playbook2.yml&lt;/code>, мы указываем на эти файлы. Все эти файлы можно найти по адресу &lt;a href="../../Configmgmt/ansible-scenario2/">ansible-scenario2&lt;/a>.&lt;/p>
&lt;p>Вы можете проверить это на своей контрольной машине. Если вы скопировали файлы из репозитория, вы должны были заметить, что кое-что изменилось в пункте &amp;ldquo;написать основной файл index.html&amp;rdquo;&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Давайте выясним, какое простое изменение я сделал. Использование &lt;code>curl web01:8000&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы только что привели в порядок наш плейбук и начали разделять области, которые могут сделать плейбук очень перегруженным в масштабе.&lt;/p>
&lt;h3 id="роли-и-ansible-galaxy">Роли и Ansible Galaxy&lt;/h3>
&lt;p>На данный момент мы развернули 4 виртуальные машины и настроили 2 из них как веб-серверы, но у нас есть еще несколько специфических функций, а именно: сервер базы данных и балансировщик нагрузки или прокси. Для того чтобы сделать это и привести в порядок наш репозиторий, мы можем использовать роли в Ansible.&lt;/p>
&lt;p>Для этого мы воспользуемся командой &lt;code>ansible-galaxy&lt;/code>, которая предназначена для управления ролями Ansible в общих репозиториях.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы собираемся использовать &lt;code>ansible-galaxy&lt;/code> для создания роли для apache2, где мы собираемся разместить специфику наших веб-серверов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Приведенная выше команда &lt;code>ansible-galaxy init roles/apache2&lt;/code> создаст структуру папок, которую мы показали выше. Следующим шагом нам нужно переместить существующие задачи и шаблоны в соответствующие папки в новой структуре.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Копировать и вставить легко для перемещения этих файлов, но нам также нужно внести изменения в tasks/main.yml, чтобы указать его на apache2_install.yml.&lt;/p>
&lt;p>Нам также нужно изменить наш playbook, чтобы он ссылался на нашу новую роль. В playbook1.yml и playbook2.yml мы определяем наши задачи и обработчики по-разному, так как мы изменили их между двумя версиями. Нам нужно изменить наш плейбук, чтобы использовать эту роль, как показано ниже:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: webservers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vars:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http_port: &lt;span style="color:#40a070">8000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https_port: &lt;span style="color:#40a070">4443&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> html_welcome_msg: &lt;span style="color:#4070a0">&amp;#34;Hello 90DaysOfDevOps - Welcome to Day 66!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> apache2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем запустить наш плейбук снова, на этот раз с новым именем плейбука &lt;code>ansible-playbook playbook3.yml&lt;/code> Вы заметите обесценивание, мы можем исправить это дальше.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хорошо, амортизация хотя наш плейбук запустился, теперь мы должны исправить наши пути, для этого я изменил опцию include в tasks/main.yml на import_tasks, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете найти эти файлы в папке &lt;a href="../Configmgmt/ansible-scenario3">ansible-scenario3&lt;/a>.&lt;/p>
&lt;p>Мы также собираемся создать еще несколько ролей, используя &lt;code>ansible-galaxy&lt;/code>, которые мы собираемся создать:&lt;/p>
&lt;ul>
&lt;li>common = for all of our servers (&lt;code>ansible-galaxy init roles/common&lt;/code>)&lt;/li>
&lt;li>nginx = for our loadbalancer (&lt;code>ansible-galaxy init roles/nginx&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day66_config10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я собираюсь оставить этот вариант здесь, а в следующей сессии мы начнем работать над другими узлами, которые мы развернули, но еще ничего не сделали.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1id6ERvfozo">What is Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=goclfp6a2IQ">Ansible 101 - Episode 1 - Introduction to Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5hycyr-8EKs&amp;amp;t=955s">NetworkChuck - You need to learn Ansible right now!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLnFWJCugpwfzTlIJ-JtuATD2MBBD7_m3u">Your complete guide to Ansible&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Этот последний плейлист, приведенный выше, является тем местом, откуда было взято много кода и идей для этого раздела, отличным ресурсом и руководством в видеоформате.&lt;/p></description></item><item><title>67. Роли и развертывание балансировщика нагрузки</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day67/</link><pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day67/</guid><description>&lt;p>На последнем занятии мы рассмотрели роли и использовали команду &lt;code>ansible-galaxy&lt;/code>, чтобы помочь создать структуру папок для некоторых ролей, которые мы будем использовать. В итоге мы получили гораздо более аккуратное рабочее хранилище для нашего кода конфигурации, поскольку все спрятано в папках ролей.&lt;/p>
&lt;p>Однако мы использовали только роль apache2 и получили рабочий playbook3.yaml для работы с нашими веб-серверами.&lt;/p>
&lt;p>На данном этапе, если вы использовали только &lt;code>vagrant up web01 web02&lt;/code>, пришло время запустить &lt;code>vagrant up loadbalancer&lt;/code>, который откроет другую систему Ubuntu, которую мы будем использовать в качестве балансировщика нагрузки/прокси.&lt;/p>
&lt;p>Мы уже определили эту новую машину в нашем файле hosts, но у нас нет настроенного ssh-ключа, пока он не доступен, поэтому нам нужно также запустить &lt;code>ssh-copy-id loadbalancer&lt;/code>, когда система будет запущена и готова.&lt;/p>
&lt;h3 id="общая-роль">Общая роль&lt;/h3>
&lt;p>В конце вчерашней сессии я создал роль &lt;code>common&lt;/code>, роль common будет использоваться на всех наших серверах, в то время как другие роли специфичны для конкретных случаев использования, сейчас приложения, которые я собираюсь установить в качестве common, не так просты, и я не вижу много причин для этого, но это показывает цель. В структуре папок нашей общей роли перейдите в папку tasks, и у вас появится файл main.yml. В этом yaml нам нужно указать на наш файл install_tools.yml, и мы делаем это, добавляя строку &lt;code>- import_tasks: install_tools.yml&lt;/code>. Раньше это был &lt;code>include&lt;/code>, но он скоро будет устаревшим, поэтому мы используем import_tasks.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>- name: &amp;#34;Install Common packages&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apt: name={{ item }} state=latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with_items:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - neofetch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - figlet
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Затем в нашем плейбуке мы добавляем общую роль для каждого блока хоста.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: webservers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vars:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http_port: &lt;span style="color:#40a070">8000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https_port: &lt;span style="color:#40a070">4443&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> html_welcome_msg: &lt;span style="color:#4070a0">&amp;#34;Hello 90DaysOfDevOps - Welcome to Day 66!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> apache2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="nginx">nginx&lt;/h3>
&lt;p>Следующим этапом будет установка и настройка nginx на нашем виртуальном компьютере loadbalancer. Как и в общей структуре папок, у нас есть nginx, основанный на последнем сеансе.&lt;/p>
&lt;p>Прежде всего, мы добавим блок host в наш playbook. Этот блок будет включать нашу общую роль, а затем нашу новую роль nginx.&lt;/p>
&lt;p>Плейбук можно найти здесь. &lt;a href=".../.../Configmgmt/ansible-scenario4/playbook4.yml">playbook4.yml&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: webservers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vars:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http_port: &lt;span style="color:#40a070">8000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https_port: &lt;span style="color:#40a070">4443&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> html_welcome_msg: &lt;span style="color:#4070a0">&amp;#34;Hello 90DaysOfDevOps - Welcome to Day 66!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: proxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Для того чтобы это что-то значило, мы должны определить наши задачи, которые мы хотим запустить, таким же образом мы изменим main.yml в задачах, чтобы указать на два файла, один для установки и один для конфигурации.&lt;/p>
&lt;p>Есть и другие файлы, которые я изменил в зависимости от желаемого результата, посмотрите в папке &lt;a href="../Configmgmt/ansible-scenario4">ansible-scenario4&lt;/a> все измененные файлы. Вам следует проверить папки tasks, handlers и templates в папке nginx, и вы найдете эти дополнительные изменения и файлы.&lt;/p>
&lt;h3 id="запуск-обновленного-плейбука">Запуск обновленного плейбука&lt;/h3>
&lt;p>Со вчерашнего дня мы добавили роль common, которая теперь будет устанавливать некоторые пакеты в нашей системе, а затем мы также добавили роль nginx, которая включает установку и настройку.&lt;/p>
&lt;p>Давайте запустим наш playbook4.yml, используя &lt;code>ansible-playbook playbook4.yml&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day67_config1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда мы настроили наши веб-серверы и loadbalancer, мы должны иметь возможность перейти по адресу &lt;a href="http://192.168.169.134/">http://192.168.169.134/&lt;/a>, который является IP-адресом нашего loadbalancer.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day67_config2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы следите за развитием событий и у вас нет такого состояния, то это может быть связано с IP-адресами серверов в вашем окружении. Файл находится в &lt;code>templates\mysite.j2&lt;/code> и выглядит примерно так, как показано ниже: Вам необходимо обновить IP-адреса ваших веб-серверов.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">upstream&lt;/span> &lt;span style="color:#4070a0">webservers&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">server&lt;/span> 192.168.169.131:&lt;span style="color:#40a070">8000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">server&lt;/span> 192.168.169.132:&lt;span style="color:#40a070">8000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">server&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">listen&lt;/span> &lt;span style="color:#40a070">80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">location&lt;/span> &lt;span style="color:#4070a0">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">proxy_pass&lt;/span> &lt;span style="color:#4070a0">http://webservers&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Я уверен, что все, что мы установили, в порядке, но давайте воспользуемся специальной командой с помощью ansible, чтобы проверить установку этих общих инструментов.&lt;/p>
&lt;p>&lt;code>ansible loadbalancer -m command -a neofetch&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day67_config3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1id6ERvfozo">What is Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=goclfp6a2IQ">Ansible 101 - Episode 1 - Introduction to Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5hycyr-8EKs&amp;amp;t=955s">NetworkChuck - You need to learn Ansible right now!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLnFWJCugpwfzTlIJ-JtuATD2MBBD7_m3u">Your complete guide to Ansible&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>TЭтот последний плейлист, приведенный выше, является тем местом, откуда было взято много кода и идей для этого раздела, отличным ресурсом и руководством в видеоформате.&lt;/p></description></item><item><title>68. Теги, переменные, инвентаризация и конфигурация сервера базы данных</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day68/</link><pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day68/</guid><description>&lt;h3 id="теги">Теги&lt;/h3>
&lt;p>Поскольку мы оставили наш плейбук во время вчерашней сессии, нам нужно будет запустить все задачи и пьесы в рамках этого плейбука. Это означает, что нам придется запустить веб-серверы и балансировщик нагрузки до конца.&lt;/p>
&lt;p>Однако теги могут позволить нам отделить их друг от друга, если мы захотим. Это может быть эффективным шагом, если в нашей среде есть очень большие и длинные плейбуки.&lt;/p>
&lt;p>В нашем файле плейбука, в данном случае мы используем &lt;a href="Configmgmt/ansible-scenario5/playbook5.yml">ansible-scenario5&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: webservers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vars:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http_port: &lt;span style="color:#40a070">8000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https_port: &lt;span style="color:#40a070">4443&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> html_welcome_msg: &lt;span style="color:#4070a0">&amp;#34;Hello 90DaysOfDevOps - Welcome to Day 66!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags: web
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: proxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags: proxy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Затем мы можем подтвердить это с помощью команды &lt;code>ansible-playbook playbook5.yml --list-tags&lt;/code>, а список тегов будет содержать теги, которые мы определили в нашем плейбуке.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, если мы хотим нацелиться только на прокси, мы можем сделать это, выполнив &lt;code>ansible-playbook playbook5.yml --tags proxy&lt;/code>, и это, как вы можете видеть ниже, запустит плейбук только против прокси.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теги могут быть добавлены и на уровне задач, так что мы можем получить действительно подробную информацию о том, где и что вы хотите, чтобы произошло. Это могут быть теги, ориентированные на приложения, например, мы можем пройтись по задачам и пометить наши задачи на основе установки, настройки или удаления. Еще один очень полезный тег, который вы можете использовать, это&lt;/p>
&lt;p>&lt;code>tag: always&lt;/code>, который гарантирует, что независимо от того, какие -теги вы используете в вашей команде, если что-то помечено значением always, то оно всегда будет запущено при выполнении команды ansible-playbook.&lt;/p>
&lt;p>С помощью тегов мы также можем объединить несколько тегов вместе, и если мы выполним команду &lt;code>ansible-playbook playbook5.yml --tags proxy,web&lt;/code>, то будут запущены все элементы с этими тегами. Очевидно, что в нашем случае это будет означать то же самое, что и запуск самого плейбука, но если бы у нас было несколько других плейбуков, то это имело бы смысл.&lt;/p>
&lt;p>Вы также можете определить более одного тега.&lt;/p>
&lt;h3 id="переменные">Переменные&lt;/h3>
&lt;p>В Ansible существует два основных типа переменных.&lt;/p>
&lt;ul>
&lt;li>Созданная пользователем (User created)&lt;/li>
&lt;li>Факты Ansible (Ansible Facts)&lt;/li>
&lt;/ul>
&lt;h3 id="факты-ansible">Факты Ansible&lt;/h3>
&lt;p>Каждый раз, когда мы запускали наши плейбуки, у нас была задача, которую мы не определяли, называемая &amp;ldquo;Сбор фактов&amp;rdquo;, мы можем использовать эти переменные или факты, чтобы заставить вещи происходить с нашими задачами автоматизации.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы выполним следующую команду &lt;code>ansible proxy -m setup&lt;/code>, то увидим много выходных данных в формате JSON. Однако на вашем терминале будет много информации, чтобы действительно использовать ее, поэтому мы хотим вывести ее в файл, используя команду &lt;code>ansible proxy -m setup &amp;gt;&amp;gt; facts.json&lt;/code>, вы можете увидеть этот файл в этом репозитории, &lt;a href="Configmgmt/ansible-scenario5/facts.json">ansible-scenario5&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если открыть этот файл, то можно увидеть всевозможную информацию для нашей команды. Мы можем получить наши IP-адреса, архитектуру, версию биоса. Много полезной информации, если мы захотим использовать ее в наших плейбуках.&lt;/p>
&lt;p>Идея заключается в том, чтобы потенциально использовать одну из этих переменных в шаблоне nginx mysite.j2, где мы жестко закодировали IP-адреса наших веб-серверов. Вы можете сделать это, создав цикл for в вашем mysite.j2, который будет проходить через группу [webservers], что позволит нам иметь более двух веб-серверов, автоматически и динамически созданных или добавленных в эту конфигурацию балансировщика нагрузки.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#Dynamic Config for server {{ ansible_facts[&amp;#39;nodename&amp;#39;] }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> upstream webservers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#666">%&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> host &lt;span style="color:#007020;font-weight:bold">in&lt;/span> groups[&lt;span style="color:#4070a0">&amp;#39;webservers&amp;#39;&lt;/span>] &lt;span style="color:#666">%&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server {{ hostvars[host][&lt;span style="color:#4070a0">&amp;#39;ansible_facts&amp;#39;&lt;/span>][&lt;span style="color:#4070a0">&amp;#39;nodename&amp;#39;&lt;/span>] }}:&lt;span style="color:#40a070">8000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#666">%&lt;/span> endfor &lt;span style="color:#666">%&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listen &lt;span style="color:#40a070">80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> location &lt;span style="color:#666">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proxy_pass http:&lt;span style="color:#666">//&lt;/span>webservers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Результат вышеописанных действий будет выглядеть так же, как и сейчас, но если мы добавим больше веб-серверов или удалим один, это динамически изменит конфигурацию прокси. Чтобы это работало, необходимо настроить разрешение имен.&lt;/p>
&lt;h3 id="созданные-пользователем">Созданные пользователем&lt;/h3>
&lt;p>Переменные, созданные пользователем, - это то, что мы создали сами. Если вы посмотрите в наш playbook, то увидите, что у нас есть &lt;code>vars:&lt;/code>, а затем список из трех переменных, которые мы используем.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: webservers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vars:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> http_port: &lt;span style="color:#40a070">8000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> https_port: &lt;span style="color:#40a070">4443&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> html_welcome_msg: &lt;span style="color:#4070a0">&amp;#34;Hello 90DaysOfDevOps - Welcome to Day 68!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags: web
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> hosts: proxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">-&lt;/span> nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags: proxy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Однако мы можем очистить наш плейбук от переменных, переместив их в собственный файл. Мы так и сделаем, но перенесем их в папку &lt;a href="Configmgmt/ansible-scenario6">ansible-scenario6&lt;/a>. В корне этой папки мы создадим папку group_vars. Затем мы создадим еще одну папку под названием all (все группы получат эти переменные). В ней мы создадим файл под названием &lt;code>common_variables.yml&lt;/code> и скопируем в него наши переменные из нашего плейбука. Удалим их из плейбука вместе с vars:.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>http_port: 8000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>https_port: 4443
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>html_welcome_msg: &amp;#34;Hello 90DaysOfDevOps - Welcome to Day 68!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Поскольку мы связываем это с глобальной переменной, мы также можем добавить сюда наши серверы NTP и DNS. Переменные устанавливаются из созданной нами структуры папок. Ниже вы можете видеть, как чисто выглядит наш Playbook.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#062873;font-weight:bold">hosts&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>webservers&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#062873;font-weight:bold">become&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#007020;font-weight:bold">yes&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#062873;font-weight:bold">roles&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- common&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- apache2&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#062873;font-weight:bold">tags&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>web&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>- &lt;span style="color:#062873;font-weight:bold">hosts&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>proxy &lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#062873;font-weight:bold">become&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#007020;font-weight:bold">yes&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#062873;font-weight:bold">roles&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- common&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>- nginx&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#062873;font-weight:bold">tags&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>proxy&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Одной из этих переменных был http_port, мы можем использовать его снова в нашем цикле for в файле mysite.j2, как показано ниже:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#Dynamic Config for server {{ ansible_facts[&amp;#39;nodename&amp;#39;] }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> upstream webservers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#666">%&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> host &lt;span style="color:#007020;font-weight:bold">in&lt;/span> groups[&lt;span style="color:#4070a0">&amp;#39;webservers&amp;#39;&lt;/span>] &lt;span style="color:#666">%&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server {{ hostvars[host][&lt;span style="color:#4070a0">&amp;#39;ansible_facts&amp;#39;&lt;/span>][&lt;span style="color:#4070a0">&amp;#39;nodename&amp;#39;&lt;/span>] }}:{{ http_port }};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#666">%&lt;/span> endfor &lt;span style="color:#666">%&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listen &lt;span style="color:#40a070">80&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> location &lt;span style="color:#666">/&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proxy_pass http:&lt;span style="color:#666">//&lt;/span>webservers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Мы также можем определить ansible fact в нашем файле roles/apache2/templates/index.html.j2, чтобы мы могли понять, на каком веб-сервере мы находимся.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#062873;font-weight:bold">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#062873;font-weight:bold">h1&lt;/span>&amp;gt;{{ html_welcome_msg }}! I&amp;#39;m webserver {{ ansible_facts[&amp;#39;nodename&amp;#39;] }} &amp;lt;/&lt;span style="color:#062873;font-weight:bold">h1&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#062873;font-weight:bold">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Результаты выполнения команды &lt;code>ansible-playbook playbook6.yml&lt;/code> с нашими изменениями переменных означают, что когда мы нажимаем на наш loadbalancer, вы можете увидеть, что мы нажимаем на любой из веб-серверов, которые есть в нашей группе.
&lt;p class="md__image">
&lt;img
src="../images/Day68_config5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем добавить папку host_vars и создать web01.yml и иметь определенное сообщение или изменить то, как это выглядит для каждого хоста, если захотим.&lt;/p>
&lt;h3 id="файлы-инвентаризации">Файлы инвентаризации&lt;/h3>
&lt;p>До сих пор мы использовали файл hosts по умолчанию в папке /etc/ansible для определения наших хостов. Однако мы можем иметь разные файлы для разных окружений, например, production и staging. Я не собираюсь создавать больше окружений. Но мы можем создавать свои собственные файлы хостов.&lt;/p>
&lt;p>Мы можем создать несколько файлов для нашего различного количества серверов и узлов. Мы будем вызывать их с помощью &lt;code>ansible-playbook -i dev playbook.yml&lt;/code> Вы также можете определить переменные в файле hosts и затем распечатать их или использовать эти переменные где-нибудь еще в своих плейбуках. Например, в примере и учебном курсе, за которым я слежу ниже, они добавили переменную окружения, созданную в файле host, в шаблон веб-страницы loadbalancer, чтобы показать окружение как часть сообщения веб-страницы.&lt;/p>
&lt;h3 id="развертывание-нашего-сервера-базы-данных">Развертывание нашего сервера базы данных&lt;/h3>
&lt;p>У нас осталась еще одна машина, которую мы еще не включили и не настроили. Мы можем сделать это с помощью команды &lt;code>vagrant up db01&lt;/code> из места, где находится наш Vagrantfile. Когда машина будет запущена и доступна, нам нужно убедиться, что SSH-ключ скопирован с помощью &lt;code>ssh-copy-id db01&lt;/code>, чтобы мы могли получить доступ.&lt;/p>
&lt;p>Мы будем работать из папки &lt;a href="Configmgmt/ansible-scenario7">ansible-scenario7&lt;/a>.&lt;/p>
&lt;p>Затем воспользуемся командой &lt;code>ansible-galaxy init roles/mysql&lt;/code>, чтобы создать новую структуру папок для новой роли под названием &amp;ldquo;mysql&amp;rdquo;.&lt;/p>
&lt;p>В нашем плейбуке мы собираемся добавить новый блок для конфигурации базы данных. В файле /etc/ansible/hosts мы определили нашу группу базы данных. Затем мы указываем нашей группе базы данных роль common и новую роль mysql, которую мы создали в предыдущем шаге. Мы также помечаем нашу группу базы данных тегами database, что означает, как мы обсуждали ранее, что мы можем выбрать запуск только с этими тегами, если захотим.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>- hosts: webservers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - apache2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> web
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- hosts: proxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - nginx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- hosts: database
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> become: yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - common
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tags: database
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь в структуре папок с нашими ролями автоматически создается дерево, в котором нам нужно заполнить следующее:&lt;/p>
&lt;p>Handlers - main.yml&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span># handlers file for roles/mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- name: restart mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: restarted
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tasks - install_mysql.yml, main.yml &amp;amp; setup_mysql.yml&lt;/p>
&lt;p>install_mysql.yml - this task is going to be there to install mysql and ensure that the service is running.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>- name: &amp;#34;Install Common packages&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apt: name={{ item }} state=latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with_items:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - python3-pip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - mysql-client
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - python3-mysqldb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - libmysqlclient-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- name: Ensure mysql-server is installed latest version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apt: name=mysql-server state=latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- name: Installing python module MySQL-python
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pip:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: PyMySQL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- name: Ensure mysql-server is running
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: started
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>main.yml is a pointer file that will suggest that we import_tasks from these files.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span># tasks file for roles/mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- import_tasks: install_mysql.yml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- import_tasks: setup_mysql.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>setup_mysql.yml - This task will create our database and database user.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> name: Create my&lt;span style="color:#666">.&lt;/span>cnf configuration file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template: src&lt;span style="color:#666">=&lt;/span>templates&lt;span style="color:#666">/&lt;/span>my&lt;span style="color:#666">.&lt;/span>cnf&lt;span style="color:#666">.&lt;/span>j2 dest&lt;span style="color:#666">=/&lt;/span>etc&lt;span style="color:#666">/&lt;/span>mysql&lt;span style="color:#666">/&lt;/span>conf&lt;span style="color:#666">.&lt;/span>d&lt;span style="color:#666">/&lt;/span>mysql&lt;span style="color:#666">.&lt;/span>cnf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notify: restart mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> name: Create database user with name &lt;span style="color:#4070a0">&amp;#39;devops&amp;#39;&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> password &lt;span style="color:#4070a0">&amp;#39;DevOps90&amp;#39;&lt;/span> with all database privileges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> community&lt;span style="color:#666">.&lt;/span>mysql&lt;span style="color:#666">.&lt;/span>mysql_user:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> login_unix_socket: &lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span>&lt;span style="color:#666">/&lt;/span>run&lt;span style="color:#666">/&lt;/span>mysqld&lt;span style="color:#666">/&lt;/span>mysqld&lt;span style="color:#666">.&lt;/span>sock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> login_user: &lt;span style="color:#4070a0">&amp;#34;{{ mysql_user_name }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> login_password: &lt;span style="color:#4070a0">&amp;#34;{{ mysql_user_password }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="color:#4070a0">&amp;#34;{{db_user}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> password: &lt;span style="color:#4070a0">&amp;#34;{{db_pass}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> priv: &lt;span style="color:#4070a0">&amp;#39;*.*:ALL&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> host: &lt;span style="color:#4070a0">&amp;#39;%&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: present
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">-&lt;/span> name: Create a new database with name &lt;span style="color:#4070a0">&amp;#39;90daysofdevops&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mysql_db:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> login_user: &lt;span style="color:#4070a0">&amp;#34;{{ mysql_user_name }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> login_password: &lt;span style="color:#4070a0">&amp;#34;{{ mysql_user_password }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="color:#4070a0">&amp;#34;{{ db_name }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: present
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вы можете видеть, что мы используем некоторые переменные для определения некоторых конфигураций, таких как пароли, имена пользователей и базы данных, все это хранится в файле group_vars/all/common_variables.yml.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>http_port: 8000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>https_port: 4443
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>html_welcome_msg: &amp;#34;Hello 90DaysOfDevOps - Welcome to Day 68!&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_user_name: root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_user_password: &amp;#34;vagrant&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db_user: devops
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db_pass: DevOps90
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db_name: 90DaysOfDevOps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>У нас также есть файл my.cnf.j2 в папке templates, который выглядит следующим образом:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>[mysql]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bind-address = 0.0.0.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="запуск-плейбука">Запуск плейбука&lt;/h3>
&lt;p>Теперь наша виртуальная машина запущена и работает, и у нас есть наши конфигурационные файлы на месте, теперь мы готовы запустить наш плейбук, который будет включать все, что мы сделали раньше, если мы запустим следующий &lt;code>ansible-playbook playbook7.yml&lt;/code> или мы можем выбрать просто развертывание на нашу группу баз данных с помощью команды &lt;code>ansible-playbook playbook7.yml --tags database&lt;/code>, которая просто запустит наши новые конфигурационные файлы.&lt;/p>
&lt;p>Я запустил только тег database, но наткнулся на ошибку. Эта ошибка говорит мне, что у нас не установлен pip3 (Python). Мы можем исправить это, добавив это в наши общие задачи и установив&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы исправили вышеуказанное и запустили плейбук снова, и у нас получилось успешное изменение.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы должны убедиться, что на нашем новом настроенном сервере db01 все так, как мы хотим. Мы можем сделать это с нашего узла управления с помощью команды &lt;code>ssh db01&lt;/code>.&lt;/p>
&lt;p>Для подключения к MySQL я использовал команду &lt;code>sudo /usr/bin/mysql -u root -p&lt;/code> и указал пароль vagrant для root.&lt;/p>
&lt;p>Когда мы подключились, давайте сначала убедимся, что у нас создан пользователь devops. &lt;code>select user, host from mysql.user;&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем выполнить команду &lt;code>SHOW DATABASES;&lt;/code>, чтобы увидеть нашу новую базу данных, которая также была создана.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day68_config9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На самом деле я использовал root для подключения, но теперь мы можем войти в систему под учетной записью devops, используя команду &lt;code>sudo /usr/bin/mysql -u devops -p&lt;/code>, но пароль здесь будет DevOps90.&lt;/p>
&lt;p>Я обнаружил, что в нашем &lt;code>setup_mysql.yml&lt;/code> мне пришлось добавить строку &lt;code>login_unix_socket: /var/run/mysqld/mysqld.sock&lt;/code> для успешного подключения к моему экземпляру db01 mysql, и теперь каждый раз, когда я запускаю это, он сообщает об изменении при создании пользователя, любые предложения будут очень признательны.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1id6ERvfozo">What is Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=goclfp6a2IQ">Ansible 101 - Episode 1 - Introduction to Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5hycyr-8EKs&amp;amp;t=955s">NetworkChuck - You need to learn Ansible right now!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLnFWJCugpwfzTlIJ-JtuATD2MBBD7_m3u">Your complete guide to Ansible&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Этот последний плейлист, приведенный выше, является тем местом, откуда было взято много кода и идей для этого раздела, отличным ресурсом и руководством в видеоформате.&lt;/p></description></item><item><title>69. Ansible - контроллер автоматизации (Tower), AWX, Vault</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day69/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day69/</guid><description>&lt;p>Завершая раздел об управлении конфигурацией, я хотел бы рассмотреть другие области, с которыми вы можете столкнуться при работе с Ansible.&lt;/p>
&lt;p>Существует множество продуктов, составляющих платформу Ansible Automation.&lt;/p>
&lt;p>Red Hat Ansible Automation Platform - это основа для создания и эксплуатации автоматизации в организации. Платформа включает в себя все инструменты, необходимые для внедрения автоматизации в масштабах предприятия.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я постараюсь осветить некоторые из них в этом посте. Но для получения более подробной информации на официальном сайте Red Hat Ansible есть много другой информации. &lt;a href="https://www.ansible.com/?hsLang=en-us">Ansible.com&lt;/a>&lt;/p>
&lt;h3 id="ansible-automation-controller--awx">Ansible Automation Controller | AWX&lt;/h3>
&lt;p>Я объединил эти два продукта вместе, потому что Automation Controller и AWX очень похожи в том, что они предлагают.&lt;/p>
&lt;p>Проект AWX или сокращенно AWX - это проект сообщества с открытым исходным кодом, спонсируемый Red Hat, который позволяет вам лучше контролировать ваши проекты Ansible в ваших средах. AWX - это основной проект, из которого взят компонент контроллера автоматизации.&lt;/p>
&lt;p>Если вы ищете корпоративное решение, то вам нужен контроллер автоматизации, или вы могли слышать его как Ansible Tower. Контроллер автоматизации Ansible - это плоскость управления для платформы автоматизации Ansible.&lt;/p>
&lt;p>И AWX, и контроллер автоматизации обладают следующими характеристиками, превосходящими все, что мы рассмотрели в этом разделе до сих пор.&lt;/p>
&lt;ul>
&lt;li>Пользовательский интерфейс&lt;/li>
&lt;li>Управление доступом на основе ролей&lt;/li>
&lt;li>Рабочие процессы&lt;/li>
&lt;li>Интеграция CI/CD&lt;/li>
&lt;/ul>
&lt;p>Automation Controller - это корпоративное предложение, в котором вы платите за поддержку.&lt;/p>
&lt;p>Мы рассмотрим развертывание AWX в нашей среде minikube Kubernetes.&lt;/p>
&lt;h3 id="развертывание-ansible-awx">Развертывание Ansible AWX&lt;/h3>
&lt;p>AWX не нужно развертывать в кластере Kubernetes, &lt;a href="https://github.com/ansible/awx">github&lt;/a> для AWX от ansible даст вам эту подробную информацию. Однако, начиная с версии 18.0, AWX Operator является предпочтительным способом установки AWX.&lt;/p>
&lt;p>Прежде всего, нам нужен кластер minikube. Мы можем сделать это, если вы следили за разделом Kubernetes, создав новый кластер minikube с помощью команды &lt;code>minikube start --cpus=4 --memory=6g --addons=ingress&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Официальный &lt;a href="https://github.com/ansible/awx-operator">Ansible AWX Operator&lt;/a> можно найти здесь. Как указано в инструкции по установке, вы должны клонировать этот репозиторий, а затем выполнить развертывание.&lt;/p>
&lt;p>Я сделал форк вышеуказанного репозитория, а затем выполнил команду &lt;code>git clone https://github.com/MichaelCade/awx-operator.git&lt;/code>. Я советую вам сделать то же самое и не использовать мой репозиторий, так как я могу что-то изменить или его там может не быть.&lt;/p>
&lt;p>В клонированном репозитории вы найдете файл awx-demo.yml, в котором нам нужно изменить &lt;code>NodePort&lt;/code> на &lt;code>ClusterIP&lt;/code>, как показано ниже:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apiVersion: awx.ansible.com/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: AWX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: awx-demo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service_type: ClusterIP
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Следующим шагом будет определение нашего пространства имен, в котором мы будем развертывать оператор awx, используя команду &lt;code>export NAMESPACE=awx&lt;/code>, а затем команду &lt;code>make deploy&lt;/code>, мы начнем развертывание.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>При проверке у нас есть наше новое пространство имен, и у нас есть наш awx-operator-controller pod, запущенный в нашем пространстве имен. &lt;code>kubectl get pods -n awx&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В клонированном репозитории вы найдете файл awx-demo.yml. Теперь мы хотим развернуть его в нашем кластере Kubernetes и нашем пространстве имен awx. &lt;code>kubectl create -f awx-demo.yml -n awx&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете следить за прогрессом с помощью &lt;code>kubectl get pods -n awx -w&lt;/code>, который будет визуально следить за происходящим.&lt;/p>
&lt;p>У вас должно получиться что-то похожее на изображение, которое вы видите ниже, когда все работает.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы должны иметь доступ к нашей awx установке после запуска в новом терминале &lt;code>minikube service awx-demo-service --url -n $NAMESPACE&lt;/code>, чтобы открыть ее через minikube ingress.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы откроем браузер по этому адресу [], вы увидите, что нам будет предложено ввести имя пользователя и пароль.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>По умолчанию имя пользователя - admin, чтобы получить пароль, мы можем выполнить следующую команду &lt;code>kubectl get secret awx-demo-admin-password -o jsonpath=&amp;quot;{.data.password}&amp;quot; -n awx| base64 --decode&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Очевидно, что это дает вам пользовательский интерфейс для централизованного управления плейбуком и задачами управления конфигурацией, а также позволяет вам работать вместе, в отличие от того, что мы делали до сих пор, когда мы работали с одной станции управления ansible.&lt;/p>
&lt;p>Это еще одна из тех областей, где вы, вероятно, могли бы провести еще много времени, изучая возможности этого инструмента.&lt;/p>
&lt;p>Я приведу отличный ресурс от Джеффа Гирлинга, который более подробно рассказывает об использовании Ansible AWX. &lt;a href="https://www.youtube.com/watch?v=iKmY4jEiy_A&amp;amp;t=752s">Ansible 101 - Episode 10 - Ansible Tower and AWX&lt;/a>&lt;/p>
&lt;p>В этом видео он также подробно рассказывает о различиях между Automation Controller (ранее Ansible Tower) и Ansible AWX (Free and Open Source).&lt;/p>
&lt;h3 id="ansible-vault">Ansible Vault&lt;/h3>
&lt;p>&lt;code>ansible-vault&lt;/code> позволяет нам шифровать и расшифровывать файлы данных Ansible. На протяжении всего этого раздела мы пропустили и поместили часть нашей конфиденциальной информации в открытый текст.&lt;/p>
&lt;p>Встроенный в двоичный файл Ansible &lt;code>ansible-vault&lt;/code> позволяет нам скрыть эту конфиденциальную информацию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day69_config10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Управление секретами постепенно становится еще одной областью, которой следовало бы уделить больше времени наряду с такими инструментами, как HashiCorp Vault или AWS Key Management Service. Я отмечу эту область как ту, в которую следует погрузиться глубже.&lt;/p>
&lt;p>Я собираюсь дать ссылку на отличный ресурс и демонстрационный пример от Jeff Geerling &lt;a href="https://www.youtube.com/watch?v=JFweg2dUvqM">Ansible 101 - Episode 6 - Ansible Vault and Roles&lt;/a>&lt;/p>
&lt;h3 id="ansible-galaxy-docs">Ansible Galaxy (Docs)&lt;/h3>
&lt;p>Итак, мы уже использовали &lt;code>ansible-galaxy&lt;/code> для создания некоторых ролей и файловой структуры для нашего демо-проекта. Но у нас также есть &lt;a href="https://galaxy.ansible.com/docs/">документация по Ansible Galaxy&lt;/a>&lt;/p>
&lt;p>&amp;ldquo;Galaxy - это центр для поиска и обмена содержимым Ansible&amp;rdquo;.&lt;/p>
&lt;h3 id="тестирование-ansible">Тестирование Ansible&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://molecule.readthedocs.io/en/latest/">Ansible Molecule&lt;/a> - проект Molecule предназначен для помощи в разработке и тестировании ролей Ansible.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://ansible-lint.readthedocs.io/en/latest/">Ansible Lint&lt;/a> - CLI-инструмент для линтинга плейбуков, ролей и коллекций.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="другой-ресурс">Другой ресурс&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.ansible.com/ansible/latest/index.html">Документация Ansible&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=1id6ERvfozo">What is Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=goclfp6a2IQ">Ansible 101 - Episode 1 - Introduction to Ansible&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5hycyr-8EKs&amp;amp;t=955s">NetworkChuck - You need to learn Ansible right now!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLnFWJCugpwfzTlIJ-JtuATD2MBBD7_m3u">Your complete guide to Ansible&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Этот последний плейлист, приведенный выше, является тем местом, откуда было взято много кода и идей для этого раздела, отличным ресурсом и руководством в видеоформате.
В этом посте мы завершаем рассмотрение управления конфигурацией, далее мы перейдем к CI/CD Pipelines и некоторым инструментам и процессам, которые мы можем увидеть и использовать для достижения этого рабочего процесса при разработке и выпуске приложений.&lt;/p></description></item><item><title>70. Конвейеры CI/CD</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day70/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day70/</guid><description>&lt;p>Реализация конвейера CI/CD (Continous Integration/Continous Deployment) является основой современной среды DevOps.&lt;/p>
&lt;p>Он устраняет разрыв между разработкой и операциями, автоматизируя сборку, тестирование и развертывание приложений.&lt;/p>
&lt;p>Мы много говорили об этой мантре Continous во вступительном разделе задачи. Но повторим еще раз:&lt;/p>
&lt;p>Continous Integration (CI) - это более современная практика разработки программного обеспечения, при которой инкрементные изменения кода вносятся чаще и надежнее. Автоматизированные шаги рабочего процесса сборки и тестирования, запускаемые Contininous Integration, обеспечивают надежность изменений кода, сливаемых в репозиторий.&lt;/p>
&lt;p>Затем этот код / приложение быстро и беспрепятственно доставляется в рамках процесса непрерывного развертывания.&lt;/p>
&lt;h3 id="важность-cicd">Важность CI/CD?&lt;/h3>
&lt;ul>
&lt;li>Доставка программного обеспечения быстро и эффективно&lt;/li>
&lt;li>Облегчает эффективный процесс вывода приложений на рынок как можно быстрее.&lt;/li>
&lt;li>Непрерывный поток исправлений ошибок и новых функций без ожидания месяцев или лет выпуска версии.&lt;/li>
&lt;/ul>
&lt;p>Возможность для разработчиков регулярно вносить небольшие важные изменения означает, что мы быстрее получаем исправления и новые функции.&lt;/p>
&lt;h3 id="хорошо-так-что-же-это-значит">Хорошо, так что же это значит?&lt;/h3>
&lt;p>В &lt;a href="../day5">День 5&lt;/a> мы рассмотрели много теории, лежащей в основе DevOps, и, как уже упоминалось здесь, CI/CD Pipeline является основой современной среды DevOps.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day5_DevOps8.ru.png?v1"
id="zoom-default"
alt="DevOps"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я хочу повторить некоторые ключевые моменты на этом изображении выше, теперь, когда мы немного продвинулись в изучении основ DevOps.&lt;/p>
&lt;p>Мы имеем в виду жизненный цикл разработки программного обеспечения (SDLC).&lt;/p>
&lt;p>Этапы обычно записываются в бесконечном цикле, поскольку этот цикл повторяется вечно.&lt;br>
The steps in the cycle are, developers write the &lt;strong>code&lt;/strong> then it gets &lt;strong>built&lt;/strong> or all compiled together then it&amp;rsquo;s &lt;strong>tested&lt;/strong> for bugs then it&amp;rsquo;s &lt;strong>deployed&lt;/strong> into production where it&amp;rsquo;s used (&lt;strong>Operated&lt;/strong>) by end users or customers then we &lt;strong>monitor&lt;/strong> and collect feedback and finally we &lt;strong>plan&lt;/strong> improvements around that feedback &lt;strong>rinse and repeat&lt;/strong>.&lt;/p>
&lt;h3 id="давайте-немного-углубимся-в-cicd">Давайте немного углубимся в CI/CD&lt;/h3>
&lt;h3 id="ci">CI&lt;/h3>
&lt;p>CI - это практика разработки, которая требует от разработчиков интегрировать код в общий репозиторий несколько раз в день.&lt;/p>
&lt;p>Когда код написан и помещен в репозиторий, такой как github или gitlab, вот тут-то и начинается волшебство.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day70_CICD1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Код проверяется автоматизированной сборкой, что позволяет командам или владельцу проекта обнаружить любые проблемы на ранней стадии.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day70_CICD2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После этого код анализируется и подвергается серии автоматизированных тестов.&lt;/p>
&lt;ul>
&lt;li>Юнит-тестирование - тестирование отдельных частей исходного кода.&lt;/li>
&lt;li>тестирование на валидность - проверяется, что программное обеспечение удовлетворяет или соответствует предполагаемому использованию.&lt;/li>
&lt;li>Тестирование формата проверяет синтаксис и другие ошибки форматирования.&lt;/li>
&lt;/ul>
&lt;p>Эти тесты создаются как рабочий процесс и затем запускаются каждый раз, когда вы продвигаете мастер-ветку, поэтому практически каждая крупная команда разработчиков имеет какой-то рабочий процесс CI/CD, и помните, что в команде разработчиков новый код может поступать из команд по всему миру в разное время суток от разработчиков, работающих над самыми разными проектами, поэтому эффективнее построить автоматизированный рабочий процесс тестов, которые убеждаются, что все находятся на одной странице, прежде чем код будет принят. Человеку потребуется гораздо больше времени, чтобы сделать это каждый раз.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day70_CICD3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как только мы завершили наши тесты и они прошли успешно, мы можем скомпилировать их и отправить в наш репозиторий. Для примера я использую Docker Hub, но это может быть любое другое хранилище, которое затем будет использовано для CD-аспекта конвейера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day70_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Итак, этот процесс, очевидно, очень похож на процесс разработки программного обеспечения: мы создаем наше приложение, добавляем, исправляем ошибки и т.д., затем обновляем контроль исходных текстов и версионируем их, одновременно тестируя.&lt;/p>
&lt;p>Переходим к следующему этапу - элементу CD, который на самом деле все больше и больше является тем, что мы обычно видим от любого готового программного обеспечения, я бы утверждал, что мы увидим тенденцию, что если мы получим наше программное обеспечение от такого поставщика, как Oracle или Microsoft, мы будем потреблять его из репозитория типа Docker Hub, а затем мы будем использовать наши конвейеры CD для развертывания этого в наших средах.&lt;/p>
&lt;h3 id="cd">CD&lt;/h3>
&lt;p>Теперь у нас есть протестированная версия нашего кода, и мы готовы к развертыванию на природе. Как я уже сказал, поставщик программного обеспечения пройдет через этот этап, но я твердо уверен, что именно так мы все будем развертывать готовое программное обеспечение, которое нам понадобится в будущем.&lt;/p>
&lt;p>Теперь пришло время выпустить наш код в среду. Это будет включать в себя производственную среду, но также, вероятно, и другие среды, такие как staging.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day70_CICD5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Следующим шагом, по крайней мере, в день 1 v1 развертывания программного обеспечения, является то, что нам нужно убедиться, что мы переносим правильную кодовую базу в правильную среду. Это может быть извлечение элементов из репозитория программного обеспечения (DockerHub), но более чем вероятно, что мы также извлечем дополнительную конфигурацию из другого репозитория кода, например, конфигурацию для приложения. На диаграмме ниже мы извлекаем последний релиз программного обеспечения из DockerHub, а затем выпускаем его в нашу среду, при этом, возможно, получая конфигурацию из репозитория Git. Наш CD-инструмент выполняет это и передает все в нашу среду.&lt;/p>
&lt;p>Скорее всего, это делается не одновременно, т.е. мы переходим в промежуточную среду и запускаем ее с нашей собственной конфигурацией, чтобы убедиться, что все правильно, и это может быть ручным шагом для тестирования или автоматизированным (давайте остановимся на автоматизированном), прежде чем позволить этому коду быть развернутым в продакшн.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day70_CICD6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После этого, когда выйдет v2 приложения, мы прополощем и повторим шаги, на этот раз мы убедимся, что наше приложение + конфигурация развернуты в staging, убедимся, что все хорошо, и затем развернем в production.&lt;/p>
&lt;h3 id="зачем-использовать-cicd">Зачем использовать CI/CD?&lt;/h3>
&lt;p>Я думаю, мы уже неоднократно рассказывали о преимуществах, но они заключаются в том, что CI/CD автоматизирует то, что в противном случае пришлось бы делать вручную. Он находит небольшие проблемы до того, как они проникнут в основную кодовую базу. Вы, вероятно, можете себе представить, что если вы выкладываете плохой код своим клиентам, то у вас будут плохие времена!&lt;/p>
&lt;p>Это также помогает предотвратить то, что мы называем техническим долгом - идею о том, что поскольку основные репозитории кода постоянно дорабатываются с течением времени, то быстрое исправление, сделанное в первый день, становится экспоненциально более дорогим исправлением годы спустя, потому что теперь этот пластырь исправления будет так глубоко переплетен и вплетен во все кодовые базы и логику.&lt;/p>
&lt;h3 id="инструментарий">Инструментарий&lt;/h3>
&lt;p>Как и в других разделах, мы будем работать с некоторыми инструментами, которые обеспечивают процесс конвейера CI/CD.&lt;/p>
&lt;p>Я считаю важным отметить, что не все инструменты должны делать и CI, и CD. Мы рассмотрим ArgoCD, который, как вы догадались, отлично справляется с CD-элементом развертывания нашего программного обеспечения в кластере Kubernetes. Но что-то вроде Jenkins может работать на разных платформах.&lt;/p>
&lt;p>Я планирую рассмотреть следующее:&lt;/p>
&lt;ul>
&lt;li>Jenkins&lt;/li>
&lt;li>ArgoCD&lt;/li>
&lt;li>GitHub Actions&lt;/li>
&lt;/ul>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://youtu.be/_MXtbjwsz3A">Jenkins is the way to build, test, deploy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/">Jenkins.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">ArgoCD Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=LFDrDnKPOTg">What is Jenkins?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=nCKxl7Q_20I&amp;amp;t=3s">Complete Jenkins Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=R8_veQiYBjI">GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=mFFXuXjVgkU">GitHub Actions CI/CD&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>71. Введение в Jenkins</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day71/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day71/</guid><description>&lt;blockquote>
&lt;p>Jenkins - это инструмент непрерывной интеграции, который позволяет непрерывно разрабатывать, тестировать и развертывать вновь созданный код.&lt;/p>&lt;/blockquote>
&lt;p>Этого можно достичь двумя способами: ночные сборки или непрерывная разработка. Первый вариант заключается в том, что наши разработчики в течение дня занимаются своими задачами и в конце рабочего дня вносят свои изменения в репозиторий исходного кода. Затем в течение ночи мы проводим модульные тесты и собираем программное обеспечение. Это можно считать старым способом интеграции всего кода.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day71_CICD1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Другой вариант и более предпочтительный способ заключается в том, что наши разработчики по-прежнему фиксируют свои изменения в исходном коде, а затем, после фиксации кода, непрерывно запускается процесс сборки.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day71_CICD2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Приведенные выше методы означают, что при распределении разработчиков по всему миру у нас нет определенного времени каждый день, когда мы должны прекратить фиксацию изменений в коде. Именно здесь на помощь приходит Jenkins, который выступает в роли CI-сервера, контролирующего тесты и процессы сборки.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day71_CICD3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я знаю, что мы говорим о Jenkins, но я также хочу добавить еще несколько, которые можно будет рассмотреть позже, чтобы понять, почему я вижу Jenkins как наиболее популярный, почему это так и что другие могут сделать по сравнению с Jenkins.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>TravisCI - Размещенный, распределенный сервис непрерывной интеграции, используемый для сборки и тестирования программных проектов, размещенных на GitHub.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Bamboo - может запускать несколько сборок параллельно для более быстрой компиляции, имеет встроенную функциональность для связи с репозиториями и задачи сборки для Ant, Maven.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Buildbot - это фреймворк с открытым исходным кодом для автоматизации процессов сборки, тестирования и выпуска программного обеспечения. Он написан на языке Python и поддерживает распределенное, параллельное выполнение заданий на нескольких платформах.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Apache Gump - специфичен для Java-проектов, разработан с целью сборки и тестирования этих Java-проектов каждую ночь. обеспечивает совместимость всех проектов как на уровне API, так и на уровне функциональности.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Поскольку мы сейчас сосредоточимся на Jenkins - Jenkins, как и все вышеперечисленные инструменты, имеет открытый исходный код и представляет собой сервер автоматизации, написанный на Java. Он используется для автоматизации процесса разработки программного обеспечения посредством непрерывной интеграции и облегчает непрерывную доставку.&lt;/p>
&lt;h3 id="особенности-jenkins">Особенности Jenkins&lt;/h3>
&lt;p>Как и следовало ожидать, Jenkins имеет множество функций, охватывающих множество областей.&lt;/p>
&lt;p>&lt;strong>Простая установка&lt;/strong> - Jenkins - это самостоятельная программа на базе java, готовая к работе с пакетами для операционных систем Windows, macOS и Linux.&lt;/p>
&lt;p>&lt;strong>Простая конфигурация&lt;/strong> - Простая установка и настройка через веб-интерфейс, включающий проверку ошибок и встроенную помощь.&lt;/p>
&lt;p>&lt;strong>Плагины&lt;/strong> - Множество плагинов доступно в Центре обновления и интегрируется со многими инструментами в инструментальной цепочке CI / CD.&lt;/p>
&lt;p>&lt;strong>Расширяемость&lt;/strong> - В дополнение к доступным плагинам, Jenkins может быть расширен за счет архитектуры плагинов, что обеспечивает практически бесконечное количество вариантов того, для чего он может быть использован.&lt;/p>
&lt;p>&lt;strong>Распределенность&lt;/strong> - Jenkins легко распределяет работу по нескольким машинам, помогая ускорить сборку, тестирование и развертывание на различных платформах.&lt;/p>
&lt;h3 id="jenkins-pipeline">Jenkins Pipeline&lt;/h3>
&lt;p>Вы уже видели этот конвейер, но он используется гораздо шире, и мы не говорили о конкретных инструментах.&lt;/p>
&lt;p>Вы собираетесь фиксировать код в Jenkins, который затем будет собирать ваше приложение со всеми автоматизированными тестами, а затем выпускать и развертывать этот код после завершения каждого этапа. Jenkins позволяет автоматизировать этот процесс.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day71_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="архитектура-jenkins">Архитектура Jenkins&lt;/h3>
&lt;p>Во-первых, чтобы не изобретать велосипед, всегда стоит начать с &lt;a href="https://www.jenkins.io/doc/developer/architecture/">Документации Jenkins&lt;/a>, но я собираюсь изложить свои заметки и выводы и здесь.&lt;/p>
&lt;p>Jenkins может быть установлен на многих различных операционных системах, Windows, Linux и macOS, а также имеет возможность развертывания в виде контейнера Docker и в Kubernetes. &lt;a href="https://www.jenkins.io/doc/book/installing/">Установка Jenkins&lt;/a>&lt;/p>
&lt;p>По мере изучения этого вопроса мы, вероятно, рассмотрим установку Jenkins в кластере minikube, имитируя развертывание в Kubernetes. Но это будет зависеть от скриптов, которые мы составим в оставшейся части раздела.&lt;/p>
&lt;p>Теперь давайте разберем изображение ниже.&lt;/p>
&lt;p>Шаг 1 - Разработчики фиксируют изменения в репозитории исходного кода.&lt;/p>
&lt;p>Шаг 2 - Jenkins проверяет репозиторий через регулярные промежутки времени и извлекает любой новый код.&lt;/p>
&lt;p>Шаг 3 - Сервер сборки затем собирает код в исполняемый файл, в данном примере мы используем maven как хорошо известный сервер сборки. Еще одна область, которую необходимо охватить.&lt;/p>
&lt;p>Шаг 4 - Если сборка не удалась, то разработчикам отправляется обратная связь.&lt;/p>
&lt;p>Шаг 5 - Jenkins развертывает собранное приложение на тестовом сервере, в данном примере мы используем selenium как хорошо известный тестовый сервер. Еще одна область, которую необходимо охватить.&lt;/p>
&lt;p>Шаг 6 - Если тест не прошел, то обратная связь передается разработчикам.&lt;/p>
&lt;p>Шаг 7 - Если тесты прошли успешно, мы можем выпустить продукт в производство.&lt;/p>
&lt;p>Этот цикл непрерывен, именно это позволяет обновлять приложения за минуты, а не за часы, дни, месяцы, годы!&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day71_CICD5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Архитектура Jenkins может быть описана гораздо подробнее, если вам это нужно, у них есть возможность работы в режиме master-slave, что позволяет ведущему распределять задачи между подчиненными jenkins.&lt;/p>
&lt;p>Для справки, поскольку Jenkins является открытым исходным кодом, будет много предприятий, которым требуется поддержка, CloudBees - это корпоративная версия Jenkins, которая предоставляет поддержку и, возможно, другие функциональные возможности для платного корпоративного клиента.&lt;/p>
&lt;p>Примером такого клиента является компания Bosch, вы можете ознакомиться с примером Bosch &lt;a href="https://assets.ctfassets.net/vtn4rfaw6n2j/case-study-boschpdf/40a0b23c61992ed3ee414ae0a55b6777/case-study-bosch.pdf">здесь&lt;/a>.&lt;/p>
&lt;p>Я собираюсь найти пошаговый пример приложения, которое мы могли бы использовать, чтобы пройтись по Jenkins, а затем использовать его с другими инструментами.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://youtu.be/_MXtbjwsz3A">Jenkins is the way to build, test, deploy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/">Jenkins.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">ArgoCD Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=LFDrDnKPOTg">What is Jenkins?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=nCKxl7Q_20I&amp;amp;t=3s">Complete Jenkins Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=R8_veQiYBjI">GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=mFFXuXjVgkU">GitHub Actions CI/CD&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>72. Работа с Jenkins</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day72/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day72/</guid><description>&lt;p>Сегодня мы планируем немного поработать с Jenkins и сделать что-то в рамках нашего конвейера CI, рассматривая некоторые примеры кодовых баз, которые мы можем использовать.&lt;/p>
&lt;h3 id="что-такое-конвейер">Что такое конвейер?&lt;/h3>
&lt;p>Прежде чем мы начнем, нам нужно знать, что такое конвейер, когда речь идет о CI, и мы уже рассмотрели это на вчерашнем занятии с помощью следующего изображения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day71_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы хотим взять процессы или шаги, описанные выше, и автоматизировать их, чтобы в итоге получить результат, то есть развернутое приложение, которое мы можем отправить нашим клиентам, конечным пользователям и т.д.&lt;/p>
&lt;p>Этот автоматизированный процесс позволяет нам иметь контроль версий для наших пользователей и клиентов. Каждое изменение, улучшение функций, исправление ошибок и т.д. проходит через этот автоматизированный процесс, подтверждая, что все в порядке, без излишнего ручного вмешательства, чтобы убедиться, что наш код хорош.&lt;/p>
&lt;p>Этот процесс включает в себя создание программного обеспечения надежным и повторяемым способом, а также продвижение созданного программного обеспечения (называемого &amp;ldquo;сборкой&amp;rdquo;) через несколько этапов тестирования и развертывания.&lt;/p>
&lt;p>Конвейер jenkins записывается в текстовый файл Jenkinsfile. Который сам должен быть зафиксирован в репозитории контроля исходного кода. Это также известно как Pipeline as code, мы также можем сравнить это с Infrastructure as code, о которой мы рассказывали несколько недель назад.&lt;/p>
&lt;p>&lt;a href="https://www.jenkins.io/doc/book/pipeline/#ji-toolbar">Jenkins Pipeline Definition&lt;/a>&lt;/p>
&lt;h3 id="развертывание-jenkins">Развертывание Jenkins&lt;/h3>
&lt;p>Я получил некоторое удовольствие от развертывания Jenkins, Вы заметите из &lt;a href="https://www.jenkins.io/doc/book/installing/">документации&lt;/a>, что есть много вариантов того, где вы можете установить Jenkins.&lt;/p>
&lt;p>Учитывая, что у меня под рукой есть minikube, и мы уже использовали его несколько раз, я хотел использовать его и для этой задачи. (Хотя шаги, описанные в &lt;a href="https://www.jenkins.io/doc/book/installing/kubernetes/">Kubernetes Installation&lt;/a>, привели к тому, что я уперся в стену и не смог запустить систему, вы можете сравнить эти два варианта, когда я задокументирую свои шаги здесь.&lt;/p>
&lt;p>Первым шагом будет запуск нашего кластера minikube, мы можем сделать это с помощью команды &lt;code>minikube start&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я добавил папку со всеми конфигурациями и значениями YAML, которые можно найти &lt;a href="../CICD/Jenkins">здесь&lt;/a> Теперь, когда у нас есть наш кластер, мы можем выполнить следующие действия для создания пространства имен jenkins. &lt;code>kubectl create -f jenkins-namespace.yml&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы будем использовать Helm для развертывания jenkins в нашем кластере, о Helm мы рассказывали в разделе Kubernetes. Сначала нам нужно добавить репозиторий jenkinsci в helm &lt;code>helm repo add jenkinsci https://charts.jenkins.io&lt;/code>, затем обновить наши таблицы &lt;code>helm repo update&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Идея Jenkins заключается в том, что он будет сохранять состояние для своих пайплайнов, вы можете запустить вышеупомянутую установку helm без персистентности, но если эти pods будут перезагружены, изменены или модифицированы, то все пайплайны или конфигурации, которые вы создали, будут потеряны. Мы создадим том для персистентности, используя файл jenkins-volume.yml с помощью команды &lt;code>kubectl apply -f jenkins-volume.yml&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нам также нужна учетная запись службы, которую мы можем создать с помощью этого yaml-файла и команды. &lt;code>kubectl apply -f jenkins-sa.yml&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На этом этапе мы готовы к развертыванию с помощью схемы helm, сначала мы определим нашу схему с помощью &lt;code>chart=jenkinsci/jenkins&lt;/code>, а затем развернем с помощью этой команды, где jenkins-values.yml содержит учетные записи персистентности и сервисов, которые мы ранее развернули на нашем кластере. &lt;code>helm install jenkins -n jenkins -f jenkins-values.yml $chart&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
На этом этапе наши капсулы будут извлекать образ, но у капсулы не будет доступа к хранилищу, поэтому никакая конфигурация не может быть начата с точки зрения запуска Jenkins.&lt;/p>
&lt;p>Именно здесь документация не помогла мне понять, что должно произойти. Но мы видим, что у нас нет разрешения на запуск установки jenkins.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для того чтобы исправить вышеописанное или решить проблему, нам нужно убедиться, что мы предоставили доступ или правильное разрешение для того, чтобы наши jenkins pods могли писать в это место, которое мы предложили. Мы можем сделать это, используя &lt;code>minikube ssh&lt;/code>, который введет нас в докер-контейнер minikube, на котором мы работаем, а затем, используя &lt;code>sudo chown -R 1000:1000 /data/jenkins-volume&lt;/code>, мы можем убедиться, что у нас установлены разрешения на наш том данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вышеописанный процесс должен исправить капсулы, однако если это не так, вы можете заставить капсулы обновиться с помощью команды &lt;code>kubectl delete pod jenkins-0 -n jenkins&lt;/code>. На этом этапе у вас должно быть 2/2 запущенных стручка под названием jenkins-0.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь нам нужен наш пароль администратора, и мы можем сделать это с помощью следующей команды. &lt;code>kubectl exec --namespace jenkins -it svc/jenkins -c jenkins -- /bin/cat /run/secrets/chart-admin-password &amp;amp;&amp;amp; echo&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь откройте новый терминал, так как мы собираемся использовать команду &lt;code>port-forward&lt;/code>, чтобы получить доступ с нашей рабочей станции. &lt;code>kubectl --namespace jenkins port-forward svc/jenkins 8080:8080&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы должны быть в состоянии открыть браузер и войти на &lt;a href="http://localhost:8080">http://localhost:8080&lt;/a> и аутентифицироваться с именем пользователя: admin и паролем, которые мы собрали в предыдущем шаге.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После аутентификации наша страница приветствия Jenkins должна выглядеть примерно так:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Отсюда я бы предложил перейти к &amp;ldquo;Manage Jenkins&amp;rdquo;, и вы увидите &amp;ldquo;Manage Plugins&amp;rdquo;, где будут доступны некоторые обновления. Выберите все эти плагины и выберите &amp;ldquo;Загрузить сейчас и установить после перезапуска&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы хотите пойти еще дальше и автоматизировать развертывание Jenkins с помощью shell-скрипта, этот замечательный репозиторий был предоставлен мне в twitter &lt;a href="https://github.com/mehyedes/nodejs-k8s/blob/main/docs/automated-setup">mehyedes/nodejs-k8s&lt;/a>&lt;/p>
&lt;h3 id="jenkinsfile">Jenkinsfile&lt;/h3>
&lt;p>Теперь у нас есть Jenkins, развернутый в нашем кластере Kubernetes, мы можем вернуться назад и подумать об этом Jenkinsfile.&lt;/p>
&lt;p>Каждый Jenkinsfile, скорее всего, будет начинаться примерно так: сначала вы определяете шаги вашего конвейера, в данном случае это Build &amp;gt; Test &amp;gt; Deploy. Но на самом деле мы не делаем ничего, кроме использования команды &lt;code>echo&lt;/code> для вызова определенных этапов.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Jenkinsfile (декларативный конвейер)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pipeline {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> agent any
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stages {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage(&amp;#39;Build&amp;#39;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#39;Building..&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage(&amp;#39;Test&amp;#39;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#39;Testing..&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage(&amp;#39;Deploy&amp;#39;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &amp;#39;Deploying....&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В нашей приборной панели Jenkins выберите &amp;ldquo;New Item&amp;rdquo; дайте элементу имя, я собираюсь &amp;ldquo;echo1&amp;rdquo; Я собираюсь предложить, что это Pipeline.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нажмите Ok, и у вас появятся вкладки (General, Build Triggers, Advanced Project Options и Pipeline) для простого теста нас интересует только Pipeline. В разделе Pipeline у вас есть возможность добавить скрипт, мы можем скопировать и вставить приведенный выше скрипт в поле.&lt;/p>
&lt;p>Как мы уже говорили выше, это не даст многого, но покажет нам этапы нашей сборки &amp;gt; тестирования &amp;gt; развертывания&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нажмите Save, теперь мы можем запустить нашу сборку, используя сборку, показанную ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также должны открыть терминал и выполнить команду &lt;code>kubectl get pods -n jenkins&lt;/code>, чтобы посмотреть, что произойдет.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day72_CICD18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Хорошо, очень просто, но теперь мы можем видеть, что наше развертывание и установка Jenkins работает правильно, и мы можем начать видеть здесь строительные блоки конвейера CI.&lt;/p>
&lt;p>В следующем разделе мы будем строить конвейер Jenkins.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://youtu.be/_MXtbjwsz3A">Jenkins is the way to build, test, deploy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/">Jenkins.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">ArgoCD Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=LFDrDnKPOTg">What is Jenkins?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=nCKxl7Q_20I&amp;amp;t=3s">Complete Jenkins Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=R8_veQiYBjI">GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=mFFXuXjVgkU">GitHub Actions CI/CD&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>73. Построение конвейера Jenkins</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day73/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day73/</guid><description>&lt;p>В предыдущем разделе мы развернули Jenkins на нашем кластере Minikube и создали очень простой Jenkins Pipeline, который не делал ничего особенного, кроме как повторял этапы Pipeline.&lt;/p>
&lt;p>Вы также могли заметить, что в процессе создания Jenkins Pipeline нам доступны некоторые примеры скриптов для запуска.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Первый демонстрационный скрипт - &amp;ldquo;Declartive (Kubernetes)&amp;rdquo;, и вы можете увидеть его этапы ниже.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>// Uses Declarative syntax to run commands inside a container.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pipeline {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> agent {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubernetes {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // Rather than inline YAML, in a multibranch Pipeline you could use: yamlFile &amp;#39;jenkins-pod.yaml&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // Or, to avoid YAML:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // containerTemplate {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // name &amp;#39;shell&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // image &amp;#39;ubuntu&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // command &amp;#39;sleep&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // args &amp;#39;infinity&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yaml &amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Pod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> containers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: shell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: ubuntu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - sleep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - infinity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // Can also wrap individual steps:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // container(&amp;#39;shell&amp;#39;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // sh &amp;#39;hostname&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> // }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultContainer &amp;#39;shell&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stages {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage(&amp;#39;Main&amp;#39;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sh &amp;#39;hostname&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ниже показан результат того, что происходит при выполнении этого конвейера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="создание-задания">Создание задания&lt;/h3>
&lt;p>&lt;strong>Цели&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Создать простое приложение и сохранить его в публичном репозитории GitHub (&lt;a href="https://github.com/scriptcamp/kubernetes-kaniko.git">https://github.com/scriptcamp/kubernetes-kaniko.git&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>С помощью Jenkins собрать образ нашего docker-контейнера и выложить в docker hub. (Для этого мы будем использовать частный репозиторий).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Чтобы добиться этого в нашем кластере Kubernetes, работающем в Minikube или с его помощью, нам нужно использовать нечто под названием &lt;a href="https://github.com/GoogleContainerTools/kaniko#running-kaniko-in-a-kubernetes-cluster">Kaniko&lt;/a> В общем, если вы используете Jenkins в реальном кластере Kubernetes или запускаете его на сервере, вы можете указать агента, который даст вам возможность выполнять команды сборки docker и загружать их в DockerHub.&lt;/p>
&lt;p>Учитывая вышесказанное, мы также собираемся развернуть секрет в Kubernetes с нашими учетными данными GitHub.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>kubectl create secret docker-registry dockercred \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --docker-server=https://index.docker.io/v1/ \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --docker-username=&amp;lt;dockerhub-username&amp;gt; \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --docker-password=&amp;lt;dockerhub-password&amp;gt;\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --docker-email=&amp;lt;dockerhub-email&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>На самом деле я хочу поделиться еще одним замечательным ресурсом от &lt;a href="https://devopscube.com/build-docker-image-kubernetes-pod/">DevOpsCube.com&lt;/a>, где рассматривается многое из того, о чем мы будем говорить здесь.&lt;/p>
&lt;h3 id="добавление-учетных-данных-в-jenkins">Добавление учетных данных в Jenkins&lt;/h3>
&lt;p>Однако если вы используете систему Jenkins, в отличие от нашей, то вы, скорее всего, захотите определить свои учетные данные в Jenkins, а затем использовать их несколько раз в своих конвейерах и конфигурациях. Мы можем ссылаться на эти учетные данные в конвейерах, используя ID, который мы определили при создании. Я пошел дальше и создал учетные данные для DockerHub и GitHub.&lt;/p>
&lt;p>Сначала выберите &amp;ldquo;Manage Jenkins&amp;rdquo;, а затем &amp;ldquo;Manage Credentials&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В центре страницы вы увидите магазины, предназначенные для Jenkins, нажмите на Jenkins здесь.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь выберите Global Credentials (Unrestricted).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем в левом верхнем углу у вас есть Добавить учетные данные&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Заполните данные вашей учетной записи и затем выберите OK, помните, что ID - это то, на что вы будете ссылаться, когда захотите вызвать эту учетную запись. Мой совет здесь также заключается в том, что вы должны использовать специальные маркеры доступа, а не пароли.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для GitHub вы должны использовать &lt;a href="https://vzilla.co.uk/vzilla-blog/creating-updating-your-github-personal-access-token">Personal Access Token&lt;/a>.&lt;/p>
&lt;p>Лично мне процесс создания этих учетных записей показался не очень интуитивным, поэтому, хотя мы не используем их, я хотел поделиться процессом, так как он не совсем понятен из пользовательского интерфейса.&lt;/p>
&lt;h3 id="построение-конвейера">Построение конвейера&lt;/h3>
&lt;p>У нас есть учетные данные DockerHub, развернутые как секрет в нашем кластере Kubernetes, к которым мы будем обращаться на этапе docker deploy to DockerHub в нашем конвейере.&lt;/p>
&lt;p>Сценарий конвейера - это то, что вы видите ниже, это, в свою очередь, может стать нашим Jenkinsfile, расположенным в нашем репозитории GitHub, который, как вы можете видеть, также указан на этапе Get the project в конвейере.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#06287e">podTemplate&lt;/span>(yaml:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#4070a0">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> apiVersion: v1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> kind: Pod
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> spec:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> containers:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - name: maven
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> image: maven:3.8.1-jdk-8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> command:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - sleep
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> args:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - 99d
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - name: kaniko
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> image: gcr.io/kaniko-project/executor:debug
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> command:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - sleep
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> args:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - 9999999
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> volumeMounts:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - name: kaniko-secret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> mountPath: /kaniko/.docker
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> restartPolicy: Never
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> volumes:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - name: kaniko-secret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> secret:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> secretName: dockercred
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> items:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> - key: .dockerconfigjson
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> path: config.json
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0">&amp;#39;&amp;#39;&amp;#39;&lt;/span>)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#06287e">node&lt;/span>(POD_LABEL)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#06287e">stage&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;Get the project&amp;#39;&lt;/span>)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>git&lt;span style="color:#bbb"> &lt;/span>url:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#4070a0">&amp;#39;https://github.com/scriptcamp/kubernetes-kaniko.git&amp;#39;&lt;/span>,&lt;span style="color:#bbb"> &lt;/span>branch:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#4070a0">&amp;#39;main&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#06287e">container&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;maven&amp;#39;&lt;/span>)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#06287e">stage&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;Test the project&amp;#39;&lt;/span>)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>sh&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#4070a0">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> echo pwd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#06287e">stage&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;Build &amp;amp; Test the Docker Image&amp;#39;&lt;/span>)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#06287e">container&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;kaniko&amp;#39;&lt;/span>)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#06287e">stage&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;Deploy to DockerHub&amp;#39;&lt;/span>)&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">{&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>sh&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#4070a0">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> /kaniko/executor --context `pwd` --destination michaelcade1/helloworld:latest
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="">}&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Чтобы начать работу на приборной панели Jenkins, нам нужно выбрать &amp;ldquo;Новый элемент&amp;rdquo;&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы дадим нашему элементу имя, выберем Pipeline и нажмем OK.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы не будем выбирать общие триггеры или триггеры сборки, но поиграйте с ними, так как здесь есть несколько интересных расписаний и других конфигураций, которые могут быть полезны.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нас интересует только вкладка Pipeline в конце.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В определении пайплайн мы скопируем и вставим скрипт пайплайна, который мы описали выше, в раздел Script и нажмем кнопку save.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы выберем опцию &amp;ldquo;Build Now&amp;rdquo; в левой части страницы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь вам нужно подождать некоторое время, меньше минуты, и вы должны увидеть в статусе этапы, которые мы определили выше в нашем скрипте.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Что еще более важно, если мы теперь перейдем на наш DockerHub и проверим, что у нас есть новая сборка.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day73_CICD15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В целом это заняло некоторое время, но я хотел придерживаться этого, чтобы получить практический опыт и проработать скрипт, который может выполнить каждый, используя minikube и доступ к github и dockerhub.&lt;/p>
&lt;p>Репозиторий DockerHub, который я использовал для этого демо, был частным. Но в следующем разделе я хочу продвинуть некоторые из этих этапов и заставить их действительно что-то делать, а не просто выводить &lt;code>pwd&lt;/code>, и действительно запустить некоторые тесты и этапы сборки.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://youtu.be/_MXtbjwsz3A">Jenkins is the way to build, test, deploy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/">Jenkins.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">ArgoCD Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=LFDrDnKPOTg">What is Jenkins?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=nCKxl7Q_20I&amp;amp;t=3s">Complete Jenkins Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=R8_veQiYBjI">GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=mFFXuXjVgkU">GitHub Actions CI/CD&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>74. Hello World - Jenkinsfile App Pipeline</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day74/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day74/</guid><description>&lt;h2 id="здравствуй-мир---jenkinsfile-app-pipeline">Здравствуй мир - Jenkinsfile App Pipeline&lt;/h2>
&lt;p>В предыдущем разделе мы построили простой конвейер в Jenkins, который будет перемещать наш образ докера из нашего dockerfile в публичном репозитории GitHub в наш частный репозиторий Dockerhub.&lt;/p>
&lt;p>В этом разделе мы хотим сделать еще один шаг вперед и добиться следующего с помощью нашего простого приложения.&lt;/p>
&lt;h3 id="цель">Цель&lt;/h3>
&lt;ul>
&lt;li>Dockerfile (Hello World)&lt;/li>
&lt;li>Jenkinsfile&lt;/li>
&lt;li>Jenkins Pipeline для запуска при обновлении репозитория GitHub&lt;/li>
&lt;li>Используйте репозиторий GitHub в качестве источника.&lt;/li>
&lt;li>Запуск - Clone/Get Repository, Build, Test, Deploy Stages&lt;/li>
&lt;li>Развертывание на DockerHub с инкрементными номерами версий&lt;/li>
&lt;li>Stretch Goal для развертывания на нашем кластере Kubernetes (для этого потребуется еще одно задание и репозиторий манифеста с использованием учетных данных GitHub).&lt;/li>
&lt;/ul>
&lt;h3 id="шаг-первый">Шаг первый&lt;/h3>
&lt;p>У нас есть наш &lt;a href="https://github.com/MichaelCade/Jenkins-HelloWorld">GitHub репозиторий&lt;/a> В настоящее время он содержит наш Dockerfile и наш index.html&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это то, что мы использовали в качестве источника в нашем конвейере, теперь мы хотим добавить этот скрипт Jenkins Pipeline в наш репозиторий GitHub.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь вернемся к нашей приборной панели Jenkins и создадим новый пайплайн, но теперь вместо вставки нашего скрипта мы будем использовать &amp;ldquo;Pipeline script from SCM&amp;rdquo; Мы будем использовать приведенные ниже параметры конфигурации.&lt;/p>
&lt;p>Для справки мы будем использовать &lt;a href="https://github.com/MichaelCade/Jenkins-HelloWorld.git">https://github.com/MichaelCade/Jenkins-HelloWorld.git&lt;/a> в качестве URL репозитория.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На этом этапе мы можем нажать кнопку сохранить и применить, после чего мы сможем вручную запустить наш Pipeline для сборки нового образа Docker, загруженного в наш репозиторий DockerHub.&lt;/p>
&lt;p>Однако я также хочу убедиться, что мы установили расписание, по которому при каждом изменении нашего репозитория или исходного кода будет запускаться сборка. Мы можем использовать веб-крючки или запланированное извлечение.&lt;/p>
&lt;p>Это важный момент, потому что если вы используете дорогостоящие облачные ресурсы для хранения конвейера и у вас много изменений в репозитории кода, то вы понесете большие расходы. Мы знаем, что это демонстрационная среда, поэтому я использую опцию &amp;ldquo;poll scm&amp;rdquo;. (Также я считаю, что при использовании minikube мне не хватает возможности использовать webhooks)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Одна вещь, которую я изменил со вчерашней сессии, это то, что теперь я хочу загружать изображение в публичный репозиторий, который в данном случае будет michaelcade1\90DaysOfDevOps, мой Jenkinsfile уже содержит это изменение. И из предыдущих разделов я удалил все существующие образы демо-контейнеров.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Двигаясь назад, мы создали наш Pipeline, а затем, как было показано ранее, добавили нашу конфигурацию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На данном этапе наш конвейер еще не запущен, и вид сцены будет выглядеть примерно так.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь нажмем кнопку &amp;ldquo;Build Now&amp;rdquo;. и в представлении этапа будут отображены наши этапы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы перейдем к нашему репозиторию DockerHub, у нас должно быть 2 новых образа Docker. У нас должен быть идентификатор сборки 1 и последняя версия, потому что каждая сборка, которую мы создаем на основе команды &amp;ldquo;Upload to DockerHub&amp;rdquo;, отправляет версию, используя переменную окружения Jenkins Build_ID, а также выпускает последнюю версию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Давайте создадим обновление файла index.html в нашем репозитории GitHub, как показано ниже, я позволю вам пойти и узнать, что говорила версия 1 файла index.html.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы вернемся в Jenkins и снова выберем &amp;ldquo;Build Now&amp;rdquo;. Мы увидим, что наша сборка #2 прошла успешно.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем быстро взглянув на DockerHub, мы увидим, что у нас есть наш тег версии 2 и наш последний тег.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day74_CICD12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Здесь стоит отметить, что я добавил в свой кластер Kubernetes секрет, который позволяет мне получить доступ и аутентификацию для отправки моих сборок docker в DockerHub. Если вы следуете этому примеру, вам следует повторить этот процесс для своей учетной записи, а также внести изменения в Jenkinsfile, связанный с моим репозиторием и учетной записью.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://youtu.be/_MXtbjwsz3A">Jenkins is the way to build, test, deploy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/">Jenkins.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">ArgoCD Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=LFDrDnKPOTg">What is Jenkins?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=nCKxl7Q_20I&amp;amp;t=3s">Complete Jenkins Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=R8_veQiYBjI">GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=mFFXuXjVgkU">GitHub Actions CI/CD&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>75. Обзор GitHub Actions</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day75/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day75/</guid><description>&lt;h2 id="обзор-действий-github">Обзор действий GitHub&lt;/h2>
&lt;p>В этом разделе я хотел бы перейти к рассмотрению, возможно, другого подхода, чем тот, на который мы только что потратили время. На этом занятии мы сосредоточимся на GitHub Actions.&lt;/p>
&lt;p>GitHub Actions - это платформа CI/CD, которая позволяет нам строить, тестировать и развертывать, помимо прочих задач, наш конвейер. В ней есть концепция рабочих процессов, которые собираются и тестируются на основе репозитория GitHub. Вы также можете использовать GitHub Actions для управления другими рабочими процессами на основе событий, происходящих в вашем репозитории.&lt;/p>
&lt;h3 id="рабочие-процессы">Рабочие процессы&lt;/h3>
&lt;p>В целом, в GitHub Actions наша задача называется &lt;strong>рабочий процесс&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>Рабочий процесс** - это настраиваемый автоматизированный процесс.&lt;/li>
&lt;li>Определяется как файлы YAML.&lt;/li>
&lt;li>Содержит и запускает одно или несколько &lt;strong>заданий&lt;/strong>.&lt;/li>
&lt;li>Запускается при срабатывании &lt;strong>события&lt;/strong> в вашем хранилище или может быть запущен вручную.&lt;/li>
&lt;li>Вы можете использовать несколько рабочих процессов для каждого хранилища.&lt;/li>
&lt;li>&lt;strong>рабочий процесс&lt;/strong> содержит &lt;strong>задание&lt;/strong>, а затем &lt;strong>шаги&lt;/strong> для достижения этого &lt;strong>задания&lt;/strong>.&lt;/li>
&lt;li>В рамках &lt;strong>рабочего процесса&lt;/strong> у нас также будет &lt;strong>запускающий механизм&lt;/strong>, на котором будет выполняться наш &lt;strong>рабочий процесс&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>Например, у вас может быть один &lt;strong>рабочий процесс&lt;/strong> для создания и тестирования запросов, другой &lt;strong>рабочий процесс&lt;/strong> для развертывания вашего приложения каждый раз, когда создается релиз, и еще один &lt;strong>рабочий процесс&lt;/strong>, который добавляет метку каждый раз, когда кто-то открывает новую проблему.&lt;/p>
&lt;h3 id="события">События&lt;/h3>
&lt;p>События - это определенные события в хранилище, которые запускают рабочий процесс на выполнение.&lt;/p>
&lt;h3 id="задания">Задания&lt;/h3>
&lt;p>Задание - это набор шагов рабочего процесса, которые выполняются на бегунке.&lt;/p>
&lt;h3 id="шаги">Шаги&lt;/h3>
&lt;p>Каждый шаг в задании может быть скриптом оболочки, который выполняется, или действием. Шаги выполняются по порядку и зависят друг от друга.&lt;/p>
&lt;h3 id="действия">Действия&lt;/h3>
&lt;p>Повторяющееся пользовательское приложение, используемое для часто повторяющихся задач.&lt;/p>
&lt;h3 id="бегуны">Бегуны&lt;/h3>
&lt;p>Бегунок - это сервер, который запускает рабочий процесс, каждый бегунок выполняет одно задание за раз. GitHub Actions предоставляет возможность запуска бегунов для Ubuntu Linux, Microsoft Windows и macOS. Вы также можете разместить свой собственный на определенной ОС или оборудовании.&lt;/p>
&lt;p>Ниже вы можете увидеть, как это выглядит: у нас есть событие, запускающее наш рабочий процесс &amp;gt; наш рабочий процесс состоит из двух заданий &amp;gt; внутри наших заданий есть шаги, а затем действия.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="yaml">YAML&lt;/h3>
&lt;p>Прежде чем мы приступим к рассмотрению реального случая использования, давайте взглянем на приведенное выше изображение в виде примера YAML-файла.&lt;/p>
&lt;p>Я добавил #, чтобы прокомментировать, где мы можем найти компоненты рабочего процесса YAML.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>#Workflow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name: 90DaysOfDevOps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#Event
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>on: [push]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>#Jobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jobs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> check-bats-version:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> #Runners
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runs-on: ubuntu-latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> #Steps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> #Actions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - uses: actions/checkout@v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - uses: actions/setup-node@v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node-version: &amp;#39;14&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - run: npm install -g bats
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - run: bats -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="приступаем-к-работе-с-github-actions">Приступаем к работе с GitHub Actions&lt;/h3>
&lt;p>Я думаю, что у GitHub Actions есть много возможностей, да, они удовлетворят ваши потребности в CI/CD, когда речь идет о сборке, тестировании, развертывании вашего кода и последующих шагах.&lt;/p>
&lt;p>Я вижу множество вариантов и других автоматизированных задач, для которых мы могли бы использовать GitHub Actions.&lt;/p>
&lt;h3 id="использование-github-actions-для-линтинга-вашего-кода">Использование GitHub Actions для линтинга вашего кода&lt;/h3>
&lt;p>Один из вариантов - убедиться, что ваш код чист и аккуратен в вашем репозитории. Это будет наш первый демонстрационный пример.&lt;/p>
&lt;p>Я собираюсь использовать некоторый пример кода, связанный в одном из ресурсов для этого раздела, мы будем использовать &lt;code>github/super-linter&lt;/code> для проверки нашего кода.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>name: Super-Linter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>on: push
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jobs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> super-lint:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: Lint code base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runs-on: ubuntu-latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Checkout code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: actions/checkout@v2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: Run Super-Linter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uses: github/super-linter@v3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DEFAULT_BRANCH: main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>github/super-linter&lt;/strong>
Вы можете видеть, что для одного из наших шагов у нас есть действие под названием github/super-linter, которое ссылается на шаг, уже написанный сообществом. Вы можете узнать больше об этом здесь &lt;a href="https://github.com/github/super-linter">Super-Linter&lt;/a>&lt;/p>
&lt;p>&amp;ldquo;Этот репозиторий предназначен для GitHub Action для запуска Super-Linter. Это простая комбинация различных линтеров, написанных на bash, чтобы помочь проверить ваш исходный код.&amp;rdquo;&lt;/p>
&lt;p>Также в приведенном фрагменте кода упоминается GITHUB_TOKEN, поэтому мне было интересно узнать, зачем и для чего это нужно.&lt;/p>
&lt;p>&amp;ldquo;ПРИМЕЧАНИЕ: Если вы передадите переменную окружения &lt;code>GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&lt;/code> в вашем рабочем процессе, то GitHub Super-Linter будет отмечать статус каждого отдельного запуска линтера в разделе &amp;ldquo;Проверки&amp;rdquo; запроса на выгрузку. Без этого вы будете видеть только общий статус всего прогона. &lt;strong>Не нужно устанавливать GitHub Secret, так как он автоматически устанавливается GitHub, его нужно только передать в действие.&lt;/strong>&amp;rdquo;.&lt;/p>
&lt;p>Выделенный жирным текст важно отметить на данном этапе. Мы используем его, но нам не нужно устанавливать какую-либо переменную окружения в нашем репозитории.&lt;/p>
&lt;p>Для тестирования мы будем использовать наш репозиторий, который мы использовали в нашей демонстрации Jenkins.&lt;a href="https://github.com/MichaelCade/Jenkins-HelloWorld">Jenkins-HelloWorld&lt;/a>.&lt;/p>
&lt;p>Вот наш репозиторий в том виде, в котором мы оставили его в сессии Jenkins.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для того, чтобы воспользоваться преимуществами, мы должны использовать вкладку Actions выше, чтобы выбрать из рынка, о котором я расскажу в ближайшее время, или мы можем создать наши собственные файлы, используя наш код супер-лайнера выше, чтобы создать свой собственный, вы должны создать новый файл в вашем репозитории именно в этом месте. &lt;code>.github/workflows/workflow_name&lt;/code>, очевидно, убедившись, что имя workflow_name - это что-то полезное для вас, узнаваемое. Здесь мы можем иметь множество различных рабочих процессов, выполняющих различные задания и задачи в нашем репозитории.&lt;/p>
&lt;p>Мы создадим &lt;code>.github/workflows/super-linter.yml&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем вставить наш код и зафиксировать его в нашем репозитории, если мы перейдем на вкладку Actions, то увидим наш рабочий процесс Super-Linter в списке, как показано ниже,&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы определили в нашем коде, что этот рабочий процесс будет запускаться, когда мы будем перемещать что-либо в наш репозиторий, поэтому при перемещении файла super-linter.yml в наш репозиторий мы запустили рабочий процесс.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как вы можете видеть из вышеприведенного, у нас есть некоторые ошибки, скорее всего, из-за моих способностей к взлому и кодированию.&lt;/p>
&lt;p>Хотя на самом деле это был не мой код, по крайней мере пока, запустив его и получив ошибку, я обнаружил вот это &lt;a href="https://github.com/github/super-linter/issues/2255">issue&lt;/a>&lt;/p>
&lt;p>Дубль #2 Я изменил версию Super-Linter с версии 3 на 4 и запустил задачу снова.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как и ожидалось, мой хакерский кодинг вызвал некоторые проблемы, и вы можете увидеть их здесь, в &lt;a href="https://github.com/MichaelCade/Jenkins-HelloWorld/runs/5600278515?check_suite_focus=true">рабочем процессе&lt;/a>.&lt;/p>
&lt;p>Я хотел показать, как теперь выглядит наш репозиторий, когда что-то в рабочем процессе не сработало или сообщило об ошибке.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, если мы решим проблему с моим кодом и внесем изменения, наш рабочий процесс снова запустится (как видно из изображения, потребовалось некоторое время, чтобы устранить наши &amp;ldquo;ошибки&amp;rdquo;). Удаление файла, вероятно, не рекомендуется, но это очень быстрый способ показать, что проблема решена.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы нажмете кнопку &amp;ldquo;Новый рабочий процесс&amp;rdquo;, выделенную выше, это откроет вам дверь к огромному количеству действий. Вы, наверное, заметили, что мы не хотим изобретать колесо, мы хотим стоять на плечах гигантов и делиться нашим кодом, автоматизацией и навыками, чтобы сделать нашу жизнь проще.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>О, я не показал вам зеленую галочку на репозитории, когда наш рабочий процесс был успешным.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day75_CICD10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я думаю, что на этом основы GitHub Actions исчерпаны, но если вы похожи на меня, то вы наверняка видите, как еще можно использовать GitHub Actions для автоматизации множества задач.&lt;/p>
&lt;p>Далее мы рассмотрим другую область CD, мы рассмотрим ArgoCD для развертывания наших приложений в наших средах.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://youtu.be/_MXtbjwsz3A">Jenkins is the way to build, test, deploy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/">Jenkins.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">ArgoCD Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=LFDrDnKPOTg">What is Jenkins?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=nCKxl7Q_20I&amp;amp;t=3s">Complete Jenkins Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=R8_veQiYBjI">GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=mFFXuXjVgkU">GitHub Actions CI/CD&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>76. Обзор ArgoCD</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day76/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day76/</guid><description>&lt;h2 id="обзор-argocd">Обзор ArgoCD&lt;/h2>
&lt;p>&amp;ldquo;Argo CD - это декларативный инструмент непрерывной доставки GitOps для Kubernetes&amp;rdquo;.&lt;/p>
&lt;p>Контроль версий - ключевой момент здесь. Вы когда-нибудь вносили изменения в вашу среду на лету и не помните об этих изменениях, а поскольку свет горит и все вокруг зеленое, вы продолжаете упорно двигаться вперед? Вы когда-нибудь вносили изменения и ломали все или часть всего? Вы могли бы знать, что внесли изменение, и вы можете быстро откатить свое изменение, тот плохой скрипт или опечатку. А теперь сделайте это в массовом масштабе, и, возможно, это были не вы, или, возможно, ошибка была обнаружена не сразу, и теперь бизнес страдает. Поэтому контроль версий очень важен. Не только это, но и &amp;ldquo;определения приложений, конфигурации и окружения должны быть декларативными и контролируемыми по версиям&amp;rdquo;. В дополнение к этому (что взято из ArgoCD), они также упоминают, что &amp;ldquo;развертывание приложений и управление жизненным циклом должно быть автоматизировано, проверяемо и просто для понимания&amp;rdquo;.&lt;/p>
&lt;p>С точки зрения операционной деятельности, но много играя с Infrastructure as Code, это следующий шаг к обеспечению того, чтобы все эти хорошие вещи были улажены по пути с помощью рабочих процессов непрерывного развертывания/доставки.&lt;/p>
&lt;p>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">Что такое ArgoCD&lt;/a>&lt;/p>
&lt;h3 id="развертывание-argocd">Развертывание ArgoCD&lt;/h3>
&lt;p>Для этого развертывания мы снова будем использовать наш надежный кластер minikube Kubernetes локально.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>kubectl create namespace argocd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day76_CICD1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Убедитесь, что все подсистемы ArgoCD запущены и работают с помощью команды &lt;code>kubectl get pods -n argocd&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day76_CICD2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Также проверим все, что мы развернули в пространстве имен с помощью &lt;code>kubectl get all -n argocd&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day76_CICD3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда все выглядит хорошо, мы должны рассмотреть возможность доступа к этому через порт. Используя команду &lt;code>kubectl port-forward svc/argocd-server -n argocd 8080:443&lt;/code>. Сделайте это в новом терминале.&lt;/p>
&lt;p>Затем откройте новый веб-браузер и перейдите по адресу &lt;a href="https://localhost:8080">https://localhost:8080&lt;/a>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day76_CICD4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для входа в систему вам понадобится имя пользователя admin, а для получения созданного вами секрета в качестве пароля используйте команду &lt;code>kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&amp;quot;{.data.password}&amp;quot; | base64 -d &amp;amp;&amp;amp; echo&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day76_CICD5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После входа в систему у вас будет чистый холст CD.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day76_CICD6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="развертывание-нашего-приложения">Развертывание нашего приложения&lt;/h3>
&lt;p>Теперь у нас есть ArgoCD, и мы можем начать использовать его для развертывания наших приложений из наших Git-репозиториев, а также Helm.&lt;/p>
&lt;p>Приложение, которое я хочу развернуть, это Pac-Man, да, именно так, знаменитая игра и то, что я использую во многих демонстрациях, когда речь идет об управлении данными, это не последний раз, когда мы видим Pac-Man.&lt;/p>
&lt;p>Вы можете найти репозиторий для &lt;a href="https://github.com/MichaelCade/pacman-tanzu.git">Pac-Man&lt;/a> здесь.&lt;/p>
&lt;p>Вместо того чтобы описывать каждый шаг с помощью снимков экрана, я решил, что будет проще создать видеоролик с описанием шагов, предпринятых для развертывания этого конкретного приложения.&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=w6J413_j0hA">ArgoCD Demo - 90DaysOfDevOps&lt;/a>&lt;/p>
&lt;p>Примечание - Во время видео есть служба, которая никогда не удовлетворяется как здоровое приложение, это потому, что тип LoadBalancer, установленный для службы pacman, находится в состоянии ожидания, в Minikube у нас нет настроенного loadbalancer. Если вы хотите проверить это, вы можете изменить YAML для службы на ClusterIP и использовать проброс портов для игры.&lt;/p>
&lt;p>На этом мы завершаем раздел CICD Pipelines, я считаю, что в настоящее время в индустрии уделяется большое внимание этой области, и вы также услышите термины GitOps, связанные с методологиями, используемыми в CICD в целом.&lt;/p>
&lt;p>Следующий раздел, в который мы переходим, посвящен Observability, еще одной концепции или области, которая не является новой, но становится все более важной, поскольку мы смотрим на наши среды по-другому.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://youtu.be/_MXtbjwsz3A">Jenkins is the way to build, test, deploy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/">Jenkins.io&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MeU5_k9ssrs">ArgoCD Tutorial for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=LFDrDnKPOTg">What is Jenkins?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=nCKxl7Q_20I&amp;amp;t=3s">Complete Jenkins Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=R8_veQiYBjI">GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=mFFXuXjVgkU">GitHub Actions CI/CD&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>77. Мониторинг</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day77/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day77/</guid><description>&lt;h2 id="введение-мониторинг">Введение: Мониторинг&lt;/h2>
&lt;p>В этом разделе мы поговорим о мониторинге, что это такое, зачем он нам нужен?&lt;/p>
&lt;h3 id="что-такое-мониторинг">Что такое мониторинг?&lt;/h3>
&lt;p>Мониторинг - это процесс пристального наблюдения за всей инфраструктурой.&lt;/p>
&lt;h3 id="и-зачем-он-нам-нужен">и зачем он нам нужен?&lt;/h3>
&lt;p>Предположим, что мы управляем тысячей серверов, которые включают в себя множество специализированных серверов, таких как серверы приложений, серверы баз данных и веб-серверы. Мы также можем усложнить эту задачу за счет дополнительных сервисов и различных платформ, включая публичные облачные предложения и Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day77_Monitoring1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы отвечаем за то, чтобы все сервисы, приложения и ресурсы на серверах работали так, как должны.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day77_Monitoring2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как мы это делаем? Есть три способа:&lt;/p>
&lt;ul>
&lt;li>Войти вручную на все наши серверы и проверить все данные, относящиеся к процессам и ресурсам служб.&lt;/li>
&lt;li>Написать скрипт, который заходит на серверы за нас и проверяет данные.&lt;/li>
&lt;/ul>
&lt;p>Оба варианта потребуют от нас значительного объема работы,&lt;/p>
&lt;p>Третий вариант проще, мы можем использовать решение для мониторинга, которое доступно на рынке.&lt;/p>
&lt;p>Nagios и Zabbix - это возможные решения, которые легко доступны и позволяют нам расширить нашу инфраструктуру мониторинга, чтобы включить столько серверов, сколько мы захотим.&lt;/p>
&lt;h3 id="nagios">Nagios&lt;/h3>
&lt;p>Nagios - это инструмент мониторинга инфраструктуры, созданный одноименной компанией. Версия этого инструмента с открытым исходным кодом называется Nagios core, а коммерческая версия называется Nagios XI. &lt;a href="https://www.nagios.org/">Сайт Nagios&lt;/a>&lt;/p>
&lt;p>Этот инструмент позволяет нам следить за нашими серверами и видеть, достаточно ли они используются или есть какие-либо задачи, требующие решения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day77_Monitoring3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>По сути, мониторинг позволяет нам достичь этих двух целей, проверить состояние наших серверов и сервисов и определить здоровье нашей инфраструктуры. Он также дает нам возможность увидеть всю инфраструктуру с высоты 40 000 метров, чтобы увидеть, работают ли наши серверы, правильно ли работают приложения, доступны или нет веб-серверы.&lt;/p>
&lt;p>Он сообщит нам, что объем нашего диска увеличивался на 10 процентов в течение последних 10 недель на определенном сервере, что он будет полностью исчерпан в течение следующих четырех или пяти дней, и мы не сможем ответить в ближайшее время. Он предупредит нас, когда ваш диск или сервер находится в критическом состоянии, чтобы мы могли принять соответствующие меры, чтобы избежать возможных сбоев.&lt;/p>
&lt;p>В этом случае мы можем освободить некоторое дисковое пространство и гарантировать, что наши серверы не выйдут из строя и наши пользователи не пострадают.&lt;/p>
&lt;p>Сложный вопрос для большинства инженеров по мониторингу - что мы отслеживаем, а что нет?&lt;/p>
&lt;p>Каждая система имеет ряд ресурсов, за какими из них мы должны внимательно следить, а на какие можем закрыть глаза, например, нужно ли следить за использованием процессора, ответ &amp;ldquo;да&amp;rdquo; очевиден, тем не менее, это все равно решение, которое нужно принять, нужно ли следить за количеством открытых портов в системе, мы можем следить или не следить в зависимости от ситуации, если это сервер общего назначения, то, вероятно, не нужно, но если это веб-сервер, то, вероятно, нужно.&lt;/p>
&lt;h3 id="постоянный-мониторинг">Постоянный мониторинг&lt;/h3>
&lt;p>Мониторинг не является чем-то новым, и даже непрерывный мониторинг был идеалом, который многие предприятия приняли в течение многих лет.&lt;/p>
&lt;p>Есть три ключевых области, на которых необходимо сосредоточиться, когда речь заходит о мониторинге.&lt;/p>
&lt;ul>
&lt;li>Мониторинг инфраструктуры&lt;/li>
&lt;li>Мониторинг приложений&lt;/li>
&lt;li>Мониторинг сети&lt;/li>
&lt;/ul>
&lt;p>Важно отметить, что существует множество доступных инструментов, мы упомянули две общие системы и инструменты в этой сессии, но их очень много. Реальная польза от решения для мониторинга появляется тогда, когда вы действительно потратили время на то, чтобы убедиться, что вы ответили на вопрос, что мы должны отслеживать, а что нет?&lt;/p>
&lt;p>Мы можем включить решение мониторинга в любой из наших платформ, и оно начнет собирать информацию, но если этой информации просто слишком много, вам будет трудно извлечь пользу из этого решения, вам придется потратить время на настройку.&lt;/p>
&lt;p>На следующем занятии мы попробуем использовать инструмент мониторинга и посмотрим, что мы можем начать отслеживать.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.devopsonline.co.uk/the-importance-of-monitoring-in-devops/">The Importance of Monitoring in DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/devopscurry/understanding-continuous-monitoring-in-devops-f6695b004e3b">Understanding Continuous Monitoring in DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4t71iv_9t_4">Top 5 - DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h4Sl21AKiDg">How Prometheus Monitoring works&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5o37CGlNLr8">Introduction to Prometheus monitoring&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>78. Hands-On Monitoring Tools</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day78/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day78/</guid><description>&lt;h2 id="инструменты-мониторинга-своими-руками">Инструменты мониторинга своими руками&lt;/h2>
&lt;p>На последнем занятии я говорил об общей картине мониторинга и рассмотрел Nagios, для этого было две причины. Во-первых, это программное обеспечение, о котором я много слышал на протяжении многих лет, поэтому хотел узнать немного больше о его возможностях.&lt;/p>
&lt;p>Сегодня я буду изучать Prometheus, я все больше и больше вижу Prometheus в ландшафте Cloud-Native, но его также можно использовать для присмотра за физическими ресурсами вне Kubernetes и тому подобного.&lt;/p>
&lt;h3 id="prometheus---мониторинг-практически-всего">Prometheus - мониторинг практически всего&lt;/h3>
&lt;p>Прежде всего, Prometheus - это Open-Source, который может помочь вам контролировать контейнеры и системы на базе микросервисов, а также физические, виртуальные и другие сервисы. За Prometheus стоит большое сообщество.&lt;/p>
&lt;p>Prometheus имеет большой набор &lt;a href="https://prometheus.io/docs/instrumenting/exporters/">интеграций и экспортеров&lt;/a> Ключевым моментом является экспорт существующих метрик в метрики Prometheus. Кроме того, он также поддерживает несколько языков программирования.&lt;/p>
&lt;p>Подход Pull - Если вы работаете с тысячами микросервисов или систем и сервисов, то метод push - это метод, при котором сервис, как правило, обращается к системе мониторинга. При этом возникают некоторые проблемы, связанные с переполнением сети, высокой производительностью процессора и единой точкой отказа. Метод Pull дает нам гораздо лучший опыт, когда Prometheus будет получать данные из конечной точки метрики на каждом сервисе.&lt;/p>
&lt;p>И снова мы видим YAML для конфигурации Prometheus.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day78_Monitoring7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Позже вы увидите, как это выглядит при развертывании в Kubernetes, в частности, у нас есть &lt;strong>PushGateway&lt;/strong>, который получает наши метрики от наших заданий/экспортеров.&lt;/p>
&lt;p>У нас есть &lt;strong>AlertManager&lt;/strong>, который рассылает оповещения, и именно здесь мы можем интегрироваться во внешние сервисы, такие как электронная почта, slack и другие инструменты.&lt;/p>
&lt;p>Затем у нас есть сервер Prometheus, который управляет получением этих метрик из PushGateway, а затем отправляет эти оповещения в AlertManager. Сервер Prometheus также хранит данные на локальном диске. Хотя можно использовать решения для удаленного хранения данных.&lt;/p>
&lt;p>У нас также есть PromQL - язык, используемый для взаимодействия с метриками, который можно увидеть позже в веб-интерфейсе Prometheus, но позже в этом разделе вы также увидите, как он используется в инструментах визуализации данных, таких как Grafana.&lt;/p>
&lt;h3 id="способы-развертывания-prometheus">Способы развертывания Prometheus&lt;/h3>
&lt;p>Существуют различные способы установки Prometheus, &lt;a href="https://prometheus.io/download/">Download Section&lt;/a> Также доступны образы Docker.&lt;/p>
&lt;p>&lt;code>docker run --name prometheus -d -p 127.0.0.1:9090:9090 prom/prometheus&lt;/code>.&lt;/p>
&lt;p>Но мы сосредоточим наши усилия на развертывании в Kubernetes. У которого также есть несколько вариантов.&lt;/p>
&lt;ul>
&lt;li>Создание конфигурационных YAML-файлов&lt;/li>
&lt;li>Использование оператора (менеджер всех компонентов prometheus)&lt;/li>
&lt;li>Использование диаграммы helm для развертывания оператора&lt;/li>
&lt;/ul>
&lt;h3 id="развертывание-в-kubernetes">Развертывание в Kubernetes&lt;/h3>
&lt;p>Для этой быстрой и простой установки мы снова будем использовать наш локальный кластер minikube. Как и в предыдущих случаях с minikube, мы будем использовать helm для развертывания диаграммы Prometheus helm.&lt;/p>
&lt;p>&lt;code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day78_Monitoring1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как видно из вышеприведенного, мы также выполнили обновление репо helm, теперь мы готовы развернуть Prometheus в нашей среде minikube с помощью команды &lt;code>helm install stable prometheus-community/prometheus&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day78_Monitoring2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Через пару минут вы увидите, что появилось несколько новых подкастов, для этого демо я развернул их в пространство имен по умолчанию, обычно я бы развернул их в собственное пространство имен.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day78_Monitoring3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После запуска всех подсистем мы также можем посмотреть на все развернутые аспекты Prometheus.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day78_Monitoring4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, чтобы получить доступ к пользовательскому интерфейсу сервера Prometheus, мы можем использовать следующую команду для проброса портов.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">export&lt;/span> POD_NAME&lt;span style="color:#666">=$&lt;/span>(kubectl get pods &lt;span style="color:#666">--&lt;/span>namespace default &lt;span style="color:#666">-&lt;/span>l &lt;span style="color:#4070a0">&amp;#34;app=prometheus,component=server&amp;#34;&lt;/span> &lt;span style="color:#666">-&lt;/span>o jsonpath&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;{.items[0].metadata.name}&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubectl &lt;span style="color:#666">--&lt;/span>namespace default port&lt;span style="color:#666">-&lt;/span>forward &lt;span style="color:#666">$&lt;/span>POD_NAME &lt;span style="color:#40a070">9090&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Когда мы впервые открываем наш браузер на &lt;a href="http://localhost:9090">http://localhost:9090&lt;/a>, мы видим следующий очень пустой экран.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day78_Monitoring5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Поскольку мы развернули наш кластер Kubernetes, мы будем автоматически получать метрики из нашего Kubernetes API, поэтому мы можем использовать некоторые PromQL, чтобы убедиться, что мы получаем метрики &lt;code>container_cpu_usage_seconds_total&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day78_Monitoring6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Коротко об изучении PromQL и применении его на практике. Это очень похоже на то, о чем я говорил ранее: получение метрик - это здорово, как и мониторинг, но вы должны знать, что вы отслеживаете и почему, и что вы не отслеживаете и почему!&lt;/p>
&lt;p>Я хочу вернуться к Prometheus, но пока я думаю, что нам нужно подумать об управлении журналами и визуализации данных, чтобы позже вернуться к Prometheus.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.devopsonline.co.uk/the-importance-of-monitoring-in-devops/">The Importance of Monitoring in DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/devopscurry/understanding-continuous-monitoring-in-devops-f6695b004e3b">Understanding Continuous Monitoring in DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4t71iv_9t_4">Top 5 - DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h4Sl21AKiDg">How Prometheus Monitoring works&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5o37CGlNLr8">Introduction to Prometheus monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.containiq.com/post/promql-cheat-sheet-with-examples">Promql cheat sheet with examples&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>79. Log Management</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day79/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day79/</guid><description>&lt;h2 id="введение-управление-журналами">Введение: Управление журналами&lt;/h2>
&lt;p>В продолжение проблем и решений в области мониторинга инфраструктуры, управление журналами - это еще один пазл в общей картине наблюдаемости.&lt;/p>
&lt;h3 id="управление-и-агрегация-журналов">Управление и агрегация журналов&lt;/h3>
&lt;p>Давайте поговорим о двух основных концепциях, первая из которых - агрегация журналов, это способ сбора и маркировки журналов приложений от множества различных служб в единую приборную панель, по которой можно легко осуществлять поиск.&lt;/p>
&lt;p>Одной из первых систем, которые должны быть построены в системе управления производительностью приложений, является агрегация журналов. Управление производительностью приложений - это та часть жизненного цикла devops, когда все было создано и развернуто, и вам нужно убедиться, что они постоянно работают, что им выделено достаточно ресурсов и что ошибки не показываются пользователям. В большинстве производственных развертываний существует множество связанных событий, которые передают журналы по сервисам, в google один поиск может попасть в десять различных сервисов, прежде чем будет возвращен пользователю, если вы получили неожиданные результаты поиска, это может означать логическую проблему в любом из десяти сервисов, и агрегация журналов помогает таким компаниям, как google, диагностировать проблемы в производстве.&lt;/p>
&lt;p>В этом суть хорошей платформы для агрегации журналов, которая эффективно собирает журналы отовсюду, откуда они исходят, и делает их легко доступными для поиска в случае повторного возникновения неисправности.&lt;/p>
&lt;h3 id="пример-приложения">Пример приложения&lt;/h3>
&lt;p>Наш пример приложения - это веб-приложение, у нас есть типичный фронт-энд и бэк-энд, хранящий наши важные данные в базе данных MongoDB.&lt;/p>
&lt;p>Если бы пользователь сказал нам, что страница стала белой и вывела сообщение об ошибке, мы бы с трудом диагностировали проблему с помощью нашего текущего стека. Пользователь должен вручную отправить нам ошибку, а мы должны сопоставить ее с соответствующими журналами в трех других сервисах.&lt;/p>
&lt;h3 id="elk">ELK&lt;/h3>
&lt;p>Давайте посмотрим на ELK, популярный стек агрегации логов с открытым исходным кодом, названный в честь его трех компонентов elasticsearch, logstash и kibana, если мы установим его в той же среде, что и наше приложение.&lt;/p>
&lt;p>Веб-приложение подключается к фронтенду, который затем подключается к бэкенду, бэкенд отправляет журналы в logstash, а затем то, как работают эти три компонента.&lt;/p>
&lt;h3 id="компоненты-elk">Компоненты elk&lt;/h3>
&lt;p>Elasticsearch, logstash и Kibana заключается в том, что все сервисы отправляют журналы в logstash, logstash принимает эти журналы, которые являются текстом, испускаемым приложением. Например, веб-приложение, когда вы посещаете веб-страницу, может зарегистрировать доступ посетителя к этой странице в это время, и это пример сообщения журнала, которое будет отправлено в logstash.&lt;/p>
&lt;p>Затем Logstash извлекает из них информацию, так что для этого сообщения пользователь сделал &lt;strong>что-то&lt;/strong>, в &lt;strong>время&lt;/strong>. Он извлечет время, извлечет сообщение, извлечет пользователя и включит все это в качестве тегов, так что сообщение будет объектом тегов и сообщений, так что вы можете легко искать по ним, вы можете найти все запросы, сделанные определенным пользователем, но logstash не хранит вещи самостоятельно, он хранит вещи в elasticsearch, который является эффективной базой данных для запроса текста, и elasticsearch раскрывает результаты как Kibana, а Kibana - это веб-сервер, который подключается к elasticsearch и позволяет администраторам, таким как devops или другим людям в вашей команде, дежурному инженеру просматривать журналы в производстве при возникновении серьезных неполадок. Вы, как администратор, подключаетесь к Kibana, Kibana запрашивает elasticsearch на предмет журналов, соответствующих тому, что вы хотите.&lt;/p>
&lt;p>Вы можете сказать: &amp;ldquo;Эй, Kibana, в строке поиска я хочу найти ошибки&amp;rdquo;, и Kibana скажет elasticsearch найти сообщения, которые содержат строку error, а затем elasticsearch вернет результаты, которые были заполнены logstash. Logstash получил бы эти результаты от всех других служб.&lt;/p>
&lt;h3 id="как-бы-мы-использовали-elk-для-диагностики-производственной-проблемы">как бы мы использовали elk для диагностики производственной проблемы&lt;/h3>
&lt;p>Пользователь говорит, что я увидел код ошибки один два три четыре пять шесть семь, когда я попытался сделать это с помощью настройки elk, мы должны зайти в kibana, ввести один два три четыре пять шесть семь в строке поиска, нажать enter, а затем это покажет нам журналы, которые соответствуют этому, и один из журналов может сказать внутреннюю ошибку сервера, возвращающую один два три четыре пять шесть семь, и мы увидим, что служба, которая выдала этот журнал. и мы увидим, что служба, которая выдала этот журнал, была backend, и мы увидим, в какое время был выдан этот журнал, поэтому мы можем перейти ко времени в этом журнале и посмотреть на сообщения выше и ниже него в backend, и тогда мы сможем увидеть лучшую картину того, что произошло для запроса пользователя, и мы сможем повторить этот процесс, переходя к другим службам, пока не найдем, что на самом деле вызвало проблему у пользователя.&lt;/p>
&lt;h3 id="безопасность-и-доступ-к-журналам">Безопасность и доступ к журналам&lt;/h3>
&lt;p>Важной частью головоломки является обеспечение того, чтобы журналы были видны только администраторам (или пользователям и группам, которым абсолютно необходим доступ). Журналы могут содержать конфиденциальную информацию, такую как токены, поэтому важно, чтобы только аутентифицированные пользователи могли получить к ним доступ. Вы не захотите выставлять Kibana в интернет без какого-либо способа аутентификации.&lt;/p>
&lt;h3 id="примеры-инструментов-управления-журналами">Примеры инструментов управления журналами&lt;/h3>
&lt;p>Примерами платформ для управления журналами являются&lt;/p>
&lt;ul>
&lt;li>Elasticsearch&lt;/li>
&lt;li>Logstash&lt;/li>
&lt;li>Kibana&lt;/li>
&lt;li>Fluentd - популярный вариант с открытым исходным кодом&lt;/li>
&lt;li>Datadog - хостинговое предложение, обычно используется на крупных предприятиях,&lt;/li>
&lt;li>LogDNA - хостируемое предложение&lt;/li>
&lt;li>Splunk&lt;/li>
&lt;/ul>
&lt;p>Облачные провайдеры также предоставляют протоколирование, например, AWS CloudWatch Logs, Microsoft Azure Monitor и Google Cloud Logging.&lt;/p>
&lt;p>Управление журналами является ключевым аспектом общей наблюдаемости ваших приложений и среды инфраструктур для диагностики проблем в производстве. Относительно просто установить готовое решение, такое как ELK или CloudWatch, и это значительно упрощает диагностику и устранение проблем в производстве.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.devopsonline.co.uk/the-importance-of-monitoring-in-devops/">The Importance of Monitoring in DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/devopscurry/understanding-continuous-monitoring-in-devops-f6695b004e3b">Understanding Continuous Monitoring in DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4t71iv_9t_4">Top 5 - DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h4Sl21AKiDg">How Prometheus Monitoring works&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5o37CGlNLr8">Introduction to Prometheus monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.containiq.com/post/promql-cheat-sheet-with-examples">Promql cheat sheet with examples&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=J0csO_Shsj0">Log Management for DevOps | Manage application, server, and cloud logs with Site24x7&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://devops.com/log-management-what-devops-teams-need-to-know/">Log Management what DevOps need to know&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4X0WLg05ASw">What is ELK Stack?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5ofsNyHZwWE&amp;amp;t=14s">Fluentd simply explained&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>80. ELK Stack</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day80/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day80/</guid><description>&lt;h2 id="elk-stack">ELK Stack&lt;/h2>
&lt;p>На этом занятии мы немного подробнее рассмотрим некоторые из упомянутых нами опций.&lt;/p>
&lt;h3 id="elk-stack-1">ELK Stack&lt;/h3>
&lt;p>ELK Stack - это комбинация трех отдельных инструментов:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.elastic.co/what-is/elasticsearch">Elasticsearch&lt;/a> - это распределенный, бесплатный и открытый поисковый и аналитический механизм для всех типов данных, включая текстовые, числовые, геопространственные, структурированные и неструктурированные.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.elastic.co/logstash/">Logstash&lt;/a> - свободный и открытый конвейер обработки данных на стороне сервера, который получает данные из множества источников, преобразует их, а затем отправляет в ваш любимый &amp;ldquo;тайник&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.elastic.co/kibana/">Kibana&lt;/a> - это бесплатный и открытый пользовательский интерфейс, позволяющий визуализировать данные Elasticsearch и перемещаться по стеку Elastic Stack. Делайте все, что угодно: от отслеживания загрузки запросов до понимания того, как запросы проходят через ваши приложения.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Стек ELK позволяет нам надежно и безопасно получать данные из любого источника, в любом формате, затем искать, анализировать и визуализировать их в режиме реального времени.&lt;/p>
&lt;p>В дополнение к вышеперечисленным компонентам вы также можете увидеть Beats - легковесные агенты, которые устанавливаются на пограничных узлах для сбора различных типов данных для передачи в стек.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Журналы: Определяются журналы сервера, которые необходимо проанализировать.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Logstash: Собирает журналы и данные о событиях. Он даже анализирует и преобразует данные.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ElasticSearch: Преобразованные данные из Logstash хранятся, ищутся и индексируются.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kibana использует БД Elasticsearch для изучения, визуализации и обмена данными&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;a href="https://www.guru99.com/elk-stack-tutorial.html">Изображение взято с сайта Guru99&lt;/a>&lt;/p>
&lt;p>Хороший ресурс, объясняющий это &lt;a href="https://logz.io/learn/complete-guide-elk-stack/">The Complete Guide to the ELK Stack&lt;/a>&lt;/p>
&lt;p>С добавлением битов стек ELK теперь также известен как Elastic Stack.&lt;/p>
&lt;p>Для практического скрипта существует множество мест, где можно развернуть Elastic Stack, но мы будем использовать docker compose для локального развертывания в нашей системе.&lt;/p>
&lt;p>&lt;a href="https://www.elastic.co/guide/en/elastic-stack-get-started/current/get-started-stack-docker.html#get-started-docker-tls">Start the Elastic Stack with Docker Compose&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Оригинальные файлы и руководство, которые я использовал, вы найдете здесь &lt;a href="https://github.com/deviantony/docker-elk">deviantony/docker-elk&lt;/a>&lt;/p>
&lt;p>Теперь мы можем запустить &lt;code>docker-compose up -d&lt;/code>, при первом запуске потребуется вытащить изображения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы следите за этим репозиторием или за тем, который использовал я, у вас будет пароль &amp;ldquo;changeme&amp;rdquo; или в моем репозитории пароль &amp;ldquo;90DaysOfDevOps&amp;rdquo;. Имя пользователя - &amp;ldquo;elastic&amp;rdquo;.&lt;/p>
&lt;p>Через несколько минут мы можем перейти на сайт &lt;a href="http://localhost:5601/">http://localhost:5601/&lt;/a>, который является нашим сервером Kibana / Docker-контейнером.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Ваш начальный главный экран будет выглядеть примерно так.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В разделе &amp;ldquo;Get started by adding integrations&amp;rdquo; есть пункт &amp;ldquo;try sample data&amp;rdquo;, нажмите на него, и мы сможем добавить одну из показанных ниже интеграций.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я собираюсь выбрать &amp;ldquo;Sample web logs&amp;rdquo;, но это действительно для того, чтобы получить представление о том, какие наборы данных можно получить в стеке ELK.&lt;/p>
&lt;p>Когда вы выбрали &amp;ldquo;Добавить данные&amp;rdquo;, требуется некоторое время, чтобы заполнить некоторые из этих данных, а затем у вас появляется опция &amp;ldquo;Просмотр данных&amp;rdquo; и список доступных способов просмотра этих данных в выпадающем списке.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как указано в представлении приборной панели:&lt;/p>
&lt;p>&lt;strong>Образцы данных журналов&lt;/strong>&lt;/p>
&lt;p>&lt;em>Эта приборная панель содержит образцы данных, с которыми вы можете поиграть. Вы можете просматривать их, искать и взаимодействовать с визуализациями. Для получения дополнительной информации о Kibana ознакомьтесь с нашей документацией.&lt;/em>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day80_Monitoring7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Здесь используется Kibana для визуализации данных, которые были добавлены в ElasticSearch через Logstash. Это не единственный вариант, но я лично хотел развернуть и посмотреть на это.&lt;/p>
&lt;p>В какой-то момент мы рассмотрим Grafana, и вы увидите некоторые сходства в визуализации данных между ними, вы также видели Prometheus.&lt;/p>
&lt;p>Ключевой момент, который я уловил между Elastic Stack и Prometheus + Grafana, заключается в том, что Elastic Stack или ELK Stack сосредоточен на журналах, а Prometheus - на метриках.&lt;/p>
&lt;p>Я читал эту статью от MetricFire &lt;a href="https://www.metricfire.com/blog/prometheus-vs-elk/">Prometheus vs. ELK&lt;/a>, чтобы лучше понять различные предложения.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MMVdkzeQ848">Understanding Logging: Containers &amp;amp; Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.devopsonline.co.uk/the-importance-of-monitoring-in-devops/">The Importance of Monitoring in DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/devopscurry/understanding-continuous-monitoring-in-devops-f6695b004e3b">Understanding Continuous Monitoring in DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4t71iv_9t_4">Top 5 - DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h4Sl21AKiDg">How Prometheus Monitoring works&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5o37CGlNLr8">Introduction to Prometheus monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.containiq.com/post/promql-cheat-sheet-with-examples">Promql cheat sheet with examples&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=J0csO_Shsj0">Log Management for DevOps | Manage application, server, and cloud logs with Site24x7&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://devops.com/log-management-what-devops-teams-need-to-know/">Log Management what DevOps need to know&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4X0WLg05ASw">What is ELK Stack?&lt;/a>&lt;/li>
&lt;li>[Fluentd simply explained](&lt;a href="https://www.youtube.com/watch?v=5ofsNyHZwWE&amp;amp;t=14s">https://www.youtube.com/watch?v=5ofsNyHZwWE&amp;t=14s&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>81. Fluentd и FluentBit</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day81/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day81/</guid><description>&lt;h2 id="fluentd-и-fluentbit">Fluentd и FluentBit&lt;/h2>
&lt;p>Еще одним коллектором данных, который я хотел изучить в рамках раздела о наблюдаемости, был &lt;a href="https://docs.fluentd.org/">Fluentd&lt;/a>. Это унифицированный уровень протоколирования с открытым исходным кодом.&lt;/p>
&lt;p>Fluentd имеет четыре ключевые особенности, которые делают его подходящим для создания чистых, надежных конвейеров протоколирования:&lt;/p>
&lt;p>Унифицированное протоколирование с JSON: Fluentd старается структурировать данные в виде JSON, насколько это возможно. Это позволяет Fluentd унифицировать все аспекты обработки данных журналов: сбор, фильтрацию, буферизацию и вывод журналов из нескольких источников и мест назначения. Последующая обработка данных намного проще с JSON, так как он имеет достаточную структуру, чтобы быть доступным без принуждения к жестким схемам.&lt;/p>
&lt;p>Подключаемая архитектура: Fluentd имеет гибкую систему плагинов, которая позволяет сообществу расширять его функциональность. Более 300 плагинов, созданных сообществом, соединяют десятки источников данных с десятками выходных данных, манипулируя данными по мере необходимости. Используя плагины, вы можете сразу же повысить эффективность использования ваших журналов.&lt;/p>
&lt;p>Требуется минимум ресурсов: Коллектор данных должен быть легким, чтобы его можно было легко запустить на загруженной машине. Fluentd написан на комбинации C и Ruby и требует минимальных системных ресурсов. Ванильный экземпляр работает на 30-40 МБ памяти и может обрабатывать 13 000 событий/секунду/ядро.&lt;/p>
&lt;p>Встроенная надежность: Потеря данных никогда не должна произойти. Fluentd поддерживает буферизацию на основе памяти и файлов для предотвращения потери данных между узлами. Fluentd также поддерживает надежное восстановление после отказа и может быть настроен на высокую доступность.&lt;/p>
&lt;p>&lt;a href="https://docs.fluentd.org/quickstart#step-1-installing-fluentd">Установка Fluentd&lt;/a>&lt;/p>
&lt;h3 id="как-приложения-записывают-данные-в-журнал">Как приложения записывают данные в журнал?&lt;/h3>
&lt;ul>
&lt;li>Запись в файлы. Файлы &lt;code>.log&lt;/code> (трудно анализировать без инструмента и в масштабе)&lt;/li>
&lt;li>Вести журнал непосредственно в базу данных (каждое приложение должно быть настроено на правильный формат)&lt;/li>
&lt;li>Сторонние приложения (NodeJS, NGINX, PostgreSQL).&lt;/li>
&lt;/ul>
&lt;p>Вот почему нам нужен единый уровень логирования.&lt;/p>
&lt;p>FluentD позволяет использовать 3 типа данных, показанных выше, и дает нам возможность собирать, обрабатывать и отправлять их по назначению, это может быть отправка логов в базы данных Elastic, MongoDB, Kafka, например.&lt;/p>
&lt;p>Любые данные, любой источник данных может быть отправлен в FluentD, и эти данные могут быть отправлены в любое место назначения. FluentD не привязан к какому-либо конкретному источнику или месту назначения.&lt;/p>
&lt;p>Изучая Fluentd, я постоянно натыкался на Fluent bit как еще один вариант, и похоже, что если вы хотите развернуть инструмент протоколирования в среде Kubernetes, то Fluent bit даст вам такую возможность, хотя Fluentd также может быть развернут как на контейнерах, так и на серверах.&lt;/p>
&lt;p>&lt;a href="https://docs.fluentbit.io/manual/about/fluentd-and-fluent-bit">Fluentd &amp;amp; Fluent Bit&lt;/a>&lt;/p>
&lt;p>Fluentd и Fluentbit будут использовать входные плагины для преобразования данных в формат Fluent Bit, затем у нас есть выходные плагины для любой цели вывода, например, elasticsearch.&lt;/p>
&lt;p>Мы также можем использовать теги и соответствия между конфигурациями.&lt;/p>
&lt;p>Я не вижу веских причин для использования Fluentd, и кажется, что Fluent Bit - лучший способ начать работу. Хотя в некоторых архитектурах они могут использоваться вместе.&lt;/p>
&lt;h3 id="fluent-bit-в-kubernetes">Fluent Bit в Kubernetes&lt;/h3>
&lt;p>Fluent Bit в Kubernetes развертывается как DaemonSet, что означает, что он будет запущен на каждом узле кластера. Каждая капсула Fluent Bit на каждом узле будет читать каждый контейнер на этом узле и собирать все доступные журналы. Он также будет собирать метаданные с сервера Kubernetes API Server.&lt;/p>
&lt;p>Аннотации Kubernetes можно использовать в конфигурационном YAML наших приложений.&lt;/p>
&lt;p>Прежде всего, мы можем развернуть приложение из репозитория fluent helm. &lt;code>helm repo add fluent https://fluent.github.io/helm-charts&lt;/code>, а затем установить с помощью команды &lt;code>helm install fluent-bit fluent/fluent-bit&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day81_Monitoring1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В моем кластере я также запускаю prometheus в моем пространстве имен по умолчанию (в тестовых целях), нам нужно убедиться, что наш fluent-bit pod запущен и работает. Мы можем сделать это с помощью команды &lt;code>kubectl get all | grep fluent&lt;/code>, которая покажет нам наш запущенный pod, сервис и набор демонов, о которых мы говорили ранее.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day81_Monitoring2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы Fluentbit знал, откуда получать журналы, у нас есть конфигурационный файл, в этом развертывании Fluentbit на Kubernetes у нас есть configmap, который напоминает конфигурационный файл.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day81_Monitoring3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Эта ConfigMap будет выглядеть примерно так:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>Name: fluent&lt;span style="color:#666">-&lt;/span>bit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Namespace: default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Labels: app&lt;span style="color:#666">.&lt;/span>kubernetes&lt;span style="color:#666">.&lt;/span>io&lt;span style="color:#666">/&lt;/span>instance&lt;span style="color:#666">=&lt;/span>fluent&lt;span style="color:#666">-&lt;/span>bit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app&lt;span style="color:#666">.&lt;/span>kubernetes&lt;span style="color:#666">.&lt;/span>io&lt;span style="color:#666">/&lt;/span>managed&lt;span style="color:#666">-&lt;/span>by&lt;span style="color:#666">=&lt;/span>Helm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app&lt;span style="color:#666">.&lt;/span>kubernetes&lt;span style="color:#666">.&lt;/span>io&lt;span style="color:#666">/&lt;/span>name&lt;span style="color:#666">=&lt;/span>fluent&lt;span style="color:#666">-&lt;/span>bit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app&lt;span style="color:#666">.&lt;/span>kubernetes&lt;span style="color:#666">.&lt;/span>io&lt;span style="color:#666">/&lt;/span>version&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">1.8&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">14&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> helm&lt;span style="color:#666">.&lt;/span>sh&lt;span style="color:#666">/&lt;/span>chart&lt;span style="color:#666">=&lt;/span>fluent&lt;span style="color:#666">-&lt;/span>bit&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">0.19&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Annotations: meta&lt;span style="color:#666">.&lt;/span>helm&lt;span style="color:#666">.&lt;/span>sh&lt;span style="color:#666">/&lt;/span>release&lt;span style="color:#666">-&lt;/span>name: fluent&lt;span style="color:#666">-&lt;/span>bit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> meta&lt;span style="color:#666">.&lt;/span>helm&lt;span style="color:#666">.&lt;/span>sh&lt;span style="color:#666">/&lt;/span>release&lt;span style="color:#666">-&lt;/span>namespace: default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">====&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>custom_parsers&lt;span style="color:#666">.&lt;/span>conf:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">----&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[PARSER]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name docker_no_time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Format json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Time_Keep Off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Time_Key time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Time_Format &lt;span style="color:#666">%&lt;/span>Y&lt;span style="color:#666">-%&lt;/span>m&lt;span style="color:#666">-%&lt;/span>dT&lt;span style="color:#666">%&lt;/span>H:&lt;span style="color:#666">%&lt;/span>M:&lt;span style="color:#666">%&lt;/span>S&lt;span style="color:#666">.%&lt;/span>L
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fluent&lt;span style="color:#666">-&lt;/span>bit&lt;span style="color:#666">.&lt;/span>conf:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">----&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[SERVICE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Daemon Off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Flush &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Log_Level info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Parsers_File parsers&lt;span style="color:#666">.&lt;/span>conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Parsers_File custom_parsers&lt;span style="color:#666">.&lt;/span>conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HTTP_Server On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HTTP_Listen &lt;span style="color:#40a070">0.0&lt;/span>&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#40a070">0.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HTTP_Port &lt;span style="color:#40a070">2020&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Health_Check On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[INPUT]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name tail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">Path&lt;/span> &lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020;font-weight:bold">var&lt;/span>&lt;span style="color:#666">/&lt;/span>&lt;span style="color:#007020">log&lt;/span>&lt;span style="color:#666">/&lt;/span>containers&lt;span style="color:#666">/*.&lt;/span>log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multiline&lt;span style="color:#666">.&lt;/span>parser docker, cri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Tag kube&lt;span style="color:#666">.*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Mem_Buf_Limit &lt;span style="color:#40a070">5&lt;/span>MB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Skip_Long_Lines On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[INPUT]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Tag host&lt;span style="color:#666">.*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Systemd_Filter _SYSTEMD_UNIT&lt;span style="color:#666">=&lt;/span>kubelet&lt;span style="color:#666">.&lt;/span>service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Read_From_Tail On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[FILTER]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name kubernetes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Match kube&lt;span style="color:#666">.*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Merge_Log On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Keep_Log Off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> K8S&lt;span style="color:#666">-&lt;/span>Logging&lt;span style="color:#666">.&lt;/span>Parser On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> K8S&lt;span style="color:#666">-&lt;/span>Logging&lt;span style="color:#666">.&lt;/span>Exclude On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[OUTPUT]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name es
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Match kube&lt;span style="color:#666">.*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Host elasticsearch&lt;span style="color:#666">-&lt;/span>master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Logstash_Format On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Retry_Limit False
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[OUTPUT]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name es
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Match host&lt;span style="color:#666">.*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Host elasticsearch&lt;span style="color:#666">-&lt;/span>master
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Logstash_Format On
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Logstash_Prefix node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Retry_Limit False
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Events: &lt;span style="color:#666">&amp;lt;&lt;/span>none&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь мы можем перенаправить наш pod на наш localhost, чтобы убедиться, что у нас есть соединение. Сначала узнайте имя вашего pod с помощью &lt;code>kubectl get pods | grep fluent&lt;/code> и затем используйте &lt;code>kubectl port-forward fluent-bit-8kvl4 2020:2020&lt;/code> откройте веб-браузер на &lt;a href="http://localhost:2020/">http://localhost:2020/&lt;/a>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day81_Monitoring4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я также нашел эту замечательную статью на Medium, в которой рассказывается о &lt;a href="https://medium.com/kubernetes-tutorials/exporting-kubernetes-logs-to-elasticsearch-using-fluent-bit-758e8de606af">Fluent Bit&lt;/a>.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MMVdkzeQ848">Understanding Logging: Containers &amp;amp; Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.devopsonline.co.uk/the-importance-of-monitoring-in-devops/">The Importance of Monitoring in DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/devopscurry/understanding-continuous-monitoring-in-devops-f6695b004e3b">Understanding Continuous Monitoring in DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4t71iv_9t_4">Top 5 - DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h4Sl21AKiDg">How Prometheus Monitoring works&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5o37CGlNLr8">Introduction to Prometheus monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.containiq.com/post/promql-cheat-sheet-with-examples">Promql cheat sheet with examples&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=J0csO_Shsj0">Log Management for DevOps | Manage application, server, and cloud logs with Site24x7&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://devops.com/log-management-what-devops-teams-need-to-know/">Log Management what DevOps need to know&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4X0WLg05ASw">What is ELK Stack?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5ofsNyHZwWE&amp;amp;t=14s">Fluentd simply explained&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=B2IS-XS-cc0">Fluent Bit explained | Fluent Bit vs Fluentd&lt;/a>)&lt;/li>
&lt;/ul></description></item><item><title>82. EFK Stack</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day82/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day82/</guid><description>&lt;h3 id="efk-stack">EFK Stack&lt;/h3>
&lt;p>В предыдущем разделе мы говорили о ELK Stack, который использует Logstash в качестве сборщика логов в стеке, в EFK Stack мы меняем его на FluentD или FluentBit.&lt;/p>
&lt;p>Наша задача в этом разделе - отслеживать журналы Kubernetes с помощью EFK.&lt;/p>
&lt;h3 id="обзор-efk">Обзор EFK&lt;/h3>
&lt;p>Мы развернем следующее в нашем кластере Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Стек EFK представляет собой набор из 3 программ, объединенных вместе, включая:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Elasticsearch : NoSQL база данных используется для хранения данных и предоставляет интерфейс для поиска и журнал запросов.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Fluentd : Fluentd - это сборщик данных с открытым исходным кодом для унифицированного уровня логирования. Fluentd позволяет унифицировать сбор и потребление данных для лучшего использования и понимания данных.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kibana : Интерфейс для управления и статистики журналов. Отвечает за чтение информации из elasticsearch .&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="развертывание-efk-на-minikube">Развертывание EFK на Minikube&lt;/h3>
&lt;p>Мы будем использовать наш надежный кластер minikube для развертывания нашего стека EFK. Давайте запустим кластер с помощью &lt;code>minikube start&lt;/code> на нашей системе. Я использую ОС Windows с включенным WSL2.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>&lt;a href=".../Monitoring/EFK%20Stack/efk-stack.yaml">efk-stack.yaml&lt;/a> содержит все необходимое для развертывания стека EFK в нашем кластере, используя команду &lt;code>kubectl create -f efk-stack.yaml&lt;/code> мы видим, что все развернуто.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В зависимости от вашей системы и если вы уже выполняли эту процедуру и получили изображения, теперь вам нужно посмотреть, как стручки переходят в состояние готовности, прежде чем мы сможем двигаться дальше, вы можете проверить прогресс с помощью следующей команды. &lt;code>kubectl get pods -n kube-logging -w&lt;/code> Это может занять несколько минут.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Приведенная выше команда позволяет нам следить за ситуацией, но я люблю уточнять, все ли в порядке, выполняя следующую команду &lt;code>kubectl get pods -n kube-logging&lt;/code>, чтобы убедиться, что все pods теперь работают.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>После того, как мы запустили все наши pods, и на этом этапе мы должны увидеть&lt;/p>
&lt;ul>
&lt;li>3 стручка, связанные с ElasticSearch&lt;/li>
&lt;li>1 стручок, связанный с Fluentd&lt;/li>
&lt;li>1 стручок, связанный с Kibana&lt;/li>
&lt;/ul>
&lt;p>Мы также можем использовать &lt;code>kubectl get all -n kube-logging&lt;/code>, чтобы показать все в нашем пространстве имен, fluentd, как объяснялось ранее, развернут как набор демонов, kibana как развертывание и ElasticSearch как набор состояний.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь все наши pods работают, и мы можем ввести в новом терминале команду port-forward, чтобы мы могли получить доступ к нашей приборной панели kibana. Обратите внимание, что имя вашего pod будет отличаться от команды, которую мы видим здесь. &lt;code>kubectl port-forward kibana-84cf7f59c-v2l8v 5601:5601 -n kube-logging&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем открыть браузер и перейти по этому адресу, &lt;a href="http://localhost:5601">http://localhost:5601&lt;/a> вас встретит либо экран, который вы видите ниже, либо вы можете увидеть экран с примерами данных, либо продолжить и настроить самостоятельно. В любом случае и непременно посмотрите на эти тестовые данные, это то, что мы рассмотрели при изучении стека ELK в предыдущей сессии.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее нам нужно перейти на вкладку &amp;ldquo;discover&amp;rdquo; в левом меню и добавить &amp;ldquo;*&amp;rdquo; к нашему шаблону индекса. Перейдите к следующему шагу, нажав кнопку &amp;ldquo;Следующий шаг&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На шаге 2 из 2 мы будем использовать опцию @timestamp из выпадающего списка, так как это позволит отфильтровать наши данные по времени. Когда вы нажмете кнопку создать шаблон, это может занять несколько секунд.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если через несколько секунд мы вернемся на вкладку &amp;ldquo;discover&amp;rdquo;, вы должны увидеть данные, поступающие с вашего кластера Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда у нас установлен и работает стек EFK и мы собираем журналы с нашего кластера Kubernetes через Fluentd, мы можем взглянуть на другие источники, которые мы можем выбрать. Если вы перейдете на главный экран, нажав на логотип Kibana в левом верхнем углу, вас встретит та же страница, которую мы видели при первом входе в систему.&lt;/p>
&lt;p>У нас есть возможность добавить APM, данные журнала, метрические данные и события безопасности из других плагинов или источников.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы выберем &amp;ldquo;Добавить данные журнала&amp;rdquo;, то увидим ниже, что у нас есть большой выбор, откуда мы хотим получать наши журналы, вы можете увидеть, что там упоминается Logstash, который является частью стека ELK.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day82_Monitoring13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Под данными метрик вы увидите, что можно добавить источники для Prometheus и многих других сервисов. Переведено с помощью &amp;lt;www.DeepL.com/Translator&amp;gt; (бесплатная версия)&lt;/p>
&lt;h3 id="apm-мониторинг-производительности-приложений">APM (Мониторинг производительности приложений)&lt;/h3>
&lt;p>Также есть возможность собрать APM (мониторинг производительности приложений), который собирает подробные показатели производительности и ошибки изнутри вашего приложения. Он позволяет отслеживать производительность тысяч приложений в режиме реального времени.&lt;/p>
&lt;p>Я не буду здесь углубляться в APM, но вы можете узнать больше на &lt;a href="https://www.elastic.co/observability/application-performance-monitoring">сайте Elastic&lt;/a>.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MMVdkzeQ848">Understanding Logging: Containers &amp;amp; Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.devopsonline.co.uk/the-importance-of-monitoring-in-devops/">The Importance of Monitoring in DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/devopscurry/understanding-continuous-monitoring-in-devops-f6695b004e3b">Understanding Continuous Monitoring in DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4t71iv_9t_4">Top 5 - DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h4Sl21AKiDg">How Prometheus Monitoring works&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5o37CGlNLr8">Introduction to Prometheus monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.containiq.com/post/promql-cheat-sheet-with-examples">Promql cheat sheet with examples&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=J0csO_Shsj0">Log Management for DevOps | Manage application, server, and cloud logs with Site24x7&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://devops.com/log-management-what-devops-teams-need-to-know/">Log Management what DevOps need to know&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4X0WLg05ASw">What is ELK Stack?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5ofsNyHZwWE&amp;amp;t=14s">Fluentd simply explained&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>See you on &lt;a href="../day83">Day 83&lt;/a>&lt;/p></description></item><item><title>83. Визуализация данных - Grafana</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day83/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day83/</guid><description>&lt;h2 id="визуализация-данных---grafana">Визуализация данных - Grafana&lt;/h2>
&lt;p>Мы много говорили о Kibana в этом разделе, посвященном Observability. Но мы также должны уделить некоторое время Grafana. Но это не одно и то же, и они не полностью конкурируют друг с другом.&lt;/p>
&lt;p>Основной функцией Kibana является запрос и анализ данных. Используя различные методы, пользователи могут искать в данных, проиндексированных в Elasticsearch, определенные события или строки в данных для анализа и диагностики первопричин. На основе этих запросов пользователи могут использовать функции визуализации Kibana, которые позволяют визуализировать данные различными способами, используя графики, таблицы, географические карты и другие виды визуализации.&lt;/p>
&lt;p>Grafana фактически началась как форк Kibana, целью Grafana была поддержка метрик и мониторинга, которые в то время Kibana не предоставляла.&lt;/p>
&lt;p>Grafana - это бесплатный инструмент визуализации данных с открытым исходным кодом. Обычно мы видим Prometheus и Grafana вместе в полевых условиях, но мы также можем увидеть Grafana вместе с Elasticsearch и Graphite.&lt;/p>
&lt;p>Ключевое различие между этими двумя инструментами - это логирование и мониторинг. В начале раздела мы рассмотрели мониторинг с помощью Nagios, затем Prometheus и перешли к логированию, где мы рассмотрели стеки ELK и EFK.&lt;/p>
&lt;p>Grafana предназначена для анализа и визуализации таких показателей, как использование системного процессора, памяти, дисков и ввода-вывода. Платформа не позволяет выполнять полнотекстовые запросы данных. Kibana работает поверх Elasticsearch и используется в основном для анализа сообщений журнала.&lt;/p>
&lt;p>Как мы уже выяснили, Kibana довольно проста в развертывании, а также в выборе места установки, то же самое можно сказать и о Grafana.&lt;/p>
&lt;p>Оба поддерживают установку на Linux, Mac, Windows, Docker или сборку из исходников.&lt;/p>
&lt;p>Несомненно, есть и другие, но Grafana - это инструмент, который, по моим наблюдениям, охватывает виртуальные, облачные и облачно-нативные платформы, поэтому я хотел рассказать о нем в этом разделе.&lt;/p>
&lt;h3 id="оператор-prometheus--развертывание-grafana">Оператор Prometheus + развертывание Grafana&lt;/h3>
&lt;p>Мы уже рассказывали о Prometheus в этом разделе, но поскольку мы так часто видим эти пары, я хотел создать среду, которая позволила бы нам хотя бы увидеть, какие метрики мы могли бы отображать в визуализации. Мы знаем, что мониторинг наших сред очень важен, но просмотр этих метрик в Prometheus или любом другом метрическом инструменте будет громоздким и не будет масштабироваться. Именно здесь на помощь приходит Grafana, которая предоставляет нам интерактивную визуализацию этих метрик, собранных и сохраненных в базе данных Prometheus.&lt;/p>
&lt;p>С помощью этой визуализации мы можем создавать пользовательские графики, диаграммы и оповещения для нашей среды. В этом руководстве мы будем использовать наш кластер minikube.&lt;/p>
&lt;p>Для начала мы клонируем его в нашу локальную систему. Используя &lt;code>git clone https://github.com/prometheus-operator/kube-prometheus.git&lt;/code> и &lt;code>cd kube-prometheus&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Первая задача - создать наше пространство имен в кластере minikube &lt;code>kubectl create -f manifests/setup&lt;/code>, если вы не следили за предыдущими разделами, мы можем использовать &lt;code>minikube start&lt;/code> для создания нового кластера.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы собираемся развернуть все необходимое для нашего демо с помощью команды &lt;code>kubectl create -f manifests/&lt;/code>, как вы можете видеть, это развернет множество различных ресурсов в нашем кластере.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем нам нужно подождать, пока наши стручки поднимутся, и, находясь в запущенном состоянии, мы можем использовать команду &lt;code>kubectl get pods -n monitoring -w&lt;/code>, чтобы следить за стручками.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда все запущено, мы можем проверить, что все pods находятся в рабочем и здоровом состоянии, используя команду &lt;code>kubectl get pods -n monitoring&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>При развертывании мы развернули ряд сервисов, которые мы будем использовать позже в демо, вы можете проверить их с помощью команды &lt;code>kubectl get svc -n monitoring&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>И, наконец, давайте проверим все ресурсы, развернутые в нашем новом пространстве имен мониторинга, используя команду &lt;code>kubectl get all -n monitoring&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Открыв новый терминал, мы готовы получить доступ к нашему инструменту Grafana и начать собирать и визуализировать некоторые из наших метрик, команда для использования - &lt;code>kubectl --namespace monitoring port-forward svc/grafana 3000&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Откройте браузер и перейдите по адресу &lt;a href="http://localhost:3000">http://localhost:3000&lt;/a>, вам будет предложено ввести имя пользователя и пароль.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
По умолчанию имя пользователя и пароль для доступа следующие&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Имя пользователя: admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Пароль: admin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Однако при первом входе в систему вам будет предложено ввести новый пароль. На начальном экране или домашней странице вы увидите несколько областей для изучения, а также некоторые полезные ресурсы для ознакомления с Grafana и ее возможностями. Обратите внимание на виджеты &amp;ldquo;Добавить свой первый источник данных&amp;rdquo; и &amp;ldquo;Создать свою первую приборную панель&amp;rdquo;, мы будем использовать их позже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы увидите, что источник данных prometheus уже добавлен в источники данных Grafana, однако, поскольку мы используем minikube, нам нужно также перенаправить prometheus, чтобы он был доступен на нашем localhost, открыв новый терминал, мы можем выполнить следующую команду. &lt;code>kubectl --namespace monitoring port-forward svc/prometheus-k8s 9090&lt;/code> если на главной странице Grafana мы теперь заходим в виджет &amp;ldquo;Add your first data source&amp;rdquo; и отсюда выбираем Prometheus.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для нашего нового источника данных мы можем использовать адрес &lt;a href="http://localhost:9090">http://localhost:9090&lt;/a>, и нам также нужно будет изменить выпадающий список на браузер, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Внизу страницы мы можем нажать кнопку сохранить и протестировать. Это должно дать нам результат, который вы видите ниже, если проброс порта для prometheus работает.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вернитесь на главную страницу и найдите опцию &amp;ldquo;Create your first dashboard&amp;rdquo;, выберите &amp;ldquo;Add a new panel&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Ниже вы увидите, что мы уже собираем данные из нашего источника данных Grafana, но мы хотели бы собирать метрики из нашего источника данных Prometheus, выберите выпадающий список источников данных и выберите наш недавно созданный &amp;ldquo;Prometheus-1&amp;rdquo;&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если затем выбрать браузер Metrics, то появится длинный список метрик, собираемых из Prometheus, связанных с нашим кластером minikube.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для целей демонстрации я собираюсь найти метрику, которая дает нам некоторые данные о наших системных ресурсах, &lt;code>cluster:node_cpu:ratio{}&lt;/code> дает нам некоторые подробности об узлах в нашем кластере и доказывает, что эта интеграция работает.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вас устраивает такая визуализация, нажмите кнопку &amp;ldquo;Применить&amp;rdquo; в правом верхнем углу, и вы добавите этот график на свою приборную панель. Разумеется, вы можете добавлять дополнительные графики и другие диаграммы, чтобы обеспечить нужную вам визуализацию.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Однако мы можем воспользоваться тысячами ранее созданных приборных панелей, которые мы можем использовать, чтобы не изобретать велосипед.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы выполним поиск по Kubernetes, то увидим длинный список готовых приборных панелей, из которых мы можем выбирать.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы выбрали приборную панель Kubernetes API Server и изменили источник данных, чтобы соответствовать нашему недавно добавленному источнику данных Prometheus-1, и мы видим некоторые метрики, отображаемые как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day83_Monitoring21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="оповещение">Оповещение&lt;/h3>
&lt;p>Вы также можете использовать развернутый нами alertmanager для отправки оповещений в slack или другие интеграции, для этого вам нужно перенести сервис alertmanager, используя следующие данные.&lt;/p>
&lt;p>&lt;code>kubectl --namespace monitoring port-forward svc/alertmanager-main 9093&lt;/code>
&lt;a href="http://localhost:9093">http://localhost:9093&lt;/a>&lt;/p>
&lt;p>На этом мы завершаем наш раздел о наблюдаемости. Лично я считаю, что этот раздел подчеркнул, насколько широка эта тема, но в равной степени, насколько она важна для наших ролей, и что будь то метрика, логирование или трассировка, вам необходимо иметь хорошее представление о том, что происходит в наших широких средах в будущем, особенно когда они могут так сильно измениться благодаря автоматизации, которую мы уже рассмотрели в других разделах.&lt;/p>
&lt;p>Далее мы рассмотрим управление данными и то, как принципы DevOps также необходимо учитывать, когда речь идет об управлении данными.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MMVdkzeQ848">Understanding Logging: Containers &amp;amp; Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.devopsonline.co.uk/the-importance-of-monitoring-in-devops/">The Importance of Monitoring in DevOps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/devopscurry/understanding-continuous-monitoring-in-devops-f6695b004e3b">Understanding Continuous Monitoring in DevOps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=Zu53QQuYqJ0">DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4t71iv_9t_4">Top 5 - DevOps Monitoring Tools&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=h4Sl21AKiDg">How Prometheus Monitoring works&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5o37CGlNLr8">Introduction to Prometheus monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.containiq.com/post/promql-cheat-sheet-with-examples">Promql cheat sheet with examples&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=J0csO_Shsj0">Log Management for DevOps | Manage application, server, and cloud logs with Site24x7&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://devops.com/log-management-what-devops-teams-need-to-know/">Log Management what DevOps need to know&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=4X0WLg05ASw">What is ELK Stack?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=5ofsNyHZwWE&amp;amp;t=14s">Fluentd simply explained&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>84. Управление данными</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day84/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day84/</guid><description>&lt;h2 id="введение-управление-данными">Введение: Управление данными&lt;/h2>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day84_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Управление данными - это далеко не новая стена, на которую нужно карабкаться, хотя мы знаем, что данные стали более важными, чем несколько лет назад. Ценные и постоянно меняющиеся, они также могут стать огромным кошмаром, когда мы говорим об автоматизации и непрерывной интеграции, тестировании и развертывании частых выпусков программного обеспечения. Вводим постоянные данные и базовые службы данных, которые часто являются главным виновником, когда что-то идет не так.&lt;/p>
&lt;p>Но прежде чем я перейду к управлению данными в облаке, нам нужно подняться на уровень выше. В ходе этой задачи мы затронули множество различных платформ. Будь то физические, виртуальные, облачные и Cloud-Native, включая Kubernetes, ни одна из этих платформ не обеспечивает отсутствие требований к управлению данными.&lt;/p>
&lt;p>Каким бы ни был наш бизнес, более чем вероятно, что вы найдете базу данных, скрывающуюся где-то в среде, будь то для самой критически важной системы в бизнесе или, по крайней мере, какой-то винтик в цепи хранит эти постоянные данные на каком-то уровне системы.&lt;/p>
&lt;h3 id="devops-и-данные">DevOps и данные&lt;/h3>
&lt;p>Как и в самом начале этой серии статей, где мы говорили о принципах DevOps, для улучшения процесса работы с данными вам необходимо привлечь нужных людей. Это могут быть DBA, но в равной степени это должны быть и люди, которые заботятся о резервном копировании этих сервисов данных.&lt;/p>
&lt;p>Во-вторых, нам также необходимо определить различные типы данных, домены, границы, которые мы связываем с нашими данными. Таким образом, данные не будут рассматриваться изолированно среди администраторов баз данных, инженеров по хранению данных или инженеров, специализирующихся на резервном копировании. Таким образом, вся команда может определить наилучший маршрут действий при разработке и размещении приложений для более широкого бизнеса и сосредоточиться на архитектуре данных, а не на том, о чем подумали позже.&lt;/p>
&lt;p>Это может охватывать множество различных областей жизненного цикла данных, мы можем говорить о вводе данных, где и как данные будут вводиться в наш сервис или приложение? Как сервис, приложение или пользователи будут получать доступ к этим данным. Но затем нам также необходимо понять, как мы будем защищать данные, и как мы будем защищать эти данные.&lt;/p>
&lt;h3 id="управление-данными-101">Управление данными 101&lt;/h3>
&lt;p>Управление данными, согласно &lt;a href="https://www.dama.org/cpages/body-of-knowledge">Data Management Body of Knowledge&lt;/a>, - это &amp;ldquo;разработка, выполнение и контроль планов, политик, программ и практик, которые контролируют, защищают, предоставляют и повышают ценность данных и информационных активов&amp;rdquo;.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Данные - самый важный аспект вашего бизнеса - Данные - это только одна часть вашего бизнеса в целом. Я встречал выражение &amp;ldquo;Данные - это жизненная сила нашего бизнеса&amp;rdquo;, и, скорее всего, это абсолютно верно. Это заставило меня задуматься о том, что кровь очень важна для организма, но сама по себе она ничего не значит, нам все еще нужны аспекты организма, чтобы сделать кровь чем-то другим, кроме жидкости.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Качество данных важно как никогда - Мы должны относиться к данным как к бизнес-активу, что означает, что мы должны уделять им должное внимание, чтобы они работали с нашими принципами автоматизации и DevOps.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Своевременный доступ к данным - Ни у кого не хватит терпения не иметь доступа к нужным данным в нужное время для принятия эффективных решений. Данные должны быть доступны в упорядоченном и своевременном виде независимо от формы представления.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Управление данными должно стать помощником DevOps - я уже упоминал о рационализации, мы должны включить требования к управлению данными в наш цикл и обеспечить не только доступность этих данных, но и другие важные политические меры защиты этих точек данных, а также полностью протестированные модели восстановления.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="dataops">DataOps&lt;/h3>
&lt;p>DataOps и DevOps применяют лучшие практики разработки и эксплуатации технологий для повышения качества, увеличения скорости, снижения угроз безопасности, восхищения клиентов и обеспечения значимой и сложной работы для квалифицированных специалистов. DevOps и DataOps имеют общие цели - ускорить доставку продукта путем автоматизации как можно большего количества этапов процесса. Для DataOps целью является устойчивый конвейер данных и надежные выводы из аналитики данных.&lt;/p>
&lt;p>Некоторые из наиболее распространенных областей более высокого уровня, которые фокусируются на DataOps, - это машинное обучение, большие данные и аналитика данных, включая искусственный интеллект.&lt;/p>
&lt;h3 id="управление-данными---это-управление-информацией">Управление данными - это управление информацией&lt;/h3>
&lt;p>В этом разделе я не буду углубляться в машинное обучение или искусственный интеллект, а сосредоточусь на защите данных с точки зрения защиты информации. Этот подраздел называется &amp;ldquo;Управление данными - это управление информацией&amp;rdquo;, и мы можем считать, что информация = данные.&lt;/p>
&lt;p>Три ключевые области, которые мы должны рассмотреть на этом пути с данными, следующие:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Точность - Убедитесь в том, что производственные данные точны, также нам необходимо убедиться в том, что наши данные в виде резервных копий также работают и протестированы на восстановление, чтобы быть уверенными в том, что в случае сбоя или возникновения причины нам необходимо иметь возможность восстановить работоспособность как можно быстрее.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Последовательность - Если наши службы данных расположены в нескольких местах, то для производства нам необходимо обеспечить последовательность во всех местах расположения данных, чтобы мы получали точные данные. Это также относится к защите данных, когда речь идет о защите этих служб данных, особенно служб данных, нам необходимо обеспечить последовательность на разных уровнях, чтобы убедиться, что мы делаем хорошую чистую копию этих данных для наших резервных копий, реплик и т. д.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Безопасность - контроль доступа, а также просто хранение данных в целом - актуальная тема в настоящее время во всем мире. Убедиться в том, что нужные люди имеют доступ к вашим данным, - первостепенная задача, и это опять же относится к защите данных, где мы должны убедиться, что только необходимый персонал имеет доступ к резервным копиям и возможность восстановления из них, а также клонирования и предоставления других версий бизнес-данных.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Лучшие данные = лучшие решения&lt;/p>
&lt;h3 id="дни-управления-данными">Дни управления данными&lt;/h3>
&lt;p>В течение следующих 6 занятий мы рассмотрим базы данных, резервное копирование и восстановление, аварийное восстановление, мобильность приложений с элементами демонстрации и практической работы.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=01qcYSck1c4&amp;amp;t=217s">Kubernetes Backup and Restore made easy!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=zybLTQER0yY">Kubernetes Backups, Upgrades, Migrations - with Velero&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=W2Z7fbCLSTw&amp;amp;t=520s">7 Database Paradigms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=07EHsPuKXc0">Disaster Recovery vs. Backup: What&amp;rsquo;s the difference?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=hDBlTdzE6Us&amp;amp;t=3s">Veeam Portability &amp;amp; Cloud Mobility&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>85. Службы данных</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day85/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day85/</guid><description>&lt;h2 id="службы-данных">Службы данных&lt;/h2>
&lt;p>Базы данных являются наиболее распространенными службами данных, с которыми мы сталкиваемся в наших средах. На этом занятии я хотел бы рассмотреть некоторые из этих различных типов баз данных и некоторые случаи их использования. Некоторые из них мы уже использовали и видели в ходе решения задачи.&lt;/p>
&lt;p>С точки зрения разработки приложений выбор правильной службы данных или базы данных будет иметь огромное значение для производительности и масштабируемости вашего приложения.&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=W2Z7fbCLSTw">https://www.youtube.com/watch?v=W2Z7fbCLSTw&lt;/a>&lt;/p>
&lt;h3 id="ключ-значение">Ключ-значение&lt;/h3>
&lt;p>База данных &amp;ldquo;ключ-значение&amp;rdquo; - это тип нереляционной базы данных, которая использует простой метод &amp;ldquo;ключ-значение&amp;rdquo; для хранения данных. База данных &amp;ldquo;ключ-значение&amp;rdquo; хранит данные в виде набора пар &amp;ldquo;ключ-значение&amp;rdquo;, в которых ключ служит уникальным идентификатором. И ключи, и значения могут быть любыми, от простых объектов до сложных составных объектов. Базы данных &amp;ldquo;ключ-значение&amp;rdquo; хорошо поддаются разделению и позволяют горизонтальное масштабирование в таких масштабах, которые недостижимы для других типов баз данных.&lt;/p>
&lt;p>Примером базы данных типа &amp;ldquo;ключ-значение&amp;rdquo; является Redis.&lt;/p>
&lt;p>*Redis - это хранилище структур данных в памяти, используемое как распределенная база данных ключей-значений в памяти, кэш и брокер сообщений с возможностью долговечности. Redis поддерживает различные виды абстрактных структур данных, таких как строки, списки, карты, множества, сортированные множества, HyperLogLogs, растровые изображения, потоки и пространственные индексы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day85_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Как вы можете видеть из описания Redis, это означает, что наша база данных работает быстро, но мы ограничены в пространстве в качестве компромисса. Также нет запросов или объединений, что означает, что возможности моделирования данных очень ограничены.&lt;/p>
&lt;p>Лучше всего подходит для:&lt;/p>
&lt;ul>
&lt;li>Кэширование&lt;/li>
&lt;li>Pub/Sub&lt;/li>
&lt;li>Лидерборды&lt;/li>
&lt;li>корзины покупок&lt;/li>
&lt;/ul>
&lt;p>Обычно используется в качестве кэша над другим постоянным слоем данных.&lt;/p>
&lt;h3 id="широкий-столбец">Широкий столбец&lt;/h3>
&lt;p>База данных с широкими колонками - это база данных NoSQL, которая организует хранение данных в гибких колонках, которые могут быть распределены по нескольким серверам или узлам базы данных, используя многомерное отображение для ссылки на данные по столбцам, строкам и временным меткам.&lt;/p>
&lt;p>&lt;em>Cassandra - это бесплатная система управления базами данных NoSQL с открытым исходным кодом, распределенная, с широким хранилищем колонок, разработанная для обработки больших объемов данных на множестве серверов, обеспечивающая высокую доступность без единой точки отказа.&lt;/em>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day85_Data2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нет схемы, что означает возможность работы с неструктурированными данными, однако это может рассматриваться как преимущество для некоторых рабочих нагрузок.&lt;/p>
&lt;p>Лучше всего подходит для:&lt;/p>
&lt;ul>
&lt;li>Временные ряды&lt;/li>
&lt;li>Исторические записи&lt;/li>
&lt;li>Высокая запись, низкий уровень чтения&lt;/li>
&lt;/ul>
&lt;h3 id="документ">Документ&lt;/h3>
&lt;p>База данных документов (также известная как документо-ориентированная база данных или хранилище документов) - это база данных, которая хранит информацию в документах.&lt;/p>
&lt;p>&lt;em>MongoDB - это кросс-платформенная кросс-платформенная программа базы данных, ориентированная на документы. Классифицируемая как NoSQL база данных, MongoDB использует JSON-подобные документы с необязательными схемами. MongoDB разработана компанией MongoDB Inc. и лицензирована по лицензии Server Side Public License.&lt;/em>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day85_Data3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Документальные базы данных NoSQL позволяют предприятиям хранить простые данные без использования сложных кодов SQL. Быстрое хранение без ущерба для надежности.&lt;/p>
&lt;p>Лучше всего подходит для:&lt;/p>
&lt;ul>
&lt;li>Большинство приложений&lt;/li>
&lt;li>Игры&lt;/li>
&lt;li>Интернет вещей&lt;/li>
&lt;/ul>
&lt;h3 id="реляционная">Реляционная&lt;/h3>
&lt;p>Если вы новичок в области баз данных, но знаете о них, то, скорее всего, вы сталкивались с реляционной базой данных.&lt;/p>
&lt;p>Реляционная база данных - это цифровая база данных, основанная на реляционной модели данных, предложенной Э. Ф. Коддом в 1970 году. Система, используемая для ведения реляционных баз данных, - это система управления реляционными базами данных. Многие системы реляционных баз данных имеют возможность использования SQL для запросов и ведения базы данных.&lt;/p>
&lt;p>&lt;em>MySQL - это система управления реляционными базами данных с открытым исходным кодом. Ее название представляет собой комбинацию слов &amp;ldquo;My&amp;rdquo;, имя дочери соучредителя Майкла Видениуса, и &amp;ldquo;SQL&amp;rdquo;, аббревиатура для языка структурированных запросов&lt;/em>.&lt;/p>
&lt;p>MySQL является одним из примеров реляционной базы данных, существует множество других вариантов.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day85_Data4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>При изучении реляционных баз данных часто упоминается термин или аббревиатура &lt;strong>ACID&lt;/strong> (atomicity, consistency, isolation, durability) - это набор свойств транзакций базы данных, призванных гарантировать достоверность данных, несмотря на ошибки, сбои питания и другие казусы. В контексте баз данных последовательность операций с базой данных, удовлетворяющая свойствам ACID (которую можно воспринимать как одну логическую операцию над данными), называется транзакцией. Например, перевод средств с одного банковского счета на другой, даже включающий несколько изменений, таких как дебетование одного счета и кредитование другого, является одной транзакцией.&lt;/p>
&lt;p>Лучше всего подходит для:&lt;/p>
&lt;ul>
&lt;li>Большинство приложений (существует уже много лет, но это не значит, что он лучший).&lt;/li>
&lt;/ul>
&lt;p>Она не идеальна для неструктурированных данных или способности к масштабированию - некоторые из других NoSQL обеспечивают лучшую способность к масштабированию для определенных рабочих нагрузок.&lt;/p>
&lt;h3 id="graph">Graph&lt;/h3>
&lt;p>Графовая база данных хранит узлы и отношения вместо таблиц или документов. Данные хранятся так же, как вы можете набросать идеи на доске. Ваши данные хранятся без ограничения их заранее определенной моделью, что позволяет очень гибко подходить к их осмыслению и использованию.&lt;/p>
&lt;p>&lt;em>Neo4j - это система управления графовыми базами данных, разработанная компанией Neo4j, Inc. Разработчики описывают ее как ACID-совместимую транзакционную базу данных со встроенными средствами хранения и обработки графов&lt;/em>.&lt;/p>
&lt;p>Лучшая для:&lt;/p>
&lt;ul>
&lt;li>Графы&lt;/li>
&lt;li>Графы знаний&lt;/li>
&lt;li>Рекомендательные движки&lt;/li>
&lt;/ul>
&lt;h3 id="поисковая-система">Поисковая система&lt;/h3>
&lt;p>В предыдущем разделе мы фактически использовали базу данных поисковой системы на пути к Elasticsearch.&lt;/p>
&lt;p>База данных поисковой системы - это тип нереляционной базы данных, предназначенной для поиска данных. Базы данных поисковых систем используют индексы для категоризации схожих характеристик данных и облегчения поиска.&lt;/p>
&lt;p>&lt;em>Elasticsearch - это поисковая система, основанная на библиотеке Lucene. Она представляет собой распределенную полнотекстовую поисковую систему с поддержкой многопользовательского доступа, веб-интерфейсом HTTP и документами JSON без схем.&lt;/em>&lt;/p>
&lt;p>Лучшее для:&lt;/p>
&lt;ul>
&lt;li>Поисковые системы&lt;/li>
&lt;li>Typeahead&lt;/li>
&lt;li>Поиск по журналу&lt;/li>
&lt;/ul>
&lt;h3 id="мультимодель">Мультимодель&lt;/h3>
&lt;p>Многомодельная база данных - это система управления базой данных, разработанная для поддержки нескольких моделей данных на основе единого интегрированного бэкенда. В отличие от этого, большинство систем управления базами данных организованы вокруг одной модели данных, которая определяет, как данные могут быть организованы, храниться и манипулироваться. Документ, граф, реляционная модель и модель ключ-значение - это примеры моделей данных, которые могут поддерживаться многомодельной базой данных.&lt;/p>
&lt;p>&lt;em>Fauna - это гибкая, удобная для разработчиков, транзакционная база данных, предоставляемая в виде безопасного и масштабируемого облачного API со встроенным GraphQL.&lt;/em>.&lt;/p>
&lt;p>Лучшее решение для:&lt;/p>
&lt;ul>
&lt;li>Вы не привязаны к выбору модели данных.&lt;/li>
&lt;li>Соответствует стандарту ACID&lt;/li>
&lt;li>Быстрая&lt;/li>
&lt;li>Отсутствие накладных расходов на инициализацию&lt;/li>
&lt;li>Как вы хотите использовать свои данные и предоставить облаку выполнять всю работу.&lt;/li>
&lt;/ul>
&lt;p>На этом мы закончим обзор баз данных, независимо от того, в какой отрасли вы работаете, вы обязательно столкнетесь с одной из областей баз данных. Далее в этом разделе мы рассмотрим некоторые из этих примеров и управление данными и, в частности, защиту и хранение этих сервисов данных.&lt;/p>
&lt;p>Существует масса ресурсов, ссылки на которые я привел ниже, и вы можете потратить 90 лет на глубокое погружение во все типы баз данных и все, что с этим связано.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=OqCK95AS-YE">Redis Crash Course - the What, Why and How to use Redis as your primary database&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=GEg7s3i6Jak">Redis: How to setup a cluster - for beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=JmCn7k0PlV4">Redis on Kubernetes for beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=YjYWsN1vek8">Intro to Cassandra - Cassandra Fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ofme2o29ngU">MongoDB Crash Course&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=-bt_y4Loofg">MongoDB in 100 Seconds&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=OqjJjpjDRLc">What is a Relational Database?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=qw--VYLpxG4">Learn PostgreSQL Tutorial - Full Course for Beginners&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=7S_tz1z_5bA">MySQL Tutorial for Beginners [Full Course]&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=REVkXVxvMQE">What is a graph database? (in 10 minutes)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ZP0NmfyfsoM">What is Elasticsearch?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=2CipVwISumA">FaunaDB Basics - The Database of your Dreams&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ihaB7CqJju0">Fauna Crash Course - Covering the Basics&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>86. Резервное копирование всех платформ</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day86/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day86/</guid><description>&lt;h2 id="резервное-копирование-всех-платформ">Резервное копирование всех платформ&lt;/h2>
&lt;p>В ходе всего этого задания мы обсудили множество различных платформ и сред. Всех их объединяет то, что все они нуждаются в определенном уровне защиты данных!&lt;/p>
&lt;p>Защита данных существует уже много лет, но богатство данных, которые мы имеем сегодня, и ценность, которую эти данные приносят, означает, что мы должны быть уверены не только в устойчивости к сбоям инфраструктуры за счет наличия нескольких узлов и высокой доступности приложений, но мы также должны учитывать, что нам нужна копия этих данных, этих важных данных в безопасном и надежном месте, если произойдет сбой.&lt;/p>
&lt;p>В наши дни мы часто слышим о киберпреступности и программах-выкупах, и не поймите меня неправильно - это серьезная угроза, и я уверен, что вы подвергнетесь атаке программ-выкупов. Это не вопрос &amp;ldquo;если&amp;rdquo;, это вопрос &amp;ldquo;когда&amp;rdquo;. Поэтому еще больше причин убедиться в том, что ваши данные надежно защищены на тот случай, если такое время настанет. Однако самой распространенной причиной потери данных является не выкупное ПО или киберпреступность, а просто случайное удаление!&lt;/p>
&lt;p>Мы все это делали, удаляли то, что не должны были удалять, и тут же сожалели об этом.&lt;/p>
&lt;p>Несмотря на все технологии и автоматизацию, о которых мы говорили в этой статье, требование защищать любые данные с состоянием или даже сложные конфигурации без состояния все еще существует, независимо от платформы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Но мы должны быть в состоянии выполнить эту защиту данных с учетом автоматизации и возможности интеграции в наши рабочие процессы.&lt;/p>
&lt;p>Если мы посмотрим, что такое резервное копирование:&lt;/p>
&lt;p>В информационных технологиях резервная копия или резервное копирование данных - это копия компьютерных данных, снятая и сохраненная в другом месте, чтобы ее можно было использовать для восстановления оригинала после потери данных. Глагольная форма, обозначающая процесс создания такой копии, - &amp;ldquo;резервное копирование&amp;rdquo;, а существительное и прилагательное - &amp;ldquo;резервное копирование&amp;rdquo;.&lt;/p>
&lt;p>Если мы разберем это в самой простой форме, то резервное копирование - это копирование и вставка данных в новое место. Проще говоря, я могу сделать резервную копию прямо сейчас, скопировав файл с диска C: на диск D:, и у меня будет копия на случай, если что-то случится с диском C: или что-то будет неправильно отредактировано в файлах. Я могу вернуться к копии, которая находится на диске D:. Теперь, если мой компьютер умрет, где находятся оба диска C и D, я не буду защищен, поэтому мне придется искать решение или копировать данные вне моей системы, может быть, на NAS-накопитель у себя дома? Но тогда что произойдет, если что-то случится с моим домом, может быть, мне нужно подумать о хранении данных на другой системе в другом месте, может быть, облако - это вариант. Может быть, я могу хранить копии важных файлов в нескольких местах, чтобы снизить риск сбоя?&lt;/p>
&lt;h3 id="3-2-1-методика-резервного-копирования">3-2-1 Методика резервного копирования&lt;/h3>
&lt;p>Сейчас самое время поговорить о правиле 3-2-1 или методологии резервного копирования. На самом деле я провел &lt;a href="https://www.youtube.com/watch?v=5wRt1bJfKBw">lightening talk&lt;/a>, посвященный этой теме.&lt;/p>
&lt;p>Мы уже упоминали о некоторых крайностях того, почему нам нужно защищать наши данные, но ниже перечислены еще несколько:&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это позволяет мне рассказать о методологии 3-2-1. Моя первая копия или резервная копия данных должна быть как можно ближе к моей производственной системе, причина этого заключается в скорости восстановления и, опять же, возвращаясь к исходному пункту о случайном удалении, это будет наиболее распространенной причиной для восстановления. Но я хочу хранить эти данные на подходящем втором носителе за пределами исходной или рабочей системы.&lt;/p>
&lt;p>Затем мы хотим убедиться, что мы также отправляем копию наших данных на внешний носитель или за пределы системы, и здесь нам на помощь приходит второе место, будь то другой дом, здание, центр обработки данных или публичное облако.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
Ответственность за резервное копирование&lt;/p>
&lt;p>Мы, скорее всего, слышали все мифы о том, что резервное копирование не нужно, например, такие как &amp;ldquo;Все не имеет состояния&amp;rdquo;. Если все не имеет состояния, то что тогда бизнес? Нет баз данных? документов? Очевидно, что каждый человек в компании несет определенную ответственность за обеспечение своей защиты, но, скорее всего, именно операционные команды должны обеспечить процесс резервного копирования критически важных приложений и данных.&lt;/p>
&lt;p>Еще одна хорошая фраза: &amp;ldquo;Высокая доступность - это моя резервная копия, мы встроили несколько узлов в наш кластер, поэтому он ни за что не выйдет из строя!&amp;rdquo;, кроме тех случаев, когда вы допускаете ошибку в базе данных, и она реплицируется на все узлы кластера, или когда происходит пожар, наводнение, что означает, что кластер больше недоступен, а вместе с ним и важные данные. Речь идет не об упрямстве, а о том, чтобы быть в курсе данных и сервисов, абсолютно все должны учитывать высокую доступность и отказоустойчивость в своей архитектуре, но это не заменяет необходимости резервного копирования!&lt;/p>
&lt;p>Репликация также может дать нам копию данных вне офиса, и, возможно, упомянутый выше кластер действительно живет в нескольких местах, однако первая случайная ошибка все равно будет реплицирована туда. Но, опять же, требование резервного копирования должно стоять в одном ряду с репликацией приложений или системной репликацией в среде.&lt;/p>
&lt;p>Теперь, учитывая все вышесказанное, можно впасть в крайность и отправить копии данных в слишком большое количество мест, что приведет не только к большим затратам, но и к увеличению риска подвергнуться атаке, поскольку площадь вашей поверхности теперь значительно увеличилась.&lt;/p>
&lt;p>В любом случае, кто заботится о резервном копировании? В каждом предприятии это будет по-разному, но кто-то должен понимать требования к резервному копированию. Но также необходимо понимать план восстановления!&lt;/p>
&lt;h3 id="никому-нет-дела-пока-всем-нет-дела">Никому нет дела, пока всем нет дела&lt;/h3>
&lt;p>Резервное копирование является ярким примером: никто не заботится о резервном копировании, пока вам не понадобится что-то восстановить. Наряду с требованием резервного копирования данных нам также необходимо подумать о том, как мы будем восстанавливать данные!&lt;/p>
&lt;p>В нашем примере с текстовыми документами речь идет об очень маленьких файлах, поэтому возможность копирования туда и обратно является простой и быстрой. Но если речь идет о файлах размером более 100 ГБ, то на это потребуется время. Также необходимо учитывать уровень, на котором требуется восстановление, например, если мы возьмем виртуальную машину.&lt;/p>
&lt;p>У нас есть вся виртуальная машина, у нас есть операционная система, установка приложений, а если это сервер баз данных, то у нас есть и некоторые файлы баз данных. Если мы допустили ошибку и вставили неправильную строку кода в нашу базу данных, мне, вероятно, не нужно восстанавливать всю виртуальную машину, я хочу быть детальным в том, что я восстанавливаю.&lt;/p>
&lt;h3 id="сценарий-резервного-копирования">Сценарий резервного копирования&lt;/h3>
&lt;p>Теперь я хочу начать строить скрипт защиты некоторых данных, в частности, я хочу защитить некоторые файлы на моей локальной машине (в данном случае Windows, но инструмент, который я собираюсь использовать, на самом деле не только бесплатный и с открытым исходным кодом, но и кроссплатформенный). Я хочу убедиться, что они защищены на устройстве NAS, которое у меня есть дома, а также в облачном хранилище Object Storage bucket.&lt;/p>
&lt;p>Я хочу сделать резервную копию этих важных данных, так получилось, что это репозиторий для 90DaysOfDevOps, который, да, также отправляется на GitHub, где вы, вероятно, сейчас это читаете, но что, если моя машина умрет, а GitHub будет закрыт? Как бы кто-нибудь смог прочитать содержимое, а также как бы я мог восстановить эти данные на другом сервисе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Существует множество инструментов, которые могут помочь нам достичь этого, но я собираюсь использовать инструмент под названием &lt;a href="https://kopia.io/">Kopia&lt;/a> - это инструмент резервного копирования с открытым исходным кодом, который позволит нам шифровать, дедупировать и сжимать наши резервные копии, а также отправлять их во многие места.&lt;/p>
&lt;p>Вы найдете релизы для загрузки &lt;a href="https://github.com/kopia/kopia/releases">здесь&lt;/a> на момент написания статьи я буду использовать версию 0.10.6.&lt;/p>
&lt;h3 id="установка-kopia">Установка Kopia&lt;/h3>
&lt;p>Существует Kopia CLI и GUI, мы будем использовать GUI, но знайте, что вы можете иметь и CLI версию для тех Linux серверов, которые не дают вам GUI.&lt;/p>
&lt;p>Я буду использовать &lt;code>KopiaUI-Setup-0.10.6.exe&lt;/code>.&lt;/p>
&lt;p>Действительно быстрая установка, а затем, когда вы откроете приложение, вам предложат выбрать тип хранилища, которое вы хотите использовать в качестве хранилища резервных копий.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="настройка-хранилища">Настройка хранилища&lt;/h3>
&lt;p>Сначала мы хотим создать хранилище на локальном NAS-устройстве и собираемся сделать это с помощью SMB, но можно использовать и NFS.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На следующем экране мы собираемся определить пароль, этот пароль используется для шифрования содержимого хранилища.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда хранилище настроено, мы можем запустить adhoc snapshot, чтобы начать запись данных в хранилище.
[18:26, 16.06.2022] evgschegolkova: &lt;a href="../images/Day86_Data9.ru.png?v1">&lt;/a>&lt;/p>
&lt;p>Прежде всего, нам нужно ввести путь к тому, что мы хотим сделать снимок, и в нашем случае мы хотим сделать копию папки &lt;code>90DaysOfDevOps&lt;/code>. Вскоре мы вернемся к аспекту планирования.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем определить хранение наших снимков.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Возможно, есть файлы или типы файлов, которые мы хотим исключить.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если бы мы хотели определить расписание, мы могли бы сделать это на следующем экране, когда вы впервые создаете этот снимок, это начальная страница для определения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>И вы увидите ряд других настроек, которые могут быть обработаны здесь.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Выберите snapshot now, и данные будут записаны в ваше хранилище.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="внесетевое-резервное-копирование-на-s3">Внесетевое резервное копирование на S3&lt;/h3>
&lt;p>С помощью Kopia мы можем настроить только одно хранилище одновременно. Но через пользовательский интерфейс мы можем проявить творческий подход и, по сути, иметь несколько файлов конфигурации хранилища на выбор для достижения нашей цели - иметь локальную и внесетевую копию в Object Storage.&lt;/p>
&lt;p>Хранилище Object Storage, в которое я решил отправить свои данные, будет Google Cloud Storage. Сначала я вошел в свой аккаунт Google Cloud Platform и создал себе ведро хранения. В моей системе уже был установлен Google Cloud SDK, но выполнение команды &lt;code>gcloud auth application-default login&lt;/code> позволило мне аутентифицироваться в моей учетной записи.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем я использовал CLI Kopia, чтобы показать мне текущее состояние моего хранилища после того, как мы добавили наше SMB хранилище в предыдущих шагах. Я сделал это с помощью команды &lt;code>&amp;quot;C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;quot; --config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config repository status&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы готовы заменить конфигурацию хранилища для целей демонстрации. Если бы мы хотели получить долгосрочное решение для обоих хранилищ, мы бы создали файл &lt;code>smb.config&lt;/code> и файл &lt;code>object.config&lt;/code> и могли бы запускать обе эти команды для отправки наших копий данных в каждое место. Для добавления нашего хранилища мы выполнили команду &lt;code>&amp;quot;C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;quot; --config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config repository create gcs --bucket 90daysofdevops&lt;/code>.&lt;/p>
&lt;p>Приведенная выше команда учитывает, что ведро Google Cloud Storage, которое мы создали, называется &lt;code>90daysofdevops&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда мы создали наше новое хранилище, мы можем снова запустит
[18:27, 16.06.2022] evgschegolkova: &lt;a href="../images/Day86_Data9.ru.png?v1">&lt;/a>&lt;/p>
&lt;p>Прежде всего, нам нужно ввести путь к тому, что мы хотим сделать снимок, и в нашем случае мы хотим сделать копию папки &lt;code>90DaysOfDevOps&lt;/code>. Вскоре мы вернемся к аспекту планирования.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем определить хранение наших снимков.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Возможно, есть файлы или типы файлов, которые мы хотим исключить.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если бы мы хотели определить расписание, мы могли бы сделать это на следующем экране, когда вы впервые создаете этот снимок, это начальная страница для определения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>И вы увидите ряд других настроек, которые могут быть обработаны здесь.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Выберите snapshot now, и данные будут записаны в ваше хранилище.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="внесетевое-резервное-копирование-на-s3-1">Внесетевое резервное копирование на S3&lt;/h3>
&lt;p>С помощью Kopia мы можем настроить только одно хранилище одновременно. Но через пользовательский интерфейс мы можем проявить творческий подход и, по сути, иметь несколько файлов конфигурации хранилища на выбор для достижения нашей цели - иметь локальную и внесетевую копию в Object Storage.&lt;/p>
&lt;p>Хранилище Object Storage, в которое я решил отправить свои данные, будет Google Cloud Storage. Сначала я вошел в свой аккаунт Google Cloud Platform и создал себе ведро хранения. В моей системе уже был установлен Google Cloud SDK, но выполнение команды &lt;code>gcloud auth application-default login&lt;/code> позволило мне аутентифицироваться в моей учетной записи.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем я использовал CLI Kopia, чтобы показать мне текущее состояние моего хранилища после того, как мы добавили наше SMB хранилище в предыдущих шагах. Я сделал это с помощью команды &lt;code>&amp;quot;C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;quot; --config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config repository status&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы готовы заменить конфигурацию хранилища для целей демонстрации. Если бы мы хотели получить долгосрочное решение для обоих хранилищ, мы бы создали файл &lt;code>smb.config&lt;/code> и файл &lt;code>object.config&lt;/code> и могли бы запускать обе эти команды для отправки наших копий данных в каждое место. Для добавления нашего хранилища мы выполнили команду &lt;code>&amp;quot;C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;quot; --config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config repository create gcs --bucket 90daysofdevops&lt;/code>.&lt;/p>
&lt;p>Приведенная выше команда учитывает, что ведро Google Cloud Storage, которое мы создали, называется &lt;code>90daysofdevops&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда мы создали наше новое хранилище, мы можем снова запустить команду &lt;code>&amp;quot;C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;quot; --config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config repository status&lt;/code>, которая теперь покажет конфигурацию хранилища GCS.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Следующее, что нам нужно сделать, это создать снимок и отправить его в наш только что созданный репозиторий. Используя команду &lt;code>&amp;quot;C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;quot; --config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config kopia snapshot create &amp;quot;C:\Users\micha\demo\90DaysOfDevOps&amp;quot;&lt;/code> мы можем запустить этот процесс. В браузере ниже вы можете увидеть, что в нашем ведре Google Cloud Storage теперь есть файлы kopia, основанные на нашей резервной копии.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>С помощью вышеописанного процесса мы смогли решить нашу задачу по отправке важных данных в 2 разных места, одно из которых находится вне помещения в Google Cloud Storage, и, конечно же, у нас все еще есть наша производственная копия данных на другом типе носителя.&lt;/p>
&lt;h3 id="восстановление">Восстановление&lt;/h3>
&lt;p>Восстановление - это еще один важный момент, Kopia дает нам возможность не только восстанавливать данные в существующее местоположение, но и в новое.&lt;/p>
&lt;p>Если мы выполним команду &lt;code>&amp;quot;C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;quot; --config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config snapshot list&lt;/code>, это приведет к списку снимков, которые в настоящее время находятся в нашем настроенном хранилище (GCS).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем смонтировать эти снимки непосредственно из GCS, используя команду ``C:\Program Files\KopiaUI\resources\server\kopia.exe&amp;rsquo;&amp;rsquo; &amp;ndash;config-file=C:\Users\micha\AppData\Roaming\kopia\repository.config mount all Z:`.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day86_Data22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы также можем восстановить содержимое снимка с помощью команды &lt;code>kopia snapshot restore kdbd9dff738996cfe7bcf99b45314e193&lt;/code>.&lt;/p>
&lt;p>Очевидно, что приведенные выше команды очень длинные, и это потому, что я использовал KopiaUI версию kopia.exe, как объяснялось в верхней части руководства, вы можете скачать kopia.exe и поместить в путь, чтобы вы могли просто использовать команду &lt;code>kopia&lt;/code>.&lt;/p>
&lt;p>На следующем занятии мы сосредоточимся на защите рабочих нагрузок в Kubernetes.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=01qcYSck1c4&amp;amp;t=217s">Kubernetes Backup and Restore made easy!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=zybLTQER0yY">Kubernetes Backups, Upgrades, Migrations - with Velero&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=W2Z7fbCLSTw&amp;amp;t=520s">7 Database Paradigms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=07EHsPuKXc0">Disaster Recovery vs. Backup: What&amp;rsquo;s the difference?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=hDBlTdzE6Us&amp;amp;t=3s">Veeam Portability &amp;amp; Cloud Mobility&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>87. Резервное копирование и восстановление</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day87/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day87/</guid><description>&lt;h2 id="резервное-копирование-и-восстановление-своими-руками">Резервное копирование и восстановление своими руками&lt;/h2>
&lt;p>На прошлом занятии мы рассмотрели &lt;a href="https://kopia.io/">Kopia&lt;/a> - инструмент резервного копирования с открытым исходным кодом, который мы использовали для переноса важных данных на локальный NAS и в облачное хранилище объектов.&lt;/p>
&lt;p>В этом разделе я хочу погрузиться в мир резервного копирования Kubernetes. Это платформа, которую мы рассматривали в &lt;a href=".../day49">The Big Picture: Kubernetes&lt;/a> ранее в этой задаче.&lt;/p>
&lt;p>Мы снова будем использовать наш кластер minikube, но на этот раз мы воспользуемся некоторыми из доступных аддонов.&lt;/p>
&lt;h3 id="настройка-кластера-kubernetes">Настройка кластера Kubernetes&lt;/h3>
&lt;p>Для настройки нашего кластера minikube мы выполним команду &lt;code>minikube start --addons volumesnapshots,csi-hostpath-driver --apiserver-port=6443 --container-runtime=containerd -p 90daysofdevops --kubernetes-version=1.21.2&lt;/code>. Вы заметите, что мы используем &lt;code>volumesnapshots&lt;/code> и &lt;code>csi-hostpath-driver&lt;/code>, поскольку мы будем использовать их для создания резервных копий.&lt;/p>
&lt;p>На данном этапе я знаю, что мы еще не развернули Kasten K10, но мы хотим выполнить следующую команду, когда ваш кластер будет запущен, но мы хотим аннотировать класс volumesnapshotclass, чтобы Kasten K10 мог использовать его.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>kubectl annotate volumesnapshotclass csi-hostpath-snapclass \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k10.kasten.io/is-snapshot-class=true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Мы также собираемся изменить класс хранения по умолчанию со стандартного класса хранения по умолчанию на класс хранения csi-hostpath, используя следующее.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>kubectl patch storageclass csi-hostpath-sc -p &amp;#39;{&amp;#34;metadata&amp;#34;: {&amp;#34;annotations&amp;#34;:{&amp;#34;storageclass.kubernetes.io/is-default-class&amp;#34;: &amp;#34;true&amp;#34;}}}}&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl patch storageclass standard -p &amp;#39;{&amp;#34;metadata&amp;#34;: {&amp;#34;annotations&amp;#34;:{&amp;#34;storageclass.kubernetes.io/is-default-class&amp;#34;: &amp;#34;false&amp;#34;}}}}&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="развертывание-kasten-k10">Развертывание Kasten K10&lt;/h3>
&lt;p>Добавьте репозиторий Kasten Helm&lt;/p>
&lt;p>&lt;code>helm repo add kasten https://charts.kasten.io/&lt;/code>.&lt;/p>
&lt;p>Мы могли бы использовать &lt;code>arkade kasten install k10&lt;/code> и здесь, но для целей демонстрации мы выполним следующие шаги. &lt;a href="https://blog.kasten.io/kasten-k10-goes-to-the-arkade">Подробнее&lt;/a>&lt;/p>
&lt;p>Создайте пространство имен и разверните K10, обратите внимание, что это займет около 5 минут&lt;/p>
&lt;p>&lt;code>helm install k10 kasten/k10 --namespace=kasten-io --set auth.tokenAuth.enabled=true --set injectKanisterSidecar.enabled=true --set-string injectKanisterSidecar.namespaceSelector.matchLabels.k10/injectKanisterSidecar=true --create-namespace&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете наблюдать за появлением стручков, выполнив следующую команду.&lt;/p>
&lt;p>&lt;code>kubectl get pods -n kasten-io -w&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы получить доступ к приборной панели K10, откройте новый терминал и выполните следующую команду&lt;/p>
&lt;p>&lt;code>kubectl --namespace kasten-io port-forward service/gateway 8080:8000&lt;/code>.&lt;/p>
&lt;p>Приборная панель Kasten будет доступна по адресу: &lt;code>http://127.0.0.1:8080/k10/#/&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для аутентификации на приборной панели нам теперь нужен токен, который мы можем получить с помощью следующих команд.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>TOKEN_NAME=$(kubectl get secret --namespace kasten-io|grep k10-k10-token | cut -d &amp;#34; &amp;#34; -f 1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN=$(kubectl get secret --namespace kasten-io $TOKEN_NAME -o jsonpath=&amp;#34;{.data.token}&amp;#34; | base64 --decode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;Значение токена: &amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $TOKEN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы берем этот токен и вводим его в браузер, после чего вам будет предложено ввести email и название компании.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы получаем доступ к приборной панели Kasten K10.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="развертывание-нашего-stateful-приложения">Развертывание нашего stateful-приложения&lt;/h3>
&lt;p>Используйте stateful-приложение, которое мы использовали в разделе Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day55_Kubernetes1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вы можете найти конфигурационный файл YAML для этого приложения здесь&lt;a href="../Kubernetes/pacman-stateful-demo.yaml">pacman-stateful-demo.yaml&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем использовать &lt;code>kubectl get all -n pacman&lt;/code>, чтобы проверить появление наших стручков.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В новом терминале мы можем перенаправить фронт-енд pacman. &lt;code>kubectl port-forward svc/pacman 9090:80 -n pacman&lt;/code>.&lt;/p>
&lt;p>Откройте другую вкладку в браузере на &lt;a href="http://localhost:9090/">http://localhost:9090/&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Найдите время, чтобы записать несколько высоких результатов в базе данных backend MongoDB.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="защитите-наши-высокие-баллы">Защитите наши высокие баллы&lt;/h3>
&lt;p>Теперь у нас есть некоторые важные данные в нашей базе данных, и мы не хотим их потерять. Мы можем использовать Kasten K10 для защиты всего приложения.&lt;/p>
&lt;p>Если мы вернемся на вкладку приборной панели Kasten K10, вы увидите, что количество наших приложений увеличилось с 1 до 2 с добавлением нашего приложения pacman в наш кластер Kubernetes.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы нажмете на карточку Applications, вы увидите автоматически обнаруженные приложения в нашем кластере.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В Kasten K10 у нас есть возможность использовать моментальные снимки на основе хранилища, а также экспортировать наши копии в объектные хранилища.&lt;/p>
&lt;p>Для целей демонстрации мы создадим ручной снимок хранилища в нашем кластере, а затем добавим некоторые неавторизованные данные в наши высокие результаты, чтобы имитировать случайную ошибку или нет?&lt;/p>
&lt;p>Для начала мы можем воспользоваться приведенным ниже вариантом ручного снапшота.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для демонстрации я собираюсь оставить все по умолчанию&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Вернувшись на приборную панель, вы получите отчет о состоянии задания в процессе его выполнения, а после завершения оно должно выглядеть так же успешно, как и здесь.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="сценарий-неудачи">Сценарий неудачи&lt;/h3>
&lt;p>Теперь мы можем внести фатальное изменение в наши критически важные данные, просто добавив предписывающее плохое изменение в наше приложение.&lt;/p>
&lt;p>Как вы можете видеть ниже, у нас есть два входа, которые мы, вероятно, не хотим видеть в нашей производственной критически важной базе данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="восстановление-данных">Восстановление данных&lt;/h3>
&lt;p>Очевидно, что это простая демонстрация и в некотором роде нереалистичная, хотя вы видели, как легко можно сбросить базы данных?&lt;/p>
&lt;p>Теперь мы хотим, чтобы список высоких результатов выглядел немного чище и как он выглядел до того, как были допущены ошибки.&lt;/p>
&lt;p>Вернемся в карточку приложений и на вкладку pacman, теперь у нас есть 1 точка восстановления, которую мы можем использовать для восстановления.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>При выборе восстановления вы можете увидеть все связанные снимки и экспорты для этого приложения.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Выберите восстановление и появится боковое окно, мы сохраним настройки по умолчанию и нажмем восстановить.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Подтвердите, что вы действительно хотите, чтобы это произошло.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем вы можете вернуться на приборную панель и просмотреть ход восстановления. Вы должны увидеть что-то вроде этого.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Но более важно то, как выглядит наш список High-Score в нашем критически важном приложении. Вам придется снова запустить проброс портов в pacman, как мы уже рассказывали ранее.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Это очень простая демонстрация, которая лишь слегка касается того, чего Kasten K10 может достичь в области резервного копирования. В будущем я буду создавать более подробные видеоматериалы по некоторым из этих областей. Мы также будем использовать Kasten K10 для освещения некоторых других важных областей управления данными, когда речь идет об аварийном восстановлении и мобильности ваших данных.&lt;/p>
&lt;p>Далее мы рассмотрим согласованность приложений.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=01qcYSck1c4&amp;amp;t=217s">Kubernetes Backup and Restore made easy!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=zybLTQER0yY">Kubernetes Backups, Upgrades, Migrations - with Velero&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=W2Z7fbCLSTw&amp;amp;t=520s">7 Database Paradigms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=07EHsPuKXc0">Disaster Recovery vs. Backup: What&amp;rsquo;s the difference?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=hDBlTdzE6Us&amp;amp;t=3s">Veeam Portability &amp;amp; Cloud Mobility&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>88. Резервное копирование, ориентированное на приложения</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day88/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day88/</guid><description>&lt;h2 id="резервное-копирование-ориентированное-на-приложения">Резервное копирование, ориентированное на приложения&lt;/h2>
&lt;p>В &lt;a href=".../day85">День 85&lt;/a> мы уже потратили некоторое время на обсуждение служб данных или приложений с интенсивным использованием данных, таких как базы данных. Для этих служб данных мы должны подумать о том, как управлять согласованностью, особенно когда речь идет о согласованности приложений.&lt;/p>
&lt;p>В этой статье мы рассмотрим требования к защите данных приложения в последовательной манере.&lt;/p>
&lt;p>Для этого мы выберем инструмент &lt;a href="https://kanister.io/">Kanister&lt;/a>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="представляем-kanister">Представляем Kanister&lt;/h3>
&lt;p>Kanister - это проект с открытым исходным кодом от Kasten, который позволяет нам управлять (резервное копирование и восстановление) данными приложений на Kubernetes. Вы можете развернуть Kanister как helm-приложение в своем кластере Kubernetes.&lt;/p>
&lt;p>Kanister использует пользовательские ресурсы Kubernetes, основные пользовательские ресурсы, которые устанавливаются при развертывании Kanister, следующие&lt;/p>
&lt;ul>
&lt;li>&lt;code>Profile&lt;/code> - целевое место для хранения резервных копий и восстановления. Чаще всего это объектное хранилище.&lt;/li>
&lt;li>&lt;code>Blueprint&lt;/code> - шаги, которые необходимо предпринять для резервного копирования и восстановления базы данных, должны быть сохранены в Blueprint.&lt;/li>
&lt;li>&lt;code>ActionSet&lt;/code> - действия по перемещению целевой резервной копии в наш профиль, а также действия по восстановлению.&lt;/li>
&lt;/ul>
&lt;h3 id="описание-выполнения">Описание выполнения&lt;/h3>
&lt;p>Прежде чем приступить к работе, мы должны рассмотреть рабочий процесс, который использует Kanister для защиты данных приложения. Во-первых, наш контроллер развертывается с помощью helm в нашем кластере Kubernetes, Kanister живет в своем собственном пространстве имен. Мы берем наш Blueprint, для которого существует множество поддерживаемых сообществом Blueprint, мы рассмотрим это более подробно в ближайшее время. Затем у нас есть рабочая нагрузка базы данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы создаем наш ActionSet.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>ActionSet позволяет нам запускать действия, определенные в чертеже, против конкретной службы данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>ActionSet, в свою очередь, использует функции Kanister (KubeExec, KubeTask, Resource Lifecycle) и выталкивает нашу резервную копию в целевое хранилище (Profile).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если действие выполнено/не выполнено, соответствующий статус обновляется в наборе действий.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="развертывание-kanister">Развертывание Kanister&lt;/h3>
&lt;p>И снова мы будем использовать кластер minikube для создания резервной копии приложения. Если у вас он все еще работает с предыдущей сессии, то мы можем продолжать использовать его.&lt;/p>
&lt;p>На момент написания статьи мы имеем версию образа &lt;code>0.75.0&lt;/code>. С помощью следующей команды helm мы установим kanister в наш кластер Kubernetes.&lt;/p>
&lt;p>&lt;code>helm install kanister --namespace kanister kanister/kanister-operator --set image.tag=0.75.0 --create-namespace&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем использовать &lt;code>kubectl get pods -n kanister&lt;/code>, чтобы убедиться, что pod запущен и работает, а также проверить, что наши пользовательские определения ресурсов теперь доступны (Если вы только установили Kanister, то вы увидите выделенные 3)
&lt;p class="md__image">
&lt;img
src="../images/Day88_Data8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="развертывание-базы-данных">Развертывание базы данных&lt;/h3>
&lt;p>Развертывание mysql через helm:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>APP_NAME=my-production-app
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl create ns ${APP_NAME}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helm install mysql-store bitnami/mysql --set primary.persistence.size=1Gi,volumePermissions.enabled=true --namespace=${APP_NAME}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl get pods -n ${APP_NAME} -w
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Заполните базу данных mysql исходными данными, выполнив следующее:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace ${APP_NAME} mysql-store -o jsonpath=&amp;#34;{.data.mysql-root-password}&amp;#34; | base64 --decode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MYSQL_HOST=mysql-store.${APP_NAME}.svc.cluster.local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MYSQL_EXEC=&amp;#34;mysql -h ${MYSQL_HOST} -u root --password=${MYSQL_ROOT_PASSWORD} -DmyImportantData -t&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="создание-mysql-client">Создание MySQL CLIENT&lt;/h3>
&lt;p>Мы запустим другой образ контейнера, который будет выступать в качестве нашего клиента&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>APP_NAME=my-production-app
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl run mysql-client --rm --env APP_NS=${APP_NAME} --env MYSQL_EXEC=&amp;#34;${MYSQL_EXEC}&amp;#34; --env MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} --env MYSQL_HOST=${MYSQL_HOST} --namespace ${APP_NAME} --tty -i --restart=&amp;#39;Never&amp;#39; --image docker.io/bitnami/mysql:latest --command -- bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Примечание: если у вас уже запущен существующий mysql client pod, удалите его с помощью команды
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl delete pod -n ${APP_NAME} mysql-client
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="добавление-данных-в-mysql">Добавление данных в MySQL&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>echo &amp;#34;create database myImportantData;&amp;#34; | mysql -h ${MYSQL_HOST} -u root --password=${MYSQL_ROOT_PASSWORD}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MYSQL_EXEC=&amp;#34;mysql -h ${MYSQL_HOST} -u root --password=${MYSQL_ROOT_PASSWORD} -DmyImportantData -t&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;drop table Accounts&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;create table if not exists Accounts(name text, balance integer); insert into Accounts values(&amp;#39;nick&amp;#39;, 0);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;albert&amp;#39;, 112);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;alfred&amp;#39;, 358);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;beatrice&amp;#39;, 1321);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;bartholomew&amp;#39;, 34);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;edward&amp;#39;, 5589);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;edwin&amp;#39;, 144);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;edwina&amp;#39;, 233);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;insert into Accounts values(&amp;#39;rastapopoulos&amp;#39;, 377);&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;select * from Accounts;&amp;#34; | ${MYSQL_EXEC}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вы должны увидеть некоторые данные, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="создание-профиля-kanister">Создание профиля Kanister&lt;/h3>
&lt;p>Kanister предоставляет CLI, &lt;code>kanctl&lt;/code> и другую утилиту &lt;code>kando&lt;/code>, которая используется для взаимодействия с провайдером объектного хранилища из blueprint и обе эти утилиты.&lt;/p>
&lt;p>&lt;a href="https://docs.kanister.io/tooling.html#tooling">CLI Download&lt;/a>&lt;/p>
&lt;p>Я пошел и создал AWS S3 Bucket, который мы будем использовать в качестве цели профиля и места восстановления. Я буду использовать переменные окружения, чтобы иметь возможность показать вам команды, которые я выполняю с помощью &lt;code>kanctl&lt;/code> для создания нашего профиля kanister.&lt;/p>
&lt;p>&lt;code>kanctl create profile s3compliant --access-key $ACCESS_KEY --secret-key $SECRET_KEY --bucket $BUCKET --region eu-west-2 --namespace my-production-app&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="время-чертежа">Время чертежа&lt;/h3>
&lt;p>Не волнуйтесь, вам не нужно создавать свой собственный с нуля, если только ваш сервис данных не указан в &lt;a href="https://github.com/kanisterio/kanister/tree/master/examples">Примерах Канистера&lt;/a>, но, конечно, вклад сообщества - это то, как этот проект становится известным.&lt;/p>
&lt;p>Мы будем использовать следующую схему.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>apiVersion: cr.kanister.io/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Blueprint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: mysql-blueprint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>actions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> backup:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputArtifacts:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mysqlCloudDump:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyValue:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s3path: &amp;#34;{{ .Phases.dumpToObjectStore.Output.s3path }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phases:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - func: KubeTask
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: dumpToObjectStore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> objects:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mysqlSecret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;#39;{{ index .Object.metadata.labels &amp;#34;app.kubernetes.io/instance&amp;#34; }}&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &amp;#39;{{ .StatefulSet.Namespace }}&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: ghcr.io/kanisterio/mysql-sidecar:0.75.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &amp;#34;{{ .StatefulSet.Namespace }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - errexit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - pipefail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s3_path=&amp;#34;/mysql-backups/{{ .StatefulSet.Namespace }}/{{ index .Object.metadata.labels &amp;#34;app.kubernetes.io/instance&amp;#34; }}/{{ toDate &amp;#34;2006-01-02T15:04:05.999999999Z07:00&amp;#34; .Time | date &amp;#34;2006-01-02T15-04-05&amp;#34; }}/dump.sql.gz&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root_password=&amp;#34;{{ index .Phases.dumpToObjectStore.Secrets.mysqlSecret.Data &amp;#34;mysql-root-password&amp;#34; | toString }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mysqldump --column-statistics=0 -u root --password=${root_password} -h {{ index .Object.metadata.labels &amp;#34;app.kubernetes.io/instance&amp;#34; }} --single-transaction --all-databases | gzip - | kando location push --profile &amp;#39;{{ toJson .Profile }}&amp;#39; --path ${s3_path} -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kando output s3path ${s3_path}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> restore:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inputArtifactNames:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - mysqlCloudDump
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phases:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - func: KubeTask
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: restoreFromBlobStore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> objects:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mysqlSecret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;#39;{{ index .Object.metadata.labels &amp;#34;app.kubernetes.io/instance&amp;#34; }}&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &amp;#39;{{ .StatefulSet.Namespace }}&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: ghcr.io/kanisterio/mysql-sidecar:0.75.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &amp;#34;{{ .StatefulSet.Namespace }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - errexit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - pipefail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s3_path=&amp;#34;{{ .ArtifactsIn.mysqlCloudDump.KeyValue.s3path }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root_password=&amp;#34;{{ index .Phases.restoreFromBlobStore.Secrets.mysqlSecret.Data &amp;#34;mysql-root-password&amp;#34; | toString }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kando location pull --profile &amp;#39;{{ toJson .Profile }}&amp;#39; --path ${s3_path} - | gunzip | mysql -u root --password=${root_password} -h {{ index .Object.metadata.labels &amp;#34;app.kubernetes.io/instance&amp;#34; }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delete:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inputArtifactNames:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - mysqlCloudDump
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phases:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - func: KubeTask
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: deleteFromBlobStore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image: ghcr.io/kanisterio/mysql-sidecar:0.75.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &amp;#34;{{ .Namespace.Name }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - errexit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - pipefail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s3_path=&amp;#34;{{ .ArtifactsIn.mysqlCloudDump.KeyValue.s3path }}&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kando location delete --profile &amp;#39;{{ toJson .Profile }}&amp;#39; --path ${s3_path}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Чтобы добавить его, мы воспользуемся командой &lt;code>kubectl create -f mysql-blueprint.yml -n kanister&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="создаем-наш-actionset-и-защищаем-наше-приложение">Создаем наш ActionSet и защищаем наше приложение&lt;/h3>
&lt;p>Теперь мы создадим резервную копию данных MySQL с помощью ActionSet, определяющего резервное копирование для этого приложения. Создайте ActionSet в том же пространстве имен, что и контроллер.&lt;/p>
&lt;p>&lt;code>kubectl get profiles.cr.kanister.io -n my-production-app&lt;/code> Эта команда покажет нам профиль, который мы ранее создали, здесь может быть настроено несколько профилей, поэтому мы можем захотеть использовать определенные профили для разных ActionSet&amp;rsquo;ов.&lt;/p>
&lt;p>Затем мы создадим наш ActionSet следующей командой с помощью &lt;code>kanctl&lt;/code>.&lt;/p>
&lt;p>&lt;code>kanctl create actionset --action backup --namespace kanister --blueprint mysql-blueprint --statefulset my-production-app/mysql-store --profile my-production-app/s3-profile-dc5zm --secrets mysql=my-production-app/mysql-store&lt;/code>.&lt;/p>
&lt;p>Из приведенной выше команды видно, что мы определяем blueprint, который мы добавили в пространство имен, statefulset в нашем пространстве имен &lt;code>my-production-app&lt;/code>, а также секреты для входа в приложение MySQL.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Проверьте состояние ActionSet, взяв имя ActionSet и используя эту команду &lt;code>kubectl --namespace kanister describe actionset backup-qpnqv&lt;/code>.&lt;/p>
&lt;p>Наконец, мы можем пойти и подтвердить, что теперь у нас есть данные в нашем ведре AWS S3.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="восстановление">Восстановление&lt;/h3>
&lt;p>Нам нужно нанести некоторый ущерб, прежде чем мы сможем что-либо восстановить, мы можем сделать это, уронив нашу таблицу, возможно, это был несчастный случай, а возможно и нет.&lt;/p>
&lt;p>Подключитесь к нашему MySQL pod.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>APP_NAME=my-production-app
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl run mysql-client --rm --env APP_NS=${APP_NAME} --env MYSQL_EXEC=&amp;#34;${MYSQL_EXEC}&amp;#34; --env MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} --env MYSQL_HOST=${MYSQL_HOST} --namespace ${APP_NAME} --tty -i --restart=&amp;#39;Never&amp;#39; --image docker.io/bitnami/mysql:latest --command -- bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Вы можете увидеть, что наша база данных importantdata находится там с помощью &lt;code>echo &amp;quot;SHOW DATABASES;&amp;quot; | ${MYSQL_EXEC}&lt;/code>.&lt;/p>
&lt;p>Затем для удаления мы запустили &lt;code>echo &amp;quot;DROP DATABASE myImportantData;&amp;quot; | ${MYSQL_EXEC}&lt;/code>.&lt;/p>
&lt;p>И подтвердили, что все исчезло, сделав несколько попыток показать нашу базу данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы можем использовать Kanister, чтобы вернуть наши важные данные в рабочее состояние, используя команду &lt;code>kubectl get actionset -n kanister&lt;/code>, чтобы узнать имя нашего ActionSet, который мы взяли ранее. Затем мы создадим ActionSet восстановления для восстановления наших данных, используя &lt;code>kanctl create actionset -n kanister --action restore --from &amp;quot;backup-qpnqv&amp;quot;&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Мы можем подтвердить, что наши данные восстановлены, используя следующую команду для подключения к нашей базе данных.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>APP_NAME=my-production-app
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl run mysql-client --rm --env APP_NS=${APP_NAME} --env MYSQL_EXEC=&amp;#34;${MYSQL_EXEC}&amp;#34; --env MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} --env MYSQL_HOST=${MYSQL_HOST} --namespace ${APP_NAME} --tty -i --restart=&amp;#39;Never&amp;#39; --image docker.io/bitnami/mysql:latest --command -- bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь мы находимся внутри клиента MySQL, мы можем выполнить команду &lt;code>echo &amp;quot;SHOW DATABASES;&amp;quot; | ${MYSQL_EXEC}&lt;/code> и мы увидим, что база данных восстановлена. Мы также можем выполнить команду &lt;code>echo &amp;quot;select * from Accounts;&amp;quot; | ${MYSQL_EXEC}&lt;/code> для проверки содержимого базы данных, и наши важные данные будут восстановлены.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day88_Data17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В следующем посте мы рассмотрим аварийное восстановление в Kubernetes.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=wFD42Zpbfts">Kanister Overview - An extensible open-source framework for app-lvl data management on Kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://community.cncf.io/events/details/cncf-cncf-online-programs-presents-cncf-live-webinar-kanister-application-level-data-operations-on-kubernetes/">Application Level Data Operations on Kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=01qcYSck1c4&amp;amp;t=217s">Kubernetes Backup and Restore made easy!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=zybLTQER0yY">Kubernetes Backups, Upgrades, Migrations - with Velero&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=W2Z7fbCLSTw&amp;amp;t=520s">7 Database Paradigms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=07EHsPuKXc0">Disaster Recovery vs. Backup: What&amp;rsquo;s the difference?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=hDBlTdzE6Us&amp;amp;t=3s">Veeam Portability &amp;amp; Cloud Mobility&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>89. Аварийное восстановление</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day89/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day89/</guid><description>&lt;h2 id="аварийное-восстановление">Аварийное восстановление&lt;/h2>
&lt;p>Мы уже упоминали о том, что различные скрипты сбоев требуют различных требований к восстановлению. Когда речь идет о скриптах пожара, наводнения и крови, мы можем рассматривать их как аварийные ситуации, в которых нам может потребоваться, чтобы наши рабочие нагрузки были запущены в совершенно другом месте как можно быстрее или, по крайней мере, с почти нулевым временем восстановления (RTO).&lt;/p>
&lt;p>Этого можно достичь только в масштабе, если автоматизировать репликацию всего стека приложений в резервную среду.&lt;/p>
&lt;p>Это позволяет быстро переходить от одного облачного региона к другому, облачным провайдерам или между локальной и облачной инфраструктурой.&lt;/p>
&lt;p>Продолжая тему, мы сосредоточимся на том, как этого можно достичь с помощью Kasten K10, используя наш кластер minikube, который мы развернули и настроили несколько занятий назад.&lt;/p>
&lt;p>Затем мы создадим еще один кластер minikube с установленным Kasten K10 в качестве резервного кластера, который теоретически может находиться в любом месте.&lt;/p>
&lt;p>Kasten K10 также имеет встроенную функциональность для обеспечения того, что если что-то случится с кластером Kubernetes, на котором он работает, данные каталога будут реплицированы и доступны на новом &lt;a href="https://docs.kasten.io/latest/operating/dr.html">K10 Disaster Recovery&lt;/a>.&lt;/p>
&lt;h3 id="добавление-объектного-хранилища-в-k10">Добавление объектного хранилища в K10&lt;/h3>
&lt;p>Первое, что нам нужно сделать, это добавить ведро объектного хранилища в качестве целевого местоположения для наших резервных копий. Это не только выступает в качестве удаленного хранилища, но мы также можем использовать его в качестве исходных данных для аварийного восстановления.&lt;/p>
&lt;p>Я очистил ведро S3, которое мы создали для демонстрации Kanister на прошлом занятии.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы получить доступ к приборной панели K10, откройте новый терминал и выполните следующую команду:&lt;/p>
&lt;p>&lt;code>kubectl --namespace kasten-io port-forward service/gateway 8080:8000&lt;/code>.&lt;/p>
&lt;p>Приборная панель Kasten будет доступна по адресу: &lt;code>http://127.0.0.1:8080/k10/#/&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для аутентификации на приборной панели нам теперь нужен токен, который мы можем получить с помощью следующих команд.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>TOKEN_NAME=$(kubectl get secret --namespace kasten-io|grep k10-k10-token | cut -d &amp;#34; &amp;#34; -f 1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN=$(kubectl get secret --namespace kasten-io $TOKEN_NAME -o jsonpath=&amp;#34;{.data.token}&amp;#34; | base64 --decode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;Token value: &amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $TOKEN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы берем этот токен и вводим его в браузер, после чего вам будет предложено ввести email и название компании.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы получаем доступ к приборной панели Kasten K10.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь, когда мы вернулись в приборную панель Kasten K10, мы можем добавить наш профиль местоположения, выберите &amp;ldquo;Настройки&amp;rdquo; в верхней части страницы и &amp;ldquo;Новый профиль&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>На изображении ниже видно, что у нас есть выбор, где будет находиться этот профиль местоположения, мы выбираем Amazon S3, и добавляем наши учетные данные доступа, регион и имя ведра.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы прокрутим окно создания нового профиля вниз, то увидим, что у нас также есть возможность включить неизменяемое резервное копирование, которое использует API блокировки объектов S3. В данном демо мы не будем использовать эту возможность.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Нажмите &amp;ldquo;Сохранить профиль&amp;rdquo;, и теперь вы можете увидеть наш только что созданный или добавленный профиль местоположения, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="создание-политики-для-защиты-приложения-pac-man-в-объектном-хранилище">Создание политики для защиты приложения Pac-Man в объектном хранилище&lt;/h3>
&lt;p>В предыдущем сеансе мы создали только специальный снимок нашего приложения Pac-Man, поэтому нам нужно создать политику резервного копирования, которая будет отправлять резервные копии нашего приложения в наше недавно созданное объектное хранилище.&lt;/p>
&lt;p>Если вы вернетесь на приборную панель и выберете карточку Policy, вы увидите окно, как показано ниже. Выберите &amp;ldquo;Создать новую политику&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Во-первых, мы можем дать нашей политике полезное имя и описание. Мы также можем определить частоту резервного копирования, для демонстрационных целей я использую &amp;ldquo;по требованию&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы хотим включить резервное копирование через Snapshot exports, что означает, что мы хотим отправлять наши данные в наш профиль местоположения. Если у вас их несколько, вы можете выбрать, в какой из них вы хотите отправлять резервные копии.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее выбираем приложение по имени или по меткам, я собираюсь выбрать по имени и все ресурсы.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В разделе Advanced settings мы не будем использовать ничего из этого, но, основываясь на нашем вчерашнем &lt;a href="https://github.com/MichaelCade/90DaysOfDevOps/blob/main/Days/day88">walkthrough of Kanister&lt;/a>, мы можем использовать Kanister как часть Kasten K10 для создания согласованных с приложением копий наших данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Наконец, выберите &amp;ldquo;Создать политику&amp;rdquo;, и теперь вы увидите политику в нашем окне политики.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>В нижней части созданной политики появится &amp;ldquo;Show import details&amp;rdquo;, нам нужна эта строка, чтобы иметь возможность импортировать в наш резервный кластер. Скопируйте ее в безопасное место.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Прежде чем двигаться дальше, нам нужно выбрать &amp;ldquo;run once&amp;rdquo;, чтобы получить резервную копию, отправленную нашему ведру объектного хранилища.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Ниже, на скриншоте просто показано успешное резервное копирование и экспорт наших данных.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data14.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="создание-нового-кластера-minikube-и-развертывание-k10">Создание нового кластера MiniKube и развертывание K10&lt;/h3>
&lt;p>Затем нам нужно развернуть второй кластер Kubernetes, и где это может быть любая поддерживаемая версия Kubernetes, включая OpenShift, в целях обучения мы будем использовать очень бесплатную версию MiniKube с другим названием.&lt;/p>
&lt;p>Используя &lt;code>minikube start --addons volumesnapshots,csi-hostpath-driver --apiserver-port=6443 --container-runtime=containerd -p standby --kubernetes-version=1.21.2&lt;/code> мы можем создать наш новый кластер.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data15.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем развернуть Kasten K10 в этом кластере, используя:&lt;/p>
&lt;p>&lt;code>helm install k10 kasten/k10 --namespace=kasten-io --set auth.tokenAuth.enabled=true --set injectKanisterSidecar.enabled=true --set-string injectKanisterSidecar.namespaceSelector.matchLabels.k10/injectKanisterSidecar=true --create-namespace&lt;/code>.&lt;/p>
&lt;p>Это займет некоторое время, но тем временем мы можем использовать &lt;code>kubectl get pods -n kasten-io -w&lt;/code>, чтобы наблюдать за прогрессом перехода наших pods в статус запущенных.&lt;/p>
&lt;p>Стоит отметить, что поскольку мы используем MiniKube, наше приложение будет запущено, когда мы запустим политику импорта, наш класс хранилища будет таким же на этом резервном кластере. Однако то, что мы рассмотрим на последнем занятии, касается мобильности и трансформации.&lt;/p>
&lt;p>Когда капсулы запущены, мы можем выполнить шаги, которые мы проделали в предыдущих шагах на другом кластере.&lt;/p>
&lt;p>Перенесите порт вперед для доступа к приборной панели K10, откройте новый терминал и выполните следующую команду&lt;/p>
&lt;p>&lt;code>kubectl --namespace kasten-io port-forward service/gateway 8080:8000&lt;/code>.&lt;/p>
&lt;p>Приборная панель Kasten будет доступна по адресу: &lt;code>http://127.0.0.1:8080/k10/#/&lt;/code>&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Для аутентификации на приборной панели нам теперь нужен токен, который мы можем получить с помощью следующих команд.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>TOKEN_NAME=$(kubectl get secret --namespace kasten-io|grep k10-k10-token | cut -d &amp;#34; &amp;#34; -f 1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TOKEN=$(kubectl get secret --namespace kasten-io $TOKEN_NAME -o jsonpath=&amp;#34;{.data.token}&amp;#34; | base64 --decode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &amp;#34;Token value: &amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $TOKEN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь мы берем этот токен и вводим его в браузер, после чего вам будет предложено ввести email и название компании.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы получаем доступ к приборной панели Kasten K10.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day87_Data7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h3 id="импортируем-pac-man-в-новый-кластер-minikube">Импортируем Pac-Man в новый кластер MiniKube&lt;/h3>
&lt;p>На данном этапе мы можем создать политику импорта в резервном кластере, подключиться к резервным копиям объектного хранилища и определить, что и как мы хотим, чтобы выглядело.&lt;/p>
&lt;p>Во-первых, мы добавляем наш профиль местоположения, который мы рассмотрели ранее на другом кластере, используя темный режим, чтобы показать разницу между нашей производственной системой и резервным местоположением DR.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data16.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь вернемся к приборной панели и перейдем на вкладку политик, чтобы создать новую политику.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data17.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Создайте политику импорта в соответствии с приведенным ниже изображением. После завершения мы можем создать политику. Здесь есть опция восстановления после импорта, и некоторые люди могут захотеть воспользоваться этой опцией, которая будет восстановлена в нашем резервном кластере по завершении. У нас также есть возможность изменить конфигурацию приложения при восстановлении, и это то, что я описал в &lt;a href="../day90">Day 90&lt;/a>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data18.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я выбрал импорт по требованию, но вы, очевидно, можете установить расписание, когда вы хотите, чтобы этот импорт происходил. В связи с этим я собираюсь выполнить один раз.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data19.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Ниже вы можете видеть успешное выполнение задания политики импорта.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data20.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если мы теперь вернемся на приборную панель и зайдем в карточку Applications, мы можем выбрать выпадающий список, где вы видите ниже &amp;ldquo;Removed&amp;rdquo;, здесь вы увидите наше приложение. Выберите &amp;ldquo;Восстановить&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data21.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Здесь мы видим доступные нам точки восстановления; это было задание резервного копирования, которое мы выполнили на первичном кластере для нашего приложения Pac-Man.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data22.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Я не буду менять никаких настроек по умолчанию, так как хочу рассмотреть это более подробно на следующем занятии.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data23.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда вы нажмете кнопку &amp;ldquo;Восстановить&amp;rdquo;, появится запрос на подтверждение.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data24.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Ниже мы видим, что мы находимся в резервном кластере, и если мы проверим наши pods, мы увидим, что у нас есть наше запущенное приложение.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data25.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы можем перенаправить порт (в реальной жизни/производственной среде вам не понадобится этот шаг для доступа к приложению, вы будете использовать ingress)&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day89_Data26.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Далее мы рассмотрим мобильность и трансформацию приложений.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=01qcYSck1c4&amp;amp;t=217s">Kubernetes Backup and Restore made easy!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=zybLTQER0yY">Kubernetes Backups, Upgrades, Migrations - with Velero&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=W2Z7fbCLSTw&amp;amp;t=520s">7 Database Paradigms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=07EHsPuKXc0">Disaster Recovery vs. Backup: What&amp;rsquo;s the difference?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=hDBlTdzE6Us&amp;amp;t=3s">Veeam Portability &amp;amp; Cloud Mobility&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>90. Мобильность данных и приложений</title><link>https://romankurnovskii.com/ru/tracks/90daysofdevops/day90/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/90daysofdevops/day90/</guid><description>&lt;h2 id="мобильность-данных-и-приложений">Мобильность данных и приложений&lt;/h2>
&lt;p>День 90 из #90DaysOfDevOps Challenge! В этой заключительной сессии я собираюсь рассказать о мобильности наших данных и приложений. Я сосредоточусь конкретно на Kubernetes, но потребность в мобильности между платформами и между платформами - это то, что является постоянно растущей потребностью и встречается на практике.&lt;/p>
&lt;p>Сценарий использования таков: &amp;ldquo;Я хочу переместить рабочую нагрузку, приложение и данные из одного места в другое&amp;rdquo; по разным причинам, будь то стоимость, риск или предоставление бизнесу более качественных услуг.&lt;/p>
&lt;p>На этом занятии мы возьмем нашу рабочую нагрузку и рассмотрим перемещение рабочей нагрузки Kubernetes с одного кластера на другой, но при этом мы изменим то, как наше приложение находится в целевом месте.&lt;/p>
&lt;p>Фактически, здесь используются многие характеристики, которые мы рассмотрели в статье &lt;a href=".../day89">Аварийное восстановление&lt;/a>&lt;/p>
&lt;h3 id="требование">&lt;strong>Требование&lt;/strong>&lt;/h3>
&lt;p>Наш текущий кластер Kubernetes не справляется со спросом, а наши затраты стремительно растут, поэтому мы хотим переместить наш производственный кластер Kubernetes в место аварийного восстановления, расположенное в другом публичном облаке, которое обеспечит возможность расширения, но при этом будет дешевле. Мы также сможем воспользоваться некоторыми собственными облачными сервисами, доступными в целевом облаке.&lt;/p>
&lt;p>Наше текущее критически важное приложение (Pac-Man) имеет базу данных (MongoDB) и работает на медленном хранилище, мы хотели бы перейти на новый более быстрый уровень хранения.&lt;/p>
&lt;p>Текущий фронтенд Pac-Man (NodeJS) не очень хорошо масштабируется, и мы хотели бы увеличить количество доступных стручков в новом месте.&lt;/p>
&lt;h3 id="приступаем-к-ит">Приступаем к ИТ&lt;/h3>
&lt;p>У нас есть бриф, и на самом деле мы уже импортировали наши импорты в кластер Disaster Recovery Kubernetes.&lt;/p>
&lt;p>Первое, что нам нужно сделать, это удалить операцию восстановления, которую мы выполнили в день 89 для тестирования Disaster Recovery.&lt;/p>
&lt;p>Мы можем сделать это с помощью команды &lt;code>kubectl delete ns pacman&lt;/code> на &amp;ldquo;резервном&amp;rdquo; кластере minikube.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data1.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Чтобы начать работу, зайдите в Kasten K10 Dashboard, выберите карточку Applications. Из выпадающего списка выберите &amp;ldquo;Удаленные&amp;rdquo;&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data2.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Затем мы получим список доступных точек восстановления. Мы выберем ту, которая доступна, так как она содержит важные данные. (В этом примере у нас только одна точка восстановления).&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data3.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Когда мы работали над процессом аварийного восстановления, мы оставили все по умолчанию. Однако эти дополнительные опции восстановления существуют, если у вас есть процесс Disaster Recovery, который требует преобразования вашего приложения. В данном случае нам требуется изменить хранилище и количество реплик.
&lt;p class="md__image">
&lt;img
src="../images/Day90_Data4.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Выберите опцию &amp;ldquo;Применить преобразования к восстановленным ресурсам&amp;rdquo;.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data5.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Так получилось, что два встроенных примера преобразования, которые мы хотим выполнить, соответствуют нашим требованиям.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data6.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Первое требование заключается в том, что на нашем основном кластере мы использовали класс хранения под названием &lt;code>csi-hostpath-sc&lt;/code>, а в нашем новом кластере мы хотим использовать &lt;code>standard&lt;/code>, поэтому мы можем сделать это изменение здесь.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data7.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Выглядит хорошо, нажимаем кнопку create transform внизу.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data8.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Следующее требование заключается в том, что мы хотим масштабировать развертывание нашего фронтенда Pac-Man до &amp;ldquo;5&amp;rdquo;&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data9.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Если вы следите за развитием событий, вы должны увидеть оба наших преобразования, как показано ниже.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data10.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Теперь вы можете видеть на изображении ниже, что мы собираемся восстановить все артефакты, перечисленные ниже, если бы мы захотели, мы могли бы также детализировать то, что мы хотим восстановить. Нажмите кнопку &amp;ldquo;Восстановить&amp;rdquo;&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data11.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Снова нам будет предложено подтвердить действия.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data12.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>И последнее, что мы покажем, если мы вернемся в терминал и посмотрим на наш кластер, вы увидите, что у нас теперь 5 стручков для стручков pacman и наш класс хранения теперь установлен на стандартный, а не на csi-hostpath-sc&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../images/Day90_Data13.ru.png?v1"
id="zoom-default"
alt=""
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;p>Существует множество различных вариантов, которые могут быть достигнуты с помощью трансформации. Это может охватывать не только миграцию, но и аварийное восстановление, скрипты типа тестирования и разработки и т.д.&lt;/p>
&lt;h3 id="api-и-автоматизация">API и автоматизация&lt;/h3>
&lt;p>Я не говорил о возможности использовать API и автоматизировать некоторые из этих задач, но эти опции присутствуют, и во всем пользовательском интерфейсе есть хлебные крошки, которые предоставляют наборы команд для использования API для задач автоматизации.&lt;/p>
&lt;p>Важно отметить, что при развертывании Kasten K10 развертывается внутри кластера Kubernetes и затем может быть вызван через API Kubernetes.&lt;/p>
&lt;p>На этом мы завершаем раздел о хранении и защите данных.&lt;/p>
&lt;h2 id="ресурсы">Ресурсы&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=01qcYSck1c4&amp;amp;t=217s">Kubernetes Backup and Restore made easy!&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=zybLTQER0yY">Kubernetes Backups, Upgrades, Migrations - with Velero&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=W2Z7fbCLSTw&amp;amp;t=520s">7 Database Paradigms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=07EHsPuKXc0">Disaster Recovery vs. Backup: What&amp;rsquo;s the difference?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=hDBlTdzE6Us&amp;amp;t=3s">Veeam Portability &amp;amp; Cloud Mobility&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="закрытие">&lt;strong>Закрытие&lt;/strong>&lt;/h3>
&lt;p>Заканчивая эту задачу, я хочу продолжить просить об обратной связи, чтобы убедиться, что информация всегда актуальна.&lt;/p>
&lt;p>Я также ценю, что есть много тем, которые я не смог охватить или не смог глубже погрузиться в тему DevOps.&lt;/p>
&lt;p>Это означает, что мы всегда можем предпринять еще одну попытку в следующем году и найти еще 90 дней контента и прохождений для работы.&lt;/p>
&lt;h3 id="что-дальше">Что дальше?&lt;/h3>
&lt;p>Во-первых, немного отдохнем от писанины, я начал этот вызов 1 января 2022 года и закончил 31 марта 2022 года в 19:50 BST! Это был тяжелый труд. Но, как я говорю и говорил уже давно, если этот контент поможет одному человеку, то всегда стоит учиться публично!
У меня есть несколько идей, куда двигаться дальше, и я надеюсь, что у него будет жизнь за пределами репозитория GitHub, и мы сможем рассмотреть возможность создания электронной книги и, возможно, даже физической книги.&lt;/p>
&lt;p>Я также знаю, что нам нужно пересмотреть каждый пост и убедиться, что все грамматически правильно, прежде чем делать что-то подобное. Если кто-то знает о том, как использовать формат markdown для печати или создания электронной книги, я буду очень признателен за ответ.&lt;/p>
&lt;p>Как всегда, продолжайте обсуждать вопросы и PR.&lt;/p>
&lt;p>Спасибо!&lt;/p></description></item></channel></rss>