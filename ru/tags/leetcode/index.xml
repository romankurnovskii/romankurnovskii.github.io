<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tags/leetcode/</link><description>Recent content in LeetCode on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Sun, 19 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Легкие</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</guid><description/></item><item><title>Средние</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</guid><description/></item><item><title>Тяжелые</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</guid><description/></item><item><title>LeetCode</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</guid><description>&lt;div id="_react_leetcode_grid_" class='bg-tertiary-bg rounded px-3 py-2 my-2 me-2 text-lg'>&lt;/div>
&lt;script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js">&lt;/script>
&lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js">&lt;/script>
&lt;div id="__react_block_render__">&lt;/div>
&lt;script src="https://romankurnovskii.com/leetcode-grid_5379294449357734749.js" divRender="_react_leetcode_grid_" defer>&lt;/script></description></item><item><title>118. Pascal's Triangle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/pascals-triangle/">LeetCode задача 118&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дано целое число &lt;code>numRows&lt;/code>. Верните первые &lt;code>numRows&lt;/code> строк Треугольника Паскаля.&lt;/p>
&lt;p>В Треугольнике Паскаля каждое число является суммой двух чисел, находящихся непосредственно над ним.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для построения каждой следующей строки можно использовать последнюю строку в текущей итерации. Например, если есть строка &lt;code>[1, 2, 1]&lt;/code>, то следующая строка начнется и закончится с 1, а числа внутри будут получены путем сложения пар чисел: &lt;code>1+2&lt;/code> и &lt;code>2+1&lt;/code>.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Для того чтобы построить Треугольник Паскаля, начнем с первой строки, состоящей только из числа &lt;code>1&lt;/code>. Для каждой следующей строки мы добавляем новое число, равное сумме двух чисел из предыдущей строки, которые стоят непосредственно над ним. Индексы этих двух чисел - это индекс текущего(искомого) числа в новом массиве и предыдущий индекс от него.&lt;/p>
&lt;p>Это повторяем до тех пор, пока не достигнем нужного количества строк.&lt;/p>
&lt;h2 id="алгоритм--абстрактный-алгоритм">Алгоритм / Абстрактный алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем список с первой строкой: &lt;code>[[1]]&lt;/code>.&lt;/li>
&lt;li>Для каждой новой строки:
&lt;ul>
&lt;li>Начинаем строку с числа 1.&lt;/li>
&lt;li>Для каждого числа в предыдущей строке (кроме последнего) добавляем к новой строке сумму этого числа и следующего за ним.&lt;/li>
&lt;li>Заканчиваем строку числом 1.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">generate&lt;/span>(self, numRows: &lt;span style="color:#007020">int&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> triangle &lt;span style="color:#666">=&lt;/span> [[&lt;span style="color:#40a070">1&lt;/span>]] &lt;span style="color:#60a0b0;font-style:italic">#1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, numRows): &lt;span style="color:#60a0b0;font-style:italic">#2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev_row &lt;span style="color:#666">=&lt;/span> triangle[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#60a0b0;font-style:italic"># Последняя строка в текущем треугольнике&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_row &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#60a0b0;font-style:italic"># Новая строка начнется с 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> j &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(prev_row) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>): &lt;span style="color:#60a0b0;font-style:italic"># Добавляем к новой строке сумму пар чисел из предыдущей строки&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_row&lt;span style="color:#666">.&lt;/span>append(prev_row[j] &lt;span style="color:#666">+&lt;/span> prev_row[j &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_row&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Заканчиваем строку числом 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> triangle&lt;span style="color:#666">.&lt;/span>append(new_row) &lt;span style="color:#60a0b0;font-style:italic"># Добавляем новую строку к треугольнику&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> triangle
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/fraction-to-recurring-decimal/">LeetCode problem 166&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.&lt;/p>
&lt;p>This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.&lt;/p>
&lt;p>For example, if we have a fraction 1/3, the decimal representation would be 0.3333&amp;hellip;. In this problem, we need to represent it as &amp;ldquo;0.(3)&amp;rdquo;.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive solution could involve simple division - you divide the numerator by the denominator and convert it to a string. However, this wouldn&amp;rsquo;t account for recurring decimals, and it would only be correct for fractions that result in a finite decimal.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;span class="caption-wrapper">
&lt;img class="caption" style="float: right; width: ; height: 250px; margin: 0px 10px 10px 0px;" src="../../assets/long-division.png" title="" alt="">
&lt;span class="caption-text">&lt;/span>
&lt;/span>
&lt;p>A better approach to solve this problem involves using the &lt;strong>long division method&lt;/strong> and a hash map to keep track of remainders. If the same remainder appears again, it means we have found a repeating sequence.&lt;/p>
&lt;p>In long division, we divide the numerator by the denominator, find the remainder, and then add a zero to the remainder and repeat the process.&lt;/p>
&lt;p>While doing this, if we encounter the same remainder that we have seen before, it means the sequence will start to repeat from here.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="../../assets/166.jpg"
id="zoom-default"
alt="LeetCode problem 166"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>First, handle the simple case where &lt;code>numerator&lt;/code> is divisible by &lt;code>denominator&lt;/code>.&lt;/li>
&lt;li>If the division isn&amp;rsquo;t exact, proceed with the long division method.&lt;/li>
&lt;li>Keep dividing the &lt;code>numerator&lt;/code> by the &lt;code>denominator&lt;/code> and track the remainder.&lt;/li>
&lt;li>Store the remainder and its corresponding index in the decimal part of the result in a dictionary.&lt;/li>
&lt;li>If the remainder repeats, stop the division and enclose the repeating part in parentheses.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">fractionToDecimal&lt;/span>(self, numerator: &lt;span style="color:#007020">int&lt;/span>, denominator: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> numerator &lt;span style="color:#666">%&lt;/span> denominator &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">str&lt;/span>(numerator &lt;span style="color:#666">//&lt;/span> denominator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> integer &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">str&lt;/span>(&lt;span style="color:#007020">abs&lt;/span>(numerator) &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(numerator) &lt;span style="color:#666">%&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder_dict &lt;span style="color:#666">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> remainder &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> remainder &lt;span style="color:#007020;font-weight:bold">in&lt;/span> remainder_dict:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal&lt;span style="color:#666">.&lt;/span>insert(remainder_dict[remainder], &lt;span style="color:#4070a0">&amp;#34;(&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#4070a0">&amp;#34;)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># future index of starting repeating part , i.e. 1.12(345)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder_dict[remainder] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(decimal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">*=&lt;/span> &lt;span style="color:#40a070">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> decimal&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#007020">str&lt;/span>(remainder &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">%=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(denominator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> integer &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#34;.&amp;#34;&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">.&lt;/span>join(decimal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (numerator &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>) &lt;span style="color:#666">^&lt;/span> (denominator &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Check if the result should be negative&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;-&amp;#34;&lt;/span> &lt;span style="color:#666">+&lt;/span> res
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> res
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When doing the division, we are always considering the absolute value of the numerator and denominator. The remainder and the index at which it appears are stored in a dictionary. Whenever a remainder repeats, it means we have found a repeating sequence and the division process is stopped. The repeating part is then enclosed in parentheses.&lt;/p>
&lt;p>Also, note the line if &lt;code>(numerator &amp;lt; 0) ^ (denominator &amp;lt; 0)&lt;/code>:. This is checking if the result should be negative. If either, but not both, of the numerator and denominator are negative, the result should also be negative. Here &lt;code>^&lt;/code> is the bitwise XOR operator in Python, which returns True if exactly one of the conditions is True.&lt;/p>
&lt;p>After doing all this, if the numerator was negative, we add a negative sign to the front of our result. Otherwise, the result is returned as is.&lt;/p>
&lt;video width="100%" controls>
&lt;source src="../../assets/166.mp4" type="video/mp4">
Your browser does not support the video tag.
&lt;/video>
&lt;figcaption>LeetCode 166 Solution&lt;/figcaption></description></item><item><title>190. Reverse Bits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/190/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/190/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reverse-bits/">LeetCode problem&lt;/a>&lt;/p>
&lt;p>This task involves understanding how binary representation works. An unsigned integer is a 32-bit value, where each bit represents a power of 2, from &lt;code>2^0&lt;/code> (the least significant bit) to &lt;code>2^31&lt;/code> (the most significant bit).&lt;/p>
&lt;blockquote>
&lt;p>Unsigned Integers (often called &amp;ldquo;uints&amp;rdquo;) are just like integers (whole numbers) but have the property that they don&amp;rsquo;t have a + or - sign associated with them. Thus they are always non-negative (zero or positive).&lt;/p>&lt;/blockquote>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive solution to this problem could involve converting the number to a binary string, reversing the string, and then converting it back to an integer. However, this would not be the most efficient solution, especially for large numbers.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>Using &lt;a href="https://romankurnovskii.com/en/posts/python-bitwise-operators/">bitwise operation&lt;/a>.&lt;/p>
&lt;p>A better approach is to manipulate the bits of the number directly. This can be done by initializing an empty result and then repeatedly shifting the result to the left to make room for the next bit, and adding the last bit of the input number.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize the result to 0.&lt;/li>
&lt;li>Repeat the following steps 32 times, once for each bit in the input number:
&lt;ol>
&lt;li>Shift the result one bit to the left to make room for the next bit. This can be done with the &lt;code>&amp;lt;&amp;lt;&lt;/code> operator.&lt;/li>
&lt;li>Add the last bit of the input number to the result. This can be done with the &lt;code>&amp;amp;&lt;/code> operator, which performs a bitwise &lt;code>AND&lt;/code> operation.&lt;/li>
&lt;li>Shift the input number one bit to the right to prepare for the next iteration. This can be done with the &lt;code>&amp;gt;&amp;gt;&lt;/code> operator.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>At the end of this process, the result will be the input number with its bits reversed.&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reverseBits&lt;/span>(self, n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">32&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> (result &lt;span style="color:#666">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> (n &lt;span style="color:#666">&amp;amp;&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>result &amp;lt;&amp;lt; 1&lt;/code> shifts the bits of the result one place to the left, (&lt;code>n &amp;amp; 1&lt;/code>) gets the last bit of &lt;code>n&lt;/code>, and &lt;code>n &amp;gt;&amp;gt;= 1&lt;/code> shifts the bits of &lt;code>n&lt;/code> one place to the right.&lt;/p>
&lt;h3 id="understanding">Understanding&lt;/h3>
&lt;p>&lt;strong>Example:&lt;/strong>&lt;/p>
&lt;p>Our number: &lt;code>n = 0110 1010&lt;/code>&lt;/p>
&lt;p>Our aim is to reverse these bits to get &lt;code>0101 0110&lt;/code>.&lt;/p>
&lt;p>In the solution, we initialize our result as &lt;code>0&lt;/code> (&lt;code>0000 0000&lt;/code> in binary). We&amp;rsquo;re going to build this result bit by bit from the binary representation of &lt;code>n&lt;/code>.&lt;/p>
&lt;p>The key point of this operation is this line of code: &lt;code>result = (result &amp;lt;&amp;lt; 1) + (n &amp;amp; 1)&lt;/code>. This line does three things:&lt;/p>
&lt;ol>
&lt;li>&lt;code>(result &amp;lt;&amp;lt; 1)&lt;/code>: This operation is a left shift operation. It shifts all the bits in result one place to the left. In binary, this is &lt;mark>equivalent to multiplying by 2&lt;/mark>. So if result was &lt;code>0101&lt;/code> (5 in decimal), after this operation result will be &lt;code>1010&lt;/code> (10 in decimal). You can see we&amp;rsquo;ve made room for a new bit on the right.&lt;/li>
&lt;li>&lt;code>(n &amp;amp; 1)&lt;/code>: This operation is a bitwise &lt;code>AND&lt;/code> operation. The &lt;code>&amp;amp;&lt;/code> operator compares each binary digit of two integers and returns a new integer, with a &lt;code>1&lt;/code> wherever both numbers had a &lt;code>1&lt;/code> and a &lt;code>0&lt;/code> anywhere else.
&lt;ul>
&lt;li>When &lt;code>n&lt;/code> is ANDed with 1 (&lt;code>0000 0001&lt;/code>), the result will be 1 only if the least significant bit of &lt;code>n&lt;/code> is 1. This effectively gives us the last bit of &lt;code>n&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>(result &amp;lt;&amp;lt; 1) + (n &amp;amp; 1)&lt;/code>: This line combines the above two steps. It shifts the bits of result one place to the left and adds the last bit of n to result.&lt;/li>
&lt;/ol>
&lt;p>Let&amp;rsquo;s work through the first couple of iterations of the loop:&lt;/p>
&lt;ol>
&lt;li>On the first iteration, result is &lt;code>0000 0000&lt;/code>. We shift result left (it remains &lt;code>0000 0000&lt;/code>), and add the last bit of &lt;code>n&lt;/code> (which is 0). So result remains &lt;code>0000 0000&lt;/code>.
&lt;ol>
&lt;li>We then shift &lt;code>n&lt;/code> right to become &lt;code>0011 0101&lt;/code> (&lt;code>n&lt;/code> From &lt;code>0110 1010&lt;/code> to &lt;code>0011 0101&lt;/code>).&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>On the second iteration, result is &lt;code>0000 0000&lt;/code>. We shift result left (it remains &lt;code>0000 0000&lt;/code>), and add the last bit of &lt;code>n&lt;/code> (which is 1). So result becomes &lt;code>0000 0001&lt;/code>. We then shift &lt;code>n&lt;/code> right to become &lt;code>0001 1010&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>If we repeat this process 8 times (for an 8-bit number), or 32 times (for a 32-bit number like in the problem), result will be the binary number formed by reversing the bits of n.&lt;/p>
&lt;h2 id="optimization">Optimization&lt;/h2>
&lt;p>If this function is called many times, way to optimize it is to cache the results for each byte (8 bits) instead of each bit. This would divide the computation time by 8.&lt;/p></description></item><item><title>191. Number of 1 Bits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/191/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/191/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/number-of-1-bits/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an integer value represented in binary format, we need to count the number of &amp;lsquo;1&amp;rsquo; bits in its binary representation.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>The naive solution for this problem would be to convert the binary number into a string and then simply iterate over the string and count the number of &amp;lsquo;1&amp;rsquo;s. However, this solution is not optimal and is not taking advantage of the properties of binary numbers.&lt;/p>
&lt;h2 id="algorithm">Algorithm&lt;/h2>
&lt;p>The optimal solution for this problem involves using &lt;a href="https://romankurnovskii.com/en/posts/python-bitwise-operators/">&lt;mark>bitwise operation&lt;/mark>&lt;/a>. Bitwise operations are a type of operation that works on the binary representation of numbers.&lt;/p>
&lt;p>Specifically, we&amp;rsquo;ll use the bitwise &lt;code>AND&lt;/code> operator (&lt;code>&amp;amp;&lt;/code>) and bitwise right shift operator (&lt;code>&amp;gt;&amp;gt;&lt;/code>).&lt;/p>
&lt;p>To count the number of 1 bits in the binary representation of a number, we can &lt;code>AND&lt;/code> the number with 1. If the result is 1, that means the least significant bit of the number is 1. We then right shift the number by 1 bit to check the next bit. We continue this process until the number becomes 0.&lt;/p>
&lt;h2 id="high-level-solution-logic">High Level Solution Logic&lt;/h2>
&lt;ol>
&lt;li>Initialize a counter variable to 0.&lt;/li>
&lt;li>While the number is not 0:
&lt;ul>
&lt;li>AND the number with 1.&lt;/li>
&lt;li>If the result is 1, increment the counter.&lt;/li>
&lt;li>Right shift the number by 1 bit.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Return the counter.&lt;/li>
&lt;/ol>
&lt;h2 id="python-code">Python Code&lt;/h2>
&lt;p>Here&amp;rsquo;s the Python code for this solution:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">hammingWeight&lt;/span>(self, n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bits &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> n:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bits &lt;span style="color:#666">+=&lt;/span> n &lt;span style="color:#666">&amp;amp;&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> bits
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="example">Example&lt;/h2>
&lt;p>Let&amp;rsquo;s say we have a binary number &lt;code>00000001011&lt;/code>, which is &lt;code>11&lt;/code> in decimal.&lt;/p>
&lt;ol>
&lt;li>Initialize a counter variable to 0. So, &lt;code>bits = 0&lt;/code>.&lt;/li>
&lt;li>Start the loop. The number &lt;code>n&lt;/code> is &lt;strong>11&lt;/strong>, which is not &lt;strong>0&lt;/strong>, so we proceed.&lt;/li>
&lt;li>We perform the operation &lt;code>n &amp;amp; 1&lt;/code>. In binary, &lt;code>1011 &amp;amp; 0001&lt;/code> equals &lt;code>0001&lt;/code>, which is 1 in decimal. This is because the bitwise &lt;code>AND&lt;/code> operation returns 1 only if both bits being compared are 1. So, since our least significant bit is 1, our &lt;code>AND&lt;/code> operation returns 1. We increment our counter bits by 1. Now &lt;code>bits = 1&lt;/code>.&lt;/li>
&lt;li>We right shift our number by 1 bit using the operation &lt;code>n &amp;gt;&amp;gt;= 1&lt;/code>. This operation moves all the bits of the number one position to the right.
&lt;ol>
&lt;li>Our number &lt;code>1011&lt;/code> becomes 101 in binary or 5 in decimal.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Our updated number &lt;code>n&lt;/code> is 5, which is not 0, so we repeat the process.&lt;/li>
&lt;li>Now, &lt;code>n &amp;amp; 1&lt;/code> is &lt;code>101 &amp;amp; 001&lt;/code> equals 001, which is 1 in decimal.
&lt;ol>
&lt;li>So, we increment our counter bits by 1.&lt;/li>
&lt;li>Now bits = 2.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>We right shift our number by 1 bit. Our number 101 becomes 10 in binary or 2 in decimal.
&lt;ol>
&lt;li>Our updated number &lt;code>n&lt;/code> is 2, which is not 0, so we repeat the process.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Now, &lt;code>n &amp;amp; 1&lt;/code> is &lt;code>10 &amp;amp; 01&lt;/code> equals &lt;code>00&lt;/code>, which is 0 in decimal. So, we do not increment our counter bits.&lt;/li>
&lt;li>We right shift our number by 1 bit. Our number 10 becomes 1 in binary.
&lt;ol>
&lt;li>Our updated number &lt;code>n&lt;/code> is 1, which is not 0, so we repeat the process.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Now, &lt;code>n &amp;amp; 1&lt;/code> is &lt;code>1 &amp;amp; 1&lt;/code> equals 1. So, we increment our counter bits by 1. &lt;code>Now bits = 3&lt;/code>.&lt;/li>
&lt;li>We right shift our number by 1 bit. Our number 1 becomes 0 in binary.&lt;/li>
&lt;li>Our updated number &lt;code>n&lt;/code> is 0, which stops the loop.&lt;/li>
&lt;/ol></description></item><item><title>202. Happy Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/202/</link><pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/202/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/happy-number/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>In this problem, we are given a number &lt;code>n&lt;/code>. We have to determine whether this number is a &amp;ldquo;happy&amp;rdquo; number or not. A happy number is a number defined by the following process:&lt;/p>
&lt;ol>
&lt;li>Starting with any positive integer, replace the number by the sum of the squares of its digits.&lt;/li>
&lt;li>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.&lt;/li>
&lt;li>Those numbers for which this process ends in 1 are happy.&lt;/li>
&lt;/ol>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive solution would be to follow the process as stated in the problem description and use a data structure such as a set to check for repetitions indicating a cycle. If during the process, the number becomes 1, we can conclude that the number is happy. However, if we encounter a number that was already visited, it means we are stuck in a cycle, and the number is not happy.&lt;/p>
&lt;ol>
&lt;li>We calculate the sum of squares of the digits of n in each iteration, and check if this sum is 1 or a number we&amp;rsquo;ve seen before.&lt;/li>
&lt;li>If it&amp;rsquo;s 1, we return true.&lt;/li>
&lt;li>If it&amp;rsquo;s a number we&amp;rsquo;ve seen before, we return false, as this means we&amp;rsquo;re in an endless loop.&lt;/li>
&lt;/ol>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>However, continuously checking if a number was already visited can be costly in terms of time complexity. A more efficient way to detect cycles is to use the Floyd Cycle detection algorithm (also known as the &lt;a href="https://www.youtube.com/watch?v=S5TcPmTl6ww">&amp;ldquo;Tortoise and the Hare&amp;rdquo; algorithm&lt;/a>).&lt;/p>
&lt;p>This algorithm allows us to detect a cycle in the sequence without having to store all previously seen numbers, making it more efficient in terms of space usage.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>Floyd Cycle detection algorithm works by moving two pointers at different speeds - a slow pointer (tortoise) and a fast pointer (hare). If there is a cycle, the fast pointer will eventually meet the slow pointer again.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two pointers slow and fast as &lt;code>n&lt;/code>.&lt;/li>
&lt;li>Replace
&lt;ol>
&lt;li>slow with the sum of the squares of its digits,&lt;/li>
&lt;li>and fast with the sum of squares of the next number in the sequence.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>If fast becomes 1, return &lt;code>True&lt;/code>. - &lt;code>n&lt;/code> is a happy number.&lt;/li>
&lt;li>If slow meets fast and the number is not 1, return &lt;code>False&lt;/code>. - &lt;code>n&lt;/code> is not a happy number as we have detected a cycle.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">isHappy&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">get_next&lt;/span>(num): &lt;span style="color:#60a0b0;font-style:italic"># get the next number in the sequence&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> num &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># get the last digit of the number and the remaining part&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num, digit &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">divmod&lt;/span>(num, &lt;span style="color:#40a070">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total_sum &lt;span style="color:#666">+=&lt;/span> digit &lt;span style="color:#666">**&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> total_sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slow &lt;span style="color:#666">=&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast &lt;span style="color:#666">=&lt;/span> get_next(n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> fast &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> slow &lt;span style="color:#666">!=&lt;/span> fast:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slow &lt;span style="color:#666">=&lt;/span> get_next(slow)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast &lt;span style="color:#666">=&lt;/span> get_next(get_next(fast))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited&lt;span style="color:#666">.&lt;/span>add(slow)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> fast &lt;span style="color:#007020;font-weight:bold">in&lt;/span> visited:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> fast &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this solution, the function &lt;code>get_next(n)&lt;/code> is used to get the next number in the sequence by replacing &lt;code>n&lt;/code> with the sum of the squares of its digits.&lt;/p>
&lt;p>We initialize &lt;code>slow&lt;/code> and &lt;code>fast&lt;/code> to &lt;code>n&lt;/code> and &lt;code>get_next(n)&lt;/code> respectively.&lt;/p>
&lt;p>Then, until &lt;code>fast&lt;/code> equals 1 or &lt;code>slow&lt;/code> catches up to &lt;code>fast&lt;/code>, we continue moving &lt;code>slow&lt;/code> one step at a time and &lt;code>fast&lt;/code> two steps at a time. If &lt;code>fast&lt;/code> equals 1 at the end of the loop, &lt;code>n&lt;/code> is a happy number.&lt;/p></description></item><item><title>229. Majority Element II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/229/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/229/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/majority-element-ii/">LeetCode problem 229&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an integer array of size &lt;code>n&lt;/code>, find all elements that appear more than ⌊ n/3 ⌋ times.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>The immediate solution would involve using a hashmap or dictionary to track the occurrence of each number in the array. After which, we can iterate over the dictionary to find numbers whose occurrences are greater than &lt;code>n/3&lt;/code>.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>There can be at most one or two majority elements which appear more than &lt;code>n/3&lt;/code> times in the array.&lt;/li>
&lt;li>Employ the &lt;a href="https://www.topcoder.com/thrive/articles/boyer-moore-majority-vote-algorithm">Boyer-Moore Voting Algorithm&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>We can apply a variation of the Boyer-Moore Voting Algorithm. The fundamental insight behind this algorithm is that at each step, we can discard a certain portion of the elements and still have the same majority elements.&lt;/p>
&lt;p>For this problem, we&amp;rsquo;ll maintain two counters and two majority candidates. This is because there could be at most two majority elements.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two counters and two majority candidates.&lt;/li>
&lt;li>Parse the array:
&lt;ol>
&lt;li>If the current element matches either of the majority candidates, increase the respective counter.&lt;/li>
&lt;li>If both counters are zero, reset both majority candidates and counters.&lt;/li>
&lt;li>Otherwise, decrease both counters.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Reassess the majority candidates by verifying their counts.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">majorityElement&lt;/span>(self, nums: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> List[&lt;span style="color:#007020">int&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cand1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Two majority candidates and their counters&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cand2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> num &lt;span style="color:#007020;font-weight:bold">in&lt;/span> nums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> num &lt;span style="color:#666">==&lt;/span> cand1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1 &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> num &lt;span style="color:#666">==&lt;/span> cand2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count2 &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> count1 &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cand1, count1 &lt;span style="color:#666">=&lt;/span> num, &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> count2 &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cand2, count2 &lt;span style="color:#666">=&lt;/span> num, &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1, count2 &lt;span style="color:#666">=&lt;/span> count1 &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>, count2 &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums) &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#40a070">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> cand &lt;span style="color:#007020;font-weight:bold">in&lt;/span> (cand1, cand2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums&lt;span style="color:#666">.&lt;/span>count(cand) &lt;span style="color:#666">&amp;gt;&lt;/span> count:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res&lt;span style="color:#666">.&lt;/span>append(cand)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> res
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/find-the-celebrity/">LeetCode задача 277&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?&lt;/p>
&lt;p>Имплементируйте функцию &lt;code>int findCelebrity(n)&lt;/code>, которая вернет знаменитость если она есть, иначе вернёт -1.&lt;/p>
&lt;p>Вам дана функция &lt;code>bool knows(a, b)&lt;/code>, которая скажет вам, знает ли &lt;code>a&lt;/code> человека &lt;code>b&lt;/code>.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем переменную &lt;code>candidate&lt;/code> значением 0.&lt;/li>
&lt;li>Используем один проход для выявления кандидата. Если &lt;code>knows(candidate, i)&lt;/code> возвращает &lt;code>True&lt;/code>, переключаем &lt;code>candidate&lt;/code> на &lt;code>i&lt;/code>.&lt;/li>
&lt;li>Второй проход для проверки, является ли &lt;code>candidate&lt;/code> знаменитостью.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findCelebrity&lt;/span>(self, n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidate &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">#1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> knows(candidate, i):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidate &lt;span style="color:#666">=&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n): &lt;span style="color:#60a0b0;font-style:italic">#3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> i &lt;span style="color:#666">!=&lt;/span> candidate &lt;span style="color:#007020;font-weight:bold">and&lt;/span> (knows(candidate, i) &lt;span style="color:#007020;font-weight:bold">or&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> knows(i, candidate)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> candidate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/move-zeroes/">LeetCode задача&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан целочисленный массив &lt;code>nums&lt;/code>. Нам необходимо переместить все &lt;code>0&lt;/code> в конец массива, сохраняя относительный порядок ненулевых элементов.&lt;/p>
&lt;p>&lt;em>Примечание:&lt;/em> вы должны сделать это на месте, без создания копии массива.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Используйте два указателя: один будет указывать на текущий элемент, а другой будет указывать на первое место в массиве, куда можно поместить ненулевой элемент.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Мы можем использовать два указателя: один для прохода по массиву и другой для отслеживания местоположения, куда следует поместить следующий ненулевой элемент. Этот метод позволяет нам сделать минимальное количество операций и изменений в массиве.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем два указателя на начало массива.
&lt;ol>
&lt;li>Первый указатель - это индексы массива. Второй с начальным значением 0,&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Используя первый указатель, проходим по массиву.
&lt;ol>
&lt;li>Если текущий элемент не равен нулю, помещаем его на позицию, указанную вторым указателем (меняем значения местами), и перемещаем второй указатель на одну позицию вперед.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>После завершения прохода, все числа после второго указателя должны быть установлены в 0.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">moveZeroes&lt;/span>(nums: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Указатель для ненулевых элементов&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[i] &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># Если текущий элемент не 0, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums[i], nums[pos] &lt;span style="color:#666">=&lt;/span> nums[pos], nums[i] &lt;span style="color:#60a0b0;font-style:italic"># меняем его местами с элементом на позиции pos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>332. Reconstruct Itinerary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/332/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/332/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reconstruct-itinerary/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from &amp;ldquo;JFK&amp;rdquo;, thus, the itinerary must begin with &amp;ldquo;JFK&amp;rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>One naive solution would be to use backtracking and try all possible combinations of tickets to form a valid itinerary. While this could work for small inputs, it&amp;rsquo;s not efficient for larger numbers of tickets.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Consider the tickets as a directed graph where each airport is a node, and a ticket between two airports represents a directed edge.&lt;/li>
&lt;li>For this problem, instead of a depth-first traversal, the solution employs an iterative approach using a stack.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>We can visualize this problem as a directed graph traversal task. Every ticket is a directed edge between two airports. The challenge is to find a path that uses all the directed edges and starts from JFK.&lt;/p>
&lt;p>The stack is an essential data structure for this solution, and here&amp;rsquo;s why:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A stack helps in maintaining the path. When visiting an airport, we&amp;rsquo;re not sure if this path will lead to a solution (because it might end up in a dead-end). Hence, pushing the airports to the stack gives us the flexibility to backtrack easily (by popping out the last visited airport) if we reach a dead-end.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>When all destinations from an airport are exhausted, it means we have found the end of that particular path. At this moment, by adding the airport to our final result and removing it from the stack, we backtrack to find the remaining itinerary.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The graph for this solution is a dictionary (specifically, a &lt;code>defaultdict&lt;/code> for ease of handling non-existing keys). The keys of this dictionary are the source airports, and the values are a list of destination airports. Importantly, these destinations are sorted in reverse lexicographical order because we will be utilizing the &lt;code>pop()&lt;/code> function to retrieve and remove the last element from these lists. This ensures that we always get the smallest lexical destination available without any extra computational overhead.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Convert the given list of tickets into a graph where each node (airport) points to a list of its destinations.&lt;/li>
&lt;li>Sort the destinations in reverse lexicographical order to aid in retrieving the smallest lexical order when using pop().&lt;/li>
&lt;li>Use a stack to iteratively traverse the graph, always trying to go to the smallest lexical destination possible.&lt;/li>
&lt;li>When stuck at a node (airport) with no unvisited outbound paths, add it to the final itinerary.&lt;/li>
&lt;li>Continue the process until the stack is empty.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> defaultdict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findItinerary&lt;/span>(tickets):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph &lt;span style="color:#666">=&lt;/span> defaultdict(&lt;span style="color:#007020">list&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Convert tickets into a graph with destinations for each departure&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> src, dest &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(tickets, reverse&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">True&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[src]&lt;span style="color:#666">.&lt;/span>append(dest)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#4070a0">&amp;#34;JFK&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> stack: &lt;span style="color:#60a0b0;font-style:italic"># Traverse the graph using the stack&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> graph[stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>]]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append(graph[stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>]]&lt;span style="color:#666">.&lt;/span>pop())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(stack&lt;span style="color:#666">.&lt;/span>pop())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result[::&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#60a0b0;font-style:italic"># The result will be in reverse order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># because of the way nodes are added to the result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>343. Integer Break</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/343/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/343/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/integer-break/">LeetCode problem 343&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a positive integer &lt;code>n&lt;/code>, our task is to divide it into the sum of &lt;code>k&lt;/code> positive integers, where $k \geq 2$, in such a way that the product of these integers is maximized. Our goal is to determine the maximum possible product.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A straightforward or naive way to solve this would be to consider all potential combinations to divide the number &lt;code>n&lt;/code> and calculate the product for each division. This method, while comprehensive, would be inefficient and impractical for larger values of &lt;code>n&lt;/code>.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Try to break down &lt;code>n&lt;/code> into smaller parts and observe the pattern of the results.&lt;/li>
&lt;li>The number 3 plays a significant role, so try to understand its impact on the problem.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>A pattern emerges when observing how the number can be broken down to maximize the product: the number 3 becomes significant. This realization stems from the fact that 3 multiplied by any number $x \geq 3$ is always greater than $x \times 2$ and $x \times 1$.&lt;/p>
&lt;p>The only exception is 4, where $2 \times 2$ is preferable to 3 and 1.&lt;/p>
&lt;p>Therefore, the optimized approach becomes:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>When $n = 2$, the answer is 1 (because $1 \times 1 = 1$).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>For $n = 3$, the answer becomes 2 (as $2 \times 1 = 2$).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If $n = 4$, the result is 4 (as $2 \times 2 = 4$).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>For any $n &amp;gt; 4$, we can repeatedly subtract 3 from &lt;code>n&lt;/code> and multiply the resulting product by 3.&lt;/p>
&lt;p>After all the 3s are extracted, the remaining &lt;code>n&lt;/code> (which will be less than 4) will contribute its optimal value to the product (either 1, 2, or 4).&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">integerBreak&lt;/span>(n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> n &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">2&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># base cases&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> n &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">3&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> n &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">4&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> product &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> n &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">4&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># As long as n is greater than 4,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> product &lt;span style="color:#666">*=&lt;/span> &lt;span style="color:#40a070">3&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># increase the product by a factor of 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">3&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># and keep reducing n by 3 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> product &lt;span style="color:#666">*=&lt;/span> n &lt;span style="color:#60a0b0;font-style:italic"># Multiply the remaining value of n to the product&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> product
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>389. Find the Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/389/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/389/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/find-the-difference/">LeetCode problem 389&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given two strings &lt;code>s&lt;/code> and &lt;code>t&lt;/code>, the string &lt;code>t&lt;/code> is generated by shuffling the characters of &lt;code>s&lt;/code> and adding one additional character at a random position. The task is to identify and return that extra character.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive solution would involve comparing the characters in both strings one by one to detect the extra character in &lt;code>t&lt;/code>. This method is not efficient as it could take a linear amount of time for strings of considerable lengths.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Counting occurrences of characters can help detect discrepancies.&lt;/li>
&lt;li>The &lt;code>collections.Counter&lt;/code> class is a handy tool in Python for counting elements in a collection.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>We can utilize Python&amp;rsquo;s &lt;code>collections.Counter&lt;/code> to help us find the difference between the two strings. The &lt;code>Counter&lt;/code> allows us to quickly count the occurrences of each character in the string &lt;code>s&lt;/code>. We then iterate over the string &lt;code>t&lt;/code> and decrement the count for each character encountered. The character that results in a count of &lt;code>-1&lt;/code> is the one that was added to &lt;code>t&lt;/code>.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Create a Counter for the string &lt;code>s&lt;/code>.&lt;/li>
&lt;li>Iterate over each character &lt;code>c&lt;/code> in string &lt;code>t&lt;/code>.&lt;/li>
&lt;li>Decrement the count for character &lt;code>c&lt;/code> in the Counter.&lt;/li>
&lt;li>If the count for any character becomes &lt;code>-1&lt;/code>, that character is the one added to string &lt;code>t&lt;/code>.&lt;/li>
&lt;li>Return the character found in the previous step.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findTheDifference&lt;/span>(self, s: &lt;span style="color:#007020">str&lt;/span>, t: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> Counter(s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> c &lt;span style="color:#007020;font-weight:bold">in&lt;/span> t:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count[c] &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> count[c] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/path-sum-iii/">LeetCode задача 437&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан корень бинарного дерева и целое число &lt;code>targetSum&lt;/code>. Верните количество путей, где сумма значений вдоль пути равна &lt;code>targetSum&lt;/code>.&lt;/p>
&lt;p>Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня. При этом на каждом уровне рекурсии мы проверяем, есть ли путь от &lt;strong>текущего узла&lt;/strong>, сумма которого равна &lt;code>targetSum&lt;/code>.&lt;/p>
&lt;p>&lt;mark>Часть 1: Обновлять корневой узел на каждом уровне рекурсии&lt;/mark>&lt;/p>
&lt;p>Под &lt;strong>текущим узлом&lt;/strong> будем иметь ввиду корневой узел (&lt;code>root&lt;/code>).&lt;/p>
&lt;p>Например, при дереве с узлами: &lt;code>[10,5,-3,3,2,null,11,3,-2,null,1]&lt;/code> и &lt;code>targetSum=8&lt;/code>&lt;/p>
&lt;p>&lt;strong>Итого каждый узел будет в какой-то момент корневым узлом.&lt;/strong>&lt;/p>
&lt;p>Текущий корневой узел (&lt;code>root&lt;/code>) = 10.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Мы обходим все возможные отрезки от текущего&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Сверяем суммы этих отрезков с &lt;code>targetSum&lt;/code> :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span> ([10], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3, -2], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 2], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 2, 1], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>После того как рассмотрели все возможные отрезки от текущего &lt;code>root=10&lt;/code>, мы идем рассматривать все возможные отрезки от нового &lt;code>root&lt;/code>.&lt;/p>
&lt;p>Новые &lt;code>root&lt;/code> становятся &lt;code>root.left&lt;/code> и &lt;code>root.right&lt;/code>.&lt;/p>
&lt;p>Тогда следующая итерация будет выглядеть следующим образом:&lt;/p>
&lt;p>Текущий корневой узел (&lt;code>root&lt;/code>) = 5.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span> ([5], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([5, 3], 8) !! нашли один отрезок
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([5, 3, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>&lt;mark>Часть 2: Правильный подсчет сумм от корня дерева до текущего узла&lt;/mark>&lt;/p>
&lt;p>Когда корневой узел был 10, мы должны были ничего предпринимать.&lt;/p>
&lt;p>Но когда во время рекурсии корневой узел будет на уровень меньше, например 5, функция должна понимать, что сумму текущего отрезка и всех его дочерних нужно считать от нового корня дерева, т.е. от 5, и так далее.&lt;/p>
&lt;p>Например: текущий корень 10, а узел 3, т.е. мы должны посчитать равен ли отрезок [10,5,3] целевому числу 8.&lt;/p>
&lt;p>Для этого узел 3 должен знать значения, которые были до него.&lt;/p>
&lt;p>Решение:&lt;/p>
&lt;ol>
&lt;li>функция с данным узлом может принимать сумму отрезка, пройденного до него&lt;/li>
&lt;li>после этого функция считает равна ли сумма значению до текущего узла и значение самого узла целевому числу &lt;code>targetSum&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>В данном случае [10,5,3] сумма до текущего узла равна $10+5=15$. Если $15+3 == 8$, то текущий отрезок подходит.&lt;/p>
&lt;h2 id="алгоритм--абстрактный-алгоритм">Алгоритм / Абстрактный алгоритм&lt;/h2>
&lt;ol>
&lt;li>Обходим дерево, начиная с корня дерева.&lt;/li>
&lt;li>Для каждого узла, проверяем существует ли путь &lt;strong>от этого узла&lt;/strong>, сумма которого равна &lt;code>targetSum&lt;/code>, перебирая все возможные дочерние пути.&lt;/li>
&lt;li>Рекурсивно выполняем шаги 1 и 2 для всех дочерних узлов.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Definition for a binary tree node.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class TreeNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, left=None, right=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.left = left&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.right = right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">pathSum&lt;/span>(self, root, targetSum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">dfs&lt;/span>(node, current_path_sum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> node:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_path_sum &lt;span style="color:#666">+=&lt;/span> node&lt;span style="color:#666">.&lt;/span>val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> current_path_sum &lt;span style="color:#666">==&lt;/span> targetSum: &lt;span style="color:#60a0b0;font-style:italic"># Равна ли текущая сумма целевому значению&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>left, current_path_sum) &lt;span style="color:#60a0b0;font-style:italic"># Считаем пути для левого &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>right, current_path_sum) &lt;span style="color:#60a0b0;font-style:italic"># и правого дочернего узла&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root_count &lt;span style="color:#666">=&lt;/span> dfs(root, &lt;span style="color:#40a070">0&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Считаем все отрезки для текущего корня дерева&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_count &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>pathSum(root&lt;span style="color:#666">.&lt;/span>left, targetSum) &lt;span style="color:#60a0b0;font-style:italic"># новый корневой узел (левый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_count &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>pathSum(root&lt;span style="color:#666">.&lt;/span>right, targetSum) &lt;span style="color:#60a0b0;font-style:italic"># и правый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> root_count &lt;span style="color:#666">+&lt;/span> left_count &lt;span style="color:#666">+&lt;/span> right_count
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/find-pivot-index/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an array of integers &lt;code>nums&lt;/code>, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index. If the sums are equal, return the index. However, this approach has a time complexity of &lt;code>O(n^2)&lt;/code> which makes it inefficient for larger inputs.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>A more optimized solution would use the &lt;mark>&lt;a href="https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/#prefix-sums">prefix and suffix sum&lt;/a>&lt;/mark> concept. Prefix sum is the sum of all elements to the left of the index, and suffix sum is the sum of all elements to the right of the index. We can calculate these sums in &lt;code>O(n)&lt;/code> time and use them to find the pivot index.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>We will calculate the total sum of the array first.&lt;/p>
&lt;p>Then, we will initialize a variable &lt;code>left_sum&lt;/code> to keep track of the sum of elements to the left of the current index.&lt;/p>
&lt;p>As we iterate over each index, we will update the total sum by subtracting the current element, which will give us the &lt;code>right sum&lt;/code>. We will then check if &lt;code>left_sum&lt;/code> is equal to the right sum &lt;code>(total sum - left_sum - current element)&lt;/code>.&lt;/p>
&lt;p>If they are equal, we return the index.&lt;/p>
&lt;p>After checking, we will update the &lt;code>left_sum&lt;/code> by adding the current element.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Calculate the total sum of the array.&lt;/li>
&lt;li>Initialize a variable left_sum to 0.&lt;/li>
&lt;li>Iterate over each index in the array.
&lt;ol>
&lt;li>Update the total sum by subtracting the current element.&lt;/li>
&lt;li>Check if left_sum is equal to the right sum (total sum - left_sum - current element). If true, return the index.&lt;/li>
&lt;li>Update the left_sum by adding the current element.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>If no pivot index is found, return -1.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">pivotIndex&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, num &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">enumerate&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total_sum &lt;span style="color:#666">-=&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> left_sum &lt;span style="color:#666">==&lt;/span> total_sum:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_sum &lt;span style="color:#666">+=&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/champagne-tower/">LeetCode problem 799&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are tasked with modeling a champagne tower. Glasses are stacked in a pyramid, with each row having one more glass than the previous. When champagne is poured into the top glass and it overflows, the overflowed champagne is split equally between the two glasses below. The objective is to determine how full a specified glass will be after pouring a given amount of champagne.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>One could imagine a simulation, where we pour champagne into the top glass and then, glass-by-glass, simulate the overflow until we reach the desired glass. This approach, though conceptually simple, is computationally expensive and will not scale efficiently.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>Utilizing a &lt;mark>Dynamic Programming&lt;/mark> approach allows for efficient computation. The key realization is that each glass only receives overflow from the glass directly above and the glass above and to the left. Therefore, by working row-by-row, we can calculate the overflow for each glass efficiently.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>To solve this problem efficiently, we can use a bottom-up dynamic programming approach. Imagine you&amp;rsquo;re looking at the champagne tower from the top. Each glass receives champagne from the one(s) above it. The relationship between glasses can be broken down as follows:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Parent-Child Relationship&lt;/strong>: Each glass has a direct influence on the two glasses directly below it (child glasses). If a glass has an excess amount of champagne, it distributes this excess equally to its two child glasses.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Calculating Overflow&lt;/strong>: For any glass (&lt;em>starting from top&lt;/em>), if the amount of champagne in it exceeds its capacity (which is 1 unit), then the overflow is given by &lt;code>(amount - 1) / 2&lt;/code>. This is because each glass can hold up to 1 unit of champagne, and any excess will be split equally between its two child glasses.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Propagation&lt;/strong>: We start our simulation from the top of the tower. After pouring the champagne into the top glass, we calculate its overflow and propagate this overflow to its child glasses. We continue this process row by row until we have processed the entire tower or until we have processed up to the row of our query. This propagation ensures that every glass in the tower has the correct amount of champagne accounting for all the overflow from the glasses above it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Efficiency&lt;/strong>: By using a 2D array to simulate the tower and processing each glass only once, we can calculate the amount of champagne in the queried glass in an efficient manner. This avoids the need for complex simulations or recursive calculations.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Initialize the Tower&lt;/strong>: Create a 2D array representing the glasses. Pour the given amount into the top glass: &lt;code>[[poured], [0,0], [0,0,0], ...]&lt;/code>&lt;/li>
&lt;li>&lt;strong>Simulate the Pour&lt;/strong>: For each glass, calculate how much overflows, and distribute this overflow to the glasses below.&lt;/li>
&lt;li>&lt;strong>Return the Result&lt;/strong>: After completing the simulation, return the amount in the specified glass. If it&amp;rsquo;s more than 1 (the capacity of a glass), return 1.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">champagneTower&lt;/span>(poured, query_row, query_glass):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tower &lt;span style="color:#666">=&lt;/span> [[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">*&lt;/span> k &lt;span style="color:#007020;font-weight:bold">for&lt;/span> k &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, query_row &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">3&lt;/span>)] &lt;span style="color:#60a0b0;font-style:italic"># query_row + 3 for children update&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tower[&lt;span style="color:#40a070">0&lt;/span>][&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> poured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> row &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(query_row &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> col &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(row &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> overflow &lt;span style="color:#666">=&lt;/span> (tower[row][col] &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1.0&lt;/span>) &lt;span style="color:#666">/&lt;/span> &lt;span style="color:#40a070">2.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> overflow &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># update children&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tower[row &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>][col] &lt;span style="color:#666">+=&lt;/span> overflow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tower[row &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>][col &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">+=&lt;/span> overflow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">min&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, tower[query_row][query_glass])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;video width="100%" controls>
&lt;source src="../../assets/799.mp4" type="video/mp4">
Your browser does not support the video tag.
&lt;/video>
&lt;figcaption>LeetCode 799 Solution&lt;/figcaption></description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes/">LeetCode problem 847&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an undirected, connected graph of n nodes labeled from 0 to &lt;code>n - 1&lt;/code>. An array graph is provided where &lt;code>graph[i]&lt;/code> is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.&lt;/p>
&lt;p>It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to attempt all possible paths (brute force) until all nodes are visited. This would involve significant computational power and time, especially for larger graphs.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>State Compression&lt;/strong>: The visited state of nodes can be represented using binary numbers.&lt;/li>
&lt;li>&lt;strong>Breadth-First Search&lt;/strong>: BFS can be used to explore the graph systematically.&lt;/li>
&lt;/ol>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>Instead of the brute force approach, a more refined BFS can be applied. The BFS is enhanced using two techniques:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>State Compression&lt;/strong>: Rather than tracking visited nodes for each path with a set or list, represent them with a binary number. This efficient way compresses the state and avoids redundancy.&lt;/li>
&lt;li>&lt;strong>Double-ended Queue&lt;/strong>: An efficient way to explore BFS paths using deque which allows operations from both ends.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Use BFS for exploration.&lt;/li>
&lt;li>Encode the visited state of nodes with binary numbers.&lt;/li>
&lt;li>Utilize a double-ended queue storing the nodes, their states, and steps taken.&lt;/li>
&lt;li>The ultimate goal is to discover a state that represents all nodes being visited.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> deque
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">shortestPathLength&lt;/span>(graph):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(graph)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> final_state &lt;span style="color:#666">=&lt;/span> (&lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">&amp;lt;&amp;lt;&lt;/span> n) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># This mask checks if all nodes are visited&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>() &lt;span style="color:#60a0b0;font-style:italic"># To track visited (node, state) pairs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue &lt;span style="color:#666">=&lt;/span> deque() &lt;span style="color:#60a0b0;font-style:italic"># Double-ended queue for BFS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Start BFS from every node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">&amp;lt;&amp;lt;&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue&lt;span style="color:#666">.&lt;/span>append((i, state, &lt;span style="color:#40a070">0&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited&lt;span style="color:#666">.&lt;/span>add((i, state))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> queue:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node, state, steps &lt;span style="color:#666">=&lt;/span> queue&lt;span style="color:#666">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> state &lt;span style="color:#666">==&lt;/span> final_state: &lt;span style="color:#60a0b0;font-style:italic"># If all nodes are visited in the current state, return steps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> steps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> neighbor &lt;span style="color:#007020;font-weight:bold">in&lt;/span> graph[node]: &lt;span style="color:#60a0b0;font-style:italic"># Check neighbors and add new states to the queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_state &lt;span style="color:#666">=&lt;/span> state &lt;span style="color:#666">|&lt;/span> (&lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">&amp;lt;&amp;lt;&lt;/span> neighbor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (neighbor, new_state) &lt;span style="color:#007020;font-weight:bold">not&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> visited:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited&lt;span style="color:#666">.&lt;/span>add((neighbor, new_state))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue&lt;span style="color:#666">.&lt;/span>append((neighbor, new_state, steps &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>880. Decoded String at Index</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/880/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/880/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/decoded-string-at-index/">LeetCode problem 880&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an encoded string &lt;code>s&lt;/code>, the encoded string is transformed into a tape based on the following criteria:&lt;/p>
&lt;ol>
&lt;li>When a letter is encountered, it&amp;rsquo;s written on the tape.&lt;/li>
&lt;li>When a digit &lt;code>d&lt;/code> is encountered, the current content of the tape is repeated &lt;code>d - 1&lt;/code> more times.&lt;/li>
&lt;/ol>
&lt;p>You are required to find and return the kth letter (1-indexed) on the decoded tape.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A straightforward solution would involve constructing the entire decoded tape and then simply accessing the kth character. However, this is impractical given the constraints, as the size of the decoded string can become extremely large.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>We can work backward from the desired index k.&lt;/li>
&lt;li>It is possible to determine the sequence of characters without decoding the entire string.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>Instead of trying to build the entire string, which might be vast, we can work in reverse. Given an index &lt;code>k&lt;/code>, we can backtrack through the original encoded string to determine which character would be at that position in the decoded string.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Iterate over the encoded string to determine the length of the decoded string.&lt;/li>
&lt;li>Work backward:
&lt;ol>
&lt;li>If the current character is a digit, reduce the size of the decoded string by dividing it by the digit and also adjust the k value.&lt;/li>
&lt;li>If the current character is a letter, reduce the size of the decoded string by 1. If k is equal to the size of the decoded string or k is 0, return the current character.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">decodeAtIndex&lt;/span>(self, s: &lt;span style="color:#007020">str&lt;/span>, k: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Calculate the length of the decoded string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> ch &lt;span style="color:#007020;font-weight:bold">in&lt;/span> s:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> ch&lt;span style="color:#666">.&lt;/span>isdigit():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#666">*=&lt;/span> &lt;span style="color:#007020">int&lt;/span>(ch)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> ch &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">reversed&lt;/span>(s): &lt;span style="color:#60a0b0;font-style:italic"># Work backward through the encoded string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#666">%=&lt;/span> size
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> k &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> ch&lt;span style="color:#666">.&lt;/span>isalpha():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> ch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> ch&lt;span style="color:#666">.&lt;/span>isdigit(): &lt;span style="color:#60a0b0;font-style:italic"># Adjust the size based on the current character&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#666">/=&lt;/span> &lt;span style="color:#007020">int&lt;/span>(ch)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1048. Longest String Chain</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1048/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1048/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/longest-string-chain/">LeetCode problem 1048&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given an array of words where each word consists of lowercase English letters. Your task is to determine the longest string chain you can form given this list. A word A can be a predecessor of word B if by adding exactly one letter to A (at any position), B is formed. The objective is to find the longest sequence where each word is a predecessor of the next.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>The straightforward brute-force way would be to try all possible combinations of word chains. Starting with each word, try to find its successor in the list and continue this until no more successors can be found. Remember the longest chain you can form. This solution, however, will be inefficient, especially with larger lists.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>A valuable hint for this problem is to consider sorting the words based on their lengths. This ensures that words of length &lt;code>n&lt;/code> will only ever be predecessors to words of length &lt;code>n + 1&lt;/code>.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The efficient way to solve this problem is using Dynamic Programming. The core idea is to maintain a hashmap where the key is a word and the value is the maximum chain length with that word as the end. This hashmap will assist in building solutions for longer words based on the solutions of shorter ones.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Sort the Words&lt;/strong>: First, sort the words by their lengths. This guarantees when processing a word, all potential predecessors have already been handled.&lt;/li>
&lt;li>&lt;strong>Hashmap for Chain Length&lt;/strong>: As each word is processed, inspect all its possible predecessors (by removing one character from the word). Use the hashmap to fetch the chain length of the predecessor and add one to it.&lt;/li>
&lt;li>&lt;strong>Determine Maximum Chain Length&lt;/strong>: As each word is processed, update the maximum chain length.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">longestStrChain&lt;/span>(words):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> words&lt;span style="color:#666">.&lt;/span>sort(key&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020">len&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp &lt;span style="color:#666">=&lt;/span> {} &lt;span style="color:#60a0b0;font-style:italic"># remember the maximum chain length for each word&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_chain &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> word &lt;span style="color:#007020;font-weight:bold">in&lt;/span> words:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[word] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Every word&amp;#39;s minimum chain length is 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(word)): &lt;span style="color:#60a0b0;font-style:italic"># For each word, explore all its potential predecessors&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev_word &lt;span style="color:#666">=&lt;/span> word[:i] &lt;span style="color:#666">+&lt;/span> word[i&lt;span style="color:#666">+&lt;/span>&lt;span style="color:#40a070">1&lt;/span>:]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> prev_word &lt;span style="color:#007020;font-weight:bold">in&lt;/span> dp:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[word] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(dp[word], dp[prev_word] &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_chain &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_chain, dp[word])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_chain
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/">LeetCode задача 1282&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Есть &lt;code>n&lt;/code> человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.&lt;/p>
&lt;p>Дан массив целых чисел &lt;code>groupSizes&lt;/code>, где &lt;code>groupSizes[i]&lt;/code> — это размер группы, в которой находится человек &lt;code>i&lt;/code>. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером &lt;code>groupSizes[i]&lt;/code>.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем словарь для временного хранения групп по их размеру и список для итогового результата.&lt;/li>
&lt;li>Итерируемся по &lt;code>groupSizes&lt;/code>, добавляя каждого человека в соответствующую группу в словаре.&lt;/li>
&lt;li>Когда группа достигает своего размера, добавьте ее в результат и очистите соответствующий список в словаре.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">typing&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> List
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">groupThePeople&lt;/span>(self, groupSizes: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> List[List[&lt;span style="color:#007020">int&lt;/span>]]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups &lt;span style="color:#666">=&lt;/span> {} &lt;span style="color:#60a0b0;font-style:italic"># временное хранение групп&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> [] &lt;span style="color:#60a0b0;font-style:italic"># итоговый список групп&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, size &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">enumerate&lt;/span>(groupSizes):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> size &lt;span style="color:#007020;font-weight:bold">not&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> groups: &lt;span style="color:#60a0b0;font-style:italic"># Если размер группы еще не существует в словаре, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups[size] &lt;span style="color:#666">=&lt;/span> [] &lt;span style="color:#60a0b0;font-style:italic"># инициализируем его пустым списком&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups[size]&lt;span style="color:#666">.&lt;/span>append(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">len&lt;/span>(groups[size]) &lt;span style="color:#666">==&lt;/span> size: &lt;span style="color:#60a0b0;font-style:italic"># Если группа достигла своего размера,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(groups[size]) &lt;span style="color:#60a0b0;font-style:italic"># добавляем ее в результат и очищаем список&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups[size] &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/">LeetCode задача 1359&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дано &lt;code>n&lt;/code> заказов, каждый заказ состоит из услуг по приему и доставке.&lt;/p>
&lt;p>Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).&lt;/p>
&lt;p>Так как ответ может быть очень большим, верните его по модулю &lt;code>10^9 + 7&lt;/code>.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Использовать комбинаторный подход.&lt;/p>
&lt;p>Для каждого нового заказа у нас есть &lt;code>2 * (2n-1)&lt;/code> способов добавить его в текущую последовательность.&lt;/p>
&lt;p>Мы используем данную формулу, так как:&lt;/p>
&lt;p>Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест). У нас 2 операции (прием и доставка) для каждого заказа.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Начнем с самого начала,&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Мы получили 1-й заказ &lt;strong>n=1&lt;/strong>&lt;/p>
&lt;p>Мы можем расставить только в одном порядке: &lt;code>P1 D1&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Теперь мы получили 2-й заказ &lt;strong>n=2&lt;/strong>, и нужно добавить к предыдущему и расставить &lt;code>P2, D2&lt;/code>.&lt;/p>
&lt;p>Куда мы можем поставить P2?&lt;/p>
&lt;p>На первое место, второе или третье. И не можем поставить на последнее, т.к. последнее место всегда будет части доставки(D).&lt;/p>
&lt;p>Попробуем расставить:&lt;/p>
&lt;ol>
&lt;li>Всего &lt;strong>3&lt;/strong> возможных позиции куда поставить 2-й (P2) заказ. (Обозначим перестановки от предыдущего заказа как &lt;code>X&lt;/code>):&lt;/li>
&lt;li>Если &lt;code>P2 X X&lt;/code>, то у P2 и D2 из расстановок - 3 возможных варианта: &lt;code>P2 D2 X X&lt;/code> или &lt;code>P2 X D2 X&lt;/code> или &lt;code>P2 X X D2&lt;/code>&lt;/li>
&lt;li>Если &lt;code>X P2 X&lt;/code>, - 2 возможных варианта: &lt;code>X P2 D2 X&lt;/code> или &lt;code>X P2 X D2&lt;/code>&lt;/li>
&lt;li>Если &lt;code>X X P2&lt;/code>, - 1 возможный вариант: &lt;code>X X P2 D2&lt;/code>&lt;/li>
&lt;li>Отсюда мы получаем формулу, что для &lt;code>n&lt;/code> заказа - &lt;code>n*2&lt;/code> операций, и &lt;code>n*2 -1&lt;/code> возможных комбинаций.&lt;/li>
&lt;li>Итого получаем, что для второго заказа возможных выборов перестановок &lt;code>3+2+1&lt;/code> - &lt;strong>6&lt;/strong>&lt;/li>
&lt;li>Также мы видим, что &lt;code>X&lt;/code> - расстановки с предыдущего заказа тоже меняли позиции, поэтому общее количество комбинаций будет равно &lt;mark>произведению количества комбинаций текущего заказа и предыдущего&lt;/mark> - &lt;strong>6*1=6&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Теперь мы получили 3-й заказ &lt;strong>n=3&lt;/strong>,&lt;/p>
&lt;ol>
&lt;li>По аналогии с предыдущим, перестановок получается &lt;code>n*2=6&lt;/code>&lt;/li>
&lt;li>Комбинаций получается &lt;code>5+4+3+2+1&lt;/code> = &lt;strong>15&lt;/strong>&lt;/li>
&lt;li>Перемножаем с комбинациями из предыдущего заказа &lt;code>15*6=90&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Для каждого заказа от 1 до n:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Рассчитываем количество способов добавления заказа в текущую последовательность.&lt;/p>
&lt;ol>
&lt;li>Для подсчета комбинаций текущего заказа можно использовать формулу:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span> 2*n * (2*n-1) // 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> # для n:3 2*3=6, 2*3-1=5, 6*5//2=15
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Умножаем текущее количество комбинаций на количество способов добавления заказа.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">countOrders&lt;/span>(n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOD &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">10&lt;/span>&lt;span style="color:#666">**&lt;/span>&lt;span style="color:#40a070">9&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">2&lt;/span>, n &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev_order_combinations &lt;span style="color:#666">=&lt;/span> res
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_combinations &lt;span style="color:#666">=&lt;/span> (&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">*&lt;/span> x) &lt;span style="color:#666">*&lt;/span> (&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">*&lt;/span> x &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> prev_order_combinations &lt;span style="color:#666">*&lt;/span> order_combinations &lt;span style="color:#666">%&lt;/span> MOD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> res
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1420/</link><pubDate>Thu, 21 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1420/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/">LeetCode Problem 1420&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>In this problem, we have three integers, &lt;code>n&lt;/code>, &lt;code>m&lt;/code>, and &lt;code>k&lt;/code>. We need to construct an array &lt;code>arr&lt;/code> having the following properties:&lt;/p>
&lt;ol>
&lt;li>It consists of exactly &lt;code>n&lt;/code> integers.&lt;/li>
&lt;li>Each integer in the array is between &lt;code>1&lt;/code> and &lt;code>m&lt;/code> inclusive.&lt;/li>
&lt;li>After executing a certain algorithm on &lt;code>arr&lt;/code>, we get a value known as &lt;code>search_cost&lt;/code>. Our goal is to ensure &lt;code>search_cost&lt;/code> is equal to &lt;code>k&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>The main challenge is determining how many ways we can construct such an array &lt;code>arr&lt;/code>.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach might involve generating all possible array combinations, then determining which ones fulfill our criteria. This method, however, would be inefficient due to its exponential time complexity. Given the constraints, this naive method won&amp;rsquo;t be feasible.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Utilize dynamic programming to avoid recalculating overlapping subproblems.&lt;/li>
&lt;li>Keeping track of the maximum value encountered so far can help narrow down the possible outcomes.&lt;/li>
&lt;/ul>
&lt;h2 id="approach--idea">Approach / Idea&lt;/h2>
&lt;p>To tackle this problem efficiently, we use dynamic programming. The main idea is to maintain a three-dimensional &lt;code>dp&lt;/code> array, which keeps track of:&lt;/p>
&lt;ol>
&lt;li>Current length of the array we&amp;rsquo;re constructing (&lt;code>i&lt;/code>).&lt;/li>
&lt;li>The maximum value used so far (&lt;code>max_so_far&lt;/code>).&lt;/li>
&lt;li>Remaining comparisons (&lt;code>remain&lt;/code>).&lt;/li>
&lt;/ol>
&lt;p>With this DP table, we can progressively compute how many ways we can construct an array of length &lt;code>i&lt;/code> while meeting our conditions.&lt;/p>
&lt;h2 id="steps--high-level-algorithm">Steps / High-Level Algorithm&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Initialize the DP Array&lt;/strong>:
Create a three-dimensional &lt;code>dp&lt;/code> array filled with zeros.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Base Case&lt;/strong>:
When the array length equals &lt;code>n&lt;/code>, the possible values for &lt;code>max_so_far&lt;/code> are already decided, hence set &lt;code>dp[n][max_so_far][0]&lt;/code> to &lt;code>1&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Fill the DP Table&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Iterate backwards, starting from the end towards the beginning.&lt;/li>
&lt;li>For each &lt;code>i&lt;/code>, determine the number of ways we can construct an array of that length based on &lt;code>max_so_far&lt;/code> and &lt;code>remain&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Note: This is where the majority of the dynamic programming logic comes into play.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Calculate the Result&lt;/strong>:
Once the DP table is complete, &lt;code>dp[0][0][k]&lt;/code> contains the number of ways we can construct the array.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>Here&amp;rsquo;s the python code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">numOfArrays&lt;/span>(self, n: &lt;span style="color:#007020">int&lt;/span>, m: &lt;span style="color:#007020">int&lt;/span>, k: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp &lt;span style="color:#666">=&lt;/span> [[[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">*&lt;/span> (k &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(m &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)] &lt;span style="color:#007020;font-weight:bold">for&lt;/span> __ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOD &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">10&lt;/span> &lt;span style="color:#666">**&lt;/span> &lt;span style="color:#40a070">9&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> num &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(dp[&lt;span style="color:#40a070">0&lt;/span>])):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[n][num][&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> max_so_far &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(m, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> remain &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(k &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> (max_so_far &lt;span style="color:#666">*&lt;/span> dp[i &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>][max_so_far][remain]) &lt;span style="color:#666">%&lt;/span> MOD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> remain &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> num &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(max_so_far &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>, m &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> (res &lt;span style="color:#666">+&lt;/span> dp[i &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>][num][remain &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>]) &lt;span style="color:#666">%&lt;/span> MOD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[i][max_so_far][remain] &lt;span style="color:#666">=&lt;/span> res
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> dp[&lt;span style="color:#40a070">0&lt;/span>][&lt;span style="color:#40a070">0&lt;/span>][k]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/">LeetCode задача 1647&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Строка &lt;code>s&lt;/code> называется хорошей, если в ней нет двух разных символов с одинаковой частотой.&lt;/p>
&lt;p>Дана строка &lt;code>s&lt;/code>, верните минимальное количество символов, которое необходимо удалить, чтобы сделать &lt;code>s&lt;/code> хорошим.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.&lt;/p>
&lt;p>Если проверять &lt;mark>встречалась ли частота текущего символа ранее&lt;/mark>, то&lt;/p>
&lt;h2 id="алгоритм--абстрактный-алгоритм">Алгоритм / Абстрактный алгоритм&lt;/h2>
&lt;ol>
&lt;li>Считаем частоты всех символов в строке.&lt;/li>
&lt;li>Сортируем частоты в порядке убывания.&lt;/li>
&lt;li>Для каждой частоты, начиная с самой большой, если она не уникальна (т.е. есть другая такая же частота), уменьшаем ее на 1 и увеличиваем счетчик удалений.&lt;/li>
&lt;li>Продолжаем, пока все частоты не станут уникальными.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">minDeletions&lt;/span>(self, s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq &lt;span style="color:#666">=&lt;/span> Counter(s) &lt;span style="color:#60a0b0;font-style:italic"># Подсчет частот символов&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freqs &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(freq&lt;span style="color:#666">.&lt;/span>values(), reverse&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">True&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Сортировка частот в порядке убывания&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deletions &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seen &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> f &lt;span style="color:#007020;font-weight:bold">in&lt;/span> freqs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> f &lt;span style="color:#007020;font-weight:bold">in&lt;/span> seen:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deletions &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> f &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seen&lt;span style="color:#666">.&lt;/span>add(f)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> deletions
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1658/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1658/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/">LeetCode problem 1658&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You have an integer array &lt;code>nums&lt;/code> and another integer &lt;code>x&lt;/code>. In a single operation, you can either remove the leftmost or the rightmost element from the array &lt;code>nums&lt;/code> and decrement &lt;code>x&lt;/code> by the value of the removed element. The question is: What is the minimum number of operations required to reduce &lt;code>x&lt;/code> to exactly zero? If it&amp;rsquo;s not feasible, the answer should be &lt;code>-1&lt;/code>.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>The naive approach would be to explore every possible combination of removing elements from the start or the end, recursively. While this approach can find the solution, it&amp;rsquo;s extremely inefficient and would result in a time complexity beyond O(2^n).&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The problem can be turned around: Instead of trying to determine which numbers to remove from the ends, think of it as finding the longest subarray inside &lt;code>nums&lt;/code> such that the sum of its elements is equal to the total sum of &lt;code>nums&lt;/code> minus &lt;code>x&lt;/code>. &lt;em>Let&amp;rsquo;s call this approach in mathematics &amp;ldquo;from the reverse&amp;rdquo;&lt;/em>.&lt;/p>
&lt;p>Why does this work? Well, if we find the maximum-length subarray with a sum equal to &lt;code>total - x&lt;/code>, then the numbers we need to remove from the array will be the numbers outside this subarray!&lt;/p>
&lt;p>This transformed problem can be tackled using a two-pointer or sliding window approach.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Calculate the total sum of &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>Set a target sum which is &lt;code>total - x&lt;/code>.&lt;/li>
&lt;li>Using a sliding window approach, find the maximum length of the subarray whose sum equals the target.&lt;/li>
&lt;li>The result will be the total length of &lt;code>nums&lt;/code> minus the length of this subarray. If no such subarray exists, return &lt;code>-1&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">minOperations&lt;/span>(nums, x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#666">=&lt;/span> total &lt;span style="color:#666">-&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># sum of current subarray&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_len &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># maximum length of the subarray that sums up to the target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Starting pointer of sliding window&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> right &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n): &lt;span style="color:#60a0b0;font-style:italic"># Starting pointer of sliding window&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_sum &lt;span style="color:#666">+=&lt;/span> nums[right]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> curr_sum &lt;span style="color:#666">&amp;gt;&lt;/span> target &lt;span style="color:#007020;font-weight:bold">and&lt;/span> left &lt;span style="color:#666">&amp;lt;&lt;/span> n: &lt;span style="color:#60a0b0;font-style:italic"># If current sum goes beyond target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_sum &lt;span style="color:#666">-=&lt;/span> nums[left] &lt;span style="color:#60a0b0;font-style:italic"># shrink the window from the left&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> curr_sum &lt;span style="color:#666">==&lt;/span> target:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_len &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_len, right &lt;span style="color:#666">-&lt;/span> left &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> max_len &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> max_len
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;video width="100%" controls>
&lt;source src="../../assets/1658.mp4" type="video/mp4">
Your browser does not support the video tag.
&lt;/video>
&lt;figcaption>LeetCode 1658 Solution&lt;/figcaption></description></item><item><title>1887. Reduction Operations to Make the Array Elements Equal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1887/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1887/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/">LeetCode Problem 1887&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>The goal of this problem is to make all elements in a given integer array &lt;code>nums&lt;/code> equal, through a series of reduction operations. In each operation, we find the largest element in the array, find the next largest element that is strictly smaller than the largest, and reduce the largest element to this next largest value. The task is to return the number of such operations needed to make all array elements equal.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>One might consider a brute-force approach: repeatedly scanning the array to find the largest element and its next largest, then performing the reduction. However, this approach would have a high time complexity, especially with larger arrays.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Think about sorting the array to make it easier to find the largest and next largest elements.&lt;/li>
&lt;li>Consider how the number of reduction operations relates to the positions of the elements in the sorted array.&lt;/li>
&lt;/ul>
&lt;h2 id="approach--idea">Approach / Idea&lt;/h2>
&lt;p>Imagine you have a stack of books of different thicknesses. Your task is to make all books have the same thickness by repeatedly choosing the thickest book and trimming it down to the next thickest one. The key to doing this efficiently is to first arrange the books in order of thickness, from thickest to thinnest. Once sorted, it&amp;rsquo;s straightforward to find the thickest book and the next thickest one.&lt;/p>
&lt;p>Applying this analogy to our problem, sorting the &lt;code>nums&lt;/code> array in descending order (non-ascending) is akin to arranging the books. The largest number in the array is like the thickest book, and the next largest is like the next thickest book in the stack. By sorting the array, we can easily keep track of when we encounter a new &amp;ldquo;largest&amp;rdquo; element (or a new &amp;ldquo;thickest book&amp;rdquo;) as we iterate through the array.&lt;/p>
&lt;h3 id="example">Example&lt;/h3>
&lt;p>Consider the array &lt;code>[5, 1, 3]&lt;/code>. After sorting, it becomes &lt;code>[5, 3, 1]&lt;/code>. The first largest value is &lt;code>5&lt;/code>, and the next largest is &lt;code>3&lt;/code>. To make &lt;code>5&lt;/code> equal to &lt;code>3&lt;/code>, we perform one operation. We then make &lt;code>3&lt;/code> equal to &lt;code>1&lt;/code> in the next step. Each step or operation can be counted by the position of these numbers in the sorted array.&lt;/p>
&lt;p>Thus, we count the number of operations required to reduce each element to the next largest value, which directly correlates to its index in the sorted array.&lt;/p>
&lt;p>The key to efficiently solving this problem lies in sorting the array. Once sorted, we can easily track the largest element and its next largest. The number of operations required to reduce an element to the next largest is directly related to its position in the sorted array.&lt;/p>
&lt;h3 id="algorithm">Algorithm&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Sort the Array&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Sort &lt;code>nums&lt;/code> in non-ascending order.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Count Reduction Operations&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Iterate through the sorted array.&lt;/li>
&lt;li>Whenever the current element is different from the previous one (indicating a new largest element), increase the operation count by its index.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Return the Count&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>The total count is the number of operations needed.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>Here&amp;rsquo;s the Python code implementing this approach:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reductionOperations&lt;/span>(nums: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#666">.&lt;/span>sort(reverse&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> operations &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#666">=&lt;/span> nums[&lt;span style="color:#40a070">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">enumerate&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> x &lt;span style="color:#666">&amp;lt;&lt;/span> largest:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> operations &lt;span style="color:#666">+=&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#666">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> operations
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2251. Number of Flowers in Full Bloom</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2251/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2251/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/number-of-flowers-in-full-bloom/">LeetCode Problem 2251&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>In the given problem, we are presented with two arrays. The first, &lt;code>flowers&lt;/code>, represents when each flower starts and stops being in full bloom. The second, &lt;code>people&lt;/code>, indicates when each person arrives to see the flowers. Our task is to determine, for each person, how many flowers they will see in full bloom upon their arrival.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A straightforward approach might involve iterating over each person&amp;rsquo;s arrival time. For each time, we could iterate over the &lt;code>flowers&lt;/code> list to count how many flowers are in full bloom. This approach, however, would lead to a time complexity of O(n*m), with n being the number of people and m being the number of flowers. With larger constraints, this could be quite inefficient.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Separating the start and end times of each flower&amp;rsquo;s blooming period can simplify the problem.&lt;/li>
&lt;li>Binary search can be an effective tool to efficiently find specific intervals in sorted lists.&lt;/li>
&lt;/ul>
&lt;h2 id="approach--idea">Approach / Idea&lt;/h2>
&lt;p>Instead of associating the start and end times of each flower&amp;rsquo;s blooming period, we can consider them separately. By focusing on how many flowers have started and stopped blooming by a specific time, we can easily determine the number of flowers in full bloom.&lt;/p>
&lt;p>The idea is to use two separate arrays: one for all the start times (&lt;code>starts&lt;/code>) and one for all the end times (&lt;code>ends&lt;/code>). By sorting these arrays, we can use binary search to swiftly identify the number of flowers that have started and stopped blooming by any given time.&lt;/p>
&lt;h2 id="steps--high-level-algorithm">Steps / High level algorithm&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Create Two Arrays&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Initialize two empty lists, &lt;code>starts&lt;/code> and &lt;code>ends&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Fill Arrays with Data&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Loop through each flower&amp;rsquo;s blooming period in &lt;code>flowers&lt;/code> and populate the &lt;code>starts&lt;/code> and &lt;code>ends&lt;/code> lists.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Sort the Arrays&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Sort both &lt;code>starts&lt;/code> and &lt;code>ends&lt;/code> to ensure efficient binary searches.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Determine Blooming Flowers&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>For each person&amp;rsquo;s arrival time in &lt;code>people&lt;/code>:
&lt;ul>
&lt;li>Use binary search on &lt;code>starts&lt;/code> to determine how many flowers have begun blooming.&lt;/li>
&lt;li>Use another binary search on &lt;code>ends&lt;/code> to see how many have finished.&lt;/li>
&lt;li>Subtract the number of finished blooms from the started ones and append to the results list.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Return the Result&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Return the generated list containing the number of flowers in full bloom for each person.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>Below is the Python code implementing the above-mentioned approach:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">bisect&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> bisect_right
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">typing&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> List
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">fullBloomFlowers&lt;/span>(self, flowers: List[List[&lt;span style="color:#007020">int&lt;/span>]], people: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> List[&lt;span style="color:#007020">int&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> starts &lt;span style="color:#666">=&lt;/span> [] &lt;span style="color:#60a0b0;font-style:italic"># Initialize start and end arrays&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ends &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> start, end &lt;span style="color:#007020;font-weight:bold">in&lt;/span> flowers: &lt;span style="color:#60a0b0;font-style:italic"># Populate arrays with flower bloom periods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> starts&lt;span style="color:#666">.&lt;/span>append(start)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ends&lt;span style="color:#666">.&lt;/span>append(end &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> starts&lt;span style="color:#666">.&lt;/span>sort() &lt;span style="color:#60a0b0;font-style:italic"># Sort both arrays for efficient binary search&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ends&lt;span style="color:#666">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> person &lt;span style="color:#007020;font-weight:bold">in&lt;/span> people: &lt;span style="color:#60a0b0;font-style:italic"># Calc number of flowers for each person&amp;#39;s arrival time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">=&lt;/span> bisect_right(starts, person) &lt;span style="color:#60a0b0;font-style:italic"># Use binary search to find flowers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#666">=&lt;/span> bisect_right(ends, person) &lt;span style="color:#60a0b0;font-style:italic"># that have started and finished blooming&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res&lt;span style="color:#666">.&lt;/span>append(i &lt;span style="color:#666">-&lt;/span> j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> res
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/equal-row-and-column-pairs/">LeetCode задача 2352&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дана квадратная матрица целых чисел &lt;code>grid&lt;/code> размером &lt;code>n×n&lt;/code>. Задача состоит в том, чтобы определить, сколько пар строк и столбцов в матрице &lt;strong>идентичны&lt;/strong> по своему содержанию и порядку.&lt;/p>
&lt;p>Строка и столбец считаются равными, если они содержат одни и те же элементы в том же порядке.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения задачи можно воспользоваться тем фактом, что каждая строка и столбец представляют собой набор чисел. Если мы конвертируем их в строки, то можем сравнивать их друг с другом.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Вместо прямого сравнения каждой строки с каждым столбцом мы можем преобразовать каждую строку и столбец в кортеж(&lt;a href="https://romankurnovskii.com/ru/tracks/python-101/basis/tuples/">&lt;code>tuple&lt;/code>&lt;/a>) и использовать словарь(&lt;a href="https://romankurnovskii.com/ru/tracks/python-101/basis/dict/">&lt;code>dict&lt;/code>&lt;/a>) для учета количества вхождений каждой уникальной строки. При проходе по столбцам мы можем напрямую обращаться к нашему словарю, чтобы узнать, совпадает ли представление кортежа столбца с любой строкой.&lt;/p>
&lt;p>&lt;strong>Почему кортежи?&lt;/strong>&lt;/p>
&lt;p>Прежде чем углубляться в оптимизированный подход, важно понимать роль кортежей. Мы преобразуем строки и столбцы в кортежи, потому что:&lt;/p>
&lt;ul>
&lt;li>Кортежи неизменяемы: их содержимое не может быть изменено после создания.&lt;/li>
&lt;li>Они могут использоваться в качестве ключей в словарях, в отличие от списков или множеств. Это свойство критически важно для нашего решения.&lt;/li>
&lt;li>Кортежи сохраняют порядок элементов, что важно для требований нашей задачи.&lt;/li>
&lt;/ul>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Преобразуем каждую строку в кортеж и подсчитаем ее вхождения с помощью словаря.&lt;/li>
&lt;li>Пройдем каждый столбец, преобразуем его в кортеж.&lt;/li>
&lt;li>Проверим, существует ли кортеж столбца в нашем словаре.
&lt;ol>
&lt;li>Если да, увеличиваем счетчик на &lt;strong>количество вхождений&lt;/strong> этого кортежа.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">equalPairs&lt;/span>(self, grid: List[List[&lt;span style="color:#007020">int&lt;/span>]]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows &lt;span style="color:#666">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Храним кортежи строк и их количество вхождений&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> row &lt;span style="color:#007020;font-weight:bold">in&lt;/span> grid:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> row &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">tuple&lt;/span>(row)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows[row]&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">+&lt;/span> rows&lt;span style="color:#666">.&lt;/span>get(row, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Для каждого столбца проверяем, существует ли кортеж столбца в словаре строк&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(grid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> c &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> col &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">tuple&lt;/span>(grid[r][c] &lt;span style="color:#007020;font-weight:bold">for&lt;/span> r &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> rows&lt;span style="color:#666">.&lt;/span>get(col, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> count
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2839. Check if Strings Can be Made Equal With Operations I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2839/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2839/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/check-if-strings-can-be-made-equal-with-operations-i/">LeetCode Problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given two strings &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>, both of length 4, consisting of lowercase English letters. The objective is to find out if it&amp;rsquo;s possible to make the two strings equal by swapping certain pairs of characters.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to try out all possible swap combinations. However, this can be very inefficient, especially when the strings have a large number of characters.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ol>
&lt;li>Observe that the swapping condition is quite specific: &lt;code>j - i = 2&lt;/code>.&lt;/li>
&lt;li>The strings should be permutations of each other.&lt;/li>
&lt;/ol>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The efficient solution for this problem involves sorting the characters at even and odd positions separately for both strings and then comparing them.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Sort the characters at even indices for &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>.&lt;/li>
&lt;li>Sort the characters at odd indices for &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>.&lt;/li>
&lt;li>Compare the sorted characters at even indices for both strings and the sorted characters at odd indices for both strings.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">canBeEqual&lt;/span>(self, s1: &lt;span style="color:#007020">str&lt;/span>, s2: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_s1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s1[::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd_s1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s1[&lt;span style="color:#40a070">1&lt;/span>::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_s2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s2[::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd_s2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s2[&lt;span style="color:#40a070">1&lt;/span>::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> even_s1 &lt;span style="color:#666">==&lt;/span> even_s2 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> odd_s1 &lt;span style="color:#666">==&lt;/span> odd_s2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2840. Check if Strings Can be Made Equal With Operations II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2840/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/check-if-strings-can-be-made-equal-with-operations-ii/">LeetCode Problem 2840&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given two strings &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>, both of length &lt;code>n&lt;/code>, consisting of lowercase English letters. You can apply certain operations to make them equal. The question is, is it possible?&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to try all possible swap operations and compare the two strings at each step, which would be highly inefficient.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ol>
&lt;li>Observe that swapping can only occur at indices &lt;code>i&lt;/code> and &lt;code>j&lt;/code> where &lt;code>j - i&lt;/code> is even.&lt;/li>
&lt;li>Separate the string into two different sequences, one containing characters at even indices and the other at odd indices.&lt;/li>
&lt;li>Check the frequency of characters in both sequences.&lt;/li>
&lt;/ol>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The efficient approach involves separating characters at even and odd positions into two different sequences for each string and then comparing the frequency of characters in these sequences.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two empty lists for &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>, each to store characters at even and odd positions.&lt;/li>
&lt;li>Populate these lists with characters from &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>.&lt;/li>
&lt;li>Sort these lists.&lt;/li>
&lt;li>Compare the sorted lists for equality.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">checkStrings&lt;/span>(s1: &lt;span style="color:#007020">str&lt;/span>, s2: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_s1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s1[::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd_s1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s1[&lt;span style="color:#40a070">1&lt;/span>::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even_s2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s2[::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd_s2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(s2[&lt;span style="color:#40a070">1&lt;/span>::&lt;span style="color:#40a070">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> even_s1 &lt;span style="color:#666">==&lt;/span> even_s2 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> odd_s1 &lt;span style="color:#666">==&lt;/span> odd_s2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2841/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-sum-of-almost-unique-subarray/">LeetCode Problem 2841&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given an integer array &lt;code>nums&lt;/code> and two positive integers &lt;code>m&lt;/code> and &lt;code>k&lt;/code>.&lt;/p>
&lt;p>The task is to return the maximum sum out of all almost unique subarrays of length &lt;code>k&lt;/code> of &lt;code>nums&lt;/code>. If no such subarray exists, return 0.&lt;/p>
&lt;p>A subarray is &lt;strong>almost unique&lt;/strong> if it contains at least &lt;code>m&lt;/code> pairwise distinct elements.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive solution would be to generate all the possible subarrays of length &lt;code>k&lt;/code> and check each one to see if it is almost unique and what its sum is. This would involve nested loops and would not be efficient.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ol>
&lt;li>Use sliding window technique to find subarrays of length &lt;code>k&lt;/code>.&lt;/li>
&lt;li>Keep track of unique elements using a set.&lt;/li>
&lt;/ol>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The solution adopts a &lt;strong>sliding window&lt;/strong> approach to go through the given array &lt;code>nums&lt;/code>, checking each subarray of size &lt;code>k&lt;/code> for its &amp;ldquo;almost uniqueness&amp;rdquo; and sum.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Define a helper function, &lt;code>is_unique&lt;/code>, which will take a subarray and return whether it contains at least &lt;code>m&lt;/code> distinct elements or not.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Initialize a variable &lt;code>_max&lt;/code> to keep track of the maximum sum among the almost unique subarrays.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Loop through &lt;code>nums&lt;/code> using the sliding window technique:&lt;/p>
&lt;ul>
&lt;li>Use the &lt;code>is_unique&lt;/code> function to check if the current subarray is almost unique.&lt;/li>
&lt;li>Update &lt;code>_max&lt;/code> with the maximum sum found so far.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Return &lt;code>_max&lt;/code> if it is not 0; otherwise, return 0.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxSum&lt;/span>(nums: List[&lt;span style="color:#007020">int&lt;/span>], m: &lt;span style="color:#007020">int&lt;/span>, k: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">is_unique&lt;/span>(arr, start, end, m):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> distinct_elements &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>(arr[start:end])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(distinct_elements) &lt;span style="color:#666">&amp;gt;=&lt;/span> m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _max &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n &lt;span style="color:#666">-&lt;/span> k &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> is_unique(nums, i, i &lt;span style="color:#666">+&lt;/span> k, m):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _max &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(_max, &lt;span style="color:#007020">sum&lt;/span>(nums[i:i &lt;span style="color:#666">+&lt;/span> k]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> _max &lt;span style="color:#007020;font-weight:bold">if&lt;/span> _max &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2844/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/minimum-operations-to-make-a-special-number/">LeetCode задача 2844&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дана строка &lt;code>num&lt;/code>, представляющая неотрицательное целое число. За одну операцию вы можете выбрать любую цифру числа &lt;code>num&lt;/code> и удалить её. Вашей задачей является определить минимальное количество операций, необходимых для преобразования данного числа в &amp;ldquo;специальное&amp;rdquo; число.&lt;/p>
&lt;p>Число считается &amp;ldquo;специальным&amp;rdquo;, если оно делится на 25.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Анализ возможных окончаний числа: Число, делится на 25 если одно из четырёх возможных окончаний: &amp;lsquo;00&amp;rsquo;, &amp;lsquo;25&amp;rsquo;, &amp;lsquo;50&amp;rsquo;, &amp;lsquo;75&amp;rsquo;.&lt;/p>
&lt;p>При этом самое последнее число должно быть из двух вариантов: &amp;lsquo;5&amp;rsquo; и &amp;lsquo;0&amp;rsquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Обратный проход по строке: Проходим по строке справа налево, фиксируя наличие символов &amp;lsquo;5&amp;rsquo; и &amp;lsquo;0&amp;rsquo;.&lt;/p>
&lt;p>Используя эти флаги, ищем возможные окончания &amp;lsquo;00&amp;rsquo;, &amp;lsquo;25&amp;rsquo;, &amp;lsquo;50&amp;rsquo;, &amp;lsquo;75&amp;rsquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Подсчет операций: В процессе прохода подсчитываем минимальное количество операций, необходимых для получения &amp;ldquo;специального&amp;rdquo; числа, точнее, как только найдем оба числа.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Проверка на наличие &amp;lsquo;0&amp;rsquo;: Если в строке нет &amp;lsquo;0&amp;rsquo;, то число не может быть &amp;ldquo;специальным&amp;rdquo;, и количество операций будет равно длине строки. Это случай когда ноль (в случае удаления каждой цифры из числа, остается последним, тогда 0 делится на 25).&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализация переменных для отслеживания наличия &amp;lsquo;5&amp;rsquo; и &amp;lsquo;0&amp;rsquo;.&lt;/li>
&lt;li>Обратный проход по строке, поиск возможных окончаний и подсчет операций.&lt;/li>
&lt;li>Возврат результата.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">minimumOperations&lt;/span>(num: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(num)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализация переменных для отслеживания наличия &amp;#39;5&amp;#39; и &amp;#39;0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_5 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_0 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Обратный проход по строке&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;0&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;00&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;5&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;50&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_5 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;2&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;25&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_5 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;7&amp;#39;&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># &amp;#39;75&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Обновление флагов наличия &amp;#39;5&amp;#39; и &amp;#39;0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_0 &lt;span style="color:#666">=&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">or&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> had_5 &lt;span style="color:#666">=&lt;/span> had_5 &lt;span style="color:#007020;font-weight:bold">or&lt;/span> num[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;5&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> had_0 &lt;span style="color:#007020;font-weight:bold">else&lt;/span> n
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В некотором смысле такой подход напоминает алгоритм прохождения с двумя указателями. Как только один указатель нашел 0 или 5, он фактически остается на месте, а второй указатель &lt;code>i&lt;/code> идет дальше к началу строки в поисках второй части искомого числа.&lt;/p>
&lt;rawhtml>
&lt;/rawhtml></description></item><item><title>2848. Points That Intersect With Cars</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2848/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2848/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/points-that-intersect-with-cars/">LeetCode problem 2848&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given cars parked on a number line, represented by starting and ending coordinates, we aim to determine the number of points on this line that are covered by any part of these cars.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A basic approach is to simply iterate through each interval and for each interval, iterate through its range, adding each point to a list. Finally, we can return the length of this list to get the total points. However, this approach has a risk of counting points multiple times when two cars overlap.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Utilizing a set can prevent duplicate counting since sets do not allow duplicates.&lt;/li>
&lt;li>Iterating through each interval&amp;rsquo;s range and adding it to the set will ensure unique counting.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The idea is to use a set to hold all the integer points that the cars cover. We iterate through each car&amp;rsquo;s interval, and for each interval, we iterate through its range, adding each point to the set. As sets do not allow duplicate values, points that are covered by multiple cars are not double-counted. Finally, we return the size of the set which gives the total unique points covered by the cars.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize an empty set &lt;code>points&lt;/code>.&lt;/li>
&lt;li>Iterate through each interval in &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>For each interval, iterate through its range from start to end, adding each point to the &lt;code>points&lt;/code> set.&lt;/li>
&lt;li>Return the size of the &lt;code>points&lt;/code> set.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">numberOfPoints&lt;/span>(nums: List[List[&lt;span style="color:#007020">int&lt;/span>]]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> points &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> start, end &lt;span style="color:#007020;font-weight:bold">in&lt;/span> nums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> p &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(start, end &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> points&lt;span style="color:#666">.&lt;/span>add(p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(points)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2849. Determine if a Cell Is Reachable at a Given Time</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2849/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2849/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/determine-if-a-cell-is-reachable-at-a-given-time">LeetCode problem 2849&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>You are given starting coordinates &lt;code>(sx, sy)&lt;/code> and final coordinates &lt;code>(fx, fy)&lt;/code> on a 2D infinite grid. Starting from the initial position, you can move to any of the 8 adjacent cells in one second. The challenge is to determine if you can reach the final cell &lt;code>(fx, fy)&lt;/code> in exactly &lt;code>t&lt;/code> seconds.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to use a recursive function to navigate the grid from the starting point &lt;code>(sx, sy)&lt;/code> and attempt to reach the target &lt;code>(fx, fy)&lt;/code> in &lt;code>t&lt;/code> seconds. This approach will check every possible path, which can be very inefficient, especially for larger grids and values of &lt;code>t&lt;/code>.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Understand that not all paths are equal. Moving diagonally is more efficient than moving in a straight line if both x and y distances are positive.&lt;/li>
&lt;li>Check the constraints. If you cannot reach the destination within the given time &lt;code>t&lt;/code>, there&amp;rsquo;s no need to try any further.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The idea is to calculate the shortest possible time to reach the target and then compare it to the given time &lt;code>t&lt;/code>. If the starting point and the ending point are the same, we can always return to the same position unless the time is exactly 1.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Calculate the difference in x (&lt;code>diff_x&lt;/code>) and y (&lt;code>diff_y&lt;/code>) coordinates.&lt;/li>
&lt;li>For the minimum of &lt;code>diff_x&lt;/code> and &lt;code>diff_y&lt;/code>, move diagonally. This reduces both x and y distances by 1 in a single step.&lt;/li>
&lt;li>Move horizontally or vertically for the absolute difference between &lt;code>diff_x&lt;/code> and &lt;code>diff_y&lt;/code>.&lt;/li>
&lt;li>If &lt;code>(diff_x + diff_y)&lt;/code> is less than or equal to &lt;code>t&lt;/code>, and &lt;code>(t - (diff_x + diff_y))&lt;/code> is an even number or zero, return &lt;code>True&lt;/code>, otherwise return &lt;code>False&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">isReachableAtTime&lt;/span>(sx: &lt;span style="color:#007020">int&lt;/span>, sy: &lt;span style="color:#007020">int&lt;/span>, fx: &lt;span style="color:#007020">int&lt;/span>, fy: &lt;span style="color:#007020">int&lt;/span>, t: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> diff_x &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(fx &lt;span style="color:#666">-&lt;/span> sx) &lt;span style="color:#60a0b0;font-style:italic"># Calculating the differences in x&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> diff_y &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(fy &lt;span style="color:#666">-&lt;/span> sy) &lt;span style="color:#60a0b0;font-style:italic"># and y coordinates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> diff_x &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> diff_y &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># If both starting and ending points are same&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> t &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> diff_x &lt;span style="color:#666">&amp;lt;=&lt;/span> t &lt;span style="color:#007020;font-weight:bold">and&lt;/span> diff_y &lt;span style="color:#666">&amp;lt;=&lt;/span> t: &lt;span style="color:#60a0b0;font-style:italic"># Check if we can reach the target within given time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2856. Minimum Array Length After Pair Removals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2856/</link><pubDate>Sat, 16 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2856/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/minimum-array-length-after-pair-removals/">LeetCode problem 2856&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a 0-indexed sorted array of integers &lt;code>nums&lt;/code>, you can perform a specific operation an unlimited number of times:&lt;/p>
&lt;ol>
&lt;li>Choose two indices, &lt;code>i&lt;/code> and &lt;code>j&lt;/code>, where &lt;code>i &amp;lt; j&lt;/code> and &lt;code>nums[i] &amp;lt; nums[j]&lt;/code>.&lt;/li>
&lt;li>Remove the elements at indices &lt;code>i&lt;/code> and &lt;code>j&lt;/code> from &lt;code>nums&lt;/code>. The remaining elements retain their original order and the array is re-indexed.&lt;/li>
&lt;/ol>
&lt;p>The task is to determine and return the smallest possible length of &lt;code>nums&lt;/code> after executing the operation as many times as you wish.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>One way to approach this problem would be to iterate through every possible pair of elements in &lt;code>nums&lt;/code> to check if they satisfy the condition &lt;code>nums[i] &amp;lt; nums[j]&lt;/code>. Whenever a valid pair is found, remove them and restart the search. This method would be inefficient and would result in a high time complexity due to frequent list updates.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Utilizing two pointers can help in efficiently determining the pairs to remove.&lt;/li>
&lt;li>Keep track of removed indices in a set to avoid duplication.&lt;/li>
&lt;li>Focus on &lt;mark>removing the largest numbers&lt;/mark> since they have the most potential pairs.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>The idea is to maintain two pointers: a slow pointer &lt;code>i&lt;/code> starting from the beginning of the array and a fast pointer &lt;code>j&lt;/code> starting from the middle of the array. Since the array is sorted, this ensures that the number at &lt;code>j&lt;/code> is always greater than the number at &lt;code>i&lt;/code>.&lt;/p>
&lt;ol>
&lt;li>Traverse the list with the two pointers.&lt;/li>
&lt;li>If a valid pair is found (i.e., &lt;code>nums[i] &amp;lt; nums[j]&lt;/code> and &lt;code>i&lt;/code> hasn&amp;rsquo;t been removed yet), mark the indices &lt;code>i&lt;/code> and &lt;code>j&lt;/code> as removed.&lt;/li>
&lt;li>Move the pointer &lt;code>i&lt;/code> one step forward.&lt;/li>
&lt;li>Repeat the process until the end of the array is reached.&lt;/li>
&lt;/ol>
&lt;p>The result would be the initial length of &lt;code>nums&lt;/code> subtracted by the number of removed indices.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two pointers: &lt;code>i = 0&lt;/code> and &lt;code>j = len(nums) // 2&lt;/code>.&lt;/li>
&lt;li>Create a set &lt;code>removed&lt;/code> to keep track of removed indices.&lt;/li>
&lt;li>Traverse the list with the two pointers.&lt;/li>
&lt;li>If &lt;code>nums[j] &amp;gt; nums[i]&lt;/code> and &lt;code>i&lt;/code> hasn&amp;rsquo;t been removed, add &lt;code>i&lt;/code> and &lt;code>j&lt;/code> to the &lt;code>removed&lt;/code> set and move the pointer &lt;code>i&lt;/code> one step forward.&lt;/li>
&lt;li>Continue the process until the end of the array.&lt;/li>
&lt;li>The result is &lt;code>len(nums) - len(removed)&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">minimumLengthAfterRemoval&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> removed &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> j &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums) &lt;span style="color:#666">//&lt;/span> &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#007020">len&lt;/span>(nums)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[j] &lt;span style="color:#666">&amp;gt;&lt;/span> nums[i] &lt;span style="color:#007020;font-weight:bold">and&lt;/span> i &lt;span style="color:#007020;font-weight:bold">not&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> removed:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> removed&lt;span style="color:#666">.&lt;/span>add(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> removed&lt;span style="color:#666">.&lt;/span>add(j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#007020">len&lt;/span>(removed)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>