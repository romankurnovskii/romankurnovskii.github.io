<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tags/leetcode/</link><description>Recent content in LeetCode on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Mon, 12 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Легкие</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</guid><description/></item><item><title>Средние</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</guid><description/></item><item><title>Тяжелые</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</guid><description/></item><item><title>LeetCode</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</guid><description> Получай решения LeetCode на email: Подписаться</description></item><item><title>118. Pascal's Triangle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</guid><description>LeetCode задача 118
Задача Дано целое число numRows. Верните первые numRows строк Треугольника Паскаля.
В Треугольнике Паскаля каждое число является суммой двух чисел, находящихся непосредственно над ним.
Подсказки Для построения каждой следующей строки можно использовать последнюю строку в текущей итерации. Например, если есть строка [1, 2, 1], то следующая строка начнется и закончится с 1, а числа внутри будут получены путем сложения пар чисел: 1+2 и 2+1.
Подход Для того чтобы построить Треугольник Паскаля, начнем с первой строки, состоящей только из числа 1.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem 166
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>190. Reverse Bits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/190/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/190/</guid><description>LeetCode problem
This task involves understanding how binary representation works. An unsigned integer is a 32-bit value, where each bit represents a power of 2, from 2^0 (the least significant bit) to 2^31 (the most significant bit).
Unsigned Integers (often called &amp;ldquo;uints&amp;rdquo;) are just like integers (whole numbers) but have the property that they don&amp;rsquo;t have a + or - sign associated with them. Thus they are always non-negative (zero or positive).
Naive Solution A naive solution to this problem could involve converting the number to a binary string, reversing the string, and then converting it back to an integer.</description></item><item><title>191. Number of 1 Bits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/191/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/191/</guid><description>LeetCode problem
Problem Statement Given an integer value represented in binary format, we need to count the number of &amp;lsquo;1&amp;rsquo; bits in its binary representation.
Naive Solution The naive solution for this problem would be to convert the binary number into a string and then simply iterate over the string and count the number of &amp;lsquo;1&amp;rsquo;s. However, this solution is not optimal and is not taking advantage of the properties of binary numbers.
Algorithm The optimal solution for this problem involves using bitwise operation.</description></item><item><title>202. Happy Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/202/</link><pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/202/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a number n. We have to determine whether this number is a &amp;ldquo;happy&amp;rdquo; number or not. A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.</description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</guid><description>LeetCode задача 277
Задача Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?
Имплементируйте функцию int findCelebrity(n), которая вернет знаменитость если она есть, иначе вернёт -1.
Вам дана функция bool knows(a, b), которая скажет вам, знает ли a человека b.
Подход Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.
Алгоритм Инициализируем переменную candidate значением 0.</description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</guid><description>LeetCode задача
Задача Дан целочисленный массив nums. Нам необходимо переместить все 0 в конец массива, сохраняя относительный порядок ненулевых элементов.
Примечание: вы должны сделать это на месте, без создания копии массива.
Подсказки Используйте два указателя: один будет указывать на текущий элемент, а другой будет указывать на первое место в массиве, куда можно поместить ненулевой элемент.
Подход Мы можем использовать два указателя: один для прохода по массиву и другой для отслеживания местоположения, куда следует поместить следующий ненулевой элемент. Этот метод позволяет нам сделать минимальное количество операций и изменений в массиве.</description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</guid><description>LeetCode задача 437
Задача Дан корень бинарного дерева и целое число targetSum. Верните количество путей, где сумма значений вдоль пути равна targetSum.
Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).
Подсказки Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.
Подход Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня.</description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</guid><description>LeetCode problem
Problem Statement Given an array of integers nums, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.
Naive Solution A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index.</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1359/</guid><description>LeetCode задача 1359
Задача Дано n заказов, каждый заказ состоит из услуг по приему и доставке.
Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).
Так как ответ может быть очень большим, верните его по модулю 10^9 + 7.
Подсказки Использовать комбинаторный подход.
Для каждого нового заказа у нас есть 2 * (2n-1) способов добавить его в текущую последовательность.
Мы используем данную формулу, так как:
Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест).</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</guid><description>LeetCode задача 1647
Задача Строка s называется хорошей, если в ней нет двух разных символов с одинаковой частотой.
Дана строка s, верните минимальное количество символов, которое необходимо удалить, чтобы сделать s хорошим.
Подход Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.
Если проверять встречалась ли частота текущего символа ранее, то
Алгоритм / Абстрактный алгоритм Считаем частоты всех символов в строке. Сортируем частоты в порядке убывания.</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode задача 2352
Задача Дана квадратная матрица целых чисел grid размером n×n. Задача состоит в том, чтобы определить, сколько пар строк и столбцов в матрице идентичны по своему содержанию и порядку.
Строка и столбец считаются равными, если они содержат одни и те же элементы в том же порядке.
Подсказки Для решения задачи можно воспользоваться тем фактом, что каждая строка и столбец представляют собой набор чисел. Если мы конвертируем их в строки, то можем сравнивать их друг с другом.</description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2844/</guid><description>LeetCode задача 2844
Задача Дана строка num, представляющая неотрицательное целое число. За одну операцию вы можете выбрать любую цифру числа num и удалить её. Вашей задачей является определить минимальное количество операций, необходимых для преобразования данного числа в &amp;ldquo;специальное&amp;rdquo; число.
Число считается &amp;ldquo;специальным&amp;rdquo;, если оно делится на 25.
Подход Анализ возможных окончаний числа: Число, делится на 25 если одно из четырёх возможных окончаний: &amp;lsquo;00&amp;rsquo;, &amp;lsquo;25&amp;rsquo;, &amp;lsquo;50&amp;rsquo;, &amp;lsquo;75&amp;rsquo;.
При этом самое последнее число должно быть из двух вариантов: &amp;lsquo;5&amp;rsquo; и &amp;lsquo;0&amp;rsquo;.</description></item><item><title>3028. Ant on the Boundary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</guid><description>LeetCode задача 3028
Воспользуемся функцией accumulate из модуля itertools, чтобы упростить вычисление и подсчет количества раз, когда муравей возвращается на границу, пройдя через массив nums.
Применяем функцию accumulate для подсчета накопительной суммы и подсчитываем количество раз, когда накопительная сумма равна 0.
Решение class Solution: def returnToBoundaryCount(self, nums: List[int]) -&amp;gt; int: return sum(s == 0 for s in accumulate(nums)) Функция accumulate(nums) генерирует последовательность накопленных сумм элементов массива nums, начиная с первого элемента.
Затем с помощью генераторного выражения s == 0 for s in accumulate(nums) мы создаем последовательность True и False, в зависимости от того, равна ли накопленная сумма в каждой точке нулю.</description></item><item><title>3030. Find the Grid of Region Average</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</guid><description>LeetCode задача 3030
Дана матрица m x n, представляющая изображение в оттенках серого, где image[i][j] представляет пиксель с интенсивностью в диапазоне от 0 до 255. Также дано неотрицательное целое число threshold (пороговое значение).
Два пикселя image[a][b] и image[c][d] считаются соседними, если |a - c| + |b - d| == 1.
Регионом считается матрица 3 x 3, где абсолютная разница в интенсивности между любыми двумя соседними пикселями меньше или равна threshold.
Необходимо вычислить матрицу m x n result, где result[i][j] - это средняя интенсивность региона, к которому принадлежит image[i][j], округленная вниз до ближайшего целого числа.</description></item></channel></rss>