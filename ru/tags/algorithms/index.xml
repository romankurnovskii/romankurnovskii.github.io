<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tags/algorithms/</link><description>Recent content in Algorithms on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Fri, 09 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>394. Decode String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode задача 394
Задача На вход подается закодированная строка, необходимо вернуть её декодированное представление.
Правило кодирования таково: k[encoded_string], где encoded_string - строка внутри квадратных скобок, повторяется ровно k раз. k - это всегда положительное целое число.
Подсказки Для решения этой задачи можно использовать стек, т.к. число[строка] могут быть вложенными.
Подход Всё, что нам нужно, это итерировать строку символ за символом и обрабатывать четыре случая: числа, буквы и скобки. Мы будем использовать один стек для хранения пар вида (префикс строки, число).</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode задача 605
Задача Дана длинная грядка, на которой некоторые участки уже засажены, а некоторые нет. Однако цветы нельзя сажать на соседние участки.
Подход Чтобы решить эту задачу, мы будем итерироваться по каждому участку грядки. Если участок пустой и его соседи (если они существуют) тоже пусты, мы сажаем цветок и уменьшаем наш счетчик.
Алгоритм Итерируемся по каждому участку грядки. Если участок пустой, проверяем его соседей. Если левый сосед пустой или его нет (начало грядки), проверяем правого соседа. Если правый сосед пустой или его нет (конец грядки), сажаем цветок на текущий участок и уменьшаем n.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode задача 1071
Задача Для двух строк str1 и str2, вернуть наибольший общий делитель (НОД). Если такового не существует, вернуть пустую строку.
Подход Если строки str1 и str2 имеют НОД строки X, то str1 и str2 могут быть представлены в форме Xn и Xm (где n и m — это натуральные числа), соответственно. Это означает, что str1 должна начинаться с str2 или наоборот.
Алгоритм Проверка начала строк: если str1 не начинается с str2 или наоборот, то НОД не существует.</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</guid><description>LeetCode задача 1359
Задача Дано n заказов, каждый заказ состоит из услуг по приему и доставке.
Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).
Так как ответ может быть очень большим, верните его по модулю 10^9 + 7.
Подсказки Использовать комбинаторный подход.
Для каждого нового заказа у нас есть 2 * (2n-1) способов добавить его в текущую последовательность.
Мы используем данную формулу, так как:
Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест).</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</guid><description>LeetCode задача 1768
Задача Вам даны две строки word1 и word2. Объедините эти строки, добавляя буквы в чередующем порядке, начиная с word1. Если одна строка длиннее другой, дополнительные буквы добавляются в конец результирующей строки.
Подход Чтобы решить эту задачу, мы можем использовать два указателя для каждого слова. Начнем с первого символа каждой строки и будем чередовать их, пока одна из строк не закончится. После этого, мы просто добавляем оставшиеся символы из более длинного слова к результирующей строке.
Алгоритм Инициализация результирующей строки и двух указателей для word1 и word2.</description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2844/</guid><description>LeetCode задача 2844
Задача Дана строка num, представляющая неотрицательное целое число. За одну операцию вы можете выбрать любую цифру числа num и удалить её. Вашей задачей является определить минимальное количество операций, необходимых для преобразования данного числа в &amp;ldquo;специальное&amp;rdquo; число.
Число считается &amp;ldquo;специальным&amp;rdquo;, если оно делится на 25.
Подход Анализ возможных окончаний числа: Число, делится на 25 если одно из четырёх возможных окончаний: &amp;lsquo;00&amp;rsquo;, &amp;lsquo;25&amp;rsquo;, &amp;lsquo;50&amp;rsquo;, &amp;lsquo;75&amp;rsquo;.
При этом самое последнее число должно быть из двух вариантов: &amp;lsquo;5&amp;rsquo; и &amp;lsquo;0&amp;rsquo;.</description></item><item><title>3028. Ant on the Boundary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</guid><description>LeetCode задача 3028
Воспользуемся функцией accumulate из модуля itertools, чтобы упростить вычисление и подсчет количества раз, когда муравей возвращается на границу, пройдя через массив nums.
Применяем функцию accumulate для подсчета накопительной суммы и подсчитываем количество раз, когда накопительная сумма равна 0.
Решение class Solution: def returnToBoundaryCount(self, nums: List[int]) -&amp;gt; int: return sum(s == 0 for s in accumulate(nums)) Функция accumulate(nums) генерирует последовательность накопленных сумм элементов массива nums, начиная с первого элемента.
Затем с помощью генераторного выражения s == 0 for s in accumulate(nums) мы создаем последовательность True и False, в зависимости от того, равна ли накопленная сумма в каждой точке нулю.</description></item></channel></rss>