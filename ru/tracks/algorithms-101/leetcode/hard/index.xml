<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Тяжелые on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</link><description>Recent content in Тяжелые on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/index.xml" rel="self" type="application/rss+xml"/><item><title>4. Median of Two Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</guid><description>LeetCode задача 4
Задача Даны два отсортированных массива nums1 и nums2 размера m и n соответственно. Найти медиану двух отсортированных массивов.
Подсказки Чтобы найти медиану, нужно сначала объединить два массива и отсортировать их. После этого медиана будет либо средним элементом, если общее количество элементов нечетное, либо средним значением двух центральных элементов, если общее количество элементов четное.
Подход Мы можем объединить два массива в один большой отсортированный массив и найти медиану этого массива. Этот подход не самый эффективный, но он прост и понятен.</description></item><item><title>42. Trapping Rain Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</guid><description>LeetCode задача 42
Задача Дан массив неотрицательных целых чисел, представляющих собой карту высот, где ширина каждой стойки равна 1. Вычислите, сколько воды может удерживать этот массив после дождя.
Подсказки Мы можем решить эту задачу, двигаясь от краев массива к его центру, отслеживая текущую максимальную высоту с обеих сторон.
Подход Простой и понятный способ решения этой задачи - пройтись по массиву и для каждого элемента вычислить, сколько воды он может удержать.
Алгоритм Инициализируем переменную для хранения общего объема воды, который может быть удержан.</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1004/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1004/</guid><description>LeetCode задача 1004
Задача Дан массив A состоящий из 0 и 1, и число K. Найти максимальную длину подпоследовательности единиц, которую можно получить, преобразовав не более K нулей в единицы.
Подсказки Использование скользящего окна может значительно ускорить решение задачи.
Подход Инициализация: Создайте переменные для хранения начала и конца &amp;ldquo;окна&amp;rdquo; и максимальной длины подпоследовательности. Проход по массиву: Перемещайте &amp;ldquo;окно&amp;rdquo; по массиву, подсчитывая количество нулей внутри. Сдвиг окна: Если количество нулей превышает K, сдвигайте левый край окна, пока это не станет истиной.</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1372/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1372/</guid><description>LeetCode задача 1372
Задача Найти самый длинный &amp;ldquo;ZigZag&amp;rdquo; путь в бинарном дереве. Путь &amp;ldquo;ZigZag&amp;rdquo; означает альтернативное движение влево и вправо при переходе от одного узла к другому.
Подсказки Используйте Depth-First Search (DFS) для решения задачи.
Подход DFS с состоянием: Запустите DFS с дополнительным аргументом, который будет отслеживать, в какую сторону нужно двигаться следующим (влево или вправо). Обновление максимума: На каждом уровне рекурсии проверьте, не превышает ли текущая длина пути максимальную известную длину. Рекурсивный вызов: Продолжайте движение в обоих направлениях, но учитывайте, что направление должно изменяться.</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1732/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1732/</guid><description>LeetCode задача 1732
Задача Велосипедист совершает путешествие, которое состоит из n + 1 точек на разных высотах. Путешествие начинается с точки 0, где высота равна 0.
Дан целочисленный массив gain длиной n, где gain[i] — это прирост высоты между точками i и i + 1 для всех (0 &amp;lt;= i &amp;lt; n).
Задача - вернуть самую высокую высоту точки.
Подход В этой задаче, вам нужно пройти по массиву gain и вычислить текущую высоту на каждом этапе. При этом следует отслеживать самую высокую высоту, которую вы достигли.</description></item><item><title>2013. Detect Squares</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2013/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2013/</guid><description>LeetCode задача 2013
В данное задаче решение будет с использованием переменных на русском языке
Задача Задача заключается в разработке структуры данных, которая позволяет добавлять точки на плоскости и подсчитывать количество квадратов, которые можно образовать, добавив новую точку.
Подсказки Решение включает в себя поддержку двух типов данных:
Счётчик точек счетчик_точек, который хранит информацию о количестве каждой точки на плоскости. Словарь координат по оси X координаты_по_x, который для каждой координаты x содержит счётчик координат y, позволяющий быстро находить все точки с данной координатой x.</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>3016. Minimum Number of Pushes to Type Word II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3016/</guid><description>LeetCode problem 3016
class Solution: def minimumPushes(self, word: str) -&amp;gt; int: cnt = Counter(word) res = 0 for i, x in enumerate(sorted(cnt.values(), reverse=True)): res += (i // 8 + 1) * x return res</description></item><item><title>3032</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3032/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3032/</guid><description>https://leetcode.com/problems/count-numbers-with-unique-digits-ii
class Solution: def numberCount(self, a: int, b: int) -&amp;gt; int: # Initialize the count of numbers with all unique digits unique_digit_count = 0 # Loop through each number in the range from a to b, inclusive for num in range(a, b + 1): # Convert the number to a string to examine its digits num_str = str(num) # Convert the string to a set of characters to remove duplicates unique_digits = set(num_str) # If the length of the set is equal to the length of the number string, # it means all digits are unique if len(unique_digits) == len(num_str): # Increment the count for each number with all unique digits unique_digit_count += 1 # Return the total count of unique digit numbers return unique_digit_count</description></item><item><title>3045. Count Prefix and Suffix Pairs II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2402/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2402/</guid><description>LeetCode problem 3045
Hint To solve this problem efficiently, consider using a Trie (prefix tree) to store each word in a way that allows checking for prefixes and suffixes simultaneously.
Idea The key idea is to leverage a Trie data structure, but with a twist: instead of only considering prefixes (as is typical with tries), we also account for suffixes simultaneously. This dual consideration allows us to efficiently count valid prefix-suffix pairs among the words.
Approach Trie Construction: Build a Trie where each node represents a pair of characters (prefix_char, suffix_char) from a word and its reversed counterpart.</description></item><item><title>3045. Count Prefix and Suffix Pairs II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3045/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3045/</guid><description>LeetCode problem 3045
Hint To solve this problem efficiently, consider using a Trie (prefix tree) to store each word in a way that allows checking for prefixes and suffixes simultaneously.
Idea The key idea is to leverage a Trie data structure, but with a twist: instead of only considering prefixes (as is typical with tries), we also account for suffixes simultaneously. This dual consideration allows us to efficiently count valid prefix-suffix pairs among the words.
Approach Trie Construction: Build a Trie where each node represents a pair of characters (prefix_char, suffix_char) from a word and its reversed counterpart.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2808/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2808/</guid><description>class Solution: def minimumSeconds(self, nums: List[int]) -&amp;gt; int: d = defaultdict(list) for i, x in enumerate(nums): d[x].append(i) res = inf n = len(nums) for idx in d.values(): t = idx[0] + n - idx[-1] for i, j in pairwise(idx): t = max(t, j - i) res = min(res, t // 2) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2818/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2818/</guid><description>def primeFactors(n): i = 2 res = set() while i * i &amp;lt;= n: while n % i == 0: res.add(i) n //= i i += 1 if n &amp;gt; 1: res.add(n) return len(res) class Solution: def maximumScore(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 arr = [(i, primeFactors(x), x) for i, x in enumerate(nums)] n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, f, x in arr: while stk and stk[-1][0] &amp;lt; f: stk.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2826/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2826/</guid><description>class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: f = [0] * 3 for x in nums: g = [0] * 3 if x == 1: g[0] = f[0] g[1] = min(f[:2]) + 1 g[2] = min(f) + 1 elif x == 2: g[0] = f[0] + 1 g[1] = min(f[:2]) g[2] = min(f) + 1 else: g[0] = f[0] + 1 g[1] = min(f[:2]) + 1 g[2] = min(f) f = g return min(f)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2827/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2827/</guid><description>class Solution: def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -&amp;gt; int: @cache def dfs(pos: int, mod: int, diff: int, lead: int, limit: int) -&amp;gt; int: if pos &amp;gt;= len(s): return mod == 0 and diff == 10 up = int(s[pos]) if limit else 9 res = 0 for i in range(up + 1): if i == 0 and lead: res += dfs(pos + 1, mod, diff, 1, limit and i == up) else: nxt = diff + (1 if i % 2 == 1 else -1) res += dfs(pos + 1, (mod * 10 + i) % k, nxt, 0, limit and i == up) return res s = str(high) a = dfs(0, 0, 10, 1, 1) dfs.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2846/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2846/</guid><description>class Solution: def minOperationsQueries( self, n: int, edges: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: m = n.bit_length() g = [[] for _ in range(n)] f = [[0] * m for _ in range(n)] p = [0] * n cnt = [None] * n depth = [0] * n for u, v, w in edges: g[u].append((v, w - 1)) g[v].append((u, w - 1)) cnt[0] = [0] * 26 q = deque([0]) while q: i = q.popleft() f[i][0] = p[i] for j in range(1, m): f[i][j] = f[f[i][j - 1]][j - 1] for j, w in g[i]: if j !</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2851/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2851/</guid><description>&amp;#34;&amp;#34;&amp;#34; DP, Z-algorithm, Fast mod. Approach How to represent a string? Each operation is just a rotation. Each result string can be represented by an integer from 0 to n - 1. Namely, it&amp;#39;s just the new index of s[0]. How to find the integer(s) that can represent string t? Create a new string s + t + t (length = 3 * n). Use Z-algorithm (or KMP), for each n &amp;lt;= index &amp;lt; 2 * n, calculate the maximum prefix length that each substring starts from index can match, if the length &amp;gt;= n, then (index - n) is a valid integer representation.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2852/</guid><description>class Solution: def sumRemoteness(self, grid: List[List[int]]) -&amp;gt; int: def dfs(i: int, j: int) -&amp;gt; (int, int): s, t = grid[i][j], 1 grid[i][j] = 0 for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; n and 0 &amp;lt;= y &amp;lt; n and grid[x][y] &amp;gt; 0: s1, t1 = dfs(x, y) s, t = s + s1, t + t1 return s, t n = len(grid) dirs = (-1, 0, 1, 0, -1) cnt = sum(x &amp;gt; 0 for row in grid for x in row) res = 0 for i, row in enumerate(grid): for j, x in enumerate(row): if x &amp;gt; 0: s, t = dfs(i, j) res += (cnt - t) * s return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2865/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2865/</guid><description>class Solution: def maximumSumOfHeights(self, maxHeights: List[int]) -&amp;gt; int: n = len(maxHeights) stk = [] left = [-1] * n for i, x in enumerate(maxHeights): while stk and maxHeights[stk[-1]] &amp;gt; x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] right = [n] * n for i in range(n - 1, -1, -1): x = maxHeights[i] while stk and maxHeights[stk[-1]] &amp;gt;= x: stk.pop() if stk: right[i] = stk[-1] stk.append(i) f = [0] * n for i, x in enumerate(maxHeights): if i and x &amp;gt;= maxHeights[i - 1]: f[i] = f[i - 1] + x else: j = left[i] f[i] = x * (i - j) + (f[j] if j !</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2874/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2874/</guid><description>class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2879/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2879/</guid><description>import pandas as pd def selectFirstRows(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: return employees.head(3)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2884/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2884/</guid><description>import pandas as pd def modifySalaryColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;salary&amp;#39;] *= 2 return employees</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2894/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2894/</guid><description>class Solution: def differenceOfSums(self, n: int, m: int) -&amp;gt; int: return sum(i if i % m else -i for i in range(1, n + 1))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2897/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2897/</guid><description>class Solution: def maxSum(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 cnt = [0] * 31 for x in nums: for i in range(31): if x &amp;gt;&amp;gt; i &amp;amp; 1: cnt[i] += 1 res = 0 for _ in range(k): x = 0 for i in range(31): if cnt[i]: x |= 1 &amp;lt;&amp;lt; i cnt[i] -= 1 res = (res + x * x) % mod return res</description></item></channel></rss>