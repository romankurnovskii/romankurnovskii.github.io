<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Тяжелые on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</link><description>Recent content in Тяжелые on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/index.xml" rel="self" type="application/rss+xml"/><item><title>4. Median of Two Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</guid><description>LeetCode задача 4
Задача Даны два отсортированных массива nums1 и nums2 размера m и n соответственно. Найти медиану двух отсортированных массивов.
Подсказки Чтобы найти медиану, нужно сначала объединить два массива и отсортировать их. После этого медиана будет либо средним элементом, если общее количество элементов нечетное, либо средним значением двух центральных элементов, если общее количество элементов четное.
Подход Мы можем объединить два массива в один большой отсортированный массив и найти медиану этого массива. Этот подход не самый эффективный, но он прост и понятен.</description></item><item><title>42. Trapping Rain Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</guid><description>LeetCode задача 42
Задача Дан массив неотрицательных целых чисел, представляющих собой карту высот, где ширина каждой стойки равна 1. Вычислите, сколько воды может удерживать этот массив после дождя.
Подсказки Мы можем решить эту задачу, двигаясь от краев массива к его центру, отслеживая текущую максимальную высоту с обеих сторон.
Подход Простой и понятный способ решения этой задачи - пройтись по массиву и для каждого элемента вычислить, сколько воды он может удержать.
Алгоритм Инициализируем переменную для хранения общего объема воды, который может быть удержан.</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1004/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1004/</guid><description>LeetCode задача 1004
Задача Дан массив A состоящий из 0 и 1, и число K. Найти максимальную длину подпоследовательности единиц, которую можно получить, преобразовав не более K нулей в единицы.
Подсказки Использование скользящего окна может значительно ускорить решение задачи.
Подход Инициализация: Создайте переменные для хранения начала и конца &amp;ldquo;окна&amp;rdquo; и максимальной длины подпоследовательности. Проход по массиву: Перемещайте &amp;ldquo;окно&amp;rdquo; по массиву, подсчитывая количество нулей внутри. Сдвиг окна: Если количество нулей превышает K, сдвигайте левый край окна, пока это не станет истиной.</description></item><item><title>1224. Maximum Equal Frequency</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1224/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1224/</guid><description>LeetCode problem 1224
class Solution: def maxEqualFreq(self, nums: List[int]) -&amp;gt; int: cnt = Counter() ccnt = Counter() res = mx = 0 for i, v in enumerate(nums, 1): if v in cnt: ccnt[cnt[v]] -= 1 cnt[v] += 1 mx = max(mx, cnt[v]) ccnt[cnt[v]] += 1 if mx == 1: res = i elif ccnt[mx] * mx + ccnt[mx - 1] * (mx - 1) == i and ccnt[mx] == 1: res = i elif ccnt[mx] * mx + 1 == i and ccnt[1] == 1: res = i return res</description></item><item><title>1231. Divide Chocolate</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1231/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1231/</guid><description>LeetCode problem 1231
class Solution: def maximizeSweetness(self, sweetness: List[int], k: int) -&amp;gt; int: def check(x: int) -&amp;gt; bool: s = cnt = 0 for v in sweetness: s += v if s &amp;gt;= x: s = 0 cnt += 1 return cnt &amp;gt; k l, r = 0, sum(sweetness) while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 if check(mid): l = mid else: r = mid - 1 return l</description></item><item><title>1235. Maximum Profit in Job Scheduling</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1235/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1235/</guid><description>LeetCode problem 1235
class Solution: def jobScheduling( self, startTime: List[int], endTime: List[int], profit: List[int] ) -&amp;gt; int: jobs = sorted(zip(endTime, startTime, profit)) n = len(profit) dp = [0] * (n + 1) for i, (_, s, p) in enumerate(jobs): j = bisect_right(jobs, s, hi=i, key=lambda x: x[0]) dp[i + 1] = max(dp[i], dp[j] + p) return dp[n]</description></item><item><title>1240. Tiling a Rectangle with the Fewest Squares</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1240/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1240/</guid><description>LeetCode problem 1240
class Solution: def tilingRectangle(self, n: int, m: int) -&amp;gt; int: def dfs(i: int, j: int, t: int): nonlocal res if j == m: i += 1 j = 0 if i == n: res = t return if filled[i] &amp;gt;&amp;gt; j &amp;amp; 1: dfs(i, j + 1, t) elif t + 1 &amp;lt; res: r = c = 0 for k in range(i, n): if filled[k] &amp;gt;&amp;gt; j &amp;amp; 1: break r += 1 for k in range(j, m): if filled[i] &amp;gt;&amp;gt; k &amp;amp; 1: break c += 1 mx = min(r, c) for x in range(i, i + mx): for y in range(j, j + mx): filled[x] |= 1 &amp;lt;&amp;lt; y for w in range(mx, 0, -1): dfs(i, j + w, t + 1) for k in range(w): filled[i + w - 1] ^= 1 &amp;lt;&amp;lt; (j + k) if k &amp;lt; w - 1: filled[i + k] ^= 1 &amp;lt;&amp;lt; (j + w - 1) res = n * m filled = [0] * n dfs(0, 0, 0) return res</description></item><item><title>1246. Palindrome Removal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1246/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1246/</guid><description>LeetCode problem 1246
class Solution: def minimumMoves(self, arr: List[int]) -&amp;gt; int: n = len(arr) f = [[0] * n for _ in range(n)] for i in range(n): f[i][i] = 1 for i in range(n - 2, -1, -1): for j in range(i + 1, n): if i + 1 == j: f[i][j] = 1 if arr[i] == arr[j] else 2 else: t = f[i + 1][j - 1] if arr[i] == arr[j] else inf for k in range(i, j): t = min(t, f[i][k] + f[k + 1][j]) f[i][j] = t return f[0][n - 1]</description></item><item><title>1250. Check If It Is a Good Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1250/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1250/</guid><description>LeetCode problem 1250
class Solution: def isGoodArray(self, nums: List[int]) -&amp;gt; bool: return reduce(gcd, nums) == 1</description></item><item><title>1255. Maximum Score Words Formed by Letters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1255/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1255/</guid><description>LeetCode problem 1255
class Solution: def maxScoreWords( self, words: List[str], letters: List[str], score: List[int] ) -&amp;gt; int: cnt = Counter(letters) n = len(words) res = 0 for i in range(1 &amp;lt;&amp;lt; n): cur = Counter(&amp;#39;&amp;#39;.join([words[j] for j in range(n) if i &amp;gt;&amp;gt; j &amp;amp; 1])) if all(v &amp;lt;= cnt[c] for c, v in cur.items()): t = sum(v * score[ord(c) - ord(&amp;#39;a&amp;#39;)] for c, v in cur.items()) res = max(res, t) return res</description></item><item><title>1259. Handshakes That Don't Cross</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1259/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1259/</guid><description>LeetCode problem 1259
class Solution: def numberOfWays(self, numPeople: int) -&amp;gt; int: @cache def dfs(i: int) -&amp;gt; int: if i &amp;lt; 2: return 1 res = 0 for l in range(0, i, 2): r = i - l - 2 res += dfs(l) * dfs(r) res %= mod return res mod = 10**9 + 7 return dfs(numPeople)</description></item><item><title>1263. Minimum Moves to Move a Box to Their Target Location</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1263/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1263/</guid><description>LeetCode problem 1263
class Solution: def minPushBox(self, grid: List[List[str]]) -&amp;gt; int: def f(i: int, j: int) -&amp;gt; int: return i * n + j def check(i: int, j: int) -&amp;gt; bool: return 0 &amp;lt;= i &amp;lt; m and 0 &amp;lt;= j &amp;lt; n and grid[i][j] != &amp;#34;#&amp;#34; for i, row in enumerate(grid): for j, c in enumerate(row): if c == &amp;#34;S&amp;#34;: si, sj = i, j elif c == &amp;#34;B&amp;#34;: bi, bj = i, j m, n = len(grid), len(grid[0]) dirs = (-1, 0, 1, 0, -1) q = deque([(f(si, sj), f(bi, bj), 0)]) vis = [[False] * (m * n) for _ in range(m * n)] vis[f(si, sj)][f(bi, bj)] = True while q: s, b, d = q.</description></item><item><title>1269. Number of Ways to Stay in the Same Place After Some Steps</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1269/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1269/</guid><description>LeetCode problem 1269
class Solution: def numWays(self, steps: int, arrLen: int) -&amp;gt; int: @cache def dfs(i, j): if i &amp;gt; j or i &amp;gt;= arrLen or i &amp;lt; 0 or j &amp;lt; 0: return 0 if i == 0 and j == 0: return 1 res = 0 for k in range(-1, 2): res += dfs(i + k, j - 1) res %= mod return res mod = 10**9 + 7 return dfs(0, steps)</description></item><item><title>1274. Number of Ships in a Rectangle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1274/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1274/</guid><description>LeetCode problem 1274
# &amp;#34;&amp;#34;&amp;#34; # This is Sea&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class Sea: # def hasShips(self, topRight: &amp;#39;Point&amp;#39;, bottomLeft: &amp;#39;Point&amp;#39;) -&amp;gt; bool: # # class Point: # def __init__(self, x: int, y: int): # self.x = x # self.y = y class Solution: def countShips(self, sea: &amp;#34;Sea&amp;#34;, topRight: &amp;#34;Point&amp;#34;, bottomLeft: &amp;#34;Point&amp;#34;) -&amp;gt; int: def dfs(topRight, bottomLeft): x1, y1 = bottomLeft.x, bottomLeft.y x2, y2 = topRight.</description></item><item><title>1278. Palindrome Partitioning III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1278/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1278/</guid><description>LeetCode problem 1278
class Solution: def palindromePartition(self, s: str, k: int) -&amp;gt; int: n = len(s) g = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][j] = int(s[i] != s[j]) if i + 1 &amp;lt; j: g[i][j] += g[i + 1][j - 1] f = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, min(i, k) + 1): if j == 1: f[i][j] = g[0][i - 1] else: f[i][j] = inf for h in range(j - 1, i): f[i][j] = min(f[i][j], f[h][j - 1] + g[h][i - 1]) return f[n][k]</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1284/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1284/</guid><description>LeetCode problem 1284
class Solution: def minFlips(self, mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) state = sum(1 &amp;lt;&amp;lt; (i * n + j) for i in range(m) for j in range(n) if mat[i][j]) q = deque([state]) vis = {state} res = 0 dirs = [0, -1, 0, 1, 0, 0] while q: for _ in range(len(q)): state = q.popleft() if state == 0: return res for i in range(m): for j in range(n): nxt = state for k in range(5): x, y = i + dirs[k], j + dirs[k + 1] if not 0 &amp;lt;= x &amp;lt; m or not 0 &amp;lt;= y &amp;lt; n: continue if nxt &amp;amp; (1 &amp;lt;&amp;lt; (x * n + y)): nxt -= 1 &amp;lt;&amp;lt; (x * n + y) else: nxt |= 1 &amp;lt;&amp;lt; (x * n + y) if nxt not in vis: vis.</description></item><item><title>1289. Minimum Falling Path Sum II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1289/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1289/</guid><description>LeetCode problem 1289
class Solution: def minFallingPathSum(self, grid: List[List[int]]) -&amp;gt; int: f = g = 0 fp = -1 for row in grid: ff = gg = inf ffp = -1 for j, v in enumerate(row): s = (g if j == fp else f) + v if s &amp;lt; ff: gg = ff ff = s ffp = j elif s &amp;lt; gg: gg = s f, g, fp = ff, gg, ffp return f</description></item><item><title>1293. Shortest Path in a Grid with Obstacles Elimination</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1293/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1293/</guid><description>LeetCode problem 1293
class Solution: def shortestPath(self, grid: List[List[int]], k: int) -&amp;gt; int: m, n = len(grid), len(grid[0]) if k &amp;gt;= m + n - 3: return m + n - 2 q = deque([(0, 0, k)]) vis = {(0, 0, k)} res = 0 while q: res += 1 for _ in range(len(q)): i, j, k = q.popleft() for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]: x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n: if x == m - 1 and y == n - 1: return res if grid[x][y] == 0 and (x, y, k) not in vis: q.</description></item><item><title>1298. Maximum Candies You Can Get from Boxes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1298/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1298/</guid><description>LeetCode problem 1298
class Solution: def maxCandies( self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int], ) -&amp;gt; int: q = deque([i for i in initialBoxes if status[i] == 1]) res = sum(candies[i] for i in initialBoxes if status[i] == 1) has = set(initialBoxes) took = {i for i in initialBoxes if status[i] == 1} while q: i = q.popleft() for k in keys[i]: status[k] = 1 if k in has and k not in took: res += candies[k] took.</description></item><item><title>1301. Number of Paths with Max Score</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1301/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1301/</guid><description>LeetCode problem 1301
class Solution: def pathsWithMaxScore(self, board: List[str]) -&amp;gt; List[int]: def update(i, j, x, y): if x &amp;gt;= n or y &amp;gt;= n or f[x][y] == -1 or board[i][j] in &amp;#34;XS&amp;#34;: return if f[x][y] &amp;gt; f[i][j]: f[i][j] = f[x][y] g[i][j] = g[x][y] elif f[x][y] == f[i][j]: g[i][j] += g[x][y] n = len(board) f = [[-1] * n for _ in range(n)] g = [[0] * n for _ in range(n)] f[-1][-1], g[-1][-1] = 0, 1 for i in range(n - 1, -1, -1): for j in range(n - 1, -1, -1): update(i, j, i + 1, j) update(i, j, i, j + 1) update(i, j, i + 1, j + 1) if f[i][j] !</description></item><item><title>1312. Minimum Insertion Steps to Make a String Palindrome</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1312/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1312/</guid><description>LeetCode problem 1312
class Solution: def minInsertions(self, s: str) -&amp;gt; int: n = len(s) f = [[0] * n for _ in range(n)] for k in range(2, n + 1): for i in range(n - k + 1): j = i + k - 1 if s[i] == s[j]: f[i][j] = f[i + 1][j - 1] else: f[i][j] = min(f[i + 1][j], f[i][j - 1]) + 1 return f[0][n - 1]</description></item><item><title>1316. Distinct Echo Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1316/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1316/</guid><description>LeetCode problem 1316
class Solution: def distinctEchoSubstrings(self, text: str) -&amp;gt; int: def get(l, r): return (h[r] - h[l - 1] * p[r - l + 1]) % mod n = len(text) base = 131 mod = int(1e9) + 7 h = [0] * (n + 10) p = [1] * (n + 10) for i, c in enumerate(text): t = ord(c) - ord(&amp;#39;a&amp;#39;) + 1 h[i + 1] = (h[i] * base) % mod + t p[i + 1] = (p[i] * base) % mod vis = set() for i in range(n - 1): for j in range(i + 1, n, 2): k = (i + j) &amp;gt;&amp;gt; 1 a = get(i + 1, k + 1) b = get(k + 2, j + 1) if a == b: vis.</description></item><item><title>1320. Minimum Distance to Type a Word Using Two Fingers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1320/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1320/</guid><description>LeetCode problem 1320
class Solution: def minimumDistance(self, word: str) -&amp;gt; int: def dist(a: int, b: int) -&amp;gt; int: x1, y1 = divmod(a, 6) x2, y2 = divmod(b, 6) return abs(x1 - x2) + abs(y1 - y2) n = len(word) f = [[[inf] * 26 for _ in range(26)] for _ in range(n)] for j in range(26): f[0][ord(word[0]) - ord(&amp;#39;A&amp;#39;)][j] = 0 f[0][j][ord(word[0]) - ord(&amp;#39;A&amp;#39;)] = 0 for i in range(1, n): a, b = ord(word[i - 1]) - ord(&amp;#39;A&amp;#39;), ord(word[i]) - ord(&amp;#39;A&amp;#39;) d = dist(a, b) for j in range(26): f[i][b][j] = min(f[i][b][j], f[i - 1][a][j] + d) f[i][j][b] = min(f[i][j][b], f[i - 1][j][a] + d) if j == a: for k in range(26): t = dist(k, b) f[i][b][j] = min(f[i][b][j], f[i - 1][k][a] + t) f[i][j][b] = min(f[i][j][b], f[i - 1][a][k] + t) a = min(f[n - 1][ord(word[-1]) - ord(&amp;#39;A&amp;#39;)]) b = min(f[n - 1][j][ord(word[-1]) - ord(&amp;#39;A&amp;#39;)] for j in range(26)) return int(min(a, b))</description></item><item><title>1326. Minimum Number of Taps to Open to Water a Garden</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1326/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1326/</guid><description>LeetCode problem 1326
class Solution: def minTaps(self, n: int, ranges: List[int]) -&amp;gt; int: last = [0] * (n + 1) for i, x in enumerate(ranges): l, r = max(0, i - x), i + x last[l] = max(last[l], r) res = mx = pre = 0 for i in range(n): mx = max(mx, last[i]) if mx &amp;lt;= i: return -1 if pre == i: res += 1 pre = mx return res</description></item><item><title>1330. Reverse Subarray To Maximize Array Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1330/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1330/</guid><description>LeetCode problem 1330
class Solution: def maxValueAfterReverse(self, nums: List[int]) -&amp;gt; int: res = s = sum(abs(x - y) for x, y in pairwise(nums)) for x, y in pairwise(nums): res = max(res, s + abs(nums[0] - y) - abs(x - y)) res = max(res, s + abs(nums[-1] - x) - abs(x - y)) for k1, k2 in pairwise((1, -1, -1, 1, 1)): mx, mi = -inf, inf for x, y in pairwise(nums): a = k1 * x + k2 * y b = abs(x - y) mx = max(mx, a - b) mi = min(mi, a + b) res = max(res, s + max(mx - mi, 0)) return res</description></item><item><title>1335. Minimum Difficulty of a Job Schedule</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1335/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1335/</guid><description>LeetCode problem 1335
class Solution: def minDifficulty(self, jobDifficulty: List[int], d: int) -&amp;gt; int: n = len(jobDifficulty) f = [[inf] * (d + 1) for _ in range(n + 1)] f[0][0] = 0 for i in range(1, n + 1): for j in range(1, min(d + 1, i + 1)): mx = 0 for k in range(i, 0, -1): mx = max(mx, jobDifficulty[k - 1]) f[i][j] = min(f[i][j], f[k - 1][j - 1] + mx) return -1 if f[n][d] &amp;gt;= inf else f[n][d]</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1340. Jump Game V</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1340/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1340/</guid><description>LeetCode problem 1340
class Solution: def maxJumps(self, arr: List[int], d: int) -&amp;gt; int: n = len(arr) f = [1] * n for x, i in sorted(zip(arr, range(n))): for j in range(i - 1, -1, -1): if i - j &amp;gt; d or arr[j] &amp;gt;= x: break f[i] = max(f[i], 1 + f[j]) for j in range(i + 1, n): if j - i &amp;gt; d or arr[j] &amp;gt;= x: break f[i] = max(f[i], 1 + f[j]) return max(f)</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1372/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1372/</guid><description>LeetCode задача 1372
Задача Найти самый длинный &amp;ldquo;ZigZag&amp;rdquo; путь в бинарном дереве. Путь &amp;ldquo;ZigZag&amp;rdquo; означает альтернативное движение влево и вправо при переходе от одного узла к другому.
Подсказки Используйте Depth-First Search (DFS) для решения задачи.
Подход DFS с состоянием: Запустите DFS с дополнительным аргументом, который будет отслеживать, в какую сторону нужно двигаться следующим (влево или вправо). Обновление максимума: На каждом уровне рекурсии проверьте, не превышает ли текущая длина пути максимальную известную длину. Рекурсивный вызов: Продолжайте движение в обоих направлениях, но учитывайте, что направление должно изменяться.</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1732/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1732/</guid><description>LeetCode задача 1732
Задача Велосипедист совершает путешествие, которое состоит из n + 1 точек на разных высотах. Путешествие начинается с точки 0, где высота равна 0.
Дан целочисленный массив gain длиной n, где gain[i] — это прирост высоты между точками i и i + 1 для всех (0 &amp;lt;= i &amp;lt; n).
Задача - вернуть самую высокую высоту точки.
Подход В этой задаче, вам нужно пройти по массиву gain и вычислить текущую высоту на каждом этапе. При этом следует отслеживать самую высокую высоту, которую вы достигли.</description></item><item><title>2013. Detect Squares</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2013/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2013/</guid><description>LeetCode задача 2013
В данное задаче решение будет с использованием переменных на русском языке
Задача Задача заключается в разработке структуры данных, которая позволяет добавлять точки на плоскости и подсчитывать количество квадратов, которые можно образовать, добавив новую точку.
Подсказки Решение включает в себя поддержку двух типов данных:
Счётчик точек счетчик_точек, который хранит информацию о количестве каждой точки на плоскости. Словарь координат по оси X координаты_по_x, который для каждой координаты x содержит счётчик координат y, позволяющий быстро находить все точки с данной координатой x.</description></item><item><title>2092. Find All People With Secret</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2092/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2092/</guid><description>LeetCode problem 2092
class Solution: def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -&amp;gt; List[int]: vis = [False] * n vis[0] = vis[firstPerson] = True meetings.sort(key=lambda x: x[2]) i, m = 0, len(meetings) while i &amp;lt; m: j = i while j + 1 &amp;lt; m and meetings[j + 1][2] == meetings[i][2]: j += 1 s = set() g = defaultdict(list) for x, y, _ in meetings[i : j + 1]: g[x].append(y) g[y].append(x) s.update([x, y]) q = deque([u for u in s if vis[u]]) while q: u = q.</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>3016. Minimum Number of Pushes to Type Word II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3016/</guid><description>LeetCode problem 3016
class Solution: def minimumPushes(self, word: str) -&amp;gt; int: cnt = Counter(word) res = 0 for i, x in enumerate(sorted(cnt.values(), reverse=True)): res += (i // 8 + 1) * x return res</description></item><item><title>3032</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3032/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3032/</guid><description>https://leetcode.com/problems/count-numbers-with-unique-digits-ii
class Solution: def numberCount(self, a: int, b: int) -&amp;gt; int: # Initialize the count of numbers with all unique digits unique_digit_count = 0 # Loop through each number in the range from a to b, inclusive for num in range(a, b + 1): # Convert the number to a string to examine its digits num_str = str(num) # Convert the string to a set of characters to remove duplicates unique_digits = set(num_str) # If the length of the set is equal to the length of the number string, # it means all digits are unique if len(unique_digits) == len(num_str): # Increment the count for each number with all unique digits unique_digit_count += 1 # Return the total count of unique digit numbers return unique_digit_count</description></item><item><title>3045. Count Prefix and Suffix Pairs II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2402/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2402/</guid><description>LeetCode problem 3045
Hint To solve this problem efficiently, consider using a Trie (prefix tree) to store each word in a way that allows checking for prefixes and suffixes simultaneously.
Idea The key idea is to leverage a Trie data structure, but with a twist: instead of only considering prefixes (as is typical with tries), we also account for suffixes simultaneously. This dual consideration allows us to efficiently count valid prefix-suffix pairs among the words.
Approach Trie Construction: Build a Trie where each node represents a pair of characters (prefix_char, suffix_char) from a word and its reversed counterpart.</description></item><item><title>3045. Count Prefix and Suffix Pairs II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3045/</link><pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3045/</guid><description>LeetCode problem 3045
Hint To solve this problem efficiently, consider using a Trie (prefix tree) to store each word in a way that allows checking for prefixes and suffixes simultaneously.
Idea The key idea is to leverage a Trie data structure, but with a twist: instead of only considering prefixes (as is typical with tries), we also account for suffixes simultaneously. This dual consideration allows us to efficiently count valid prefix-suffix pairs among the words.
Approach Trie Construction: Build a Trie where each node represents a pair of characters (prefix_char, suffix_char) from a word and its reversed counterpart.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2808/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2808/</guid><description>class Solution: def minimumSeconds(self, nums: List[int]) -&amp;gt; int: d = defaultdict(list) for i, x in enumerate(nums): d[x].append(i) res = inf n = len(nums) for idx in d.values(): t = idx[0] + n - idx[-1] for i, j in pairwise(idx): t = max(t, j - i) res = min(res, t // 2) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2818/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2818/</guid><description>def primeFactors(n): i = 2 res = set() while i * i &amp;lt;= n: while n % i == 0: res.add(i) n //= i i += 1 if n &amp;gt; 1: res.add(n) return len(res) class Solution: def maximumScore(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 arr = [(i, primeFactors(x), x) for i, x in enumerate(nums)] n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, f, x in arr: while stk and stk[-1][0] &amp;lt; f: stk.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2826/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2826/</guid><description>class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: f = [0] * 3 for x in nums: g = [0] * 3 if x == 1: g[0] = f[0] g[1] = min(f[:2]) + 1 g[2] = min(f) + 1 elif x == 2: g[0] = f[0] + 1 g[1] = min(f[:2]) g[2] = min(f) + 1 else: g[0] = f[0] + 1 g[1] = min(f[:2]) + 1 g[2] = min(f) f = g return min(f)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2827/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2827/</guid><description>class Solution: def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -&amp;gt; int: @cache def dfs(pos: int, mod: int, diff: int, lead: int, limit: int) -&amp;gt; int: if pos &amp;gt;= len(s): return mod == 0 and diff == 10 up = int(s[pos]) if limit else 9 res = 0 for i in range(up + 1): if i == 0 and lead: res += dfs(pos + 1, mod, diff, 1, limit and i == up) else: nxt = diff + (1 if i % 2 == 1 else -1) res += dfs(pos + 1, (mod * 10 + i) % k, nxt, 0, limit and i == up) return res s = str(high) a = dfs(0, 0, 10, 1, 1) dfs.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2846/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2846/</guid><description>class Solution: def minOperationsQueries( self, n: int, edges: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: m = n.bit_length() g = [[] for _ in range(n)] f = [[0] * m for _ in range(n)] p = [0] * n cnt = [None] * n depth = [0] * n for u, v, w in edges: g[u].append((v, w - 1)) g[v].append((u, w - 1)) cnt[0] = [0] * 26 q = deque([0]) while q: i = q.popleft() f[i][0] = p[i] for j in range(1, m): f[i][j] = f[f[i][j - 1]][j - 1] for j, w in g[i]: if j !</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2851/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2851/</guid><description>&amp;#34;&amp;#34;&amp;#34; DP, Z-algorithm, Fast mod. Approach How to represent a string? Each operation is just a rotation. Each result string can be represented by an integer from 0 to n - 1. Namely, it&amp;#39;s just the new index of s[0]. How to find the integer(s) that can represent string t? Create a new string s + t + t (length = 3 * n). Use Z-algorithm (or KMP), for each n &amp;lt;= index &amp;lt; 2 * n, calculate the maximum prefix length that each substring starts from index can match, if the length &amp;gt;= n, then (index - n) is a valid integer representation.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2852/</guid><description>class Solution: def sumRemoteness(self, grid: List[List[int]]) -&amp;gt; int: def dfs(i: int, j: int) -&amp;gt; (int, int): s, t = grid[i][j], 1 grid[i][j] = 0 for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; n and 0 &amp;lt;= y &amp;lt; n and grid[x][y] &amp;gt; 0: s1, t1 = dfs(x, y) s, t = s + s1, t + t1 return s, t n = len(grid) dirs = (-1, 0, 1, 0, -1) cnt = sum(x &amp;gt; 0 for row in grid for x in row) res = 0 for i, row in enumerate(grid): for j, x in enumerate(row): if x &amp;gt; 0: s, t = dfs(i, j) res += (cnt - t) * s return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2865/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2865/</guid><description>class Solution: def maximumSumOfHeights(self, maxHeights: List[int]) -&amp;gt; int: n = len(maxHeights) stk = [] left = [-1] * n for i, x in enumerate(maxHeights): while stk and maxHeights[stk[-1]] &amp;gt; x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] right = [n] * n for i in range(n - 1, -1, -1): x = maxHeights[i] while stk and maxHeights[stk[-1]] &amp;gt;= x: stk.pop() if stk: right[i] = stk[-1] stk.append(i) f = [0] * n for i, x in enumerate(maxHeights): if i and x &amp;gt;= maxHeights[i - 1]: f[i] = f[i - 1] + x else: j = left[i] f[i] = x * (i - j) + (f[j] if j !</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2874/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2874/</guid><description>class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2879/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2879/</guid><description>import pandas as pd def selectFirstRows(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: return employees.head(3)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2884/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2884/</guid><description>import pandas as pd def modifySalaryColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;salary&amp;#39;] *= 2 return employees</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2894/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2894/</guid><description>class Solution: def differenceOfSums(self, n: int, m: int) -&amp;gt; int: return sum(i if i % m else -i for i in range(1, n + 1))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2897/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2897/</guid><description>class Solution: def maxSum(self, nums: List[int], k: int) -&amp;gt; int: mod = 10**9 + 7 cnt = [0] * 31 for x in nums: for i in range(31): if x &amp;gt;&amp;gt; i &amp;amp; 1: cnt[i] += 1 res = 0 for _ in range(k): x = 0 for i in range(31): if cnt[i]: x |= 1 &amp;lt;&amp;lt; i cnt[i] -= 1 res = (res + x * x) % mod return res</description></item></channel></rss>