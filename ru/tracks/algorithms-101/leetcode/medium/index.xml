<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Средние on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</link><description>Recent content in Средние on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2/</guid><description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. First accepted Idea:
Loop through lists add each value to the list reverse list calculate sum create linked list from reversed sum class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def createLinkedNode(values): head = ListNode(values[0]) current = head for i in values[1:]: node = ListNode(i) current.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/5/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/5/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/7/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/7/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:
Convert number to int Remove minus if exist (or convert module of number) reverse class Solution: def reverse(self, x: int) -&amp;gt; int: reversed_int = [] str_int = str(x) if x &amp;lt; 0: str_int = str_int[1:] for i in reversed(range(len(str_int))): reversed_int.</description></item><item><title>8. String to Integer (atoi)</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/8/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/8/</guid><description>LeetCode problem
// .js /** * @param {string} s * @return {number} */ var myAtoi = function(s) { let res = 0; let num = parseInt(s); if(num &amp;gt;= 2147483648){ res = 2147483647; } else if (num &amp;lt;= -2147483648){ res = -2147483648; } else if (isNaN(num)) { res = 0; } else { res = num; } return res; };</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</guid><description>LeetCode задача 11
Задача Вам дан массив, в котором каждый элемент представляет высоту стены. Высоты стен разные. Две стены и пространство между ними образуют контейнер. Ваша задача - найти контейнер, который может вместить максимальное количество воды.
Подсказки Метод &amp;ldquo;Two Pointers&amp;rdquo;.
Подход Цель этой задачи - найти пару &amp;ldquo;стен&amp;rdquo;, между которыми будет находиться максимальное количество &amp;ldquo;воды&amp;rdquo;. Вместимость контейнера определяется двумя факторами: расстоянием между стенками и минимальной высотой из двух стенок.
Идея алгоритма заключается в следующем: начнем с самых &amp;ldquo;дальних&amp;rdquo; друг от друга стенок и будем постепенно &amp;ldquo;сужать&amp;rdquo; интервал, сдвигая одну из стенок внутрь массива.</description></item><item><title>12. Integer to Roman</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/12/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/12/</guid><description>LeetCode problem 12
class Solution: def intToRoman(self, num: int) -&amp;gt; str: cs = (&amp;#39;M&amp;#39;, &amp;#39;CM&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;CD&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;XC&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;XL&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;IX&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;IV&amp;#39;, &amp;#39;I&amp;#39;) vs = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) res = [] for c, v in zip(cs, vs): while num &amp;gt;= v: num -= v res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>15. 3Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/15/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/15/</guid><description>LeetCode problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/17/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/17/</guid><description>LeetCode задача 17
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] keyboard = { &amp;#34;2&amp;#34;: &amp;#34;abc&amp;#34;, &amp;#34;3&amp;#34;: &amp;#34;def&amp;#34;, &amp;#34;4&amp;#34;: &amp;#34;ghi&amp;#34;, &amp;#34;5&amp;#34;: &amp;#34;jkl&amp;#34;, &amp;#34;6&amp;#34;: &amp;#34;mno&amp;#34;, &amp;#34;7&amp;#34;: &amp;#34;pqrs&amp;#34;, &amp;#34;8&amp;#34;: &amp;#34;tuv&amp;#34;, &amp;#34;9&amp;#34;: &amp;#34;wxyz&amp;#34; } levels = [] for d in digits: levels.append(keyboard[d]) results = [] def helper(cur_path, level): if level &amp;gt;= len(digits): results.append(cur_path) else: for d in levels[level]: new_path = cur_path + d helper(new_path, level + 1) helper(&amp;#39;&amp;#39;, 0) return results</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem 19
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeNthFromEnd(self, head, n: int): p1 = head p2 = head for _ in range(n): p1 = p1.next if not p1: return head.next # in case: head=[1], n=1 -&amp;gt; return [] while p1.next: p1 = p1.next p2 = p2.next p2.next = p2.next.next return head</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem 22
class Solution: def generateParenthesis(self, n): res = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: res.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return res</description></item><item><title>24. Swap Nodes in Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/24/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/24/</guid><description>LeetCode problem 24
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def swapPairs(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) pre, cur = dummy, head while cur and cur.next: t = cur.next cur.next = t.next t.next = cur pre.next = t pre, cur = cur, cur.next return dummy.next</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/29/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/29/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/33/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/33/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/34/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/34/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]
Code Idea:</description></item><item><title>36. Valid Sudoku</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/36/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/36/</guid><description>LeetCode problem
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/38/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/38/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/46/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/46/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: result_permutation = [] if len(nums) == 1: # base case return [nums[:]] for _ in nums: tmp_removed = nums.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/48/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/48/</guid><description>LeetCode problem
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify matrix in-place instead.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/49/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/49/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dd = {} for s in strs: s_sort = &amp;#34;&amp;#34;.</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive
class Solution: def myPow(self, x, n): if not n: return 1 if n &amp;lt; 0: return 1 / self.</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>56. Merge Intervals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/56/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/56/</guid><description>LeetCode problem
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:
Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Approach 1:
class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort() res = [intervals[0]] for ir in range(1, len(intervals)): if intervals[ir][0] &amp;gt;= res[-1][0] and intervals[ir][0] &amp;lt;= res[-1][1]: # [1,3],[2,6] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) elif res[-1][0] &amp;gt;= intervals[ir][0] and res[-1][0] &amp;lt;= intervals[ir][1]: # [1,3],[0,4] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) else: res.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 10^9.</description></item><item><title>73. Set Matrix Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/73/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/73/</guid><description>LeetCode problem
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Approach 1:
Idea:
LeetCode Submission
class Solution: def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None: rows = len(matrix) cols = len(matrix[0]) # 1. Check first row/column for zero&amp;#39;s first_row_has_zero = 0 in matrix[0] first_col_has_zero = 0 in list(zip(*matrix))[0] # 2.</description></item><item><title>75. Sort Colors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/75/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/75/</guid><description>LeetCode problem
This problem is also known as the Dutch National Flag problem. One solution is to use three pointers to partition the array into three sections: red, white, and blue.
Here&amp;rsquo;s the algorithm:
Initialize three pointers: left, mid, and right. Initialize left to 0, mid to 0, and right to n-1, where n is the length of the input array. While mid is less than or equal to right: If nums[mid] is 0, swap nums[mid] with nums[left], increment mid and left.</description></item><item><title>78. Subsets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/78/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/78/</guid><description>LeetCode problem
In this solution, we start with an empty list in the results array.
For each element in the nums array, we append that element to all of the subsets in the results array to create new subsets, and then add these new subsets to the results array.
By doing this for all elements in nums, we generate all possible subsets.
class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [[]] for i in nums: for j in range(len(res)): cur = [] cur.</description></item><item><title>92. Reverse Linked List II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</guid><description>LeetCode задача 92
Задача Дан односвязный список и два целых числа left и right, где left &amp;lt;= right. Задача заключается в том, чтобы перевернуть узлы списка с позиции left до right
Т.е. если список 1-2-3-4-5-6-7-8-9, left=2, right=7, то итоговый список будет 1-7-6-5-4-3-2-8-9.
Подсказки Для решения задачи удобно использовать два указателя: один для сохранения начальной позиции участка, который нужно перевернуть, и второй для выполнения самого разворота.
Подход Основная идея решения заключается в использовании двух указателей: одного для начала подсписка, который нужно перевернуть, и второго для его конца.</description></item><item><title>116. Populating Next Right Pointers in Each Node</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/116/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/116/</guid><description>LeetCode problem
from collections import deque class Solution: def connect(self, root: &amp;#39;Optional[Node]&amp;#39;) -&amp;gt; &amp;#39;Optional[Node]&amp;#39;: if not root: return root queue = deque([root]) while queue: level_size = len(queue) for i in range(level_size): node = queue.popleft() if i &amp;lt; level_size - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root LeetCode Editorial:
Editorial</description></item><item><title>122. Best Time to Buy and Sell Stock II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/122/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/122/</guid><description>LeetCode problem
To solve this problem, we can use a greedy approach.
The idea is to keep adding the profit whenever the price on the next day is higher than the price on the current day.
This way, we will maximize profit.
class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = 0 for i in range(1, len(prices)): if prices[i] &amp;gt; prices[i - 1]: profit += prices[i] - prices[i - 1] return profit LeetCode Editorial:
Editorial</description></item><item><title>128. Longest Consecutive Sequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/128/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/128/</guid><description>LeetCode problem
Save all numbers in set to make it possible to get number at O(1). For each element look for the current+1 element if exists. class Solution: def longestConsecutive(self, nums: List[int]) -&amp;gt; int: res = 0 nset = set(nums) for x in nset: if x - 1 not in nset: # prevent double calculations _max = 1 cur = x while cur + 1 in nset: _max += 1 cur += 1 res = max(_max, res) return res</description></item><item><title>130. Surrounded Regions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/130/</link><pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/130/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to iterate through each cell in the grid, and for each O, check if it is surrounded by X&amp;rsquo;s in all four directions (up, down, left, and right). If so, flip it to X. However, this method has a high time complexity and does not take advantage of any properties of the problem.
Approach: The more efficient solution is to perform a Depth-First Search (DFS) starting from the border O&amp;rsquo;s.</description></item><item><title>131. Palindrome Partitioning</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/131/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/131/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to generate all possible partitions of the given string and then check if every substring in each partition is a palindrome.
However, this approach would be inefficient, as there would be an exponential number of partitions to check.
Approach:
Using Backtracking.
Logic:
Define a helper function, is_palindrome, to check if a given substring is a palindrome. Define the backtrack function to find all palindrome partitions recursively. This function will take the current position in the string and the current partition as input arguments.</description></item><item><title>134. Gas Station</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/134/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/134/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to try starting from each gas station and check if you can complete the circuit. For each gas station, calculate the remaining gas in the tank after traveling to the next station.
If the gas is not enough to travel to the next station, stop and try starting from the next gas station.
Approach:
In this problem, we can use a greedy algorithm
We can keep track of the total gas and total cost while iterating through the gas stations.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode задача 138
Задача Дан односвязный список, каждый узел которого содержит дополнительный &amp;ldquo;произвольный&amp;rdquo; указатель, который может указывать на любой узел в списке или быть null. Задача состоит в том, чтобы создать глубокую копию этого списка.
Подсказки Простое копирование значений не сработает. Нам нужно создать новые узлы и корректно установить как основные, так и &amp;ldquo;произвольные&amp;rdquo; указатели.
Подход / Идея решения Идея решения заключается в двухпроходном методе. В первом проходе мы создаем копии всех узлов исходного списка и сохраняем их в словаре, где ключом будет оригинальный узел, а значением — его копия.</description></item><item><title>139. Word Break</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/139/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/139/</guid><description>LeetCode problem
Approach:
Dynamic Programming.
Logic:
Using DP:
Iterate through each character of string s. Generate all possible substrings ending at the current index. Check if the substring is in wordDict: If it is, check if the index before the substring&amp;rsquo;s first index is marked as True (this indicates that the part of the string before the current substring can be segmented into words in wordDict). If it is, then mark the current index as True. Solution:
class Solution: def wordBreak(self, s, wordDict): n = len(s) dp = [False] * n for end in range(1, n + 1): # 1.</description></item><item><title>146. LRU Cache</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/146/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/146/</guid><description>LeetCode problem
The operations we need to support are get and put which should both be done in O(1) time.
get(key) should return the value if the key exists in the cache, otherwise return -1. put(key, value) should update the value of the key if the key exists; otherwise, this method should insert the key-value pair into the cache. If the cache is full, this method should also evict the least recently used key-value pair. Approach Use Doubly Linked List or Python OrderedDict</description></item><item><title>148. Sort List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/148/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/148/</guid><description>LeetCode problem
Naive Solution Traverse the linked list, adding each node&amp;rsquo;s value to a Python list sort that list create a new linked list from the sorted values return the head of this new list. This solution would have a time complexity of O(n log n) due to the sort operation and a space complexity of O(n) because of the extra list we&amp;rsquo;re creating.
class Solution: def sortList(self, head): values = [] node = head while node: values.append(node.val) node = node.</description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</guid><description>LeetCode задача 151
Задача На вход подается строка s. Нам необходимо перевернуть порядок слов в этой строке. Слова определяются как последовательность символов без пробелов. Слова в s разделены хотя бы одним пробелом. Нужно вернуть строку, в которой слова расположены в обратном порядке, разделенные одним пробелом.
Важно: строка s может содержать начальные или конечные пробелы или множественные пробелы между двумя словами. В возвращаемой строке должен быть только один пробел, разделяющий слова. Лишние пробелы не включаем.
Подход Для решения задачи мы можем разделить строку на слова, используя пробел в качестве разделителя, а затем просто объединить их в обратном порядке.</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem 166
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>172. Factorial Trailing Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/172/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/172/</guid><description>LeetCode problem 172
class Solution: def trailingZeroes(self, n: int) -&amp;gt; int: res = 0 while n: n //= 5 res += n return res</description></item><item><title>173. Binary Search Tree Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/173/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/173/</guid><description>LeetCode problem 173
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] while root: self.stack.append(root) root = root.left def next(self) -&amp;gt; int: cur = self.stack.pop() node = cur.right while node: self.stack.append(node) node = node.left return cur.val def hasNext(self) -&amp;gt; bool: return len(self.stack) &amp;gt; 0 # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.</description></item><item><title>176. Second Highest Salary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/176/</guid><description>LeetCode problem 176
Drop any duplicate salary values to avoid counting duplicates as separate salary ranks Sort the unique salaries in descending order and get the second highest salary If the second highest salary doesn&amp;rsquo;t exist (e.g., there are fewer than two unique salaries), return None Create a DataFrame with the second highest salary import pandas as pd def second_highest_salary(employee: pd.DataFrame) -&amp;gt; pd.DataFrame: unique_salaries = employee[&amp;#34;salary&amp;#34;].drop_duplicates() second_highest = ( unique_salaries.nlargest(2).iloc[-1] if len(unique_salaries) &amp;gt;= 2 else None ) if second_highest is None: return pd.</description></item><item><title>177. Nth Highest Salary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/177/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/177/</guid><description>LeetCode problem 177
import pandas as pd def nth_highest_salary(employee: pd.DataFrame, N: int) -&amp;gt; pd.DataFrame: unique_salaries = employee.salary.unique() if len(unique_salaries) &amp;lt; N: return pd.DataFrame([np.NaN], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;]) salary = sorted(unique_salaries, reverse=True)[N - 1] return pd.DataFrame([salary], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;])</description></item><item><title>178. Rank Scores</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/178/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/178/</guid><description>LeetCode problem 178
import pandas as pd def order_scores(scores: pd.DataFrame) -&amp;gt; pd.DataFrame: # Use the rank method to assign ranks to the scores in descending order with no gaps scores[&amp;#34;rank&amp;#34;] = scores[&amp;#34;score&amp;#34;].rank(method=&amp;#34;dense&amp;#34;, ascending=False) # Drop id column &amp;amp; Sort the DataFrame by score in descending order result_df = scores.drop(&amp;#34;id&amp;#34;, axis=1).sort_values(by=&amp;#34;score&amp;#34;, ascending=False) return result_df</description></item><item><title>179. Largest Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/179/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/179/</guid><description>LeetCode problem 179
class Solution: def largestNumber(self, nums: List[int]) -&amp;gt; str: nums = [str(v) for v in nums] nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b &amp;lt; b + a else -1)) return &amp;#34;0&amp;#34; if nums[0] == &amp;#34;0&amp;#34; else &amp;#34;&amp;#34;.join(nums)</description></item><item><title>180. Consecutive Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/180/</guid><description>LeetCode problem 180
import pandas as pd def consecutive_numbers(logs: pd.DataFrame) -&amp;gt; pd.DataFrame: all_the_same = lambda lst: lst.nunique() == 1 logs[&amp;#34;is_consecutive&amp;#34;] = ( logs[&amp;#34;num&amp;#34;].rolling(window=3, center=True, min_periods=3).apply(all_the_same) ) return ( logs.query(&amp;#34;is_consecutive == 1.0&amp;#34;)[[&amp;#34;num&amp;#34;]] .drop_duplicates() .rename(columns={&amp;#34;num&amp;#34;: &amp;#34;ConsecutiveNums&amp;#34;}) )</description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/189/</guid><description>LeetCode problem
Problem Statement Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Naive Solution A simple, but inefficient, approach would be to rotate the array k times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations.</description></item><item><title>201. Bitwise AND of Numbers Range</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/201/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/201/</guid><description>LeetCode problem 201
Focus on the leftmost bits of left and right. The result&amp;rsquo;s bits are only set if left and right share the same leftmost bits up to a point.
Idea The core idea is to find the common prefix of the binary representations of left and right. The bitwise AND of any two numbers is only affected by the common prefix because any difference in the subsequent bits will result in zeros when ANDed.
Approach Track the Shifts: Initialize a variable to track the number of shifts needed to find the common prefix.</description></item><item><title>210. Course Schedule II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</guid><description>LeetCode задача 210
Задача Вам дано ( n ) курсов для изучения, пронумерованных от ( 0 ) до ( n-1 ), и массив ( prerequisites ), где ( prerequisites[i] = [a, b] ) означает, что для изучения курса ( a ) предварительно необходимо пройти курс ( b ).
Напишите функцию для нахождения порядка, в котором можно пройти курсы. Если это невозможно, верните пустой массив.
Подсказки Топологическая сортировка может быть использована для решения этой задачи.
Подход Создадим граф, представляющий предварительные требования для каждого курса.</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</guid><description>LeetCode задача 215
Задача Найти k-й по величине элемент в неотсортированном массиве. Примечание: это k-й по величине элемент в отсортированном порядке, а не k-й различный элемент.
Подсказки Можно отсортировать массив и просто взять k-й элемент с конца. Для более эффективного решения можно использовать алгоритм быстрой выборки. Подход В самом простом случае мы можем отсортировать массив и взять k-й элемент с конца.
Алгоритм Сортируем массив. Возвращаем k-й элемент с конца. Решение def findKthLargest(nums, k): nums.sort() return nums[-k] Оптимальное решение На собеседованиях обычно ожидают от кандидата более эффективного решения.</description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</guid><description>LeetCode задача 236
Задача Найдите наименьшего общего предка (LCA) двух заданных узлов в бинарном дереве.
Подсказки Используйте метод обхода в глубину (DFS) для решения этой задачи.
Подход Обход в глубину (DFS): Используйте рекурсивный метод для обхода дерева. Поиск узлов: При обходе дерева ищите заданные узлы p и q. Возврат значения: Если найден один из узлов, верните его как потенциального предка. Сравнение результатов: Если оба поддерева возвращают узлы, текущий узел является LCA. Пропуск пустых узлов: Если узел пуст, верните None.</description></item><item><title>237. Delete Node in a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</guid><description>LeetCode задача 237
Задача Написать функцию для удаления узла (за исключением хвостового) в односвязном списке, дан только доступ к этому узлу.
Подсказки Обычно, для удаления узла из односвязного списка, нам нужен доступ к предыдущему узлу. В этом случае, у нас такого доступа нет. Как это обойти? Подход Поскольку доступа к предыдущему узлу нет, мы не можем просто &amp;ldquo;вырезать&amp;rdquo; текущий узел. Однако мы можем переписать значение текущего узла значением следующего узла и затем удалить следующий узел.
Алгоритм Перезаписываем значение текущего узла значением следующего узла.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</guid><description>LeetCode задача 238
Задача Дан целочисленный массив nums. Нужно вернуть массив answer, такой что answer[i] равен произведению всех элементов nums, кроме nums[i].
Подсказки Чтобы не использовать операцию деления и оставаться в рамках времени $O(n)$, можно использовать концепцию префиксного и суффиксного произведения для каждого элемента.
Подход Создадим два массива: prefix и suffix.
prefix[i] будет содержать произведение всех чисел слева от i suffix[i] будет содержать произведение всех чисел справа от i. Ответ для i будет равен prefix[i] * suffix[i]. Алгоритм Создадим два массива: prefix и suffix с таким же размером, что и nums.</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</guid><description>LeetCode задача 240
Задача Вам дана двумерная матрица размера m x n, представляющая прямоугольник, и целое число target. Отсортированные строки матрицы по неубыванию с лева направо и столбцы отсортированы по неубыванию сверху вниз.
Найдите элемент target в матрице. Верните True, если элемент target есть в матрице, и False, если его нет.
Подсказки Попробуйте использовать двоичный поиск для каждого ряда.
Подход Самый простой подход - использовать двоичный поиск для каждого ряда. Хотя это не самый эффективный метод, он достаточно прост для понимания.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</guid><description>LeetCode задача 251
Задача Дизайн и реализация итератора для 2D вектора. Итератор должен быть инициализирован 2D вектором (vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;) и должен поддерживать следующие операции:
next(): Возвращает следующий элемент из 2D вектора. Если нет больше элементов, возвращает 0. hasNext(): Возвращает True, если в 2D векторе есть следующий элемент, и False в противном случае. Подход Мы можем использовать две переменные: одну для текущего индекса строки и одну для текущего индекса столбца, чтобы навигироваться по 2D вектору.
Алгоритм Инициализируем переменные row и col в конструкторе.</description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</guid><description>LeetCode задача 277
Задача Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?
Имплементируйте функцию int findCelebrity(n), которая вернет знаменитость если она есть, иначе вернёт -1.
Вам дана функция bool knows(a, b), которая скажет вам, знает ли a человека b.
Подход Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.
Алгоритм Инициализируем переменную candidate значением 0.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode задача 287
Задача Дан массив nums размера n + 1, в котором каждый элемент принимает значение от 1 до n, что означает, что как минимум одно число будет дублироваться.
Найдите это дублирующееся число.
Подход Один из способов решения задачи — использование двух указателей (tortoise и hare), что известно как &amp;ldquo;алгоритм зайца и черепахи&amp;rdquo; для нахождения цикла в связанном списке.
Алгоритм Инициализируем два указателя: tortoise и hare. Используем их для прохода по массиву: tortoise двигается на один шаг, а hare — на два.</description></item><item><title>300. Longest Increasing Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</guid><description>LeetCode задача 300
Задача Дан массив чисел, ваша задача — найти длину наибольшей возрастающей подпоследовательности.
Подсказки Для решения этой задачи вы можете использовать динамическое программирование.
Подход Инициализация: Инициализируйте массив, который будет хранить длины наибольших возрастающих подпоследовательностей для каждого элемента массива. Обход массива: Обойдите массив, и для каждого элемента обновите массив длин наибольших возрастающих подпоследовательностей. Максимум: По окончании обхода найдите максимальное значение в массиве длин. Простейший способ решения — это использовать двойной цикл для обхода массива и поиска наибольшей возрастающей подпоследовательности для каждого элемента.</description></item><item><title>328. Odd Even Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</guid><description>LeetCode задача 328
Задача Дан односвязный список и задача переставить его узлы таким образом, чтобы все узлы с нечетными индексами шли перед всеми узлами с четными индексами.
Вариант решения 1 Рассмотрим вариант решения более простой для понимания и реализации.
Подсказки Использовать два связных списка.
Подход Во время прохода по связному списку указатель для чётных узлов добавлять связанный список с четными, то же самое делать с нечетными.
В конце прохода список с четными узлами добавить в конец списка с нечетными узлами.</description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</guid><description>LeetCode problem
Задача Дан целочисленный массив nums. Вернуть true, если существует тройка индексов (i, j, k) таких, что
i &amp;lt; j &amp;lt; k и nums[i] &amp;lt; nums[j] &amp;lt; nums[k]. Если таких индексов нет, вернуть false.
Подсказки Для решения этой задачи вам необходимо найти возможное максимальное и минимальное число до текущего числа, не используя дополнительное пространство памяти.
Подход Мы можем обойти список, используя два указателя, чтобы хранить первое минимальное и последующие &amp;ldquo;два&amp;rdquo; минимальные значения, которые мы встретили до сих пор.</description></item><item><title>341. Flatten Nested List Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</guid><description>Задача Дан вложенный список целых чисел. Реализуйте итератор, который &amp;ldquo;разворачивает&amp;rdquo; этот вложенный список.
Подход Задача состоит в реализации итератора, который будет последовательно возвращать все элементы из вложенного списка. Вложенный список может содержать как обычные числа, так и другие вложенные списки. Наивное решение заключается в том, чтобы сначала полностью &amp;ldquo;развернуть&amp;rdquo; весь вложенный список в одномерный список, а затем реализовать итератор для этого одномерного списка.
Алгоритм Инициализация: Создать одномерный список и заполнить его элементами из вложенного списка. next(): Возвращает следующий элемент одномерного списка.</description></item><item><title>377. Combination Sum IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</guid><description>LeetCode задача 377
Задача Дан массив различных целых чисел nums и целевое целое число target от 1 до 1000. Нужно вернуть количество возможных комбинаций, которые в сумме дают target.
Подсказки Построить дерево решений Задачу можно решить путем разложения ее на меньшие подзадачи с помощью динамического программирования. Нахождение целевого значения в дереве решений
Your browser does not support the video tag. LeetCode 377 Решение Подход Если целевое значение - target=7 и nums=[2, 3, 4], то в дереве решений может быть несколько путей до этого числа.</description></item><item><title>384. Shuffle an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</guid><description>LeetCode задача 384
Задача Реализуйте класс, который принимает массив чисел в конструкторе и предоставляет метод для их случайного перемешивания, а также метод для возвращения исходного массива.
Подсказки Для создания случайного порядка элементов можно использовать алгоритм Фишера-Йетса или другие методы перемешивания.
Подход Инициализация: Сохранить исходный массив в переменной класса для дальнейшего использования. reset(): Вернуть исходный массив. shuffle(): Вернуть перемешанный массив. Из всех возможных подходов к решению этой задачи, наиболее простым является использование встроенного метода random.shuffle() из Python стандартной библиотеки для перемешивания массива.</description></item><item><title>388. Longest Absolute File Path</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/388/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/388/</guid><description>LeetCode задача 388
Задача Необходимо вычислить длину самого длинного абсолютного пути к файлу в файловой системе. Путь представлен строкой, где &amp;ldquo;\n&amp;rdquo; разделяет имена директорий и файлов, а &amp;ldquo;\t&amp;rdquo; обозначает уровень вложенности.
Подсказки Задача заключается в анализе строки, представляющей файловую систему, и определении максимальной длины пути к файлу, учитывая вложенность директорий.
Подход Мы можем решить эту задачу, используя стек для отслеживания текущего пути и его длины. Каждый раз, когда мы встречаем файл, мы сравниваем его полную длину с максимальной и обновляем максимум при необходимости.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode задача 394
Задача На вход подается закодированная строка, необходимо вернуть её декодированное представление.
Правило кодирования таково: k[encoded_string], где encoded_string - строка внутри квадратных скобок, повторяется ровно k раз. k - это всегда положительное целое число.
Подсказки Для решения этой задачи можно использовать стек, т.к. число[строка] могут быть вложенными.
Подход Всё, что нам нужно, это итерировать строку символ за символом и обрабатывать четыре случая: числа, буквы и скобки. Мы будем использовать один стек для хранения пар вида (префикс строки, число).</description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</guid><description>LeetCode задача 437
Задача Дан корень бинарного дерева и целое число targetSum. Верните количество путей, где сумма значений вдоль пути равна targetSum.
Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).
Подсказки Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.
Подход Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня.</description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</guid><description>LeetCode задача 443
Задача Дан массив символов chars, ваша задача — сжать его с помощью следующего алгоритма: Заменить последовательность одинаковых символов одним символом, за которым идет его количество.
Пример: &amp;ldquo;aaabbaaa&amp;rdquo; =&amp;gt; &amp;ldquo;a3b2a3&amp;rdquo;
Подход В этой задаче у нас есть два указателя: один для чтения элементов из исходного массива (read_ptr) и второй для записи результата сжатия в тот же массив (write_ptr). Сначала оба указателя стоят на начале массива. Далее, read_ptr движется вправо, считая количество повторяющихся символов. После подсчета, мы записываем символ и его количество в массив, используя write_ptr.</description></item><item><title>454. 4Sum II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</guid><description>LeetCode задача 454
Задача Даны четыре списка A, B, C, D целых чисел. Вычислите, сколько существует таких кортежей (i, j, k, l), что ( A[i] + B[j] + C[k] + D[l] = 0 ).
Подсказки Используйте хэш-таблицу для ускорения решения.
Подход Создание хэш-таблицы: Сначала создайте хэш-таблицу, которая будет хранить суммы пар чисел из массивов A и B. Подсчет сумм: Для каждой пары (i, j) из A и B, увеличьте соответствующий элемент хэш-таблицы на 1. Поиск в хэш-таблице: Для каждой пары (k, l) из C и D, проверьте, существует ли -(C[k] + D[l]) в хэш-таблице.</description></item><item><title>649. Dota2 Senate</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</guid><description>LeetCode задача 649
Задача В игре Dota2, сенат состоит из двух партий: партии &amp;ldquo;Radiant&amp;rdquo; и партии &amp;ldquo;Dire&amp;rdquo;. Сенат решает, когда будет следующая игра, и каждый сенатор может голосовать за бан одного из сенаторов из другой партии.
Забаненные сенаторы не могут делать действий и не участвуют в процессе подготовки следующего раунда.
Предположим, у нас есть строка &amp;ldquo;RRDDD&amp;rdquo;. Здесь первый сенатор принадлежит партии Radiant, второй тоже к Radiant, третий, четвертый и пятый к Dire. Сначала первый сенатор Radiant делает ход, затем первый сенатор Dire, и так далее.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode задача 725
Задача Дан односвязный список и целое число k. Задача заключается в том, чтобы разделить односвязный список на k последовательных частей.
Длина каждой части должна быть максимально равномерной: любые две части не должны отличаться по размеру более чем на одну единицу. Это может привести к тому, что некоторые части будут пустыми (null).
Части должны идти в том порядке, в котором они встречаются в исходном списке, и ранее встречающиеся части всегда должны иметь размер больше или равный позднее встречающимся.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode задача 735
Задача Мы имеем массив asteroids целых чисел, представляющих астероиды в ряду. Для каждого астероида абсолютное значение представляет его размер, а знак представляет его направление (положительное означает вправо, отрицательное влево). Все астероиды движутся с одинаковой скоростью. Необходимо определить состояние астероидов после всех столкновений.
Подсказки Для решения задачи можно использовать стек.
Подход Мы будем использовать стек для отслеживания движущихся вправо астероидов. Когда мы видим астероид, движущийся влево, мы проверяем, будет ли он сталкиваться с верхним элементом стека (астероидом, движущимся вправо).</description></item><item><title>777. Swap Adjacent in LR String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/777/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/777/</guid><description>LeetCode problem 777
class Solution: def canTransform(self, start: str, end: str) -&amp;gt; bool: n = len(start) i = j = 0 while 1: while i &amp;lt; n and start[i] == &amp;#39;X&amp;#39;: i += 1 while j &amp;lt; n and end[j] == &amp;#39;X&amp;#39;: j += 1 if i &amp;gt;= n and j &amp;gt;= n: return True if i &amp;gt;= n or j &amp;gt;= n or start[i] != end[j]: return False if start[i] == &amp;#39;L&amp;#39; and i &amp;lt; j: return False if start[i] == &amp;#39;R&amp;#39; and i &amp;gt; j: return False i, j = i + 1, j + 1</description></item><item><title>779. K-th Symbol in Grammar</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/779/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/779/</guid><description>LeetCode problem 779
class Solution: def kthGrammar(self, n: int, k: int) -&amp;gt; int: return (k - 1).bit_count() &amp;amp; 1</description></item><item><title>781. Rabbits in Forest</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/781/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/781/</guid><description>LeetCode problem 781
class Solution: def numRabbits(self, answers: List[int]) -&amp;gt; int: counter = Counter(answers) return sum([math.ceil(v / (k + 1)) * (k + 1) for k, v in counter.items()])</description></item><item><title>784. Letter Case Permutation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/784/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/784/</guid><description>LeetCode problem 784
class Solution: def letterCasePermutation(self, s: str) -&amp;gt; List[str]: res = [] n = sum(c.isalpha() for c in s) for i in range(1 &amp;lt;&amp;lt; n): j, t = 0, [] for c in s: if c.isalpha(): c = c.lower() if (i &amp;gt;&amp;gt; j) &amp;amp; 1 else c.upper() j += 1 t.append(c) res.append(&amp;#39;&amp;#39;.join(t)) return res</description></item><item><title>785. Is Graph Bipartite</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/785/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/785/</guid><description>LeetCode problem 785
class Solution: def isBipartite(self, graph: List[List[int]]) -&amp;gt; bool: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(len(graph))) for u, g in enumerate(graph): for v in g: if find(u) == find(v): return False p[find(v)] = find(g[0]) return True</description></item><item><title>786. K-th Smallest Prime Fraction</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/786/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/786/</guid><description>LeetCode problem 786
class Solution: def kthSmallestPrimeFraction(self, arr: List[int], k: int) -&amp;gt; List[int]: h = [(1 / y, 0, j + 1) for j, y in enumerate(arr[1:])] heapify(h) for _ in range(k - 1): _, i, j = heappop(h) if i + 1 &amp;lt; j: heappush(h, (arr[i + 1] / arr[j], i + 1, j)) return [arr[h[0][1]], arr[h[0][2]]]</description></item><item><title>787. Cheapest Flights Within K Stops</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/787/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/787/</guid><description>LeetCode problem 787
class Solution: def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -&amp;gt; int: @cache # helps in case of time limit def dfs(u, k): if u == dst: return 0 if k &amp;lt;= 0: return inf k -= 1 res = inf for v, p in g[u]: res = min(res, dfs(v, k) + p) return res g = defaultdict(list) for u, v, p in flights: g[u].append((v, p)) res = dfs(src, k + 1) return -1 if res &amp;gt;= inf else res</description></item><item><title>788. Rotated Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/788/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/788/</guid><description>LeetCode problem 788
class Solution: def rotatedDigits(self, n: int) -&amp;gt; int: @cache def dfs(pos, ok, limit): if pos &amp;lt;= 0: return ok up = a[pos] if limit else 9 res = 0 for i in range(up + 1): if i in (0, 1, 8): res += dfs(pos - 1, ok, limit and i == up) if i in (2, 5, 6, 9): res += dfs(pos - 1, 1, limit and i == up) return res a = [0] * 6 l = 1 while n: a[l] = n % 10 n //= 10 l += 1 return dfs(l, 0, True)</description></item><item><title>789. Escape The Ghosts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/789/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/789/</guid><description>LeetCode problem 789
class Solution: def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -&amp;gt; bool: tx, ty = target return all(abs(tx - x) + abs(ty - y) &amp;gt; abs(tx) + abs(ty) for x, y in ghosts)</description></item><item><title>790. Domino and Tromino Tiling</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/790/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/790/</guid><description>LeetCode problem 790
class Solution: def numTilings(self, n: int) -&amp;gt; int: f = [1, 0, 0, 0] mod = 10**9 + 7 for i in range(1, n + 1): g = [0] * 4 g[0] = (f[0] + f[1] + f[2] + f[3]) % mod g[1] = (f[2] + f[3]) % mod g[2] = (f[1] + f[3]) % mod g[3] = f[0] f = g return f[0]</description></item><item><title>791. Custom Sort String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/791/</guid><description>LeetCode problem 791
class Solution: def customSortString(self, order: str, s: str) -&amp;gt; str: cnt = Counter(s) res = [] for c in order: res.append(c * cnt[c]) cnt[c] = 0 for c, v in cnt.items(): res.append(c * v) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>792. Number of Matching Subsequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/792/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/792/</guid><description>LeetCode problem 792
class Solution: def numMatchingSubseq(self, s: str, words: List[str]) -&amp;gt; int: def check(w): i = -1 for c in w: j = bisect_right(d[c], i) if j == len(d[c]): return False i = d[c][j] return True d = defaultdict(list) for i, c in enumerate(s): d[c].append(i) return sum(check(w) for w in words)</description></item><item><title>794. Valid Tic-Tac-Toe State</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/794/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/794/</guid><description>LeetCode problem 794
class Solution: def validTicTacToe(self, board: List[str]) -&amp;gt; bool: def win(x): for i in range(3): if all(board[i][j] == x for j in range(3)): return True if all(board[j][i] == x for j in range(3)): return True if all(board[i][i] == x for i in range(3)): return True return all(board[i][2 - i] == x for i in range(3)) x = sum(board[i][j] == &amp;#39;X&amp;#39; for i in range(3) for j in range(3)) o = sum(board[i][j] == &amp;#39;O&amp;#39; for i in range(3) for j in range(3)) if x !</description></item><item><title>795. Number of Subarrays with Bounded Maximum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/795/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/795/</guid><description>LeetCode problem 795
class Solution: def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -&amp;gt; int: n = len(nums) l, r = [-1] * n, [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;lt;= v: stk.pop() if stk: l[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: r[i] = stk[-1] stk.append(i) return sum( (i - l[i]) * (r[i] - i) for i, v in enumerate(nums) if left &amp;lt;= v &amp;lt;= right )</description></item><item><title>797. All Paths From Source to Target</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/797/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/797/</guid><description>LeetCode problem 797
class Solution: def allPathsSourceTarget(self, graph: List[List[int]]) -&amp;gt; List[List[int]]: def dfs(t): if t[-1] == len(graph) - 1: res.append(t[:]) return for v in graph[t[-1]]: t.append(v) dfs(t) t.pop() res = [] dfs([0]) return res</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</guid><description>LeetCode problem 799
class Solution: def champagneTower(self, poured: int, query_row: int, query_glass: int) -&amp;gt; float: f = [poured] for i in range(1, query_row + 1): g = [0] * (i + 1) for j, v in enumerate(f): if v &amp;gt; 1: half = (v - 1) / 2 g[j] += half g[j + 1] += half f = g return min(1, f[query_glass])</description></item><item><title>802. Find Eventual Safe States</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/802/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/802/</guid><description>LeetCode problem 802
class Solution: def eventualSafeNodes(self, graph: List[List[int]]) -&amp;gt; List[int]: def dfs(i): if color[i]: return color[i] == 2 color[i] = 1 for j in graph[i]: if not dfs(j): return False color[i] = 2 return True n = len(graph) color = [0] * n return [i for i in range(n) if dfs(i)]</description></item><item><title>1101. The Earliest Moment When Everyone Become Friends</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1101/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1101/</guid><description>LeetCode problem 1101
class UnionFind: __slots__ = (&amp;#39;p&amp;#39;, &amp;#39;size&amp;#39;) def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x: int) -&amp;gt; int: if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a: int, b: int) -&amp;gt; bool: pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def earliestAcq(self, logs: List[List[int]], n: int) -&amp;gt; int: uf = UnionFind(n) for t, x, y in sorted(logs): if uf.</description></item><item><title>1102. Path With Maximum Minimum Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1102/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1102/</guid><description>LeetCode problem 1102
class UnionFind: __slots__ = (&amp;#34;p&amp;#34;, &amp;#34;size&amp;#34;) def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x: int) -&amp;gt; int: if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a: int, b: int) -&amp;gt; bool: pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def maximumMinimumPath(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) uf = UnionFind(m * n) q = [(v, i, j) for i, row in enumerate(grid) for j, v in enumerate(row)] q.</description></item><item><title>1104. Path In Zigzag Labelled Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1104/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1104/</guid><description>LeetCode problem 1104
class Solution: def pathInZigZagTree(self, label: int) -&amp;gt; List[int]: x = i = 1 while (x &amp;lt;&amp;lt; 1) &amp;lt;= label: x &amp;lt;&amp;lt;= 1 i += 1 res = [0] * i while i: res[i - 1] = label label = ((1 &amp;lt;&amp;lt; (i - 1)) + (1 &amp;lt;&amp;lt; i) - 1 - label) &amp;gt;&amp;gt; 1 i -= 1 return res</description></item><item><title>1105. Filling Bookcase Shelves</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1105/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1105/</guid><description>LeetCode problem 1105
class Solution: def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -&amp;gt; int: n = len(books) f = [0] * (n + 1) for i, (w, h) in enumerate(books, 1): f[i] = f[i - 1] + h for j in range(i - 1, 0, -1): w += books[j - 1][0] if w &amp;gt; shelfWidth: break h = max(h, books[j - 1][1]) f[i] = min(f[i], f[j - 1] + h) return f[n]</description></item><item><title>1109. Corporate Flight Bookings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1109/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1109/</guid><description>LeetCode problem 1109
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) def update(self, x, delta): while x &amp;lt;= self.n: self.c[x] += delta x += x &amp;amp; -x def query(self, x): s = 0 while x: s += self.c[x] x -= x &amp;amp; -x return s class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -&amp;gt; List[int]: tree = BinaryIndexedTree(n) for first, last, seats in bookings: tree.update(first, seats) tree.update(last + 1, -seats) return [tree.</description></item><item><title>1110. Delete Nodes And Return Forest</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1110/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1110/</guid><description>LeetCode problem 1110
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def delNodes( self, root: Optional[TreeNode], to_delete: List[int] ) -&amp;gt; List[TreeNode]: def dfs(root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: if root is None: return None root.left, root.right = dfs(root.left), dfs(root.right) if root.val not in s: return root if root.left: res.append(root.left) if root.right: res.append(root.right) return None s = set(to_delete) res = [] if dfs(root): res.</description></item><item><title>1111. Maximum Nesting Depth of Two Valid Parentheses Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1111/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1111/</guid><description>LeetCode problem 1111
class Solution: def maxDepthAfterSplit(self, seq: str) -&amp;gt; List[int]: res = [0] * len(seq) x = 0 for i, c in enumerate(seq): if c == &amp;#34;(&amp;#34;: res[i] = x &amp;amp; 1 x += 1 else: x -= 1 res[i] = x &amp;amp; 1 return res</description></item><item><title>1115. Print FooBar Alternately</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1115/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1115/</guid><description>LeetCode problem 1115
from threading import Semaphore class FooBar: def __init__(self, n): self.n = n self.f = Semaphore(1) self.b = Semaphore(0) def foo(self, printFoo: &amp;#34;Callable[[], None]&amp;#34;) -&amp;gt; None: for _ in range(self.n): self.f.acquire() # printFoo() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line. printFoo() self.b.release() def bar(self, printBar: &amp;#34;Callable[[], None]&amp;#34;) -&amp;gt; None: for _ in range(self.n): self.b.acquire() # printBar() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line. printBar() self.f.release()</description></item><item><title>1116. Print Zero Even Odd</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1116/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1116/</guid><description>LeetCode problem 1116
from threading import Semaphore class ZeroEvenOdd: def __init__(self, n): self.n = n self.z = Semaphore(1) self.e = Semaphore(0) self.o = Semaphore(0) # printNumber(x) outputs &amp;#34;x&amp;#34;, where x is an integer. def zero(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(self.n): self.z.acquire() printNumber(0) if i % 2 == 0: self.o.release() else: self.e.release() def even(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(2, self.n + 1, 2): self.e.acquire() printNumber(i) self.z.release() def odd(self, printNumber: &amp;#39;Callable[[int], None]&amp;#39;) -&amp;gt; None: for i in range(1, self.</description></item><item><title>1120. Maximum Average Subtree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1120/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1120/</guid><description>LeetCode problem 1120
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maximumAverageSubtree(self, root: Optional[TreeNode]) -&amp;gt; float: def dfs(root): if root is None: return 0, 0 ls, ln = dfs(root.left) rs, rn = dfs(root.right) s = root.val + ls + rs n = 1 + ln + rn nonlocal res res = max(res, s / n) return s, n res = 0 dfs(root) return res</description></item><item><title>1123. Lowest Common Ancestor of Deepest Leaves</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1123/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1123/</guid><description>LeetCode problem 1123
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def lcaDeepestLeaves(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: def dfs(root): if root is None: return None, 0 l, d1 = dfs(root.left) r, d2 = dfs(root.right) if d1 &amp;gt; d2: return l, d1 + 1 if d1 &amp;lt; d2: return r, d2 + 1 return root, d1 + 1 return dfs(root)[0]</description></item><item><title>1207. Unique Number of Occurrences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1207/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1207/</guid><description>LeetCode problem
Problem Statement Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
Naive Solution A naive approach would be to create a dictionary to store the count of each integer, then iterate over the dictionary and compare each count with the counts of other integers. This approach requires O(n^2) time complexity, where n is the length of the array. This is not efficient for large input sizes.</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1359/</guid><description>LeetCode задача 1359
Задача Дано n заказов, каждый заказ состоит из услуг по приему и доставке.
Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).
Так как ответ может быть очень большим, верните его по модулю 10^9 + 7.
Подсказки Использовать комбинаторный подход.
Для каждого нового заказа у нас есть 2 * (2n-1) способов добавить его в текущую последовательность.
Мы используем данную формулу, так как:
Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест).</description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1456/</guid><description>LeetCode Problem 1456
Problem Statement Given a string s and an integer k, the task is to return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.
Naive Solution The most straightforward solution to this problem is to take every possible substring of length k and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length k.</description></item><item><title>1481. Least Number of Unique Integers after K Removals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1481/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1481/</guid><description>LeetCode problem 1481
class Solution: def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -&amp;gt; int: counter = Counter(arr) for i, v in enumerate(sorted(counter.values())): k -= v if k &amp;lt; 0: return len(counter) - i return 0</description></item><item><title>1642. Furthest Building You Can Reach</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1642/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1642/</guid><description>LeetCode problem 1642
class Solution: def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -&amp;gt; int: h = [] for i, a in enumerate(heights[:-1]): b = heights[i + 1] d = b - a if d &amp;gt; 0: heappush(h, d) if len(h) &amp;gt; ladders: bricks -= heappop(h) if bricks &amp;lt; 0: return i return len(heights) - 1</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</guid><description>LeetCode задача 1647
Задача Строка s называется хорошей, если в ней нет двух разных символов с одинаковой частотой.
Дана строка s, верните минимальное количество символов, которое необходимо удалить, чтобы сделать s хорошим.
Подход Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.
Если проверять встречалась ли частота текущего символа ранее, то
Алгоритм / Абстрактный алгоритм Считаем частоты всех символов в строке. Сортируем частоты в порядке убывания.</description></item><item><title>1657. Determine if Two Strings Are Close</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1657/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1657/</guid><description>LeetCode problem
Problem Statement Two strings are considered close if you can attain one from the other using two operations:
Swap any two existing characters. Transform every occurrence of one existing character into another existing character, and do the same with the other character. The challenge is to determine whether two given strings are close or not.
Naive Solution A naive approach might involve trying every possible combination of operations on the two strings until they match or until you&amp;rsquo;ve exhausted all possibilities.</description></item><item><title>1679. Max Number of K-Sum Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</guid><description>LeetCode задача 1679
Задача Вам дан массив чисел nums и целое число k. Задача — найти максимальное количество пар в массиве, сумма элементов которых равна k.
Подсказки Используйте технику двух указателей(pointers) после сортировки массива для оптимизации поиска пар.
Подход Центральная идея решения задачи заключается в использовании техники двух указателей для быстрого нахождения пар чисел с заданной суммой k. Прежде чем применить эту технику, массив сортируется в возрастающем порядке. Затем создаются два указателя: один, указывающий на начало массива, и второй — на конец.</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1768/</guid><description>LeetCode задача 1768
Задача Вам даны две строки word1 и word2. Объедините эти строки, добавляя буквы в чередующем порядке, начиная с word1. Если одна строка длиннее другой, дополнительные буквы добавляются в конец результирующей строки.
Подход Чтобы решить эту задачу, мы можем использовать два указателя для каждого слова. Начнем с первого символа каждой строки и будем чередовать их, пока одна из строк не закончится. После этого, мы просто добавляем оставшиеся символы из более длинного слова к результирующей строке.
Алгоритм Инициализация результирующей строки и двух указателей для word1 и word2.</description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</guid><description>LeetCode задача 2095
Задача Дан связный список (linked list). Задача — удалить средний узел из этого списка и вернуть начало(head) измененного списка.
Подсказки Мы можем использовать метод двух указателей для того, чтобы найти средний узел в одном проходе по списку, где второй указатель проходит весь список в два раза быстрее первого указателя.
Подход Используем два указателя для прохода по списку: один медленный и один быстрый. Оба начинают с головного узла списка. Быстрый указатель будет двигаться в два раза быстрее медленного.</description></item><item><title>2108. Find First Palindromic String in the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2108/</guid><description>LeetCode problem 2108
class Solution: def firstPalindrome(self, words: List[str]) -&amp;gt; str: return next((w for w in words if w == w[::-1]), &amp;#34;&amp;#34;)</description></item><item><title>2130. Maximum Twin Sum of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</guid><description>LeetCode задача 2130
Задача Дан односвязный список четной длины. Узлы в этом списке имеют &amp;ldquo;близнецов&amp;rdquo; по определенным правилам. Задача — найти максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.
Т.е. у первой половины узлов списка есть свой близнец из второй половины.
Пример: для списка длиной n = 8 i = 0, twin = n-1-i = 8-1-0 = 7 i = 1, twin = n-1-1 = 6 i = 2, twin = n-1-2 = 5 &amp;hellip;
Подсказки У первой половины узлов списка есть свой близнец из второй половины, т.</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode задача 2352
Задача Дана квадратная матрица целых чисел grid размером n×n. Задача состоит в том, чтобы определить, сколько пар строк и столбцов в матрице идентичны по своему содержанию и порядку.
Строка и столбец считаются равными, если они содержат одни и те же элементы в том же порядке.
Подсказки Для решения задачи можно воспользоваться тем фактом, что каждая строка и столбец представляют собой набор чисел. Если мы конвертируем их в строки, то можем сравнивать их друг с другом.</description></item><item><title>2353. Design a Food Rating System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2353/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2353/</guid><description>LeetCode problem 2353
from sortedcontainers import SortedSet class FoodRatings: def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]): self.mp = {} self.t = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1]))) for a, b, c in zip(foods, cuisines, ratings): self.mp[a] = (b, c) self.t[b].add((c, a)) def changeRating(self, food: str, newRating: int) -&amp;gt; None: b, c = self.mp[food] self.mp[food] = (b, newRating) self.t[b].remove((c, food)) self.t[b].add((newRating, food)) def highestRated(self, cuisine: str) -&amp;gt; str: return self.t[cuisine][0][1] # Your FoodRatings object will be instantiated and called as such: # obj = FoodRatings(foods, cuisines, ratings) # obj.</description></item><item><title>2358. Maximum Number of Groups Entering a Competition</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2358/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2358/</guid><description>LeetCode problem 2358
class Solution: def maximumGroups(self, grades: List[int]) -&amp;gt; int: n = len(grades) return bisect_right(range(n + 1), n * 2, key=lambda x: x * x + x) - 1</description></item><item><title>2359. Find Closest Node to Given Two Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2359/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2359/</guid><description>LeetCode problem 2359
class Solution: def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -&amp;gt; int: def f(i): dist = [inf] * n dist[i] = 0 q = deque([i]) while q: i = q.popleft() for j in g[i]: if dist[j] == inf: dist[j] = dist[i] + 1 q.append(j) return dist g = defaultdict(list) for i, j in enumerate(edges): if j != -1: g[i].append(j) n = len(edges) d1 = f(node1) d2 = f(node2) res, d = -1, inf for i, (a, b) in enumerate(zip(d1, d2)): if (t := max(a, b)) &amp;lt; d: d = t res = i return res</description></item><item><title>2364. Count Number of Bad Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2364/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2364/</guid><description>LeetCode problem 2364
class Solution: def countBadPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter() res = 0 for i, x in enumerate(nums): res += i - cnt[i - x] cnt[i - x] += 1 return res</description></item><item><title>2365. Task Scheduler II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2365/</guid><description>LeetCode problem 2365
class Solution: def taskSchedulerII(self, tasks: List[int], space: int) -&amp;gt; int: day = defaultdict(int) res = 0 for task in tasks: res += 1 res = max(res, day[task]) day[task] = res + space + 1 return res</description></item><item><title>2368. Reachable Nodes With Restrictions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2368/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2368/</guid><description>LeetCode problem 2368
class Solution: def reachableNodes( self, n: int, edges: List[List[int]], restricted: List[int] ) -&amp;gt; int: s = set(restricted) g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) q = deque([0]) vis = [False] * n for v in restricted: vis[v] = True res = 0 while q: i = q.popleft() res += 1 vis[i] = True for j in g[i]: if not vis[j]: q.append(j) return res</description></item><item><title>2369. Check if There is a Valid Partition For The Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2369/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2369/</guid><description>LeetCode problem 2369
class Solution: def validPartition(self, nums: List[int]) -&amp;gt; bool: n = len(nums) dp = [False] * (n + 1) dp[0] = True for i in range(2, n + 1): if nums[i - 1] == nums[i - 2]: dp[i] = dp[i] or dp[i - 2] if i &amp;gt; 2 and nums[i - 1] == nums[i - 2] == nums[i - 3]: dp[i] = dp[i] or dp[i - 3] if ( i &amp;gt; 2 and nums[i - 1] - nums[i - 2] == 1 and nums[i - 2] - nums[i - 3] == 1 ): dp[i] = dp[i] or dp[i - 3] return dp[-1]</description></item><item><title>2370. Longest Ideal Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2370/</guid><description>LeetCode problem 2370
class Solution: def longestIdealString(self, s: str, k: int) -&amp;gt; int: n = len(s) res = 1 dp = [1] * n d = {s[0]: 0} for i in range(1, n): a = ord(s[i]) for b in ascii_lowercase: if abs(a - ord(b)) &amp;gt; k: continue if b in d: dp[i] = max(dp[i], dp[d[b]] + 1) d[s[i]] = i return max(dp)</description></item><item><title>2374. Node With Highest Edge Score</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2374/</guid><description>LeetCode problem 2374
class Solution: def edgeScore(self, edges: List[int]) -&amp;gt; int: cnt = Counter() for i, v in enumerate(edges): cnt[v] += i res = 0 for i in range(len(edges)): if cnt[res] &amp;lt; cnt[i]: res = i return res</description></item><item><title>2375. Construct Smallest Number From DI String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2375/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2375/</guid><description>LeetCode problem 2375
class Solution: def smallestNumber(self, pattern: str) -&amp;gt; str: def dfs(u): nonlocal res if res: return if u == len(pattern) + 1: res = &amp;#39;&amp;#39;.join(t) return for i in range(1, 10): if not vis[i]: if u and pattern[u - 1] == &amp;#39;I&amp;#39; and int(t[-1]) &amp;gt;= i: continue if u and pattern[u - 1] == &amp;#39;D&amp;#39; and int(t[-1]) &amp;lt;= i: continue vis[i] = True t.append(str(i)) dfs(u + 1) vis[i] = False t.pop() vis = [False] * 10 t = [] res = None dfs(0) return res</description></item><item><title>2378. Choose Edges to Maximize Score in a Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2378/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2378/</guid><description>LeetCode problem 2378
class Solution: def maxScore(self, edges: List[List[int]]) -&amp;gt; int: def dfs(i): a = b = t = 0 for j, w in g[i]: x, y = dfs(j) a += y b += y t = max(t, x - y + w) b += t return a, b g = defaultdict(list) for i, (p, w) in enumerate(edges[1:], 1): g[p].append((i, w)) return dfs(0)[1]</description></item><item><title>2380. Time Needed to Rearrange a Binary String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2380/</guid><description>LeetCode problem 2380
class Solution: def secondsToRemoveOccurrences(self, s: str) -&amp;gt; int: res = cnt = 0 for c in s: if c == &amp;#39;0&amp;#39;: cnt += 1 elif cnt: res = max(res + 1, cnt) return res</description></item><item><title>2381. Shifting Letters II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2381/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2381/</guid><description>LeetCode problem 2381
class Solution: def shiftingLetters(self, s: str, shifts: List[List[int]]) -&amp;gt; str: n = len(s) d = [0] * (n + 1) for i, j, v in shifts: if v == 0: v = -1 d[i] += v d[j + 1] -= v for i in range(1, n + 1): d[i] += d[i - 1] return &amp;#39;&amp;#39;.join( chr(ord(&amp;#39;a&amp;#39;) + (ord(s[i]) - ord(&amp;#39;a&amp;#39;) + d[i] + 26) % 26) for i in range(n) )</description></item><item><title>2384. Largest Palindromic Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2384/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2384/</guid><description>LeetCode problem 2384
class Solution: def largestPalindromic(self, num: str) -&amp;gt; str: cnt = Counter(num) res = &amp;#39;&amp;#39; for i in range(9, -1, -1): v = str(i) if cnt[v] % 2: res = v cnt[v] -= 1 break for i in range(10): v = str(i) if cnt[v]: cnt[v] //= 2 s = cnt[v] * v res = s + res + s return res.strip(&amp;#39;0&amp;#39;) or &amp;#39;0&amp;#39;</description></item><item><title>2385. Amount of Time for Binary Tree to Be Infected</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2385/</guid><description>LeetCode problem 2385
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def amountOfTime(self, root: Optional[TreeNode], start: int) -&amp;gt; int: def dfs(root): if root is None: return if root.left: g[root.val].append(root.left.val) g[root.left.val].append(root.val) if root.right: g[root.val].append(root.right.val) g[root.right.val].append(root.val) dfs(root.left) dfs(root.right) def dfs2(i, fa): res = 0 for j in g[i]: if j != fa: res = max(res, 1 + dfs2(j, i)) return res g = defaultdict(list) dfs(root) return dfs2(start, -1)</description></item><item><title>2387. Median of a Row Wise Sorted Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2387/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2387/</guid><description>LeetCode problem 2387
class Solution: def matrixMedian(self, grid: List[List[int]]) -&amp;gt; int: def count(x): return sum(bisect_right(row, x) for row in grid) m, n = len(grid), len(grid[0]) target = (m * n + 1) &amp;gt;&amp;gt; 1 return bisect_left(range(10**6 + 1), target, key=count)</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem 2390
class Solution: def removeStars(self, s: str) -&amp;gt; str: res = [] for c in s: if c == &amp;#39;*&amp;#39;: res.pop() else: res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>2391. Minimum Amount of Time to Collect Garbage</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2391/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2391/</guid><description>LeetCode problem 2391
class Solution: def garbageCollection(self, garbage: List[str], travel: List[int]) -&amp;gt; int: def f(x: str) -&amp;gt; int: res = 0 st = 0 for i, s in enumerate(garbage): if t := s.count(x): res += t + st st = 0 if i &amp;lt; len(travel): st += travel[i] return res return f(&amp;#39;M&amp;#39;) + f(&amp;#39;P&amp;#39;) + f(&amp;#39;G&amp;#39;)</description></item><item><title>2393. Count Strictly Increasing Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2393/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2393/</guid><description>LeetCode problem 2393
class Solution: def countSubarrays(self, nums: List[int]) -&amp;gt; int: res = pre = cnt = 0 for x in nums: if pre &amp;lt; x: cnt += 1 else: cnt = 1 pre = x res += cnt return res</description></item><item><title>2396. Strictly Palindromic Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2396/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2396/</guid><description>LeetCode problem 2396
class Solution: def isStrictlyPalindromic(self, n: int) -&amp;gt; bool: return False</description></item><item><title>2397. Maximum Rows Covered by Columns</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2397/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2397/</guid><description>LeetCode problem 2397
class Solution: def maximumRows(self, matrix: List[List[int]], numSelect: int) -&amp;gt; int: rows = [] for row in matrix: mask = reduce(or_, (1 &amp;lt;&amp;lt; j for j, x in enumerate(row) if x), 0) rows.append(mask) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(matrix[0])): if mask.bit_count() != numSelect: continue t = sum((x &amp;amp; mask) == x for x in rows) res = max(res, t) return res</description></item><item><title>2400. Number of Ways to Reach a Position After Exactly k Steps</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2400/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2400/</guid><description>LeetCode problem 2400
class Solution: def numberOfWays(self, startPos: int, endPos: int, k: int) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if i &amp;gt; j or j &amp;lt; 0: return 0 if j == 0: return 1 if i == 0 else 0 return (dfs(i + 1, j - 1) + dfs(abs(i - 1), j - 1)) % mod mod = 10**9 + 7 return dfs(abs(startPos - endPos), k)</description></item><item><title>2401. Longest Nice Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2401/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2401/</guid><description>LeetCode problem 2401
class Solution: def longestNiceSubarray(self, nums: List[int]) -&amp;gt; int: res = j = mask = 0 for i, x in enumerate(nums): while mask &amp;amp; x: mask ^= nums[j] j += 1 res = max(res, i - j + 1) mask |= x return res</description></item><item><title>2405. Optimal Partition of String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2405/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2405/</guid><description>LeetCode problem 2405
class Solution: def partitionString(self, s: str) -&amp;gt; int: res, v = 1, 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if (v &amp;gt;&amp;gt; i) &amp;amp; 1: v = 0 res += 1 v |= 1 &amp;lt;&amp;lt; i return res</description></item><item><title>2406. Divide Intervals Into Minimum Number of Groups</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2406/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2406/</guid><description>LeetCode problem 2406
class Solution: def minGroups(self, intervals: List[List[int]]) -&amp;gt; int: h = [] for a, b in sorted(intervals): if h and h[0] &amp;lt; a: heappop(h) heappush(h, b) return len(h)</description></item><item><title>2408. Design SQL</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2408/</guid><description>LeetCode problem 2408
class SQL: def __init__(self, names: List[str], columns: List[int]): self.tables = defaultdict(list) def insertRow(self, name: str, row: List[str]) -&amp;gt; None: self.tables[name].append(row) def deleteRow(self, name: str, rowId: int) -&amp;gt; None: pass def selectCell(self, name: str, rowId: int, columnId: int) -&amp;gt; str: return self.tables[name][rowId - 1][columnId - 1] # Your SQL object will be instantiated and called as such: # obj = SQL(names, columns) # obj.insertRow(name,row) # obj.deleteRow(name,rowId) # param_3 = obj.selectCell(name,rowId,columnId)</description></item><item><title>2410. Maximum Matching of Players With Trainers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2410/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2410/</guid><description>LeetCode problem 2410
class Solution: def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -&amp;gt; int: players.sort() trainers.sort() res = j = 0 for p in players: while j &amp;lt; len(trainers) and trainers[j] &amp;lt; p: j += 1 if j &amp;lt; len(trainers): res += 1 j += 1 return res</description></item><item><title>2411. Smallest Subarrays With Maximum Bitwise OR</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2411/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2411/</guid><description>LeetCode problem 2411
class Solution: def smallestSubarrays(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n f = [-1] * 32 for i in range(n - 1, -1, -1): t = 1 for j in range(32): if (nums[i] &amp;gt;&amp;gt; j) &amp;amp; 1: f[j] = i elif f[j] != -1: t = max(t, f[j] - i + 1) res[i] = t return res</description></item><item><title>2414. Length of the Longest Alphabetical Continuous Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2414/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2414/</guid><description>LeetCode problem 2414
class Solution: def longestContinuousSubstring(self, s: str) -&amp;gt; int: res = 0 i, j = 0, 1 while j &amp;lt; len(s): res = max(res, j - i) if ord(s[j]) - ord(s[j - 1]) != 1: i = j j += 1 res = max(res, j - i) return res</description></item><item><title>2415. Reverse Odd Levels of Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2415/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2415/</guid><description>LeetCode problem 2415
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def reverseOddLevels(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: q = deque([root]) i = 0 while q: if i &amp;amp; 1: l, r = 0, len(q) - 1 while l &amp;lt; r: q[l].val, q[r].val = q[r].val, q[l].val l, r = l + 1, r - 1 for _ in range(len(q)): node = q.</description></item><item><title>2417. Closest Fair Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2417/</guid><description>LeetCode problem 2417
class Solution: def closestFair(self, n: int) -&amp;gt; int: a = b = k = 0 t = n while t: if (t % 10) &amp;amp; 1: a += 1 else: b += 1 t //= 10 k += 1 if k &amp;amp; 1: x = 10**k y = int(&amp;#39;1&amp;#39; * (k &amp;gt;&amp;gt; 1) or &amp;#39;0&amp;#39;) return x + y if a == b: return n return self.closestFair(n + 1)</description></item><item><title>2419. Longest Subarray With Maximum Bitwise AND</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2419/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2419/</guid><description>LeetCode problem 2419
class Solution: def longestSubarray(self, nums: List[int]) -&amp;gt; int: mx = max(nums) res = cnt = 0 for v in nums: if v == mx: cnt += 1 res = max(res, cnt) else: cnt = 0 return res</description></item><item><title>2420. Find All Good Indices</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2420/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2420/</guid><description>LeetCode problem 2420
class Solution: def goodIndices(self, nums: List[int], k: int) -&amp;gt; List[int]: n = len(nums) decr = [1] * (n + 1) incr = [1] * (n + 1) for i in range(2, n - 1): if nums[i - 1] &amp;lt;= nums[i - 2]: decr[i] = decr[i - 1] + 1 for i in range(n - 3, -1, -1): if nums[i + 1] &amp;lt;= nums[i + 2]: incr[i] = incr[i + 1] + 1 return [i for i in range(k, n - k) if decr[i] &amp;gt;= k and incr[i] &amp;gt;= k]</description></item><item><title>2422. Merge Operations to Turn Array Into a Palindrome</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2422/</guid><description>LeetCode problem 2422
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: i, j = 0, len(nums) - 1 a, b = nums[i], nums[j] res = 0 while i &amp;lt; j: if a &amp;lt; b: i += 1 a += nums[i] res += 1 elif b &amp;lt; a: j -= 1 b += nums[j] res += 1 else: i, j = i + 1, j - 1 a, b = nums[i], nums[j] return res</description></item><item><title>2424. Longest Uploaded Prefix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2424/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2424/</guid><description>LeetCode problem 2424
class LUPrefix: def __init__(self, n: int): self.r = 0 self.s = set() def upload(self, video: int) -&amp;gt; None: self.s.add(video) while self.r + 1 in self.s: self.r += 1 def longest(self) -&amp;gt; int: return self.r # Your LUPrefix object will be instantiated and called as such: # obj = LUPrefix(n) # obj.upload(video) # param_2 = obj.longest()</description></item><item><title>2425. Bitwise XOR of All Pairings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2425/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2425/</guid><description>LeetCode problem 2425
class Solution: def xorAllNums(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: res = 0 if len(nums2) &amp;amp; 1: for v in nums1: res ^= v if len(nums1) &amp;amp; 1: for v in nums2: res ^= v return res</description></item><item><title>2428. Maximum Sum of an Hourglass</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2428/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2428/</guid><description>LeetCode problem 2428
class Solution: def maxSum(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) res = 0 for i in range(1, m - 1): for j in range(1, n - 1): s = -grid[i][j - 1] - grid[i][j + 1] s += sum( grid[x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) ) res = max(res, s) return res</description></item><item><title>2429. Minimize XOR</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2429/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2429/</guid><description>LeetCode problem 2429
class Solution: def minimizeXor(self, num1: int, num2: int) -&amp;gt; int: cnt1 = num1.bit_count() cnt2 = num2.bit_count() while cnt1 &amp;gt; cnt2: num1 &amp;amp;= num1 - 1 cnt1 -= 1 while cnt1 &amp;lt; cnt2: num1 |= num1 + 1 cnt1 += 1 return num1</description></item><item><title>2971. Find Polygon With the Largest Perimeter</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2971/</guid><description>LeetCode problem 2971
class Solution: def largestPerimeter(self, nums: List[int]) -&amp;gt; int: nums.sort() s = list(accumulate(nums, initial=0)) res = -1 for k in range(3, len(nums) + 1): if s[k - 1] &amp;gt; nums[k - 1]: res = max(res, s[k]) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3029/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3029/</guid><description>https://leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-i/description/
class Solution: def minimumTimeToInitialState(self, word: str, k: int) -&amp;gt; int: n = len(word) # Calculate the length of the word # Iterate through the word in steps of k for i in range(k, n, k): # Check if the suffix starting from i matches the prefix up to n-i if word[i:] == word[:-i]: # If they match, the word can return to the initial state in i/k steps return i // k # If no matching prefix and suffix are found, # return the ceiling division of n by k return (n + k - 1) // k Length Calculation: First, calculate the length of word to know the range we&amp;rsquo;re working with.</description></item><item><title>3030. Find the Grid of Region Average</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</guid><description>LeetCode задача 3030
Дана матрица m x n, представляющая изображение в оттенках серого, где image[i][j] представляет пиксель с интенсивностью в диапазоне от 0 до 255. Также дано неотрицательное целое число threshold (пороговое значение).
Два пикселя image[a][b] и image[c][d] считаются соседними, если |a - c| + |b - d| == 1.
Регионом считается матрица 3 x 3, где абсолютная разница в интенсивности между любыми двумя соседними пикселями меньше или равна threshold.
Необходимо вычислить матрицу m x n result, где result[i][j] - это средняя интенсивность региона, к которому принадлежит image[i][j], округленная вниз до ближайшего целого числа.</description></item><item><title>3031. Minimum Time to Revert Word to Initial State II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3031/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3031/</guid><description>LeetCode problem 3031
class Hashing: __slots__ = [&amp;#34;mod&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;p&amp;#34;] def __init__(self, s: str, base: int, mod: int): self.mod = mod self.h = [0] * (len(s) + 1) self.p = [1] * (len(s) + 1) for i in range(1, len(s) + 1): self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod self.p[i] = (self.p[i - 1] * base) % mod def query(self, l: int, r: int) -&amp;gt; int: return (self.h[r] - self.h[l - 1] * self.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3033/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3033/</guid><description>class Solution: def modifiedMatrix(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: rows = len(matrix) cols = len(matrix[0]) for j in range(rows): max_val = max(matrix[i][j] for i in range(cols)) for i in range(cols): if matrix[i][j] == -1: matrix[i][j] = max_val return matrix</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2573/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2573/</guid><description>class Solution: def findTheString(self, lcp: List[List[int]]) -&amp;gt; str: n = len(lcp) s = [&amp;#34;&amp;#34;] * n i = 0 for c in ascii_lowercase: while i &amp;lt; n and s[i]: i += 1 if i == n: break for j in range(i, n): if lcp[i][j]: s[j] = c if &amp;#34;&amp;#34; in s: return &amp;#34;&amp;#34; for i in range(n - 1, -1, -1): for j in range(n - 1, -1, -1): if s[i] == s[j]: if i == n - 1 or j == n - 1: if lcp[i][j] !</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2576/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2576/</guid><description>class Solution: def maxNumOfMarkedIndices(self, nums: List[int]) -&amp;gt; int: nums.sort() n = len(nums) i, j = 0, (n + 1) // 2 res = 0 while j &amp;lt; n: while j &amp;lt; n and nums[i] * 2 &amp;gt; nums[j]: j += 1 if j &amp;lt; n: res += 2 i, j = i + 1, j + 1 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2579/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2579/</guid><description>class Solution: def coloredCells(self, n: int) -&amp;gt; int: return 2 * n * (n - 1) + 1</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2581/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2581/</guid><description>class Solution: def rootCount( self, edges: List[List[int]], guesses: List[List[int]], k: int ) -&amp;gt; int: def dfs1(i, fa): nonlocal cnt for j in g[i]: if j != fa: cnt += gs[(i, j)] dfs1(j, i) def dfs2(i, fa): nonlocal res, cnt res += cnt &amp;gt;= k for j in g[i]: if j != fa: cnt -= gs[(i, j)] cnt += gs[(j, i)] dfs2(j, i) cnt -= gs[(j, i)] cnt += gs[(i, j)] g = defaultdict(list) for a, b in edges: g[a].</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2582/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2582/</guid><description>class Solution: def passThePillow(self, n: int, time: int) -&amp;gt; int: k, mod = divmod(time, n - 1) return n - mod if k &amp;amp; 1 else mod + 1</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2584/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2584/</guid><description>class Solution: def findValidSplit(self, nums: List[int]) -&amp;gt; int: first = {} n = len(nums) last = list(range(n)) for i, x in enumerate(nums): j = 2 while j &amp;lt;= x // j: if x % j == 0: if j in first: last[first[j]] = i else: first[j] = i while x % j == 0: x //= j j += 1 if x &amp;gt; 1: if x in first: last[first[x]] = i else: first[x] = i mx = last[0] for i, x in enumerate(last): if mx &amp;lt; i: return mx mx = max(mx, x) return -1</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2586/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2586/</guid><description>class Solution: def vowelStrings(self, words: List[str], left: int, right: int) -&amp;gt; int: return sum( w[0] in &amp;#39;aeiou&amp;#39; and w[-1] in &amp;#39;aeiou&amp;#39; for w in words[left : right + 1] )</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2587/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2587/</guid><description>class Solution: def maxScore(self, nums: List[int]) -&amp;gt; int: nums.sort(reverse=True) s = 0 for i, x in enumerate(nums): s += x if s &amp;lt;= 0: return i return len(nums)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2590/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2590/</guid><description>from sortedcontainers import SortedList class TodoList: def __init__(self): self.i = 1 self.tasks = defaultdict(SortedList) def addTask( self, userId: int, taskDescription: str, dueDate: int, tags: List[str] ) -&amp;gt; int: taskId = self.i self.i += 1 self.tasks[userId].add([dueDate, taskDescription, set(tags), taskId, False]) return taskId def getAllTasks(self, userId: int) -&amp;gt; List[str]: return [x[1] for x in self.tasks[userId] if not x[4]] def getTasksForTag(self, userId: int, tag: str) -&amp;gt; List[str]: return [x[1] for x in self.tasks[userId] if not x[4] and tag in x[2]] def completeTask(self, userId: int, taskId: int) -&amp;gt; None: for task in self.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2591/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2591/</guid><description>class Solution: def distMoney(self, money: int, children: int) -&amp;gt; int: if money &amp;lt; children: return -1 if money &amp;gt; 8 * children: return children - 1 if money == 8 * children - 4: return children - 2 # money-8x &amp;gt;= children-x, x &amp;lt;= (money-children)/7 return (money - children) // 7</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2593/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2593/</guid><description>class Solution: def findScore(self, nums: List[int]) -&amp;gt; int: n = len(nums) vis = [False] * (n + 2) idx = sorted(range(n), key=lambda i: (nums[i], i)) res = 0 for i in idx: if not vis[i + 1]: res += nums[i] vis[i] = vis[i + 2] = True return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2595/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2595/</guid><description>class Solution: def evenOddBit(self, n: int) -&amp;gt; List[int]: mask = 0x5555 even = (n &amp;amp; mask).bit_count() odd = (n &amp;amp; ~mask).bit_count() return [even, odd]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2599/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2599/</guid><description>class Solution: def makePrefSumNonNegative(self, nums: List[int]) -&amp;gt; int: h = [] res = s = 0 for x in nums: s += x if x &amp;lt; 0: heappush(h, x) while s &amp;lt; 0: s -= heappop(h) res += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2600/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2600/</guid><description>class Solution: def kItemsWithMaximumSum( self, numOnes: int, numZeros: int, numNegOnes: int, k: int ) -&amp;gt; int: if numOnes &amp;gt;= k: return k if numZeros &amp;gt;= k - numOnes: return numOnes return numOnes - (k - numOnes - numZeros)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2603/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2603/</guid><description>class Solution: def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -&amp;gt; int: g = defaultdict(set) for a, b in edges: g[a].add(b) g[b].add(a) n = len(coins) q = deque(i for i in range(n) if len(g[i]) == 1 and coins[i] == 0) while q: i = q.popleft() for j in g[i]: g[j].remove(i) if coins[j] == 0 and len(g[j]) == 1: q.append(j) g[i].clear() for k in range(2): q = [i for i in range(n) if len(g[i]) == 1] for i in q: for j in g[i]: g[j].</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2604/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2604/</guid><description>class Solution: def minimumTime(self, hens: List[int], grains: List[int]) -&amp;gt; int: def check(t): j = 0 for x in hens: if j == m: return True y = grains[j] if y &amp;lt;= x: d = x - y if d &amp;gt; t: return False while j &amp;lt; m and grains[j] &amp;lt;= x: j += 1 while j &amp;lt; m and min(d, grains[j] - x) + grains[j] - y &amp;lt;= t: j += 1 else: while j &amp;lt; m and grains[j] - x &amp;lt;= t: j += 1 return j == m hens.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2606/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2606/</guid><description>class Solution: def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -&amp;gt; int: d = {c: v for c, v in zip(chars, vals)} res = f = 0 for c in s: v = d.get(c, ord(c) - ord(&amp;#39;a&amp;#39;) + 1) f = max(f, 0) + v res = max(res, f) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2607/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2607/</guid><description>class Solution: def makeSubKSumEqual(self, arr: List[int], k: int) -&amp;gt; int: n = len(arr) g = gcd(n, k) res = 0 for i in range(g): t = sorted(arr[i:n:g]) mid = t[len(t) &amp;gt;&amp;gt; 1] res += sum(abs(x - mid) for x in t) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2609/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2609/</guid><description>class Solution: def findTheLongestBalancedSubstring(self, s: str) -&amp;gt; int: res = zero = one = 0 for c in s: if c == &amp;#39;0&amp;#39;: if one: zero = one = 0 zero += 1 else: one += 1 res = max(res, 2 * min(one, zero)) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2612/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2612/</guid><description>from sortedcontainers import SortedSet class Solution: def minReverseOperations( self, n: int, p: int, banned: List[int], k: int ) -&amp;gt; List[int]: res = [-1] * n res[p] = 0 ts = [SortedSet() for _ in range(2)] for i in range(n): ts[i % 2].add(i) ts[p % 2].remove(p) for i in banned: ts[i % 2].remove(i) ts[0].add(n) ts[1].add(n) q = deque([p]) while q: i = q.popleft() mi = max(i - k + 1, k - i - 1) mx = min(i + k - 1, n * 2 - k - i - 1) s = ts[mi % 2] j = s.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2615/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2615/</guid><description>class Solution: def distance(self, nums: List[int]) -&amp;gt; List[int]: d = defaultdict(list) for i, x in enumerate(nums): d[x].append(i) res = [0] * len(nums) for idx in d.values(): left, right = 0, sum(idx) - len(idx) * idx[0] for i in range(len(idx)): res[idx[i]] = left + right if i + 1 &amp;lt; len(idx): left += (idx[i + 1] - idx[i]) * (i + 1) right -= (idx[i + 1] - idx[i]) * (len(idx) - i - 1) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2616/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2616/</guid><description>class Solution: def minimizeMax(self, nums: List[int], p: int) -&amp;gt; int: def check(diff: int) -&amp;gt; bool: cnt = i = 0 while i &amp;lt; len(nums) - 1: if nums[i + 1] - nums[i] &amp;lt;= diff: cnt += 1 i += 2 else: i += 1 return cnt &amp;gt;= p nums.sort() return bisect_left(range(nums[-1] - nums[0] + 1), True, key=check)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2638/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2638/</guid><description>class Solution: def countTheNumOfKFreeSubsets(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() g = defaultdict(list) for x in nums: g[x % k].append(x) res = 1 for arr in g.values(): m = len(arr) f = [0] * (m + 1) f[0] = 1 f[1] = 2 for i in range(2, m + 1): if arr[i - 1] - arr[i - 2] == k: f[i] = f[i - 1] + f[i - 2] else: f[i] = f[i - 1] * 2 res *= f[m] return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2640/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2640/</guid><description>class Solution: def findPrefixScore(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [0] * n mx = 0 for i, x in enumerate(nums): mx = max(mx, x) res[i] = x + mx + (0 if i == 0 else res[i - 1]) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2641/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2641/</guid><description># Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def replaceValueInTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: root.val = 0 q = [root] while q: t = [] s = 0 for node in q: if node.left: t.append(node.left) s += node.left.val if node.right: t.append(node.right) s += node.right.val for node in q: sub = (node.left.val if node.left else 0) + ( node.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2644/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2644/</guid><description>class Solution: def maxDivScore(self, nums: List[int], divisors: List[int]) -&amp;gt; int: res, mx = divisors[0], 0 for div in divisors: cnt = sum(x % div == 0 for x in nums) if mx &amp;lt; cnt: mx, res = cnt, div elif mx == cnt and res &amp;gt; div: res = div return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2646/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2646/</guid><description>class Solution: def minimumTotalPrice( self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]] ) -&amp;gt; int: def dfs(i: int, fa: int, k: int) -&amp;gt; bool: cnt[i] += 1 if i == k: return True ok = any(j != fa and dfs(j, i, k) for j in g[i]) if not ok: cnt[i] -= 1 return ok def dfs2(i: int, fa: int) -&amp;gt; (int, int): a = cnt[i] * price[i] b = a // 2 for j in g[i]: if j !</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2651/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2651/</guid><description>class Solution: def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -&amp;gt; int: return (arrivalTime + delayedTime) % 24</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2653/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2653/</guid><description>class Solution: def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -&amp;gt; List[int]: def f(x: int) -&amp;gt; int: s = 0 for i in range(50): s += cnt[i] if s &amp;gt;= x: return i - 50 return 0 cnt = [0] * 101 for v in nums[:k]: cnt[v + 50] += 1 res = [f(x)] for i in range(k, len(nums)): cnt[nums[i] + 50] += 1 cnt[nums[i - k] + 50] -= 1 res.append(f(x)) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2655/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2655/</guid><description>class Solution: def findMaximalUncoveredRanges( self, n: int, ranges: List[List[int]] ) -&amp;gt; List[List[int]]: ranges.sort() last = -1 res = [] for l, r in ranges: if last + 1 &amp;lt; l: res.append([last + 1, l - 1]) last = max(last, r) if last + 1 &amp;lt; n: res.append([last + 1, n - 1]) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2656/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2656/</guid><description>class Solution: def maximizeSum(self, nums: List[int], k: int) -&amp;gt; int: x = max(nums) return k * x + k * (k - 1) // 2</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2661/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2661/</guid><description>class Solution: def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) idx = {} for i in range(m): for j in range(n): idx[mat[i][j]] = (i, j) row = [0] * m col = [0] * n for k in range(len(arr)): i, j = idx[arr[k]] row[i] += 1 col[j] += 1 if row[i] == n or col[j] == m: return k</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2662/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2662/</guid><description>class Solution: def minimumCost( self, start: List[int], target: List[int], specialRoads: List[List[int]] ) -&amp;gt; int: def dist(x1: int, y1: int, x2: int, y2: int) -&amp;gt; int: return abs(x1 - x2) + abs(y1 - y2) q = [(0, start[0], start[1])] vis = set() res = inf while q: d, x, y = heappop(q) if (x, y) in vis: continue vis.add((x, y)) res = min(res, d + dist(x, y, *target)) for x1, y1, x2, y2, cost in specialRoads: heappush(q, (d + dist(x, y, x1, y1) + cost, x2, y2)) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2664/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2664/</guid><description>class Solution: def tourOfKnight(self, m: int, n: int, r: int, c: int) -&amp;gt; List[List[int]]: def dfs(i: int, j: int): nonlocal ok if g[i][j] == m * n - 1: ok = True return for a, b in pairwise((-2, -1, 2, 1, -2, 1, 2, -1, -2)): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and g[x][y] == -1: g[x][y] = g[i][j] + 1 dfs(x, y) if ok: return g[x][y] = -1 g = [[-1] * n for _ in range(m)] g[r][c] = 0 ok = False dfs(r, c) return g</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2670/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2670/</guid><description>class Solution: def distinctDifferenceArray(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) suf = [0] * (n + 1) s = set() for i in range(n - 1, -1, -1): s.add(nums[i]) suf[i] = len(s) s.clear() res = [0] * n for i, x in enumerate(nums): s.add(x) res[i] = len(s) - suf[i + 1] return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2672/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2672/</guid><description>class Solution: def colorTheArray(self, n: int, queries: List[List[int]]) -&amp;gt; List[int]: nums = [0] * n res = [0] * len(queries) x = 0 for k, (i, c) in enumerate(queries): if i &amp;gt; 0 and nums[i] and nums[i - 1] == nums[i]: x -= 1 if i &amp;lt; n - 1 and nums[i] and nums[i + 1] == nums[i]: x -= 1 if i &amp;gt; 0 and nums[i - 1] == c: x += 1 if i &amp;lt; n - 1 and nums[i + 1] == c: x += 1 res[k] = x nums[i] = c return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2673/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2673/</guid><description>class Solution: def minIncrements(self, n: int, cost: List[int]) -&amp;gt; int: def dfs(i: int) -&amp;gt; int: if (i &amp;lt;&amp;lt; 1) &amp;gt; n: return cost[i - 1] l, r = dfs(i &amp;lt;&amp;lt; 1), dfs(i &amp;lt;&amp;lt; 1 | 1) nonlocal res res += max(l, r) - min(l, r) return cost[i - 1] + max(l, r) res = 0 dfs(1) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2674/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2674/</guid><description># Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def splitCircularLinkedList( self, list: Optional[ListNode] ) -&amp;gt; List[Optional[ListNode]]: a = b = list while b.next != list and b.next.next != list: a = a.next b = b.next.next if b.next != list: b = b.next list2 = a.next b.next = list2 a.next = list return [list, list2]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2680/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2680/</guid><description>class Solution: def maximumOr(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) suf = [0] * (n + 1) for i in range(n - 1, -1, -1): suf[i] = suf[i + 1] | nums[i] res = pre = 0 for i, x in enumerate(nums): res = max(res, pre | (x &amp;lt;&amp;lt; k) | suf[i + 1]) pre |= x return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2683/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2683/</guid><description>class Solution: def doesValidArrayExist(self, derived: List[int]) -&amp;gt; bool: return reduce(xor, derived) == 0</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2685/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2685/</guid><description>class Solution: def countCompleteComponents(self, n: int, edges: List[List[int]]) -&amp;gt; int: def dfs(i: int) -&amp;gt; (int, int): vis[i] = True x, y = 1, len(g[i]) for j in g[i]: if not vis[j]: a, b = dfs(j) x += a y += b return x, y g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) vis = [False] * n res = 0 for i in range(n): if not vis[i]: a, b = dfs(i) res += a * (a - 1) == b return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2696/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2696/</guid><description>class Solution: def minLength(self, s: str) -&amp;gt; int: stk = [&amp;#34;&amp;#34;] for c in s: if (c == &amp;#34;B&amp;#34; and stk[-1] == &amp;#34;A&amp;#34;) or (c == &amp;#34;D&amp;#34; and stk[-1] == &amp;#34;C&amp;#34;): stk.pop() else: stk.append(c) return len(stk) - 1</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2699/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2699/</guid><description>class Solution: def modifiedGraphEdges( self, n: int, edges: List[List[int]], source: int, destination: int, target: int ) -&amp;gt; List[List[int]]: def dijkstra(edges: List[List[int]]) -&amp;gt; int: g = [[inf] * n for _ in range(n)] for a, b, w in edges: if w == -1: continue g[a][b] = g[b][a] = w dist = [inf] * n dist[source] = 0 vis = [False] * n for _ in range(n): k = -1 for j in range(n): if not vis[j] and (k == -1 or dist[k] &amp;gt; dist[j]): k = j vis[k] = True for j in range(n): dist[j] = min(dist[j], dist[k] + g[k][j]) return dist[destination] inf = 2 * 10**9 d = dijkstra(edges) if d &amp;lt; target: return [] ok = d == target for e in edges: if e[2] &amp;gt; 0: continue if ok: e[2] = inf continue e[2] = 1 d = dijkstra(edges) if d &amp;lt;= target: ok = True e[2] += target - d return edges if ok else []</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2702/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2702/</guid><description>class Solution: def minOperations(self, nums: List[int], x: int, y: int) -&amp;gt; int: def check(t: int) -&amp;gt; bool: cnt = 0 for v in nums: if v &amp;gt; t * y: cnt += ceil((v - t * y) / (x - y)) return cnt &amp;lt;= t l, r = 0, max(nums) while l &amp;lt; r: mid = (l + r) &amp;gt;&amp;gt; 1 if check(mid): r = mid else: l = mid + 1 return l</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2706/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2706/</guid><description>class Solution: def buyChoco(self, prices: List[int], money: int) -&amp;gt; int: a = b = inf for x in prices: if x &amp;lt; a: a, b = x, a elif x &amp;lt; b: b = x cost = a + b return money if money &amp;lt; cost else money - cost</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2709/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2709/</guid><description>class UnionFind: def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a, b): pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True mx = 100010 p = defaultdict(list) for x in range(1, mx + 1): v = x i = 2 while i &amp;lt;= v // i: if v % i == 0: p[x].</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2710/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2710/</guid><description>class Solution: def removeTrailingZeros(self, num: str) -&amp;gt; str: return num.rstrip(&amp;#34;0&amp;#34;)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2712/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2712/</guid><description>class Solution: def minimumCost(self, s: str) -&amp;gt; int: res, n = 0, len(s) for i in range(1, n): if s[i] != s[i - 1]: res += min(i, n - i) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2713/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2713/</guid><description>class Solution: def maxIncreasingCells(self, mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) g = defaultdict(list) for i in range(m): for j in range(n): g[mat[i][j]].append((i, j)) rowMax = [0] * m colMax = [0] * n res = 0 for _, pos in sorted(g.items()): mx = [] for i, j in pos: mx.append(1 + max(rowMax[i], colMax[j])) res = max(res, mx[-1]) for k, (i, j) in enumerate(pos): rowMax[i] = max(rowMax[i], mx[k]) colMax[j] = max(colMax[j], mx[k]) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2716/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2716/</guid><description>class Solution: def minimizedStringLength(self, s: str) -&amp;gt; int: return len(set(s))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2718/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2718/</guid><description>class Solution: def matrixSumQueries(self, n: int, queries: List[List[int]]) -&amp;gt; int: row = set() col = set() res = 0 for t, i, v in queries[::-1]: if t == 0: if i not in row: res += v * (n - len(col)) row.add(i) else: if i not in col: res += v * (n - len(row)) col.add(i) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2728/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2728/</guid><description># Definition for a street. # class Street: # def openDoor(self): # pass # def closeDoor(self): # pass # def isDoorOpen(self): # pass # def moveRight(self): # pass # def moveLeft(self): # pass class Solution: def houseCount(self, street: Optional[&amp;#34;Street&amp;#34;], k: int) -&amp;gt; int: for _ in range(k): street.openDoor() street.moveLeft() res = 0 while street.isDoorOpen(): street.closeDoor() street.moveLeft() res += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2730/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2730/</guid><description>class Solution: def longestSemiRepetitiveSubstring(self, s: str) -&amp;gt; int: n = len(s) res = cnt = j = 0 for i in range(n): if i and s[i] == s[i - 1]: cnt += 1 while cnt &amp;gt; 1: if s[j] == s[j + 1]: cnt -= 1 j += 1 res = max(res, i - j + 1) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2731/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2731/</guid><description>class Solution: def sumDistance(self, nums: List[int], s: str, d: int) -&amp;gt; int: mod = 10**9 + 7 for i, c in enumerate(s): nums[i] += d if c == &amp;#34;R&amp;#34; else -d nums.sort() res = s = 0 for i, x in enumerate(nums): res += i * x - s s += x return res % mod</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2735/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2735/</guid><description>class Solution: def minCost(self, nums: List[int], x: int) -&amp;gt; int: n = len(nums) f = [[0] * n for _ in range(n)] for i, v in enumerate(nums): f[i][0] = v for j in range(1, n): f[i][j] = min(f[i][j - 1], nums[(i - j) % n]) return min(sum(f[i][j] for i in range(n)) + x * j for j in range(n))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2736/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2736/</guid><description>class BinaryIndexedTree: __slots__ = [&amp;#34;n&amp;#34;, &amp;#34;c&amp;#34;] def __init__(self, n: int): self.n = n self.c = [-1] * (n + 1) def update(self, x: int, v: int): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], v) x += x &amp;amp; -x def query(self, x: int) -&amp;gt; int: mx = -1 while x: mx = max(mx, self.c[x]) x -= x &amp;amp; -x return mx class Solution: def maximumSumQueries( self, nums1: List[int], nums2: List[int], queries: List[List[int]] ) -&amp;gt; List[int]: nums = sorted(zip(nums1, nums2), key=lambda x: -x[0]) nums2.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2740/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2740/</guid><description>class Solution: def findValueOfPartition(self, nums: List[int]) -&amp;gt; int: nums.sort() return min(b - a for a, b in pairwise(nums))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2742/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2742/</guid><description>class Solution: def paintWalls(self, cost: List[int], time: List[int]) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if n - i &amp;lt;= j: return 0 if i &amp;gt;= n: return inf return min(dfs(i + 1, j + time[i]) + cost[i], dfs(i + 1, j - 1)) n = len(cost) return dfs(0, 0)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2743/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2743/</guid><description>class Solution: def numberOfSpecialSubstrings(self, s: str) -&amp;gt; int: cnt = Counter() res = j = 0 for i, c in enumerate(s): cnt[c] += 1 while cnt[c] &amp;gt; 1: cnt[s[j]] -= 1 j += 1 res += i - j + 1 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2745/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2745/</guid><description>class Solution: def longestString(self, x: int, y: int, z: int) -&amp;gt; int: if x &amp;lt; y: return (x * 2 + z + 1) * 2 if x &amp;gt; y: return (y * 2 + z + 1) * 2 return (x + y + z) * 2</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2749/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2749/</guid><description>class Solution: def makeTheIntegerZero(self, num1: int, num2: int) -&amp;gt; int: for k in count(1): x = num1 - k * num2 if x &amp;lt; 0: break if x.bit_count() &amp;lt;= k &amp;lt;= x: return k return -1</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2750/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2750/</guid><description>class Solution: def numberOfGoodSubarraySplits(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 res, j = 1, -1 for i, x in enumerate(nums): if x == 0: continue if j &amp;gt; -1: res = res * (i - j) % mod j = i return 0 if j == -1 else res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2753/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2753/</guid><description># Definition for a street. # class Street: # def closeDoor(self): # pass # def isDoorOpen(self): # pass # def moveRight(self): # pass class Solution: def houseCount(self, street: Optional[&amp;#34;Street&amp;#34;], k: int) -&amp;gt; int: while not street.isDoorOpen(): street.moveRight() for i in range(1, k + 1): street.moveRight() if street.isDoorOpen(): res = i street.closeDoor() return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2760/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2760/</guid><description>class Solution: def longestAlternatingSubarray(self, nums: List[int], threshold: int) -&amp;gt; int: res, l, n = 0, 0, len(nums) while l &amp;lt; n: if nums[l] % 2 == 0 and nums[l] &amp;lt;= threshold: r = l + 1 while r &amp;lt; n and nums[r] % 2 != nums[r - 1] % 2 and nums[r] &amp;lt;= threshold: r += 1 res = max(res, r - l) l = r else: l += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2762/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2762/</guid><description>from sortedcontainers import SortedList class Solution: def continuousSubarrays(self, nums: List[int]) -&amp;gt; int: res = i = 0 sl = SortedList() for x in nums: sl.add(x) while sl[-1] - sl[0] &amp;gt; 2: sl.remove(nums[i]) i += 1 res += len(sl) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2764/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2764/</guid><description>class Solution: def isPreorder(self, nodes: List[List[int]]) -&amp;gt; bool: def dfs(i: int) -&amp;gt; int: nonlocal k if i != nodes[k][0]: return False k += 1 return all(dfs(j) for j in g[i]) g = defaultdict(list) for i, p in nodes: g[p].append(i) k = 0 return dfs(nodes[0][0]) and k == len(nodes)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2766/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2766/</guid><description>class Solution: def relocateMarbles( self, nums: List[int], moveFrom: List[int], moveTo: List[int] ) -&amp;gt; List[int]: pos = set(nums) for f, t in zip(moveFrom, moveTo): pos.remove(f) pos.add(t) return sorted(pos)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2770/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2770/</guid><description>class Solution: def maximumJumps(self, nums: List[int], target: int) -&amp;gt; int: @cache def dfs(i: int) -&amp;gt; int: if i == n - 1: return 0 res = -inf for j in range(i + 1, n): if abs(nums[i] - nums[j]) &amp;lt;= target: res = max(res, 1 + dfs(j)) return res n = len(nums) res = dfs(0) return -1 if res &amp;lt; 0 else res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2771/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2771/</guid><description>class Solution: def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) f = g = 1 res = 1 for i in range(1, n): ff = gg = 1 if nums1[i] &amp;gt;= nums1[i - 1]: ff = max(ff, f + 1) if nums1[i] &amp;gt;= nums2[i - 1]: ff = max(ff, g + 1) if nums2[i] &amp;gt;= nums1[i - 1]: gg = max(gg, f + 1) if nums2[i] &amp;gt;= nums2[i - 1]: gg = max(gg, g + 1) f, g = ff, gg res = max(res, f, g) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2835/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2835/</guid><description>class Solution: def minOperations(self, nums: List[int], target: int) -&amp;gt; int: s = sum(nums) if s &amp;lt; target: return -1 cnt = [0] * 32 for x in nums: for i in range(32): if x &amp;gt;&amp;gt; i &amp;amp; 1: cnt[i] += 1 i = j = 0 res = 0 while 1: while i &amp;lt; 32 and (target &amp;gt;&amp;gt; i &amp;amp; 1) == 0: i += 1 if i == 32: break while j &amp;lt; i: cnt[j + 1] += cnt[j] // 2 cnt[j] %= 2 j += 1 while cnt[j] == 0: cnt[j] = 1 j += 1 res += j - i cnt[j] -= 1 j = i i += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2838/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2838/</guid><description>class Solution: def maximumCoins( self, heroes: List[int], monsters: List[int], coins: List[int] ) -&amp;gt; List[int]: m = len(monsters) idx = sorted(range(m), key=lambda i: monsters[i]) s = list(accumulate((coins[i] for i in idx), initial=0)) res = [] for h in heroes: i = bisect_right(idx, h, key=lambda i: monsters[i]) res.append(s[i]) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2840/</guid><description>class Solution: def checkStrings(self, s1: str, s2: str) -&amp;gt; bool: return sorted(s1[::2]) == sorted(s2[::2]) and sorted(s1[1::2]) == sorted( s2[1::2] )</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2842/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2842/</guid><description>class Solution: def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -&amp;gt; int: f = Counter(s) if len(f) &amp;lt; k: return 0 mod = 10**9 + 7 vs = sorted(f.values(), reverse=True) val = vs[k - 1] x = vs.count(val) res = 1 for v in vs: if v == val: break k -= 1 res = res * v % mod res = res * comb(x, k) * pow(val, k, mod) % mod return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2845/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2845/</guid><description>class Solution: def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -&amp;gt; int: arr = [int(x % modulo == k) for x in nums] cnt = Counter() cnt[0] = 1 res = s = 0 for x in arr: s += x res += cnt[(s - k) % modulo] cnt[s % modulo] += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2848/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2848/</guid><description>class Solution: def numberOfPoints(self, nums: List[List[int]]) -&amp;gt; int: d = [0] * 110 for a, b in nums: d[a] += 1 d[b + 1] -= 1 return sum(s &amp;gt; 0 for s in accumulate(d))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2850/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2850/</guid><description>class Solution: def minimumMoves(self, grid: List[List[int]]) -&amp;gt; int: def cal(a: tuple, b: tuple) -&amp;gt; int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) left, right = [], [] for i in range(3): for j in range(3): if grid[i][j] == 0: left.append((i, j)) else: for _ in range(grid[i][j] - 1): right.append((i, j)) n = len(left) f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): k = i.bit_count() for j in range(n): if i &amp;gt;&amp;gt; j &amp;amp; 1: f[i] = min(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + cal(left[k - 1], right[j])) return f[-1]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2855/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2855/</guid><description>class Solution: def minimumRightShifts(self, nums: List[int]) -&amp;gt; int: n = len(nums) i = 1 while i &amp;lt; n and nums[i - 1] &amp;lt; nums[i]: i += 1 k = i + 1 while k &amp;lt; n and nums[k - 1] &amp;lt; nums[k] &amp;lt; nums[0]: k += 1 return -1 if k &amp;lt; n else n - i</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2856/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2856/</guid><description>class Solution: def minLengthAfterRemovals(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) pq = [-x for x in cnt.values()] heapify(pq) res = len(nums) while len(pq) &amp;gt; 1: x, y = -heappop(pq), -heappop(pq) x -= 1 y -= 1 if x &amp;gt; 0: heappush(pq, -x) if y &amp;gt; 0: heappush(pq, -y) res -= 2 return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2858/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2858/</guid><description>class Solution: def minEdgeReversals(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: res = [0] * n g = [[] for _ in range(n)] for x, y in edges: g[x].append((y, 1)) g[y].append((x, -1)) def dfs(i: int, fa: int): for j, k in g[i]: if j != fa: res[0] += int(k &amp;lt; 0) dfs(j, i) dfs(0, -1) def dfs2(i: int, fa: int): for j, k in g[i]: if j != fa: res[j] = res[i] + k dfs2(j, i) dfs2(0, -1) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2867/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2867/</guid><description>class Solution: def countPaths(self, n: int, edges: List[List[int]]) -&amp;gt; int: def mul(x, y): return x * y def dfs(x, f, con, prime, r): v = [1 - prime[x], prime[x]] for y in con[x]: if y == f: continue p = dfs(y, x, con, prime, r) r[0] += mul(p[0], v[1]) + mul(p[1], v[0]) if prime[x]: v[1] += p[0] else: v[0] += p[0] v[1] += p[1] return v prime = [True] * (n + 1) prime[1] = False all_primes = [] for i in range(2, n + 1): if prime[i]: all_primes.</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2868/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2868/</guid><description>class Solution: def canAliceWin(self, a: List[str], b: List[str]) -&amp;gt; bool: i, j, k = 1, 0, 1 w = a[0] while 1: if k: if j == len(b): return True if (b[j][0] == w[0] and b[j] &amp;gt; w) or ord(b[j][0]) - ord(w[0]) == 1: w = b[j] k ^= 1 j += 1 else: if i == len(a): return False if (a[i][0] == w[0] and a[i] &amp;gt; w) or ord(a[i][0]) - ord(w[0]) == 1: w = a[i] k ^= 1 i += 1</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2869/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2869/</guid><description>class Solution: def minOperations(self, nums: List[int], k: int) -&amp;gt; int: is_added = [False] * k count = 0 n = len(nums) for i in range(n - 1, -1, -1): if nums[i] &amp;gt; k or is_added[nums[i] - 1]: continue is_added[nums[i] - 1] = True count += 1 if count == k: return n - i</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2871/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2871/</guid><description>class Solution: def maxSubarrays(self, nums: List[int]) -&amp;gt; int: score, res = -1, 1 for num in nums: score &amp;amp;= num if score == 0: score = -1 res += 1 return 1 if res == 1 else res - 1</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2872/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2872/</guid><description>class Solution: def maxKDivisibleComponents( self, n: int, edges: List[List[int]], values: List[int], k: int ) -&amp;gt; int: def dfs(i: int, fa: int) -&amp;gt; int: s = values[i] for j in g[i]: if j != fa: s += dfs(j, i) nonlocal res res += s % k == 0 return s g = [[] for _ in range(n)] for a, b in edges: g[a].append(b) g[b].append(a) res = 0 dfs(0, -1) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2873/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2873/</guid><description>class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2877/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2877/</guid><description>import pandas as pd def createDataframe(student_data: List[List[int]]) -&amp;gt; pd.DataFrame: return pd.DataFrame(student_data, columns=[&amp;#39;student_id&amp;#39;, &amp;#39;age&amp;#39;])</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2878/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2878/</guid><description>import pandas as pd def getDataframeSize(players: pd.DataFrame) -&amp;gt; List[int]: return list(players.shape)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2880/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2880/</guid><description>import pandas as pd def selectData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;student_id&amp;#39;] == 101][[&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;]]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2882/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2882/</guid><description>import pandas as pd def dropDuplicateEmails(customers: pd.DataFrame) -&amp;gt; pd.DataFrame: return customers.drop_duplicates(subset=[&amp;#39;email&amp;#39;])</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2883/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2883/</guid><description>import pandas as pd def dropMissingData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;name&amp;#39;].notnull()]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2885/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2885/</guid><description>import pandas as pd def renameColumns(students: pd.DataFrame) -&amp;gt; pd.DataFrame: students.rename( columns={ &amp;#39;id&amp;#39;: &amp;#39;student_id&amp;#39;, &amp;#39;first&amp;#39;: &amp;#39;first_name&amp;#39;, &amp;#39;last&amp;#39;: &amp;#39;last_name&amp;#39;, &amp;#39;age&amp;#39;: &amp;#39;age_in_years&amp;#39;, }, inplace=True, ) return students</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2887/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2887/</guid><description>import pandas as pd def fillMissingValues(products: pd.DataFrame) -&amp;gt; pd.DataFrame: products[&amp;#39;quantity&amp;#39;] = products[&amp;#39;quantity&amp;#39;].fillna(0) return products</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2888/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2888/</guid><description>import pandas as pd def concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.concat([df1, df2], ignore_index=True)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2889/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2889/</guid><description>import pandas as pd def pivotTable(weather: pd.DataFrame) -&amp;gt; pd.DataFrame: return weather.pivot(index=&amp;#39;month&amp;#39;, columns=&amp;#39;city&amp;#39;, values=&amp;#39;temperature&amp;#39;)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2890/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2890/</guid><description>import pandas as pd def meltTable(report: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.melt(report, id_vars=[&amp;#39;product&amp;#39;], var_name=&amp;#39;quarter&amp;#39;, value_name=&amp;#39;sales&amp;#39;)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2891/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2891/</guid><description>import pandas as pd def findHeavyAnimals(animals: pd.DataFrame) -&amp;gt; pd.DataFrame: return animals[animals[&amp;#39;weight&amp;#39;] &amp;gt; 100].sort_values(&amp;#39;weight&amp;#39;, ascending=False)[ [&amp;#39;name&amp;#39;] ]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2898/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2898/</guid><description>class Solution: def maxScore(self, prices: List[int]) -&amp;gt; int: cnt = Counter() for i, x in enumerate(prices): cnt[x - i] += x return max(cnt.values())</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2903/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2903/</guid><description>class Solution: def findIndices( self, nums: List[int], indexDifference: int, valueDifference: int ) -&amp;gt; List[int]: mi = mx = 0 for i in range(indexDifference, len(nums)): j = i - indexDifference if nums[j] &amp;lt; nums[mi]: mi = j if nums[j] &amp;gt; nums[mx]: mx = j if nums[i] - nums[mi] &amp;gt;= valueDifference: return [mi, i] if nums[mx] - nums[i] &amp;gt;= valueDifference: return [mx, i] return [-1, -1]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2904/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2904/</guid><description>class Solution: def shortestBeautifulSubstring(self, s: str, k: int) -&amp;gt; str: i = j = cnt = 0 n = len(s) res = &amp;#34;&amp;#34; while j &amp;lt; n: cnt += s[j] == &amp;#34;1&amp;#34; while cnt &amp;gt; k or (i &amp;lt; j and s[i] == &amp;#34;0&amp;#34;): cnt -= s[i] == &amp;#34;1&amp;#34; i += 1 j += 1 if cnt == k and ( not res or j - i &amp;lt; len(res) or (j - i == len(res) and s[i:j] &amp;lt; res) ): res = s[i:j] return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2908/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2908/</guid><description>class Solution: def minimumSum(self, nums: List[int]) -&amp;gt; int: n = len(nums) right = [inf] * (n + 1) for i in range(n - 1, -1, -1): right[i] = min(right[i + 1], nums[i]) res = left = inf for i, x in enumerate(nums): if left &amp;lt; x and right[i + 1] &amp;lt; x: res = min(res, left + x + right[i + 1]) left = min(left, x) return -1 if res == inf else res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2912/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2912/</guid><description>class Solution: def numberOfWays( self, n: int, m: int, k: int, source: List[int], dest: List[int] ) -&amp;gt; int: mod = 10**9 + 7 f = [1, 0, 0, 0] for _ in range(k): g = [0] * 4 g[0] = ((n - 1) * f[1] + (m - 1) * f[2]) % mod g[1] = (f[0] + (n - 2) * f[1] + (m - 1) * f[3]) % mod g[2] = (f[0] + (m - 2) * f[2] + (n - 1) * f[3]) % mod g[3] = (f[1] + f[2] + (n - 2) * f[3] + (m - 2) * f[3]) % mod f = g if source[0] == dest[0]: return f[0] if source[1] == dest[1] else f[2] return f[1] if source[1] == dest[1] else f[3]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2914/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2914/</guid><description>class Solution: def minChanges(self, s: str) -&amp;gt; int: return sum(s[i] != s[i - 1] for i in range(1, len(s), 2))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2915/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2915/</guid><description>class Solution: def lengthOfLongestSubsequence(self, nums: List[int], target: int) -&amp;gt; int: f = [0] + [-inf] * target for x in nums: for j in range(target, x - 1, -1): f[j] = max(f[j], f[j - x] + 1) return -1 if f[-1] &amp;lt;= 0 else f[-1]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2918/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2918/</guid><description>class Solution: def minSum(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: s1 = sum(nums1) + nums1.count(0) s2 = sum(nums2) + nums2.count(0) if s1 &amp;gt; s2: return self.minSum(nums2, nums1) if s1 == s2: return s1 return -1 if nums1.count(0) == 0 else s2</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2920/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2920/</guid><description>class Solution: def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -&amp;gt; int: @cache def dfs(i: int, fa: int, j: int) -&amp;gt; int: a = (coins[i] &amp;gt;&amp;gt; j) - k b = coins[i] &amp;gt;&amp;gt; (j + 1) for c in g[i]: if c != fa: a += dfs(c, i, j) if j &amp;lt; 14: b += dfs(c, i, j + 1) return max(a, b) n = len(coins) g = [[] for _ in range(n)] for a, b in edges: g[a].</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2933/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2933/</guid><description>class Solution: def findHighAccessEmployees(self, access_times: List[List[str]]) -&amp;gt; List[str]: d = defaultdict(list) for name, t in access_times: d[name].append(int(t[:2]) * 60 + int(t[2:])) res = [] for name, ts in d.items(): ts.sort() if any(ts[i] - ts[i - 2] &amp;lt; 60 for i in range(2, len(ts))): res.append(name) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2934/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2934/</guid><description>class Solution: def minOperations(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: def f(x: int, y: int) -&amp;gt; int: cnt = 0 for a, b in zip(nums1[:-1], nums2[:-1]): if a &amp;lt;= x and b &amp;lt;= y: continue if not (a &amp;lt;= y and b &amp;lt;= x): return -1 cnt += 1 return cnt a, b = f(nums1[-1], nums2[-1]), f(nums2[-1], nums1[-1]) return -1 if a + b == -2 else min(a, b + 1)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2944/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2944/</guid><description>class Solution: def minimumCoins(self, prices: List[int]) -&amp;gt; int: n = len(prices) q = deque() for i in range(n, 0, -1): while q and q[0] &amp;gt; i * 2 + 1: q.popleft() if i &amp;lt;= (n - 1) // 2: prices[i - 1] += prices[q[0] - 1] while q and prices[q[-1] - 1] &amp;gt;= prices[i - 1]: q.pop() q.append(i) return prices[0]</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2953/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2953/</guid><description>class Solution: def countCompleteSubstrings(self, word: str, k: int) -&amp;gt; int: def f(s: str) -&amp;gt; int: m = len(s) res = 0 for i in range(1, 27): l = i * k if l &amp;gt; m: break cnt = Counter(s[:l]) freq = Counter(cnt.values()) res += freq[k] == i for j in range(l, m): freq[cnt[s[j]]] -= 1 cnt[s[j]] += 1 freq[cnt[s[j]]] += 1 freq[cnt[s[j - l]]] -= 1 cnt[s[j - l]] -= 1 freq[cnt[s[j - l]]] += 1 res += freq[k] == i return res n = len(word) res = i = 0 while i &amp;lt; n: j = i + 1 while j &amp;lt; n and abs(ord(word[j]) - ord(word[j - 1])) &amp;lt;= 2: j += 1 res += f(word[i:j]) i = j return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2954/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2954/</guid><description>mod = 10**9 + 7 mx = 10**5 fac = [1] * (mx + 1) for i in range(2, mx + 1): fac[i] = fac[i - 1] * i % mod class Solution: def numberOfSequence(self, n: int, sick: List[int]) -&amp;gt; int: nums = [b - a - 1 for a, b in pairwise([-1] + sick + [n])] res = 1 s = sum(nums) res = fac[s] for x in nums: if x: res = res * pow(fac[x], mod - 2, mod) % mod for x in nums[1:-1]: if x &amp;gt; 1: res = res * pow(2, x - 1, mod) % mod return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2979/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2979/</guid><description>class Solution: def mostExpensiveItem(self, primeOne: int, primeTwo: int) -&amp;gt; int: return primeOne * primeTwo - primeOne - primeTwo</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3/</guid><description>class Solution(): def lengthOfLongestSubstring(self, s): max_len = 0 substr = &amp;#39;&amp;#39; for char in s: if char not in substr: substr += char max_len = max(max_len, len(substr)) else: start = substr.index(char) + 1 substr = substr[start:] + char return max_len</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3000/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3000/</guid><description>class Solution: def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -&amp;gt; int: res = mx = 0 for l, w in dimensions: t = l**2 + w**2 if mx &amp;lt; t: mx = t res = l * w elif mx == t: res = max(res, l * w) return res</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3002/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3002/</guid><description>class Solution: def maximumSetSize(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: s1 = set(nums1) s2 = set(nums2) n = len(nums1) a = min(len(s1 - s2), n // 2) b = min(len(s2 - s1), n // 2) return min(a + b + len(s1 &amp;amp; s2), n)</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3018/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3018/</guid><description>class Solution: def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -&amp;gt; int: n = len(nums) f = [[0] * n for _ in range(n)] m = len(queries) for i in range(n): for j in range(n - 1, i - 1, -1): if i: f[i][j] = max( f[i][j], f[i - 1][j] + (nums[i - 1] &amp;gt;= queries[f[i - 1][j]]) ) if j + 1 &amp;lt; n: f[i][j] = max( f[i][j], f[i][j + 1] + (nums[j + 1] &amp;gt;= queries[f[i][j + 1]]) ) if f[i][j] == m: return m return max(f[i][i] + (nums[i] &amp;gt;= queries[f[i][i]]) for i in range(n))</description></item><item><title/><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3026/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3026/</guid><description>class Solution: def maximumSubarraySum(self, nums: List[int], k: int) -&amp;gt; int: res = -inf p = {nums[0]: 0} s, n = 0, len(nums) for i, x in enumerate(nums): s += x if x - k in p: res = max(res, s - p[x - k]) if x + k in p: res = max(res, s - p[x + k]) if i + 1 &amp;lt; n and (nums[i + 1] not in p or p[nums[i + 1]] &amp;gt; s): p[nums[i + 1]] = s return 0 if res == -inf else res</description></item></channel></rss>