<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Карманная книга по Python on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tracks/python-101/</link><description>Recent content in Карманная книга по Python on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Tue, 28 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tracks/python-101/index.xml" rel="self" type="application/rss+xml"/><item><title>Топ 55 вопросов по Python</title><link>https://romankurnovskii.com/ru/tracks/python-101/top-questions/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/top-questions/</guid><description>&lt;blockquote>
&lt;p>В процессе заполнения&lt;/p>&lt;/blockquote>
&lt;p>&lt;mark>&lt;a href="https://romankurnovskii.com/handbooks/python-handbook.pdf">Скачать | PDF&lt;/a>&lt;/mark> &lt;em>обновление 2023/02/17&lt;/em>&lt;/p>
&lt;h2 id="junior">Junior&lt;/h2>
&lt;h3 id="1-что-такое-python-какие-преимущества-использования-python">1. Что такое Python? Какие преимущества использования Python?&lt;/h3>
&lt;p>Python - это высокоуровневый интерпретируемый язык программирования общего назначения. Будучи языком общего назначения, он может быть использован для создания практически любого типа приложений при наличии соответствующих инструментов/библиотек.&lt;/p>
&lt;p>Кроме того, python поддерживает объекты, модули, потоки, обработку исключений и автоматическое управление памятью, что помогает моделировать реальные проблемы и создавать приложения для решения этих проблем.&lt;/p>
&lt;p>&lt;strong>Преимущества использования Python:&lt;/strong>&lt;/p>
&lt;p>Python - это язык программирования общего назначения, который имеет простой, легко изучаемый синтаксис, подчеркивающий удобочитаемость и, следовательно, снижающий затраты на сопровождение программ. Более того, язык способен выполнять сценарии, является полностью открытым и поддерживает пакеты сторонних разработчиков, что способствует модульности и повторному использованию кода.&lt;/p>
&lt;p>Его высокоуровневые структуры данных в сочетании с динамической типизацией и динамическим связыванием привлекают огромное сообщество разработчиков для быстрой разработки и развертывания приложений.&lt;/p>
&lt;h3 id="2-что-такое-динамически-типизированный-язык">2. Что такое динамически типизированный язык?&lt;/h3>
&lt;p>Прежде чем понять, что такое динамически типизированный язык, мы должны узнать, что такое типизация. Типизация относится к проверке типов в языках программирования. В языке с сильной типизацией, таком как Python, &amp;ldquo;1&amp;rdquo; + 2 приведет к ошибке типа, поскольку эти языки не допускают &amp;ldquo;приведения типов&amp;rdquo; (неявного преобразования типов данных). С другой стороны, слабо типизированный язык, такой как JavaScript, просто выведет &amp;ldquo;12&amp;rdquo; в качестве результата.&lt;/p>
&lt;p>Проверка типов может быть выполнена на двух этапах:&lt;/p>
&lt;ol>
&lt;li>Статический - типы данных проверяются перед выполнением.&lt;/li>
&lt;li>Динамический - типы данных проверяются во время выполнения.&lt;/li>
&lt;/ol>
&lt;p>Python - интерпретируемый язык, каждый оператор выполняется построчно, поэтому проверка типов выполняется на лету, во время выполнения. Следовательно, Python является динамически типизированным языком.&lt;/p>
&lt;h3 id="3-что-такое-интерпретируемый-язык">3. Что такое интерпретируемый язык?&lt;/h3>
&lt;p>Интерпретированный язык выполняет свои утверждения построчно. Такие языки, как Python, JavaScript, R, PHP и Ruby, являются яркими примерами интерпретируемых языков. Программы, написанные на интерпретируемом языке, выполняются непосредственно из исходного кода, без промежуточного этапа компиляции.&lt;/p>
&lt;h3 id="4-что-такое-pep-8-и-почему-он-важен">4. Что такое PEP 8 и почему он важен?&lt;/h3>
&lt;p>PEP расшифровывается как Python Enhancement Proposal. PEP - это официальный проектный документ, предоставляющий информацию сообществу Python или описывающий новую функцию для Python или его процессов.&lt;/p>
&lt;p>&lt;a href="https://peps.python.org/pep-0008/">PEP 8&lt;/a> особенно важен, поскольку в нем документированы руководящие принципы стиля для кода Python. Очевидно, что вклад в сообщество разработчиков открытого кода Python требует от вас искреннего и строгого следования этим руководящим принципам стиля.&lt;/p>
&lt;h3 id="5-что-такое-область-видимости-в-python">5. Что такое область видимости в Python?&lt;/h3>
&lt;p>Каждый объект в Python функционирует в пределах области видимости. &lt;strong>Область видимости&lt;/strong> - это блок кода, в котором объект в Python остается актуальным. Пространства имен однозначно идентифицируют все объекты внутри программы.&lt;/p>
&lt;p>В Python существует &lt;strong>3 области видимости&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>Локальная&lt;/li>
&lt;li>Глобальная&lt;/li>
&lt;li>Нелокальная&lt;/li>
&lt;/ol>
&lt;p>Однако эти пространства имен также имеют область видимости, определенную для них, где вы можете использовать их объекты без префикса. Ниже приведено несколько примеров областей видимости, создаваемых во время выполнения кода в Python:&lt;/p>
&lt;p>&lt;strong>Локальная область видимости&lt;/strong> относится к локальным объектам, доступным в текущей функции.&lt;/p>
&lt;p>Локальная область видимости - определенная внутри функции, метода или выражения. Переменные, определенные внутри этой области, недоступны за ее пределами.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">my_func&lt;/span>(a, b):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(z)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span>my_func(&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Traceback (most recent call last):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &lt;span style="color:#4070a0">&amp;#34;&amp;lt;pyshell#19&amp;gt;&amp;#34;&lt;/span>, line &lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>module&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> my_func(&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &lt;span style="color:#4070a0">&amp;#34;&amp;lt;pyshell#18&amp;gt;&amp;#34;&lt;/span>, line &lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#007020;font-weight:bold">in&lt;/span> my_func
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(z)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">NameError&lt;/span>: name &lt;span style="color:#4070a0">&amp;#39;z&amp;#39;&lt;/span> &lt;span style="color:#007020;font-weight:bold">is&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> defined
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Глобальная область видимости&lt;/strong> относится к объектам, доступным во время выполнения кода с момента их создания.&lt;/p>
&lt;p>Глобальная область видимости - определенная вне функций, методов и выражений. Переменные, определенные в глобальной области видимости, доступны везде в коде.&lt;/p>
&lt;p>Область видимости на уровне модуля относится к глобальным объектам текущего модуля, доступным в программе.&lt;/p>
&lt;p>Глобальная область видимости относится ко всем встроенным именам, вызываемым в программе. Объекты в этой области видимости ищутся в последнюю очередь, чтобы найти имя, на которое ссылаются.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">my_func&lt;/span>(a, b):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">global&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">if&lt;/span> __name__ &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> my_func(&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#40a070">5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>🎾 &lt;strong>Примечание:&lt;/strong> Объекты локальной области видимости могут быть синхронизированы с объектами глобальной области видимости с помощью таких ключевых слов, как &lt;strong>global&lt;/strong>.&lt;/p>
&lt;p>В Python 3 было добавлено новое ключевое слово под названием &lt;code>nonlocal&lt;/code>. С его помощью мы можем добавлять переопределение области во внутреннюю область. Вы можете ознакомиться со всей необходимой на данный счет информацией в PEP 3104. Это наглядно демонстрируется в нескольких примерах. Один из самых простых – это создание функции, которая может увеличиваться:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">counter&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">incrementer&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> incrementer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Если вы попробуете запустить этот код, вы получите ошибку UnboundLocalError, так как переменная num ссылается прежде, чем она будет назначена в самой внутренней функции. Давайте добавим nonlocal в наш код:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">counter&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">incrementer&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">nonlocal&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> incrementer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c &lt;span style="color:#666">=&lt;/span> counter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(c) &lt;span style="color:#60a0b0;font-style:italic"># &amp;lt;function counter.&amp;lt;locals&amp;gt;.incrementer at 0x7f45caf44048&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c() &lt;span style="color:#60a0b0;font-style:italic"># 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c() &lt;span style="color:#60a0b0;font-style:italic"># 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c() &lt;span style="color:#60a0b0;font-style:italic"># 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="6-что-такое-списки-и-кортежи-в-чем-ключевое-различие-между-ними">6. Что такое списки и кортежи? В чем ключевое различие между ними?&lt;/h3>
&lt;p>Списки и кортежи - это типы данных последовательности, которые могут хранить коллекцию объектов в Python. Объекты, хранящиеся в обеих последовательностях, могут иметь различные типы данных. Списки представлены квадратными скобками &lt;code>['sara', 6, 0.19]&lt;/code>, а кортежи - круглыми &lt;code>('ansh', 5, 0.97)&lt;/code>.&lt;/p>
&lt;p>Но в чем реальная разница между ними? Ключевое различие между ними заключается в том, что списки являются изменяемыми, а кортежи, напротив, неизменяемыми объектами. Это означает, что списки можно изменять, добавлять или нарезать на ходу, а кортежи остаются неизменными и не могут быть изменены никаким образом. Вы можете выполнить следующий пример, чтобы убедиться в разнице:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>my_tuple &lt;span style="color:#666">=&lt;/span> (&lt;span style="color:#4070a0">&amp;#39;sara&amp;#39;&lt;/span>, &lt;span style="color:#40a070">6&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>, &lt;span style="color:#40a070">0.97&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>my_list &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#4070a0">&amp;#39;sara&amp;#39;&lt;/span>, &lt;span style="color:#40a070">6&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>, &lt;span style="color:#40a070">0.97&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(my_tuple[&lt;span style="color:#40a070">0&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; &amp;#39;sara&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(my_list[&lt;span style="color:#40a070">0&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; &amp;#39;sara&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>my_tuple[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;ansh&amp;#39;&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># modifying tuple =&amp;gt; throws an error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>my_list[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;ansh&amp;#39;&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># modifying list =&amp;gt; list modified&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(my_tuple[&lt;span style="color:#40a070">0&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; &amp;#39;sara&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(my_list[&lt;span style="color:#40a070">0&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; &amp;#39;ansh&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="7-каковы-общие-встроенные-типы-данных-в-python">7. Каковы общие встроенные типы данных в Python?&lt;/h3>
&lt;p>В Python существует несколько встроенных типов данных. Хотя Python не требует явного определения типов данных при объявлении переменных, ошибки могут возникнуть, если пренебречь знанием типов данных и их совместимости друг с другом. Python предоставляет функции type() и isinstance() для проверки типа этих переменных. Эти типы данных можно сгруппировать в следующие категории-&lt;/p>
&lt;p>&lt;strong>Тип None:&lt;/strong>&lt;/p>
&lt;p>Ключевое слово &lt;strong>None&lt;/strong> представляет нулевые значения в Python. Операция булева равенства может быть выполнена с использованием этих объектов &lt;strong>NoneType&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>NoneType&lt;/strong> Представляет значения &lt;code>NULL&lt;/code> в Python.&lt;/p>
&lt;p>&lt;strong>Числовые типы:&lt;/strong>&lt;/p>
&lt;p>Существует три различных числовых типа - целые числа (integers), числа с плавающей точкой (floating-point) и комплексные числа(complex numbers). Кроме того, булевы числа являются подтипом целых чисел.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>int&lt;/strong> Хранит целочисленные литералы, включая шестнадцатеричные, восьмеричные и двоичные числа, как целые числа&lt;/li>
&lt;li>&lt;strong>float&lt;/strong> Хранит литералы, содержащие десятичные значения и/или знаки экспоненты, как числа с плавающей точкой&lt;/li>
&lt;li>&lt;strong>complex&lt;/strong> Хранит комплексные числа в виде &lt;code>(A + Bj)&lt;/code> и имеет атрибуты: real и imag&lt;/li>
&lt;li>&lt;strong>bool&lt;/strong> Хранит булево значение (True или False).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Типы последовательностей:&lt;/strong>&lt;/p>
&lt;p>Согласно Python Docs, существует три основных типа последовательностей - списки (lists), кортежи (tuples) и объекты диапазона (range objects). Типы последовательностей имеют операторы &lt;code>in&lt;/code> и &lt;code>not in&lt;/code>, определенные для обхода их элементов. Эти операторы имеют тот же приоритет, что и операции сравнения.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>list&lt;/strong> Неизменяемая последовательность, используемая для хранения коллекции элементов.&lt;/li>
&lt;li>&lt;strong>tuple&lt;/strong> Неизменяемая последовательность, используемая для хранения коллекции элементов.&lt;/li>
&lt;li>&lt;strong>range&lt;/strong> Представляет собой неизменяемую последовательность чисел, генерируемую во время выполнения.&lt;/li>
&lt;li>&lt;strong>str&lt;/strong> Неизменяемая последовательность кодовых точек Unicode для хранения текстовых данных.&lt;/li>
&lt;/ul>
&lt;p>Стандартная библиотека также включает дополнительные типы для обработки:&lt;/p>
&lt;ol>
&lt;li>Двоичные данные&lt;/li>
&lt;li>Текстовые строки, такие как &lt;code>str&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Тип словарь (dict):&lt;/strong>&lt;/p>
&lt;p>Объект отображения может отображать хэшируемые значения на произвольные объекты в Python. Объекты отображения являются изменяемыми, и в настоящее время существует только один стандартный тип отображения - &lt;strong>dict&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>dict&lt;/strong> Хранит список пар ключ: значение, разделенных запятыми.&lt;/li>
&lt;/ul>
&lt;p>Типы множеств:&lt;/p>
&lt;p>В настоящее время в Python есть два встроенных типа множеств - &lt;strong>set&lt;/strong> и &lt;strong>frozenset&lt;/strong>.&lt;/p>
&lt;p>Тип &lt;strong>set&lt;/strong> является изменяемым и поддерживает такие методы, как &lt;code>add()&lt;/code> и &lt;code>remove()&lt;/code>.&lt;/p>
&lt;p>Тип &lt;strong>frozenset&lt;/strong> является неизменяемым и не может быть изменен после создания.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>set&lt;/strong> Мутабельная неупорядоченная коллекция отдельных хэшируемых объектов.&lt;/li>
&lt;li>&lt;strong>frozenset&lt;/strong> Неизменяемая коллекция отдельных хэшируемых объектов.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>set&lt;/strong> является изменяемым и поэтому не может быть использован в качестве ключа словаря. С другой стороны, &lt;strong>frozenset&lt;/strong> является неизменяемым и, следовательно, хэшируемым, и может использоваться как ключ словаря или как элемент другого множества.&lt;/p>
&lt;p>&lt;strong>Модули:&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Module&lt;/strong> - это дополнительный встроенный тип, поддерживаемый интерпретатором Python. Он поддерживает одну специальную операцию, т.е. доступ к атрибуту: &lt;code>mymod.myobj&lt;/code>, где &lt;code>mymod&lt;/code> - модуль, а &lt;code>myobj&lt;/code> ссылается на имя, определенное в модуле.&lt;/p>
&lt;p>Таблица символов модуля находится в специальном атрибуте модуля &lt;strong>dict&lt;/strong>, но прямое присвоение этому модулю невозможно и не рекомендуется.&lt;/p>
&lt;p>&lt;strong>Типы Callable:&lt;/strong>&lt;/p>
&lt;p>Callable типы - это типы, к которым может быть применен вызов функции. Это могут быть определяемые пользователем функции, методы экземпляра, функции генератора и некоторые другие встроенные функции, методы и классы.&lt;/p>
&lt;h3 id="8-что-такое-pass-в-python">8. Что такое pass в Python?&lt;/h3>
&lt;p>Ключевое слово &lt;strong>pass&lt;/strong> представляет собой нулевую операцию в Python. Обычно оно используется для заполнения пустых блоков кода, который может выполняться во время исполнения, но еще не написан. Без оператора &lt;strong>pass&lt;/strong> в следующем коде мы можем столкнуться с некоторыми ошибками во время выполнения кода.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">myEmptyFunc&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># do nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>myEmptyFunc() &lt;span style="color:#60a0b0;font-style:italic"># nothing happens&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">## Without the pass keyword&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># IndentationError: expected an indented block&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="9-что-такое-модули-и-пакеты-в-python">9. Что такое модули и пакеты в Python?&lt;/h3>
&lt;p>Пакеты Python и модули Python - это два механизма, которые позволяют осуществлять модульное программирование в Python. Модулирование имеет несколько преимуществ:&lt;/p>
&lt;ul>
&lt;li>Простота: Работа над одним модулем помогает сосредоточиться на относительно небольшой части решаемой задачи. Это делает разработку более простой и менее подверженной ошибкам.&lt;/li>
&lt;li>Удобство обслуживания: Модули предназначены для обеспечения логических границ между различными проблемными областями. Если они написаны таким образом, что уменьшают взаимозависимость, то меньше вероятность того, что изменения в модуле могут повлиять на другие части программы.&lt;/li>
&lt;li>Возможность повторного использования: Функции, определенные в модуле, могут быть легко использованы повторно в других частях приложения.&lt;/li>
&lt;li>Разметка: Модули обычно определяют отдельное пространство имен, что помогает избежать путаницы между идентификаторами из других частей программы.&lt;/li>
&lt;/ul>
&lt;p>Модули, в общем случае, это просто файлы Python с расширением &lt;code>.py&lt;/code>, в которых может быть определен и реализован набор функций, классов или переменных. Они могут быть импортированы и инициализированы один раз с помощью оператора &lt;code>import&lt;/code>. Если требуется частичная функциональность, импортируйте необходимые классы или функции с помощью оператора &lt;code>import&lt;/code>: &lt;code>from foo import bar&lt;/code>.&lt;/p>
&lt;p>Пакеты позволяют иерархически структурировать пространство имен модуля с помощью точечной нотации. Как модули помогают избежать столкновений между именами глобальных переменных, так и пакеты помогают избежать столкновений между именами модулей.&lt;/p>
&lt;p>Создать пакет очень просто, поскольку он использует присущую системе файловую структуру. Просто поместите модули в папку, и вот оно, имя папки как имя пакета. Для импорта модуля или его содержимого из этого пакета требуется, чтобы имя пакета было префиксом к имени модуля, соединенным точкой.&lt;/p>
&lt;p>Примечание: технически вы можете импортировать и пакет, но, увы, это не импортирует модули внутри пакета в локальное пространство имен.&lt;/p>
&lt;h3 id="10-что-такое-глобальные-защищенные-и-приватные-атрибуты-в-python">10. Что такое глобальные, защищенные и приватные атрибуты в Python?&lt;/h3>
&lt;p>&lt;strong>Глобальные переменные&lt;/strong>- это общедоступные переменные, которые определены в глобальной области видимости. Чтобы использовать переменную в глобальной области видимости внутри функции, мы используем ключевое слово &lt;strong>global&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>Защищенные атрибуты&lt;/strong> (Protected attributes) - это атрибуты, определенные с префиксом подчеркивания к их идентификатору, например, &lt;code>_sara&lt;/code>. К ним все еще можно получить доступ и изменить их извне класса, в котором они определены, но ответственный разработчик должен воздержаться от этого.&lt;/p>
&lt;p>&lt;strong>Приватные атрибуты&lt;/strong> (Private attributes) - это атрибуты с двойным подчеркиванием в префиксе к их идентификатору, например __ansh. Они не могут быть доступны или изменены извне напрямую, и при такой попытке будет выдана ошибка &lt;code>AttributeError&lt;/code>.&lt;/p>
&lt;h3 id="11-как-используется-self-в-python">11. Как используется self в Python?&lt;/h3>
&lt;p>&lt;code>self&lt;/code> используется для представления экземпляра класса. С помощью этого ключевого слова вы можете получить доступ к атрибутам и методам класса в python.&lt;/p>
&lt;p>&lt;code>self&lt;/code> связывает атрибуты с заданными аргументами. &lt;code>self&lt;/code> используется в разных местах и часто считается ключевым словом. Но в отличие от C++, &lt;code>self&lt;/code> не является ключевым словом в Python.&lt;/p>
&lt;h3 id="12-что-такое-init">12. Что такое &lt;strong>init&lt;/strong>?&lt;/h3>
&lt;p>&lt;strong>init&lt;/strong> - это метод-конструктор в Python, который автоматически вызывается для выделения памяти при создании нового объекта/экземпляра. Все классы имеют метод &lt;strong>init&lt;/strong>, связанный с ними. Он помогает отличить методы и атрибуты класса от локальных переменных.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class definition&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Student&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, fname, lname, age, section):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>firstname &lt;span style="color:#666">=&lt;/span> fname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>lastname &lt;span style="color:#666">=&lt;/span> lname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>age &lt;span style="color:#666">=&lt;/span> age
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>section &lt;span style="color:#666">=&lt;/span> section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># creating a new object&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stu1 &lt;span style="color:#666">=&lt;/span> Student(&lt;span style="color:#4070a0">&amp;#34;Sara&amp;#34;&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;Ansh&amp;#34;&lt;/span>, &lt;span style="color:#40a070">22&lt;/span>, &lt;span style="color:#4070a0">&amp;#34;A2&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-что-такое-break-continue-и-pass-в-python">13. Что такое break, continue и pass в Python?&lt;/h3>
&lt;p>Оператор &lt;strong>break&lt;/strong> немедленно завершает цикл, а управление переходит к оператору после тела цикла.&lt;/p>
&lt;p>Оператор &lt;strong>continue&lt;/strong> завершает текущую итерацию оператора, пропускает остальной код в текущей итерации, а управление переходит к следующей итерации цикла.&lt;/p>
&lt;p>Ключевое слово &lt;strong>pass&lt;/strong> в Python обычно используется для заполнения пустых блоков и аналогично пустому утверждению, представленному точкой с запятой в таких языках, как Java, C++, Javascript и т.д.&lt;/p>
&lt;h3 id="14-что-такое-модульные-тесты-в-python">14. Что такое модульные тесты в Python?&lt;/h3>
&lt;p>Юнит-тесты - это структура модульного тестирования в Python.&lt;/p>
&lt;p>Юнит-тестирование означает тестирование различных компонентов программного обеспечения по отдельности. Можете ли вы подумать о том, почему модульное тестирование важно? Представьте себе сценарий: вы создаете программное обеспечение, которое использует три компонента, а именно A, B и C. Теперь предположим, что в какой-то момент ваше программное обеспечение ломается. Как вы определите, какой компонент был ответственен за поломку программы? Может быть, это компонент A вышел из строя, который, в свою очередь, вышел из строя компонент B, что и привело к поломке программного обеспечения. Таких комбинаций может быть множество.&lt;/p>
&lt;p>Вот почему необходимо должным образом протестировать каждый компонент, чтобы знать, какой компонент может быть ответственен за сбой программного обеспечения.&lt;/p>
&lt;h3 id="15-что-такое-docstring-в-python">15. Что такое docstring в Python?&lt;/h3>
&lt;p>docstring - это многострочная строка, используемая для документирования определенного участка кода.&lt;/p>
&lt;p>В &lt;code>docstring&lt;/code> должно быть описано, что делает функция или метод.&lt;/p>
&lt;h3 id="16--что-такое-срез-в-python">16. Что такое срез в Python?&lt;/h3>
&lt;p>Как следует из названия, &amp;ldquo;срез&amp;rdquo; - это взятие частей.&lt;/p>
&lt;p>Синтаксис следующий [start : stop : step].&lt;/p>
&lt;ul>
&lt;li>start - начальный индекс, с которого производится нарезка списка или кортежа&lt;/li>
&lt;li>stop - конечный индекс или место нарезки.&lt;/li>
&lt;li>step - количество шагов для перехода.&lt;/li>
&lt;/ul>
&lt;p>Значение по умолчанию для start - 0, stop - количество элементов, step - 1.&lt;/p>
&lt;p>Срезы можно выполнять для строк, массивов, списков и кортежей.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>numbers &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">4&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>, &lt;span style="color:#40a070">6&lt;/span>, &lt;span style="color:#40a070">7&lt;/span>, &lt;span style="color:#40a070">8&lt;/span>, &lt;span style="color:#40a070">9&lt;/span>, &lt;span style="color:#40a070">10&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(numbers[&lt;span style="color:#40a070">1&lt;/span> : : &lt;span style="color:#40a070">2&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic">#output : [2, 4, 6, 8, 10]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="17--объясните-как-можно-сделать-python-script-исполняемым-на-unix">17. Объясните, как можно сделать Python Script исполняемым на Unix?&lt;/h3>
&lt;p>Файл сценария должен начинаться с #!/usr/bin/env python&lt;/p>
&lt;h3 id="18--в-чем-разница-между-массивами-и-списками-в-python">18. В чем разница между массивами и списками в Python?&lt;/h3>
&lt;p>Массивы в python могут содержать элементы только одного типа данных, т.е. тип данных массива должен быть однородным. Это тонкая обертка вокруг массивов языка C, и они потребляют гораздо меньше памяти, чем списки.&lt;/p>
&lt;p>Списки в python могут содержать элементы разных типов данных, то есть тип данных списков может быть неоднородным. Их недостатком является потребление большого объема памяти.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">array&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#666">=&lt;/span> array&lt;span style="color:#666">.&lt;/span>array(&lt;span style="color:#4070a0">&amp;#39;i&amp;#39;&lt;/span>, [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> a:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(i, end&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#39; &amp;#39;&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic">#OUTPUT: 1 2 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#666">=&lt;/span> array&lt;span style="color:#666">.&lt;/span>array(&lt;span style="color:#4070a0">&amp;#39;i&amp;#39;&lt;/span>, [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;string&amp;#39;&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic">#OUTPUT: TypeError: an integer is required (got type str)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;string&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> a:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(i, end&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#39; &amp;#39;&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic">#OUTPUT: 1 2 string&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="middle--senior">Middle / Senior&lt;/h2>
&lt;h3 id="19-как-осуществляется-управление-памятью-в-python">19. Как осуществляется управление памятью в Python?&lt;/h3>
&lt;p>Управление памятью в Python осуществляется менеджером памяти Python. Память, выделяемая менеджером, представляет собой частное пространство кучи, предназначенное для Python. Все объекты Python хранятся в этой куче, и, будучи частной, она недоступна программисту. Тем не менее, Python предоставляет некоторые основные функции API для работы с частным пространством кучи.&lt;/p>
&lt;p>Кроме того, Python имеет встроенную сборку мусора для утилизации неиспользуемой памяти для частного пространства кучи.&lt;/p>
&lt;h3 id="20-что-такое-пространства-имен-python-зачем-они-используются">20. Что такое пространства имен Python? Зачем они используются?&lt;/h3>
&lt;p>Пространство имен в Python гарантирует, что имена объектов в программе уникальны и могут использоваться без каких-либо конфликтов. Python реализует эти пространства имен в виде словарей, в которых &amp;ldquo;имя как ключ&amp;rdquo; сопоставлено с соответствующим &amp;ldquo;объектом как значением&amp;rdquo;. Это позволяет нескольким пространствам имен использовать одно и то же имя и сопоставлять его с отдельным объектом. Ниже приведены несколько примеров пространств имен:&lt;/p>
&lt;p>Локальное пространство имен включает локальные имена внутри функции. Пространство имен временно создается для вызова функции и очищается после возвращения функции.&lt;/p>
&lt;p>Глобальное пространство имен включает имена из различных импортированных пакетов/модулей, которые используются в текущем проекте. Это пространство имен создается при импорте пакета в скрипт и сохраняется до выполнения скрипта.&lt;/p>
&lt;p>Встроенное пространство имен включает встроенные функции ядра Python и встроенные имена для различных типов исключений.&lt;/p>
&lt;p>Жизненный цикл пространства имен зависит от области видимости объектов, с которыми они сопоставлены. Если область видимости объекта заканчивается, жизненный цикл этого пространства имен завершается. Следовательно, невозможно получить доступ к объектам внутреннего пространства имен из внешнего пространства имен.&lt;/p>
&lt;h3 id="21-что-такое-разрешение-области-видимости-в-python">21. Что такое разрешение области видимости в Python?&lt;/h3>
&lt;p>Иногда объекты в одной области видимости имеют одинаковые имена, но функционируют по-разному. В таких случаях разрешение области видимости в Python происходит автоматически. Вот несколько примеров такого поведения:&lt;/p>
&lt;p>Модули Python &amp;lsquo;math&amp;rsquo; и &amp;lsquo;cmath&amp;rsquo; имеют множество функций, общих для обоих - log10(), acos(), exp() и т.д. Чтобы разрешить эту двусмысленность, необходимо снабдить их префиксом соответствующего модуля, например, math.exp() и cmath.exp().&lt;/p>
&lt;p>Рассмотрим приведенный ниже код, объект temp был инициализирован на 10 глобально и затем на 20 при вызове функции. Однако вызов функции не изменил значение temp глобально. Здесь мы можем заметить, что Python проводит четкую границу между глобальными и локальными переменными, рассматривая их пространства имен как отдельные личности.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>temp &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">10&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># global-scope variable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">func&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">20&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># local-scope variable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(temp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(temp) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(temp) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Это поведение может быть переопределено с помощью ключевого слова global внутри функции, как показано в следующем примере:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>temp &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">10&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># global-scope variable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">func&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">global&lt;/span> temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">20&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># local-scope variable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(temp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(temp) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(temp) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22-что-такое-декораторы-в-python">22. Что такое декораторы в Python?&lt;/h3>
&lt;p>Декораторы в Python - это, по сути, функции, которые добавляют функциональность к существующей функции в Python без изменения структуры самой функции. В Python они обозначаются @decorator_name и вызываются по принципу &amp;ldquo;снизу вверх&amp;rdquo;. Например:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># decorator function to convert to lowercase&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">lowercase_decorator&lt;/span>(function):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">wrapper&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func &lt;span style="color:#666">=&lt;/span> function()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string_lowercase &lt;span style="color:#666">=&lt;/span> func&lt;span style="color:#666">.&lt;/span>lower()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> string_lowercase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> wrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># decorator function to split words&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">splitter_decorator&lt;/span>(function):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">wrapper&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func &lt;span style="color:#666">=&lt;/span> function()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string_split &lt;span style="color:#666">=&lt;/span> func&lt;span style="color:#666">.&lt;/span>split()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> string_split
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> wrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#555;font-weight:bold">@splitter_decorator&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># this is executed next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#555;font-weight:bold">@lowercase_decorator&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># this is executed first&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">hello&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#39;Hello World&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [ &amp;#39;hello&amp;#39; , &amp;#39;world&amp;#39; ]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Прелесть декораторов заключается в том, что помимо добавления функциональности к выходу метода, они могут даже принимать аргументы для функций и дополнительно модифицировать эти аргументы перед передачей в саму функцию. Внутренняя вложенная функция, то есть функция-&amp;ldquo;обертка&amp;rdquo;, играет здесь важную роль. Она реализуется для обеспечения инкапсуляции и, таким образом, скрывает себя от глобальной области видимости.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># decorator function to capitalize names&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">names_decorator&lt;/span>(function):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">wrapper&lt;/span>(arg1, arg2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arg1 &lt;span style="color:#666">=&lt;/span> arg1&lt;span style="color:#666">.&lt;/span>capitalize()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arg2 &lt;span style="color:#666">=&lt;/span> arg2&lt;span style="color:#666">.&lt;/span>capitalize()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string_hello &lt;span style="color:#666">=&lt;/span> function(arg1, arg2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> string_hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> wrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#555;font-weight:bold">@names_decorator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">say_hello&lt;/span>(name1, name2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#39;Hello &amp;#39;&lt;/span> &lt;span style="color:#666">+&lt;/span> name1 &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#39;! Hello &amp;#39;&lt;/span> &lt;span style="color:#666">+&lt;/span> name2 &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#39;!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>say_hello(&lt;span style="color:#4070a0">&amp;#39;sara&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;ansh&amp;#39;&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; &amp;#39;Hello Sara! Hello Ansh!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="23-что-такое-comprehensions-dict-и-list">23. Что такое comprehensions Dict и List?&lt;/h3>
&lt;p>Python comprehensions, как и декораторы, - это синтаксический сахар, который помогает строить измененные и отфильтрованные списки, словари или множества из заданного списка, словаря или множества. Использование понятий позволяет сэкономить много времени и сэкономить код, который мог бы быть значительно более многословным (содержать больше строк кода). Давайте рассмотрим несколько примеров, в которых понимания могут быть действительно полезны:&lt;/p>
&lt;p>Словарные (Dict) comprehension используют фигурные скобки и позволяют создавать новые словари на основе уже существующих.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>new_dict &lt;span style="color:#666">=&lt;/span> {key: value &lt;span style="color:#007020;font-weight:bold">for&lt;/span> key, value &lt;span style="color:#007020;font-weight:bold">in&lt;/span> old_dict&lt;span style="color:#666">.&lt;/span>items() &lt;span style="color:#007020;font-weight:bold">if&lt;/span> value &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">2&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Выполнение математических операций над всем списком&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>my_list &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>, &lt;span style="color:#40a070">7&lt;/span>, &lt;span style="color:#40a070">11&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>squared_list &lt;span style="color:#666">=&lt;/span> [x&lt;span style="color:#666">**&lt;/span>&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> my_list] &lt;span style="color:#60a0b0;font-style:italic"># list comprehension&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [4 , 9 , 25 , 49 , 121]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>squared_dict &lt;span style="color:#666">=&lt;/span> {x:x&lt;span style="color:#666">**&lt;/span>&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> my_list} &lt;span style="color:#60a0b0;font-style:italic"># dict comprehension&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Выполнение операций условной фильтрации для всего списка&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>my_list &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>, &lt;span style="color:#40a070">7&lt;/span>, &lt;span style="color:#40a070">11&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>squared_list &lt;span style="color:#666">=&lt;/span> [x&lt;span style="color:#666">**&lt;/span>&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> my_list &lt;span style="color:#007020;font-weight:bold">if&lt;/span> x&lt;span style="color:#666">%&lt;/span>&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#60a0b0;font-style:italic"># list comprehension&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [9 , 25 , 49 , 121]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>squared_dict &lt;span style="color:#666">=&lt;/span> {x:x&lt;span style="color:#666">**&lt;/span>&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> my_list &lt;span style="color:#007020;font-weight:bold">if&lt;/span> x&lt;span style="color:#666">%&lt;/span>&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>} &lt;span style="color:#60a0b0;font-style:italic"># dict comprehension&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; {11: 121, 3: 9 , 5: 25 , 7: 49}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Объединение нескольких списков в один&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">7&lt;/span>, &lt;span style="color:#40a070">8&lt;/span>, &lt;span style="color:#40a070">9&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[(x &lt;span style="color:#666">+&lt;/span> y) &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (x,y) &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">zip&lt;/span>(a,b)] &lt;span style="color:#60a0b0;font-style:italic"># parallel iterators&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [8, 10, 12]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[(x,y) &lt;span style="color:#007020;font-weight:bold">for&lt;/span> x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> a &lt;span style="color:#007020;font-weight:bold">for&lt;/span> y &lt;span style="color:#007020;font-weight:bold">in&lt;/span> b] &lt;span style="color:#60a0b0;font-style:italic"># nested iterators&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Преобразование многомерного массива в одномерный&lt;/p>
&lt;p>Аналогичный подход вложенных итераторов (как описано выше) может быть применен для сглаживания многомерного списка или работы с его внутренними элементами.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>my_list &lt;span style="color:#666">=&lt;/span> [[&lt;span style="color:#40a070">10&lt;/span>,&lt;span style="color:#40a070">20&lt;/span>,&lt;span style="color:#40a070">30&lt;/span>],[&lt;span style="color:#40a070">40&lt;/span>,&lt;span style="color:#40a070">50&lt;/span>,&lt;span style="color:#40a070">60&lt;/span>],[&lt;span style="color:#40a070">70&lt;/span>,&lt;span style="color:#40a070">80&lt;/span>,&lt;span style="color:#40a070">90&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flattened &lt;span style="color:#666">=&lt;/span> [x &lt;span style="color:#007020;font-weight:bold">for&lt;/span> temp &lt;span style="color:#007020;font-weight:bold">in&lt;/span> my_list &lt;span style="color:#007020;font-weight:bold">for&lt;/span> x &lt;span style="color:#007020;font-weight:bold">in&lt;/span> temp]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [10, 20, 30, 40, 50, 60, 70, 80, 90]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Примечание: генератор списков имеет тот же эффект, что и метод map в других языках. Они используют математическую нотацию построителя множеств, а не функции &lt;code>map&lt;/code> и &lt;code>filter&lt;/code> в Python.&lt;/p>
&lt;h3 id="24-что-такое-лямбда-в-python-почему-это-используется">24. Что такое лямбда в Python? Почему это используется?&lt;/h3>
&lt;p>Лямбда - это анонимная функция в Python, которая может принимать любое количество аргументов, но может иметь только одно выражение. Обычно она используется в ситуациях, когда требуется анонимная функция на короткий промежуток времени. Лямбда-функции можно использовать одним из двух способов:&lt;/p>
&lt;p>Присвоение лямбда-функций переменной:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>mul &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">lambda&lt;/span> a, b : a &lt;span style="color:#666">*&lt;/span> b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(mul(&lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>)) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Обертывание лямбда-функций внутри другой функции:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">myWrapper&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">lambda&lt;/span> a : a &lt;span style="color:#666">*&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mulFive &lt;span style="color:#666">=&lt;/span> myWrapper(&lt;span style="color:#40a070">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(mulFive(&lt;span style="color:#40a070">2&lt;/span>)) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="25-как-скопировать-объект-в-python">25. Как скопировать объект в Python?&lt;/h3>
&lt;p>В Python оператор присваивания (&lt;code>=&lt;/code>) не копирует объекты. Вместо этого он создает связь(ссылку) между существующим объектом и именем целевой переменной. Чтобы создать копии объекта в Python, необходимо использовать модуль &lt;code>copy&lt;/code>. Существует два способа создания копий для данного объекта с помощью модуля &lt;code>copy&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Shallow Copy&lt;/strong> - это побитовая копия объекта. Созданный скопированный объект имеет точную копию значений в исходном объекте. Если одно из значений является ссылкой на другие объекты, копируются только адреса ссылок на них.&lt;/p>
&lt;p>&lt;strong>Глубокое копирование&lt;/strong> рекурсивно копирует все значения от исходного объекта к целевому, т.е. дублирует даже объекты, на которые ссылается исходный объект.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">copy&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> copy, deepcopy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_1 &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, [&lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>], &lt;span style="color:#40a070">4&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">## shallow copy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_2 &lt;span style="color:#666">=&lt;/span> copy(list_1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_2[&lt;span style="color:#40a070">3&lt;/span>] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_2[&lt;span style="color:#40a070">2&lt;/span>]&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#40a070">6&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_2 &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [1, 2, [3, 5, 6], 7]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_1 &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [1, 2, [3, 5, 6], 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">## deep copy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_3 &lt;span style="color:#666">=&lt;/span> deepcopy(list_1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_3[&lt;span style="color:#40a070">3&lt;/span>] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_3[&lt;span style="color:#40a070">2&lt;/span>]&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#40a070">7&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_3 &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [1, 2, [3, 5, 6, 7], 8]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list_1 &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; [1, 2, [3, 5, 6], 4]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="26-в-чем-разница-между-xrange-и-range-в-python">26. В чем разница между xrange и range в Python?&lt;/h3>
&lt;p>&lt;code>xrange()&lt;/code> и &lt;code>range()&lt;/code> довольно похожи по функциональности. Они оба генерируют последовательность целых чисел, с той лишь разницей, что &lt;code>range()&lt;/code> возвращает список Python, тогда как &lt;code>xrange()&lt;/code> возвращает объект &lt;code>xrange&lt;/code>.&lt;/p>
&lt;p>В отличие от &lt;code>range()&lt;/code>, &lt;code>xrange()&lt;/code> не генерирует статический список, а создает значение на ходу. Эта техника обычно используется с генератором объектного типа и называется &amp;ldquo;&lt;strong>yielding&lt;/strong>&amp;rdquo;.&lt;/p>
&lt;p>Выдача очень важна в приложениях, где память ограничена. Создание статического списка, как в &lt;code>range()&lt;/code>, может привести к ошибке памяти в таких условиях, в то время как &lt;code>xrange()&lt;/code> может справиться с этим оптимально, используя только достаточное количество памяти для генератора (значительно меньше по сравнению с другими).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> xrange(&lt;span style="color:#40a070">10&lt;/span>): &lt;span style="color:#60a0b0;font-style:italic"># numbers from o to 9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span> i &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 0 1 2 3 4 5 6 7 8 9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> xrange(&lt;span style="color:#40a070">1&lt;/span>,&lt;span style="color:#40a070">10&lt;/span>): &lt;span style="color:#60a0b0;font-style:italic"># numbers from 1 to 9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span> i &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 1 2 3 4 5 6 7 8 9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> xrange(&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">10&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>): &lt;span style="color:#60a0b0;font-style:italic"># skip by two for next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span> i &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 1 3 5 7 9&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Примечание: &lt;code>xrange&lt;/code> была устаревшей начиная с Python 3.x. Теперь &lt;code>range&lt;/code> делает то же самое, что делала &lt;code>xrange&lt;/code> в Python 2.x, поскольку в Python 2.x было гораздо лучше использовать &lt;code>xrange()&lt;/code>, чем оригинальную функцию &lt;code>range()&lt;/code>.&lt;/p>
&lt;h3 id="27-что-такое-pickling-и-unpickling">27. Что такое &lt;code>pickling&lt;/code> и &lt;code>unpickling&lt;/code>?&lt;/h3>
&lt;p>Библиотека Python предлагает &lt;strong>функцию сериализации&lt;/strong> из коробки. Сериализация объекта означает преобразование его в формат, который можно хранить, чтобы впоследствии можно было десериализовать его и получить исходный объект.&lt;/p>
&lt;p>&lt;strong>Pickling&lt;/strong> - это название процесса сериализации в Python. Любой объект в Python может быть сериализован в поток байтов и выгружен в память в виде файла. Процесс &lt;code>pickling&lt;/code> компактен, но объекты &lt;code>pickle&lt;/code> могут быть сжаты еще больше. &lt;code>pickle&lt;/code> отслеживает объекты, которые он сериализовал, и сериализация переносима между версиями.&lt;/p>
&lt;p>Для этого процесса используется функция &lt;code>pickle.dump()&lt;/code>.&lt;/p>
&lt;p>Распаковка (&lt;strong>Unpickling&lt;/strong>) - является полной противоположностью &lt;code>pickle&lt;/code>. Он десериализует поток байтов для воссоздания объектов, хранящихся в файле, и загружает объект в память.&lt;/p>
&lt;p>Для этого используется функция &lt;code>pickle.load()&lt;/code>.&lt;/p>
&lt;h3 id="28-что-такое-генераторы-в-python">28. Что такое генераторы в Python?&lt;/h3>
&lt;p>Генераторы - это функции, которые возвращают итерируемую коллекцию элементов, по одному за раз, заданным образом. Генераторы, в общем случае, используются для создания итераторов с другим подходом. Они используют ключевое слово &lt;code>yield&lt;/code>, а не &lt;code>return&lt;/code> для возврата объекта генератора.&lt;/p>
&lt;p>Построим генератор для чисел Фибоначчи:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">## generate fibonacci numbers upto n&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">fib&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p, q &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span>(p &lt;span style="color:#666">&amp;lt;&lt;/span> n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">yield&lt;/span> p
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p, q &lt;span style="color:#666">=&lt;/span> q, p &lt;span style="color:#666">+&lt;/span> q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#666">=&lt;/span> fib(&lt;span style="color:#40a070">10&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># create generator object &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">## iterating using __next__(), for Python2, use next()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x&lt;span style="color:#666">.&lt;/span>__next__() &lt;span style="color:#60a0b0;font-style:italic"># error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">## iterating using loop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> fib(&lt;span style="color:#40a070">10&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(i) &lt;span style="color:#60a0b0;font-style:italic"># output =&amp;gt; 0 1 1 2 3 5 8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="29-что-такое-pythonpath-в-python">29. Что такое PYTHONPATH в Python?&lt;/h3>
&lt;p>&lt;code>PYTHONPATH&lt;/code> - это переменная окружения, которую можно установить, чтобы добавить дополнительные каталоги, в которых Python будет искать модули и пакеты.&lt;/p>
&lt;p>Это особенно полезно при работе с библиотеками Python, которые вы не хотите устанавливать в глобальном месте по умолчанию.&lt;/p>
&lt;h3 id="30-как-используются-функции-help-и-dir">30. Как используются функции help() и dir()?&lt;/h3>
&lt;p>Функция &lt;code>help()&lt;/code> в Python используется для отображения документации по модулям, классам, функциям, ключевым словам и т.д. Если функции &lt;code>help()&lt;/code> не передан ни один параметр, то на консоли запускается интерактивная справочная утилита.&lt;/p>
&lt;p>Функция &lt;code>dir()&lt;/code> пытается вернуть правильный список атрибутов и методов объекта, к которому она обращается. Она ведет себя по-разному с разными объектами, поскольку стремится выдать наиболее релевантные данные, а не полную информацию.&lt;/p>
&lt;ul>
&lt;li>Для объектов Modules/Library он возвращает список всех атрибутов, содержащихся в данном модуле.&lt;/li>
&lt;li>Для объектов класса возвращает список всех допустимых атрибутов и базовых атрибутов.&lt;/li>
&lt;li>При отсутствии аргументов возвращает список атрибутов в текущей области видимости.&lt;/li>
&lt;/ul>
&lt;h3 id="31-в-чем-разница-между-файлами-py-и-pyc">31. В чем разница между файлами .py и .pyc?&lt;/h3>
&lt;p>Файлы &lt;code>.py&lt;/code> содержат исходный код программы. В то время как файл &lt;code>.pyc&lt;/code> содержит байткод программы. Мы получаем байткод после компиляции файла &lt;code>.py&lt;/code> (исходного кода). Файлы &lt;code>.pyc&lt;/code> создаются не для всех файлов, которые вы запускаете. Они создаются только для тех файлов, которые вы импортируете.&lt;/p>
&lt;p>Перед выполнением программы python интерпретатор python проверяет наличие скомпилированных файлов. Если файл присутствует, виртуальная машина выполняет его. Если файл не найден, он проверяет наличие файла &lt;code>.py&lt;/code>. Если он найден, то компилирует его в файл &lt;code>.pyc&lt;/code>, а затем виртуальная машина python выполняет его.&lt;/p>
&lt;p>Наличие файла &lt;code>.pyc&lt;/code> экономит время компиляции.&lt;/p>
&lt;h3 id="32-как-интерпретируется-язык-python">32. Как интерпретируется язык Python?&lt;/h3>
&lt;p>Python как язык не интерпретируется и не компилируется. Интерпретация или компиляция - это свойство реализации. Python - это байткод (набор инструкций, читаемых интерпретатором), интерпретируемый в общем случае.&lt;/p>
&lt;p>Исходный код - это файл с расширением &lt;code>.py&lt;/code>.&lt;/p>
&lt;p>Python компилирует исходный код в набор инструкций для виртуальной машины. Интерпретатор Python является реализацией этой виртуальной машины. Этот промежуточный формат называется &amp;ldquo;байткод&amp;rdquo;.&lt;/p>
&lt;p>Исходный код &lt;code>.py&lt;/code> сначала компилируется, чтобы получить &lt;code>.pyc&lt;/code>, который является байткодом. Затем этот байткод может быть интерпретирован официальным CPython или JIT (Just in Time compiler) компилятором PyPy.&lt;/p>
&lt;h3 id="33-как-в-python-аргументы-передаются-по-значению-или-по-ссылке">33. Как в python аргументы передаются по значению или по ссылке?&lt;/h3>
&lt;p>Передача по значению: Передается копия реального объекта. Изменение значения копии объекта не приведет к изменению значения исходного объекта.&lt;/p>
&lt;p>Передача по ссылке: Передается ссылка на реальный объект. Изменение значения нового объекта изменит значение исходного объекта.&lt;/p>
&lt;p>В Python аргументы передаются по ссылке, т.е. передается ссылка на реальный объект.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">appendNumber&lt;/span>(arr):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr&lt;span style="color:#666">.&lt;/span>append(&lt;span style="color:#40a070">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>arr &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>]&lt;span style="color:#666">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(arr) &lt;span style="color:#60a0b0;font-style:italic">#Вывод: =&amp;gt; [1, 2, 3]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>appendNumber(arr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(arr) &lt;span style="color:#60a0b0;font-style:italic">#Вывод: =&amp;gt; [1, 2, 3, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="34-что-такое-итераторы-в-python">34. Что такое итераторы в Python?&lt;/h3>
&lt;ul>
&lt;li>Итератор - это объект.&lt;/li>
&lt;li>Он запоминает свое состояние, т.е. где он находится во время итерации (см. код ниже, чтобы увидеть, как это делается).&lt;/li>
&lt;li>Метод &lt;strong>iter&lt;/strong>() инициализирует итератор.&lt;/li>
&lt;li>У него есть метод &lt;strong>next&lt;/strong>(), который возвращает следующий элемент в итерации и указывает на следующий элемент. При достижении конца итерируемого объекта &lt;strong>next&lt;/strong>() должен возвращать исключение &lt;a href="https://docs.python.org/3/library/exceptions.html#StopIteration">&lt;code>StopIteration&lt;/code>&lt;/a>.&lt;/li>
&lt;li>Он также является самоитерируемым.&lt;/li>
&lt;li>Итераторы - это объекты, с помощью которых мы можем выполнять итерации над итерируемыми объектами, такими как списки, строки и т.д.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ArrayList&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, number_list):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>numbers &lt;span style="color:#666">=&lt;/span> number_list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __iter__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>pos &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> возвращать себя
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __next__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span>(self&lt;span style="color:#666">.&lt;/span>pos &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(self&lt;span style="color:#666">.&lt;/span>numbers)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>pos &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>numbers[self&lt;span style="color:#666">.&lt;/span>pos &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">raise&lt;/span> &lt;span style="color:#007020">StopIteration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>array_obj &lt;span style="color:#666">=&lt;/span> ArrayList([&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>it &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">iter&lt;/span>(array_obj)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#007020">next&lt;/span>(it)) &lt;span style="color:#60a0b0;font-style:italic">#вывод: 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#007020">next&lt;/span>(it)) &lt;span style="color:#60a0b0;font-style:italic">#вывод: 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#007020">next&lt;/span>(it))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#Throws Exception&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#Traceback (последний последний вызов):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#StopIteration&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="35-объясните-как-удалить-файл-в-python">35. Объясните, как удалить файл в Python?&lt;/h3>
&lt;p>Используйте команду &lt;code>os.remove(file_name)&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">os&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>os&lt;span style="color:#666">.&lt;/span>remove(&lt;span style="color:#4070a0">&amp;#34;ChangedFile.csv&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;File Removed!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="36-объясните-функции-split-и-join-в-python">36. Объясните функции split() и join() в Python?&lt;/h3>
&lt;p>Вы можете использовать функцию &lt;code>split()&lt;/code> для разбиения строки на основе разделителя на список строк.&lt;/p>
&lt;p>С помощью функции &lt;code>join()&lt;/code> можно объединить список строк на основе разделителя, чтобы получить одну строку.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>string &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Текст строки&amp;#34;&lt;/span>&lt;span style="color:#666">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>string_list &lt;span style="color:#666">=&lt;/span> string&lt;span style="color:#666">.&lt;/span>split(&lt;span style="color:#4070a0">&amp;#39; &amp;#39;&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic">#разделителем является символ &amp;#34;пробел&amp;#34; или &amp;#39; &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(string_list) &lt;span style="color:#60a0b0;font-style:italic">#вывод: [&amp;#39;This&amp;#39;, &amp;#39;is&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;string.&amp;#39;].&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#666">.&lt;/span>join(string_list)) &lt;span style="color:#60a0b0;font-style:italic">#вывод: Это строка.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="37-что-означают-args-и-kwargs">37. Что означают *args и **kwargs?&lt;/h3>
&lt;p>&lt;code>*args&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>*args&lt;/code> - это специальный синтаксис, используемый в определении функции для передачи аргументов переменной длины.&lt;/li>
&lt;li>&lt;code>&amp;quot;*&amp;quot;&lt;/code> означает переменную длину, а &amp;ldquo;args&amp;rdquo; - это имя, используемое по соглашению. Вы можете использовать любое другое.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">multiply&lt;/span>(a, b, &lt;span style="color:#666">*&lt;/span>argv):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mul &lt;span style="color:#666">=&lt;/span> a &lt;span style="color:#666">*&lt;/span> b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> num &lt;span style="color:#007020;font-weight:bold">in&lt;/span> argv:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mul &lt;span style="color:#666">*=&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> возвращать mul
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(multiply(&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">4&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>)) &lt;span style="color:#60a0b0;font-style:italic">#вывод: 120&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>**kwargs&lt;/code>&lt;/p>
&lt;p>&lt;code>**kwargs&lt;/code> - это специальный синтаксис, используемый в определении функции для передачи аргументов переменной длины с ключевыми словами.&lt;/p>
&lt;ul>
&lt;li>Здесь также &lt;code>kwargs&lt;/code> используется просто по соглашению. Вы можете использовать любое другое имя.&lt;/li>
&lt;li>Аргумент с ключевым словом означает переменную, которая имеет имя при передаче в функцию.&lt;/li>
&lt;li>На самом деле это словарь имен переменных и их значений.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">tellArguments&lt;/span>(&lt;span style="color:#666">**&lt;/span>kwargs):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> key, value &lt;span style="color:#007020;font-weight:bold">in&lt;/span> kwargs&lt;span style="color:#666">.&lt;/span>items():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(key &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#666">+&lt;/span> value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tellArguments(arg1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;аргумент 1&amp;#34;&lt;/span>, arg2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;аргумент 2&amp;#34;&lt;/span>, arg3 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;аргумент 3&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#вывод:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># arg1: аргумент 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># arg2: аргумент 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># arg3: аргумент 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="38-что-такое-отрицательные-индексы-и-зачем-они-используются">38. Что такое отрицательные индексы и зачем они используются?&lt;/h3>
&lt;p>Отрицательные индексы - это индексы с конца списка, кортежа или строки.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>arr &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">4&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>, &lt;span style="color:#40a070">6&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>arr[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] означает последний элемент массива arr[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#получить последний элемент&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(arr[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic">#вывод 6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">#получить второй последний элемент&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(arr[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">2&lt;/span>]) &lt;span style="color:#60a0b0;font-style:italic">#вывод 5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="juniormiddle--ооп">Junior/Middle+ / ООП&lt;/h2>
&lt;h3 id="39-как-создать-класс-в-python">39. Как создать класс в Python?&lt;/h3>
&lt;p>Чтобы создать класс в python, используем ключевое слово &lt;code>class&lt;/code>, как показано в примере ниже:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Employee&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, emp_name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>emp_name &lt;span style="color:#666">=&lt;/span> emp_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Чтобы инстанцировать или создать объект из класса, созданного выше, мы делаем следующее:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>emp_1 &lt;span style="color:#666">=&lt;/span> Employee(&lt;span style="color:#4070a0">&amp;#34;Mr. Employee&amp;#34;&lt;/span>)&lt;span style="color:#666">.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Чтобы получить доступ к атрибуту &lt;code>name&lt;/code>, мы просто вызываем атрибут с помощью &lt;em>точки&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(emp_1&lt;span style="color:#666">.&lt;/span>emp_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Mr. Employee&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Чтобы создать методы внутри класса, мы включаем их в область видимости класса:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Employee&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, emp_name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>emp_name &lt;span style="color:#666">=&lt;/span> emp_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">introduce&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hello I am &amp;#34;&lt;/span> &lt;span style="color:#666">+&lt;/span> self&lt;span style="color:#666">.&lt;/span>emp_name)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Параметр &lt;code>self&lt;/code> в функциях &lt;code>init&lt;/code> и introduce представляет собой ссылку на текущий экземпляр класса, которая используется для доступа к атрибутам и методам этого класса. Параметр &lt;code>self&lt;/code> должен быть первым параметром любого метода, определенного внутри класса.&lt;/p>
&lt;p>Доступ к методу класса &lt;code>Employee&lt;/code> можно получить:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>emp_1&lt;span style="color:#666">.&lt;/span>introduce()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Общая программа будет выглядеть следующим образом:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">InterviewbitEmployee&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, emp_name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>emp_name &lt;span style="color:#666">=&lt;/span> emp_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">introduce&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hello I am &amp;#34;&lt;/span> &lt;span style="color:#666">+&lt;/span> self&lt;span style="color:#666">.&lt;/span>emp_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># create an object of InterviewbitEmployee class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>emp_1 &lt;span style="color:#666">=&lt;/span> InterviewbitEmployee(&lt;span style="color:#4070a0">&amp;#34;Mr Employee&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(emp_1&lt;span style="color:#666">.&lt;/span>emp_name) &lt;span style="color:#60a0b0;font-style:italic">#print employee name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>emp_1&lt;span style="color:#666">.&lt;/span>introduce() &lt;span style="color:#60a0b0;font-style:italic">#introduce the employee&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="40-как-работает-наследование-в-python">40. Как работает наследование в python?&lt;/h3>
&lt;p>Наследование дает классу право доступа ко всем атрибутам и методам другого класса. Это способствует повторному использованию кода и помогает разработчику поддерживать приложения без лишнего кода. Класс, наследующий от другого класса, является дочерним классом или также называется производным классом. Класс, от которого дочерний класс получает свои члены, называется родительским классом или суперклассом.&lt;/p>
&lt;p>Python поддерживает различные виды наследования, а именно:&lt;/p>
&lt;ul>
&lt;li>Одиночное наследование&lt;/li>
&lt;li>Многоуровневое наследование&lt;/li>
&lt;li>Множественное наследование&lt;/li>
&lt;li>Иерархическое наследование&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Одиночное наследование:&lt;/strong> Дочерний класс получает члены от одного родительского класса.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="assets/Single_Inheritance.ru.jpg"
id="zoom-default"
alt="Одиночное наследование python"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Parent class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ParentClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">par_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;I am parent class function&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Child class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ChildClass&lt;/span>(ParentClass):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">child_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;I am child class function&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Driver code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1 &lt;span style="color:#666">=&lt;/span> ChildClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1&lt;span style="color:#666">.&lt;/span>par_func()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1&lt;span style="color:#666">.&lt;/span>child_func()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Многоуровневое наследование:&lt;/strong> Члены родительского класса &lt;code>A&lt;/code> наследуются дочерним классом, который затем наследуется другим дочерним классом &lt;code>B&lt;/code>. Характеристики базового и производного классов далее наследуются в новом производном классе &lt;code>C&lt;/code>.&lt;/p>
&lt;p>Здесь &lt;code>A&lt;/code> является &lt;em>дедушкой&lt;/em> класса &lt;code>C&lt;/code>.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="assets/Multi-level_Inheritance.ru.jpg"
id="zoom-default"
alt="Многоуровневое наследование python"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Parent class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">A&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, a_name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>a_name &lt;span style="color:#666">=&lt;/span> a_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Intermediate class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">B&lt;/span>(A):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, b_name, a_name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>b_name &lt;span style="color:#666">=&lt;/span> b_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># invoke constructor of class A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A&lt;span style="color:#666">.&lt;/span>__init__(self, a_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Child class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">C&lt;/span>(B):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self,c_name, b_name, a_name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>c_name &lt;span style="color:#666">=&lt;/span> c_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># invoke constructor of class B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> B&lt;span style="color:#666">.&lt;/span>__init__(self, b_name, a_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">display_names&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;A name : &amp;#34;&lt;/span>, self&lt;span style="color:#666">.&lt;/span>a_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;B name : &amp;#34;&lt;/span>, self&lt;span style="color:#666">.&lt;/span>b_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;C name : &amp;#34;&lt;/span>, self&lt;span style="color:#666">.&lt;/span>c_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Driver code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1 &lt;span style="color:#666">=&lt;/span> C(&lt;span style="color:#4070a0">&amp;#39;child&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;intermediate&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;parent&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(obj1&lt;span style="color:#666">.&lt;/span>a_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1&lt;span style="color:#666">.&lt;/span>display_names()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Множественное наследование:&lt;/strong> Это достигается, когда один дочерний класс получает свойста от более чем одного родительского класса. Все свойства родительских классов наследуются в дочернем классе.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="assets/Multiple_Inheritance.ru.jpg"
id="zoom-default"
alt="Множественное наследование python"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Parent class1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Parent1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">parent1_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hi I am first Parent&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Parent class2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Parent2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">parent2_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Hi I am second Parent&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Child class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Child&lt;/span>(Parent1, Parent2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">child_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>parent1_func()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>parent2_func()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Driver&amp;#39;s code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1 &lt;span style="color:#666">=&lt;/span> Child()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1&lt;span style="color:#666">.&lt;/span>child_func()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Иерархическое наследование:&lt;/strong> Когда от родительского класса происходит более одного дочернего класса.&lt;/p>
&lt;p>&lt;p class="md__image">
&lt;img
src="assets/Hierarchical_Inheritance.ru.jpg"
id="zoom-default"
alt="Иерархическое наследование python"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Base class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">A&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">a_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;I am from the parent class.&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># 1st Derived class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">B&lt;/span>(A):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">b_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;I am from the first child.&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># 2nd Derived class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">C&lt;/span>(A):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">c_func&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;I am from the second child.&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Driver&amp;#39;s code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1 &lt;span style="color:#666">=&lt;/span> B()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj2 &lt;span style="color:#666">=&lt;/span> C()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1&lt;span style="color:#666">.&lt;/span>a_func()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj1&lt;span style="color:#666">.&lt;/span>b_func() &lt;span style="color:#60a0b0;font-style:italic">#child 1 method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj2&lt;span style="color:#666">.&lt;/span>a_func()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj2&lt;span style="color:#666">.&lt;/span>c_func() &lt;span style="color:#60a0b0;font-style:italic">#child 2 method&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="41-как-получить-доступ-к-членам-родительского-класса-в-дочернем-классе">41. Как получить доступ к членам родительского класса в дочернем классе?&lt;/h3>
&lt;p>Ниже перечислены способы, с помощью которых вы можете получить доступ к членам родительского класса в дочернем классе:&lt;/p>
&lt;p>С помощью &lt;strong>имени родительского класса&lt;/strong>: Вы можете использовать имя родительского класса для доступа к атрибутам, как показано в примере ниже:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Parent&lt;/span>(&lt;span style="color:#007020">object&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Constructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>name &lt;span style="color:#666">=&lt;/span> name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Child&lt;/span>(Parent):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Constructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, name, age):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Parent&lt;span style="color:#666">.&lt;/span>name &lt;span style="color:#666">=&lt;/span> name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>age &lt;span style="color:#666">=&lt;/span> age
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">display&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(Parent&lt;span style="color:#666">.&lt;/span>name, self&lt;span style="color:#666">.&lt;/span>age)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Driver Code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj &lt;span style="color:#666">=&lt;/span> Child(&lt;span style="color:#4070a0">&amp;#34;ParentName&amp;#34;&lt;/span>, &lt;span style="color:#40a070">6&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj&lt;span style="color:#666">.&lt;/span>display()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>С помощью метода &lt;code>super()&lt;/code>: Члены родительского класса могут быть доступны в дочернем классе с помощью ключевого слова &lt;code>super&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Parent&lt;/span>(&lt;span style="color:#007020">object&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Constructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>name &lt;span style="color:#666">=&lt;/span> name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Child&lt;/span>(Parent):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Constructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, name, age):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> In Python 3.x, we can also use super().__init__(name)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#4070a0"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">super&lt;/span>(Child, self)&lt;span style="color:#666">.&lt;/span>__init__(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>age &lt;span style="color:#666">=&lt;/span> age
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">display&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Note that Parent.name cant be used &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># here since super() is used in the constructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(self&lt;span style="color:#666">.&lt;/span>name, self&lt;span style="color:#666">.&lt;/span>age)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Driver Code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj &lt;span style="color:#666">=&lt;/span> Child(&lt;span style="color:#4070a0">&amp;#34;Interviewbit&amp;#34;&lt;/span>, &lt;span style="color:#40a070">6&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>obj&lt;span style="color:#666">.&lt;/span>display()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="42-используются-ли-спецификаторы-доступа-в-python">42. Используются ли спецификаторы доступа в python?&lt;/h3>
&lt;p>Да, в Python есть спецификаторы доступа, но они не являются строгими и не работают так же, как в других языках, таких как C++ или Java.&lt;/p>
&lt;p>В Python есть три уровня спецификаторов доступа:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Public&lt;/strong> - открытый доступ. Переменные и методы, объявленные без какого-либо спецификатора доступа, считаются общедоступными и могут быть использованы в любом месте программы.&lt;/li>
&lt;li>&lt;strong>Protected&lt;/strong> - защищенный доступ. Переменные и методы, которые начинаются с символа подчеркивания (_), считаются защищенными и должны использоваться только внутри класса и его потомков.&lt;/li>
&lt;li>&lt;strong>Private&lt;/strong> - закрытый доступ. Переменные и методы, которые начинаются с двух символов подчеркивания (__), считаются закрытыми и не могут быть использованы за пределами класса, даже его потомками.&lt;/li>
&lt;/ul>
&lt;p>Однако в Python все переменные и методы на самом деле являются общедоступными и могут быть доступны вне класса, даже если они были объявлены с использованием защищенного или закрытого спецификатора доступа. Но общепринятым правилом считается использование подчеркиваний в начале имен переменных и методов, чтобы показать, что они не предназначены для использования вне класса.&lt;/p>
&lt;p>Также существует соглашение, что имена методов и переменных, начинающихся с двух символов подчеркивания, должны использоваться только внутри класса.&lt;/p>
&lt;p>Пример использования спецификаторов доступа в Python:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Example&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>public_variable &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Public variable&amp;#34;&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># публичная переменная&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>_protected_variable &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Protected variable&amp;#34;&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># защищенная переменная&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>__private_variable &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Private variable&amp;#34;&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># приватная переменная&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">public_method&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Public method&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">_protected_method&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Protected method&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">__private_method&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Private method&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>example &lt;span style="color:#666">=&lt;/span> Example()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Доступ к публичной переменной и методу&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(example&lt;span style="color:#666">.&lt;/span>public_variable) &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;Public variable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>example&lt;span style="color:#666">.&lt;/span>public_method() &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;Public method&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Доступ к защищенной переменной и методу&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(example&lt;span style="color:#666">.&lt;/span>_protected_variable) &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;Protected variable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>example&lt;span style="color:#666">.&lt;/span>_protected_method() &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;Protected method&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Доступ к приватной переменной и методу&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Возникнет ошибка AttributeError, потому что переменная и метод приватные&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(example&lt;span style="color:#666">.&lt;/span>__private_variable)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>example&lt;span style="color:#666">.&lt;/span>__private_method()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом примере мы создали класс &lt;code>Example&lt;/code> с тремя переменными и методами, которые имеют разные уровни спецификаторов доступа. Затем мы создали объект &lt;code>example&lt;/code> и использовали различные спецификаторы доступа, чтобы получить доступ к его переменным и методам.&lt;/p>
&lt;h3 id="43-можно-ли-вызвать-родительский-класс-без-создания-его-экземпляра">43. Можно ли вызвать родительский класс без создания его экземпляра?&lt;/h3>
&lt;p>Да, это возможно, если базовый класс инстанцируется другими дочерними классами или если базовый класс является статическим методом.&lt;/p>
&lt;h3 id="44-как-в-python-создается-пустой-класс">44. Как в python создается пустой класс?&lt;/h3>
&lt;p>Пустой класс не имеет определенных свойств/методов, определенных внутри. Он создается с помощью ключевого слова pass (команда pass ничего не делает в python). Мы можем создавать объекты для этого класса вне класса.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">MyClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">pass&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="45-проведите-различие-между-модификаторами-new-и-override">45. Проведите различие между модификаторами &lt;code>new&lt;/code> и &lt;code>override&lt;/code>&lt;/h3>
&lt;p>&lt;code>new&lt;/code> используется для создания новой реализации метода в классе-наследнике, которая заменяет реализацию метода в базовом классе. Это означает, что когда метод вызывается на объекте класса-наследника, будет использоваться новая реализация метода из класса-наследника, а не из базового класса.&lt;/p>
&lt;p>&lt;code>override&lt;/code> используется для переопределения реализации метода, унаследованного от базового класса. Это означает, что когда метод вызывается на объекте класса-наследника, будет использоваться новая реализация метода из класса-наследника, а не реализация метода из базового класса.&lt;/p>
&lt;p>Если в классе-наследнике не определен метод с тем же именем, что и метод в базовом классе, то метод базового класса будет унаследован.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">BaseClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">method&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;BaseClass.method&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">DerivedClass1&lt;/span>(BaseClass):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">method&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;DerivedClass1.method&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">DerivedClass2&lt;/span>(BaseClass):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">new_method&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;DerivedClass2.new_method&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">DerivedClass3&lt;/span>(BaseClass):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">method&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">super&lt;/span>()&lt;span style="color:#666">.&lt;/span>method()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;DerivedClass3.method&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>base_object &lt;span style="color:#666">=&lt;/span> BaseClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>derived_object1 &lt;span style="color:#666">=&lt;/span> DerivedClass1()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>derived_object2 &lt;span style="color:#666">=&lt;/span> DerivedClass2()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>derived_object3 &lt;span style="color:#666">=&lt;/span> DerivedClass3()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>base_object&lt;span style="color:#666">.&lt;/span>method() &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;BaseClass.method&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>derived_object1&lt;span style="color:#666">.&lt;/span>method() &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;DerivedClass1.method&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>derived_object2&lt;span style="color:#666">.&lt;/span>new_method() &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;DerivedClass2.new_method&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>derived_object3&lt;span style="color:#666">.&lt;/span>method() &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;BaseClass.method&amp;#34; и &amp;#34;DerivedClass3.method&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="46-как-использовать-декораторы-для-определения-свойств-property-в-python">46. Как использовать декораторы для определения свойств (property) в Python?&lt;/h3>
&lt;p>В Python свойства (property) позволяют использовать методы геттера (getter) и сеттера (setter) для доступа к данным объекта, скрывая реализацию от пользователя.&lt;/p>
&lt;p>Для определения свойства (property) в Python используются декораторы @property, @property_name.setter и @property_name.deleter. Декоратор @property указывается перед методом геттера, который должен возвращать значение свойства. Декоратор @property_name.setter указывается перед методом сеттера, который должен устанавливать значение свойства. Декоратор @property_name.deleter указывается перед методом удаления, который должен удалить свойство.&lt;/p>
&lt;p>Пример определения свойства (property) с помощью декораторов в Python:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Rectangle&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, width, height):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>width &lt;span style="color:#666">=&lt;/span> width
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>height &lt;span style="color:#666">=&lt;/span> height
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@property&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">area&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>width &lt;span style="color:#666">*&lt;/span> self&lt;span style="color:#666">.&lt;/span>height
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@property&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">perimeter&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">*&lt;/span> (self&lt;span style="color:#666">.&lt;/span>width &lt;span style="color:#666">+&lt;/span> self&lt;span style="color:#666">.&lt;/span>height)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@property&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">width&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>_width
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@width.setter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">width&lt;/span>(self, value):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> value &lt;span style="color:#666">&amp;lt;=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">raise&lt;/span> &lt;span style="color:#007020">ValueError&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Width must be positive.&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>_width &lt;span style="color:#666">=&lt;/span> value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@property&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">height&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>_height
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@height.setter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">height&lt;/span>(self, value):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> value &lt;span style="color:#666">&amp;lt;=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">raise&lt;/span> &lt;span style="color:#007020">ValueError&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;Height must be positive.&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>_height &lt;span style="color:#666">=&lt;/span> value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@property&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">dimensions&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> (self&lt;span style="color:#666">.&lt;/span>width, self&lt;span style="color:#666">.&lt;/span>height)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@dimensions.setter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">dimensions&lt;/span>(self, values):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>width, self&lt;span style="color:#666">.&lt;/span>height &lt;span style="color:#666">=&lt;/span> values
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __str__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;Rectangle(&lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>self&lt;span style="color:#666">.&lt;/span>width&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">, &lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>self&lt;span style="color:#666">.&lt;/span>height&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом примере мы создали класс &lt;code>Rectangle&lt;/code>, который определяет прямоугольник с шириной и высотой. Мы определили свойства (property) &lt;code>area&lt;/code>, &lt;code>perimeter&lt;/code>, &lt;code>width&lt;/code>, &lt;code>height&lt;/code> и &lt;code>dimensions&lt;/code> с помощью декораторов.&lt;/p>
&lt;p>Свойства &lt;code>area&lt;/code> и &lt;code>perimeter&lt;/code> используют методы геттера для вычисления площади и периметра.&lt;/p>
&lt;p>Свойства &lt;code>width&lt;/code> и &lt;code>height&lt;/code> используют методы геттера и сеттера для доступа к ширине и высоте.&lt;/p>
&lt;p>Свойство &lt;code>dimensions&lt;/code> использует методы геттера и сеттера для доступа к ширине и высоте в виде кортежа.&lt;/p>
&lt;p>Теперь мы можем создать объект класса &lt;code>Rectangle&lt;/code> и использовать свойства для доступа к данным:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>rect &lt;span style="color:#666">=&lt;/span> Rectangle(&lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(rect&lt;span style="color:#666">.&lt;/span>width) &lt;span style="color:#60a0b0;font-style:italic"># выведет 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(rect&lt;span style="color:#666">.&lt;/span>height) &lt;span style="color:#60a0b0;font-style:italic"># выведет 4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(rect&lt;span style="color:#666">.&lt;/span>area) &lt;span style="color:#60a0b0;font-style:italic"># выведет 12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(rect&lt;span style="color:#666">.&lt;/span>perimeter) &lt;span style="color:#60a0b0;font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="47-что-такое-метод-init-в-python">47. Что такое метод &lt;code>init&lt;/code> в python?&lt;/h3>
&lt;p>В Python метод &lt;code>__init__&lt;/code> является конструктором класса, который вызывается при создании нового объекта класса. Он используется для инициализации свойств объекта и может принимать параметры, которые передаются при создании объекта.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">MyClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, name):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>name &lt;span style="color:#666">=&lt;/span> name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>my_object &lt;span style="color:#666">=&lt;/span> MyClass(&lt;span style="color:#4070a0">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(my_object&lt;span style="color:#666">.&lt;/span>name) &lt;span style="color:#60a0b0;font-style:italic"># выведет &amp;#34;John&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом примере мы создали класс &lt;code>MyClass&lt;/code> с методом &lt;code>__init__&lt;/code>, который инициализирует свойство &lt;code>name&lt;/code> объекта класса. При создании объекта &lt;code>my_object&lt;/code> мы передали ему параметр &amp;ldquo;John&amp;rdquo;, который был использован для инициализации свойства &lt;code>name&lt;/code>.&lt;/p>
&lt;h3 id="48-как-проверить-является-ли-класс-дочерним-по-отношению-к-другому-классу">48. Как проверить, является ли класс дочерним по отношению к другому классу?&lt;/h3>
&lt;p>В Python можно проверить, является ли класс дочерним по отношению к другому классу с помощью функции &lt;code>issubclass&lt;/code>. Функция &lt;code>issubclass&lt;/code> принимает два аргумента: класс-потомок и класс-родитель, и возвращает &lt;code>True&lt;/code>, если класс-потомок является подклассом класса-родителя, и &lt;code>False&lt;/code> в противном случае.&lt;/p>
&lt;p>Вот пример использования функции &lt;code>issubclass&lt;/code> в Python:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">BaseClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">DerivedClass&lt;/span>(BaseClass):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#007020">issubclass&lt;/span>(DerivedClass, BaseClass)) &lt;span style="color:#60a0b0;font-style:italic"># выведет True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#007020">issubclass&lt;/span>(BaseClass, DerivedClass)) &lt;span style="color:#60a0b0;font-style:italic"># выведет False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом примере мы создали два класса, &lt;code>BaseClass&lt;/code> и &lt;code>DerivedClass&lt;/code>, где &lt;code>DerivedClass&lt;/code> наследует &lt;code>BaseClass&lt;/code>. Мы затем использовали функцию &lt;code>issubclass&lt;/code>, чтобы проверить, является ли &lt;code>DerivedClass&lt;/code> дочерним по отношению к &lt;code>BaseClass&lt;/code>, и вывели результат на экран.&lt;/p>
&lt;p>В этом примере функция &lt;code>issubclass(DerivedClass, BaseClass)&lt;/code> возвращает &lt;code>True&lt;/code>, потому что &lt;code>DerivedClass&lt;/code> является дочерним по отношению к &lt;code>BaseClass&lt;/code>.&lt;/p>
&lt;p>А функция &lt;code>issubclass(BaseClass, DerivedClass)&lt;/code> возвращает &lt;code>False&lt;/code>, потому что &lt;code>BaseClass&lt;/code> не является дочерним по отношению к &lt;code>DerivedClass&lt;/code>.&lt;/p>
&lt;h2 id="библиотеки">Библиотеки&lt;/h2>
&lt;h3 id="49-различия-между-пакетом-и-модулем-в-python">49. Различия между пакетом и модулем в python&lt;/h3>
&lt;p>Различия между пакетами и модулями в Python: модуль - это файл с расширением .py, который содержит определение функций, классов и других объектов, которые могут быть использованы в других модулях. Пакет - это каталог, который содержит один или несколько файлов модулей и может содержать другие подкаталоги.&lt;/p>
&lt;h3 id="50-каковы-некоторые-из-наиболее-часто-используемых-встроенных-модулей-в-python">50. Каковы некоторые из наиболее часто используемых встроенных модулей в Python?&lt;/h3>
&lt;p>Некоторые из наиболее часто используемых встроенных модулей в Python включают &lt;code>os&lt;/code>, &lt;code>sys&lt;/code>, &lt;code>math&lt;/code>, &lt;code>random&lt;/code>, &lt;code>datetime&lt;/code>, &lt;code>re&lt;/code>, &lt;code>json&lt;/code>, &lt;code>csv&lt;/code>, &lt;code>urllib&lt;/code>, &lt;code>socket&lt;/code> и многие другие.&lt;/p>
&lt;h3 id="51-что-такое-лямбда-функции">51. Что такое лямбда-функции?&lt;/h3>
&lt;p>Лямбда-функции в Python - это функции, которые определяются без использования ключевого слова &lt;code>def&lt;/code>. Они используются для определения функции в одной строке кода.&lt;/p>
&lt;h3 id="52-как-можно-генерировать-случайные-числа">52. Как можно генерировать случайные числа?&lt;/h3>
&lt;p>В Python можно генерировать случайные числа с помощью модуля random. Например, для генерации случайного числа в диапазоне от 1 до 10 можно использовать функцию &lt;code>random.randint(1, 10)&lt;/code>.&lt;/p>
&lt;h3 id="53-можете-ли-вы-проверить-все-ли-символы-в-заданной-строке-являются-буквенно-цифровыми">53. Можете ли вы проверить, все ли символы в заданной строке являются буквенно-цифровыми?&lt;/h3>
&lt;p>Для проверки, являются ли все символы в заданной строке буквенно-цифровыми, можно использовать метод &lt;code>isalnum()&lt;/code>. Например, &lt;code>&amp;quot;Abc123&amp;quot;.isalnum()&lt;/code> вернет &lt;code>True&lt;/code>, а &lt;code>&amp;quot;Abc 123&amp;quot;.isalnum()&lt;/code> вернет &lt;code>False&lt;/code>.&lt;/p>
&lt;h3 id="54-дайте-определение-понятию-gil">54. Дайте определение понятию GIL&lt;/h3>
&lt;p>&lt;strong>GIL&lt;/strong> (Global Interpreter Lock) - это механизм блокировки интерпретатора Python, который ограничивает выполнение только одного потока Python в любой момент времени. Это ограничение делает невозможным многопоточное выполнение Python-кода на нескольких ядрах процессора.&lt;/p>
&lt;h3 id="55-существуют-ли-инструменты-для-выявления-ошибок-и-выполнения-статического-анализа-в-python">55. Существуют ли инструменты для выявления ошибок и выполнения статического анализа в python?&lt;/h3>
&lt;p>В Python существует множество инструментов для идентификации ошибок и проведения статического анализа кода, таких как &lt;code>pylint&lt;/code>, &lt;code>pyflakes&lt;/code>, &lt;code>pycodestyle&lt;/code> и другие.&lt;/p></description></item></channel></rss>