<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>III - Расширенные возможности on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/</link><description>Recent content in III - Расширенные возможности on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Tue, 28 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tracks/python-101/enhance_python/index.xml" rel="self" type="application/rss+xml"/><item><title>Лямбда</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/lambda/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/lambda/</guid><description>&lt;p>Лямбда-функции в Python - это безымянные функции, которые можно определить в одной строке и не требуют ключевого слова def. Они используются для написания коротких функций внутри других функций или выражений, где требуется функция в качестве аргумента.&lt;/p>
&lt;p>Лямбда-функция определяется ключевым словом &lt;strong>lambda&lt;/strong>, за которым следуют параметры функции, после чего через двоеточие указывается выражение, которое нужно вернуть из функции.&lt;/p>
&lt;p>Пример:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>add &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">lambda&lt;/span> x, y: x &lt;span style="color:#666">+&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(add(&lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>)) &lt;span style="color:#60a0b0;font-style:italic"># Output: 5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Здесь мы определяем лямбда-функцию &lt;code>add&lt;/code>, которая принимает два аргумента &lt;code>x&lt;/code> и &lt;code>y&lt;/code> и возвращает их сумму. Затем мы вызываем эту функцию, передав ей аргументы 2 и 3, и выводим результат, который равен 5.&lt;/p>
&lt;p>Лямбда-функции могут использоваться в качестве аргументов для функций высшего порядка, таких как &lt;code>map&lt;/code>, &lt;code>filter&lt;/code> или &lt;code>reduce&lt;/code>. Например, следующий код использует лямбда-функцию для фильтрации списка:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>numbers &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#40a070">3&lt;/span>, &lt;span style="color:#40a070">4&lt;/span>, &lt;span style="color:#40a070">5&lt;/span>, &lt;span style="color:#40a070">6&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>even_numbers &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">list&lt;/span>(&lt;span style="color:#007020">filter&lt;/span>(&lt;span style="color:#007020;font-weight:bold">lambda&lt;/span> x: x &lt;span style="color:#666">%&lt;/span> &lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>, numbers))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(even_numbers) &lt;span style="color:#60a0b0;font-style:italic"># Output: [2, 4, 6]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Здесь мы используем функцию &lt;code>filter&lt;/code>, чтобы отфильтровать только четные числа из списка &lt;code>numbers&lt;/code>. В качестве первого аргумента передаем лямбда-функцию, которая проверяет, является ли число четным. Результат фильтрации преобразуем в список и выводим на экран.&lt;/p>
&lt;p>Лямбда-функции также могут использоваться для создания простых обработчиков событий или для задания ключей сортировки. В целом, лямбда-функции могут быть удобным инструментом для написания коротких функций на лету.&lt;/p></description></item><item><title>Декораторы</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/decorators/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/decorators/</guid><description>&lt;p>Декораторы в Python позволяют изменять поведение функций и методов, оборачивая их в другую функцию. В этом разделе мы рассмотрим несколько встроенных декораторов и создание собственного декоратора.&lt;/p>
&lt;h2 id="classmethod">@classmethod&lt;/h2>
&lt;p>Декоратор &lt;code>@classmethod&lt;/code> используется для создания методов класса в Python. Методы класса имеют доступ к состоянию класса и могут использоваться без необходимости создания экземпляра класса. Методы класса можно вызывать как от самого класса, так и от его экземпляров.&lt;/p>
&lt;p>Декоратор &lt;code>@classmethod&lt;/code> применяется к методам класса. Он принимает первым аргументом класс (&lt;code>cls&lt;/code>) вместо экземпляра класса (&lt;code>self&lt;/code>).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">MyClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@classmethod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">my_class_method&lt;/span>(cls, arg1, arg2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;Class:&amp;#39;&lt;/span>, cls, &lt;span style="color:#4070a0">&amp;#39;arg1:&amp;#39;&lt;/span>, arg1, &lt;span style="color:#4070a0">&amp;#39;arg2:&amp;#39;&lt;/span>, arg2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MyClass&lt;span style="color:#666">.&lt;/span>my_class_method(&lt;span style="color:#4070a0">&amp;#39;a&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;b&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="staticmethod">@staticmethod&lt;/h2>
&lt;p>Декоратор &lt;code>@staticmethod&lt;/code> используется для создания статических методов в Python. Статические методы не имеют доступа к состоянию класса и могут использоваться без необходимости создания экземпляра класса. Статические методы можно вызывать как от самого класса, так и от его экземпляров.&lt;/p>
&lt;p>Декоратор &lt;code>@staticmethod&lt;/code> также применяется к методам класса. Он не принимает первый аргумент, связанный с классом.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">MyClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@staticmethod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">my_static_method&lt;/span>(arg1, arg2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;arg1:&amp;#39;&lt;/span>, arg1, &lt;span style="color:#4070a0">&amp;#39;arg2:&amp;#39;&lt;/span>, arg2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MyClass&lt;span style="color:#666">.&lt;/span>my_static_method(&lt;span style="color:#4070a0">&amp;#39;a&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;b&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="property">@property&lt;/h2>
&lt;p>Декоратор &lt;code>@property&lt;/code> используется для создания свойств класса в Python. Свойства класса обеспечивают доступ к закрытым переменным класса, так что они могут быть использованы без необходимости создания экземпляра класса. Доступ к свойствам можно получить как чтением, так и записью.&lt;/p>
&lt;p>Декоратор &lt;code>@property&lt;/code> используется для превращения метода в атрибут объекта. Метод, декорированный &lt;code>@property&lt;/code>, может быть вызван как атрибут объекта, а не как метод.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">MyClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>_x &lt;span style="color:#666">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@property&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">x&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> self&lt;span style="color:#666">.&lt;/span>_x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>my_obj &lt;span style="color:#666">=&lt;/span> MyClass(&lt;span style="color:#40a070">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(my_obj&lt;span style="color:#666">.&lt;/span>x) &lt;span style="color:#60a0b0;font-style:italic"># 10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="contextmanager">@contextmanager&lt;/h2>
&lt;p>Декоратор &lt;code>@contextmanager&lt;/code> используется для создания менеджера контекста в Python. Менеджеры контекста позволяют определять блоки кода, которые должны быть выполнены с определенными контекстными условиями, такими как открытие и закрытие файлов, установка и восстановление состояния объекта и т. д.&lt;/p>
&lt;p>&lt;code>@contextmanager&lt;/code> позволяет использовать функцию как менеджер контекста с использованием ключевого слова &lt;code>with&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">contextlib&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> contextmanager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#555;font-weight:bold">@contextmanager&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">my_context&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;entering context&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">yield&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;exiting context&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">with&lt;/span> my_context():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;inside context&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="lru_cache">@lru_cache&lt;/h2>
&lt;p>Декоратор &lt;code>@lru_cache&lt;/code> используется для кэширования результатов функции. Он сохраняет результаты вызовов функции в памяти, чтобы избежать повторных вычислений.&lt;/p>
&lt;p>&lt;code>@lru_cache&lt;/code> использует алгоритм LRU (least recently used) для автоматического удаления наиболее неиспользуемых элементов из кэша.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">functools&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> lru_cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#555;font-weight:bold">@lru_cache&lt;/span>(maxsize&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">128&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">fibonacci&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> n &lt;span style="color:#666">&amp;lt;=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> fibonacci(n&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> fibonacci(n&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(fibonacci(&lt;span style="color:#40a070">30&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="создание-декоратора">Создание декоратора&lt;/h2>
&lt;p>Для создания собственного декоратора в Python нужно определить функцию-обертку, которая будет принимать функцию в качестве аргумента и возвращать новую функцию, изменяющую поведение исходной функции.&lt;/p>
&lt;p>Например, создадим декоратор, который будет выводить время выполнения функции:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">timer&lt;/span>(func):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">wrapper&lt;/span>(&lt;span style="color:#666">*&lt;/span>args, &lt;span style="color:#666">**&lt;/span>kwargs):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start_time &lt;span style="color:#666">=&lt;/span> time&lt;span style="color:#666">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> func(&lt;span style="color:#666">*&lt;/span>args, &lt;span style="color:#666">**&lt;/span>kwargs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end_time &lt;span style="color:#666">=&lt;/span> time&lt;span style="color:#666">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;Function &amp;#39;&lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>func&lt;span style="color:#666">.&lt;/span>__name__&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">&amp;#39; executed in &lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>end_time &lt;span style="color:#666">-&lt;/span> start_time&lt;span style="color:#70a0d0">:&lt;/span>&lt;span style="color:#4070a0">.4f&lt;/span>&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0"> seconds&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> wrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#555;font-weight:bold">@timer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">my_func&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time&lt;span style="color:#666">.&lt;/span>sleep(&lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>my_func()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Здесь мы определили функцию-обертку &lt;code>wrapper&lt;/code>, которая принимает любое количество позиционных и именованных аргументов и вызывает исходную функцию &lt;code>func&lt;/code> с этими аргументами. Затем мы измеряем время выполнения функции, выводим результат и возвращаем его.&lt;/p></description></item><item><title>Замыкания</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/closure/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/closure/</guid><description>&lt;p>Замыкание в Python - это функция, которая запоминает значения из внешней области видимости, даже если эта область видимости больше не существует. Таким образом, замыкание позволяет функции использовать переменные, которые были определены вне самой функции.&lt;/p>
&lt;p>Пример:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">outer_func&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">inner_func&lt;/span>(y):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> x &lt;span style="color:#666">+&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> inner_func
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>closure &lt;span style="color:#666">=&lt;/span> outer_func(&lt;span style="color:#40a070">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>result &lt;span style="color:#666">=&lt;/span> closure(&lt;span style="color:#40a070">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(result) &lt;span style="color:#60a0b0;font-style:italic"># выводит 15&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом примере &lt;code>outer_func&lt;/code> возвращает &lt;code>inner_func&lt;/code>, которая запоминает значение &lt;code>x&lt;/code>. Затем &lt;code>outer_func&lt;/code> вызывается, и возвращаемая функция сохраняется в &lt;code>closure&lt;/code>. Затем &lt;code>closure&lt;/code> вызывается с аргументом 5, и она использует сохраненное значение x (которое равно 10), чтобы вернуть результат 15.&lt;/p>
&lt;p>Замыкания могут быть полезны для создания функций, которые сохраняют состояние между вызовами, а также для создания функций, которые могут быть адаптированы к различным сценариям использования, например для создания функций, которые возвращают другие функции в зависимости от переданных аргументов.&lt;/p>
&lt;p>Ниже приведен другой пример замыкания, который возвращает функцию, которая будет умножать аргумент на заданное число:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">multiply_by&lt;/span>(num):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">multiplier&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">*&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> multiplier
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>double &lt;span style="color:#666">=&lt;/span> multiply_by(&lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>triple &lt;span style="color:#666">=&lt;/span> multiply_by(&lt;span style="color:#40a070">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(double(&lt;span style="color:#40a070">5&lt;/span>)) &lt;span style="color:#60a0b0;font-style:italic"># выводит 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(triple(&lt;span style="color:#40a070">5&lt;/span>)) &lt;span style="color:#60a0b0;font-style:italic"># выводит 15&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом примере &lt;code>multiply_by&lt;/code> возвращает функцию &lt;code>multiplier&lt;/code>, которая запоминает значение &lt;code>num&lt;/code>. Затем мы вызываем &lt;code>multiply_by&lt;/code> два раза с аргументами 2 и 3 соответственно, и сохраняем возвращаемые функции в переменных &lt;code>double&lt;/code> и &lt;code>triple&lt;/code>.&lt;/p>
&lt;p>Затем мы вызываем каждую из этих функций с аргументом 5, и каждая функция использует сохраненное значение &lt;code>num&lt;/code> (которое равно 2 для &lt;code>double&lt;/code> и 3 для &lt;code>triple&lt;/code>) для умножения аргумента и возврата результата.&lt;/p></description></item><item><title>Отладка Python</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/debugging/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/debugging/</guid><description>&lt;p>Python поставляется с собственным модулем отладчика, который называется &lt;strong>pdb&lt;/strong>. Этот модуль предоставляет интерактивный отладчик исходного кода для ваших программ на Python. Вы можете устанавливать брейкпоинты, просматривать код, изучать кадры стека и многое другое. Мы рассмотрим следующие аспекты этого модуля:&lt;/p>
&lt;p>Например, чтобы установить точку останова в коде, можно вставить следующую строку в месте, где вы хотите остановить выполнение программы:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>import pdb; pdb.set_trace()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>После запуска программы выполнение остановится на этой строке, и вы сможете использовать различные команды отладчика для изучения переменных и выполнения других операций.&lt;/p>
&lt;p>Также можно запустить python модуль в режиме отладчика:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>python3 -m pdb myscript.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Кроме встроенного отладчика Python, есть также сторонние инструменты, такие как PyCharm, Visual Studio Code и Eclipse, которые предоставляют расширенные функции отладки, такие как автоматическое определение ошибок и возможность управления отладкой из пользовательского интерфейса.&lt;/p>
&lt;p>Некоторые из основных команд &lt;code>pdb&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>break: установить точку останова в коде&lt;/li>
&lt;li>continue: продолжить исполнение программы до следующей точки останова&lt;/li>
&lt;li>step: перейти к следующей строке в коде, вызванной из текущей строки&lt;/li>
&lt;li>next: перейти к следующей строке в коде, не вызывая функции, если таковые имеются&lt;/li>
&lt;li>return: выполнить оставшуюся часть текущей функции и вернуться к вызывающей функции&lt;/li>
&lt;li>list: отобразить несколько строк кода вокруг текущей строки&lt;/li>
&lt;li>print: напечатать значение переменной&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Ресурсы:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.python.org/3/library/pdb.html">The Python Debugger&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Тестирование</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/testing/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/testing/</guid><description>&lt;h2 id="unittest">unittest&lt;/h2>
&lt;p>Python поставляется со встроенным модулем для тестирования - &lt;code>unittest&lt;/code>.&lt;/p>
&lt;p>Пример теста:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">unittest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">square&lt;/span>(x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> x &lt;span style="color:#666">*&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">TestSquare&lt;/span>(unittest&lt;span style="color:#666">.&lt;/span>TestCase):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">test_positive&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>assertEqual(square(&lt;span style="color:#40a070">2&lt;/span>), &lt;span style="color:#40a070">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>assertEqual(square(&lt;span style="color:#40a070">3&lt;/span>), &lt;span style="color:#40a070">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>assertEqual(square(&lt;span style="color:#40a070">4&lt;/span>), &lt;span style="color:#40a070">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">test_negative&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>assertEqual(square(&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">2&lt;/span>), &lt;span style="color:#40a070">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>assertEqual(square(&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">3&lt;/span>), &lt;span style="color:#40a070">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>assertEqual(square(&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">4&lt;/span>), &lt;span style="color:#40a070">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">if&lt;/span> __name__ &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unittest&lt;span style="color:#666">.&lt;/span>main()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>В этом примере мы создаем тестовый класс &lt;code>TestSquare&lt;/code>, который наследуется от &lt;code>unittest.TestCase&lt;/code>. В этом классе мы определяем два метода: &lt;code>test_positive&lt;/code> и &lt;code>test_negative&lt;/code>. Эти методы используют метод &lt;code>assertEqual&lt;/code> для проверки ожидаемых результатов.&lt;/p>
&lt;p>Метод &lt;code>assertEqual&lt;/code> сравнивает два значения и генерирует исключение, если они не равны. Если тест проходит успешно, то мы не получаем никаких сообщений.&lt;/p>
&lt;p>Запуск тестов можно выполнить из командной строки с помощью следующей команды:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>python test_square.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Да, в модуле &lt;code>unittest&lt;/code> есть возможность делать моки с помощью встроенного класса &lt;code>unittest.mock.Mock&lt;/code>. Это позволяет заменить реальный объект на имитацию, чтобы упростить тестирование и избежать внешних зависимостей.&lt;/p>
&lt;p>Вот пример, который демонстрирует, как можно использовать моки в &lt;code>unittest&lt;/code> для тестирования функции, которая зависит от внешнего сервиса:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">unittest&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> TestCase, mock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">get_external_data&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Это внешний сервис, который может вернуть много данных&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Но для тестирования нас интересует только первый элемент&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> [&lt;span style="color:#4070a0">&amp;#39;data1&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;data2&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;data3&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">process_data&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data &lt;span style="color:#666">=&lt;/span> get_external_data()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> data[&lt;span style="color:#40a070">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">TestProcessData&lt;/span>(TestCase):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#555;font-weight:bold">@mock.patch&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;__main__.get_external_data&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">test_process_data&lt;/span>(self, mock_get_external_data):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mock_get_external_data&lt;span style="color:#666">.&lt;/span>return_value &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#4070a0">&amp;#39;test_data1&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;test_data2&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;test_data3&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> process_data()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>assertEqual(result, &lt;span style="color:#4070a0">&amp;#39;test_data1&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Здесь мы используем декоратор &lt;code>@mock.patch&lt;/code> для замены реального &lt;code>get_external_data&lt;/code> на имитацию. В тесте мы устанавливаем возвращаемое значение имитации и проверяем, что функция &lt;code>process_data&lt;/code> вернула ожидаемый результат.&lt;/p>
&lt;p>&lt;strong>Ресурсы:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.python.org/3/library/unittest.html">Документация по unittest&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>