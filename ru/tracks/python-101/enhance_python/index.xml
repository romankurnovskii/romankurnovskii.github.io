<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>III - Расширенные возможности on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/</link><description>Recent content in III - Расширенные возможности on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Tue, 28 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tracks/python-101/enhance_python/index.xml" rel="self" type="application/rss+xml"/><item><title>Лямбда</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/lambda/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/lambda/</guid><description>Лямбда-функции в Python - это безымянные функции, которые можно определить в одной строке и не требуют ключевого слова def. Они используются для написания коротких функций внутри других функций или выражений, где требуется функция в качестве аргумента.
Лямбда-функция определяется ключевым словом lambda, за которым следуют параметры функции, после чего через двоеточие указывается выражение, которое нужно вернуть из функции.
Пример:
add = lambda x, y: x + y print(add(2, 3)) # Output: 5 Здесь мы определяем лямбда-функцию add, которая принимает два аргумента x и y и возвращает их сумму.</description></item><item><title>Декораторы</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/decorators/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/decorators/</guid><description>Декораторы в Python позволяют изменять поведение функций и методов, оборачивая их в другую функцию. В этом разделе мы рассмотрим несколько встроенных декораторов и создание собственного декоратора.
@classmethod Декоратор @classmethod используется для создания методов класса в Python. Методы класса имеют доступ к состоянию класса и могут использоваться без необходимости создания экземпляра класса. Методы класса можно вызывать как от самого класса, так и от его экземпляров.
Декоратор @classmethod применяется к методам класса. Он принимает первым аргументом класс (cls) вместо экземпляра класса (self).</description></item><item><title>Замыкания</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/closure/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/closure/</guid><description>Замыкание в Python - это функция, которая запоминает значения из внешней области видимости, даже если эта область видимости больше не существует. Таким образом, замыкание позволяет функции использовать переменные, которые были определены вне самой функции.
Пример:
def outer_func(x): def inner_func(y): return x + y return inner_func closure = outer_func(10) result = closure(5) print(result) # выводит 15 В этом примере outer_func возвращает inner_func, которая запоминает значение x. Затем outer_func вызывается, и возвращаемая функция сохраняется в closure. Затем closure вызывается с аргументом 5, и она использует сохраненное значение x (которое равно 10), чтобы вернуть результат 15.</description></item><item><title>Отладка Python</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/debugging/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/debugging/</guid><description>Python поставляется с собственным модулем отладчика, который называется pdb. Этот модуль предоставляет интерактивный отладчик исходного кода для ваших программ на Python. Вы можете устанавливать брейкпоинты, просматривать код, изучать кадры стека и многое другое. Мы рассмотрим следующие аспекты этого модуля:
Например, чтобы установить точку останова в коде, можно вставить следующую строку в месте, где вы хотите остановить выполнение программы:
import pdb; pdb.set_trace() После запуска программы выполнение остановится на этой строке, и вы сможете использовать различные команды отладчика для изучения переменных и выполнения других операций.</description></item><item><title>Тестирование</title><link>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/testing/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/python-101/enhance_python/testing/</guid><description>unittest Python поставляется со встроенным модулем для тестирования - unittest.
Пример теста:
import unittest def square(x): return x * x class TestSquare(unittest.TestCase): def test_positive(self): self.assertEqual(square(2), 4) self.assertEqual(square(3), 9) self.assertEqual(square(4), 16) def test_negative(self): self.assertEqual(square(-2), 4) self.assertEqual(square(-3), 9) self.assertEqual(square(-4), 16) if __name__ == &amp;#39;__main__&amp;#39;: unittest.main() В этом примере мы создаем тестовый класс TestSquare, который наследуется от unittest.TestCase. В этом классе мы определяем два метода: test_positive и test_negative. Эти методы используют метод assertEqual для проверки ожидаемых результатов.
Метод assertEqual сравнивает два значения и генерирует исключение, если они не равны.</description></item></channel></rss>