<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Карманная книга по WebRTC on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/tracks/webrtc/</link><description>Recent content in Карманная книга по WebRTC on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Sat, 02 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/tracks/webrtc/index.xml" rel="self" type="application/rss+xml"/><item><title>Мультимедиа-устройства</title><link>https://romankurnovskii.com/ru/tracks/webrtc/media-devices/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/media-devices/</guid><description>&lt;h2 id="мультимедиа-устройства">Мультимедиа-устройства&lt;/h2>
&lt;h3 id="начало-работы-с-мультимедийными-устройствами">Начало работы с мультимедийными устройствами&lt;/h3>
&lt;p>При web-разработке WebRTC-стандарт предоставляет API для доступа к камерам и микрофонам, подключенным к компьютеру или смартфону. Эти устройства обычно называются мультимедийными устройствами, и к ним можно получить доступ с помощью Java-скрипта через объект navigator.mediaDevices, который реализует интерфейс MediaDevices. С помощью этого объекта мы можем просмотреть все подключенные устройства, отслеживать изменения статуса устройства (когда устройство подключается или отключается) и открывать устройство для извлечения мультимедийного потока (см. ниже).
Чаще всего для этого используют функцию getUserMedia(), которая возвращает промис, который будет преобразован в MediaStream для соответствующих мультимедийных устройств. Эта функция принимает один объект MediaStreamConstraints, который определяет имеющиеся требования. Например, чтобы просто открыть микрофон и камеру по умолчанию, мы должны сделать следующее:&lt;/p>
&lt;p>&lt;em>Через промисы:&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> constraints &lt;span style="color:#666">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;video&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;audio&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>navigator.mediaDevices.getUserMedia(constraints)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .then(stream =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.log(&lt;span style="color:#4070a0">&amp;#39;Got MediaStream:&amp;#39;&lt;/span>, stream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#007020;font-weight:bold">catch&lt;/span>(error =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.error(&lt;span style="color:#4070a0">&amp;#39;Error accessing media devices.&amp;#39;&lt;/span>, error);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>Через async/await&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> openMediaDevices &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">async&lt;/span> (constraints) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> navigator.mediaDevices.getUserMedia(constraints);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> stream &lt;span style="color:#666">=&lt;/span> openMediaDevices({&lt;span style="color:#4070a0">&amp;#39;video&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span>&lt;span style="color:#007020;font-weight:bold">true&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;audio&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span>&lt;span style="color:#007020;font-weight:bold">true&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.log(&lt;span style="color:#4070a0">&amp;#39;Got MediaStream:&amp;#39;&lt;/span>, stream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#007020;font-weight:bold">catch&lt;/span>(error) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.error(&lt;span style="color:#4070a0">&amp;#39;Error accessing media devices.&amp;#39;&lt;/span>, error);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Обращение к &lt;code>getUserMedia()&lt;/code> запускает запрос на разрешение. Если пользователь одобряет запрос, промис разрешает MediaStream, содержащий одну видео и одну аудио дорожку. Если запрос отклонен, появляется PermissionDeniedError. Если же нет подключенных устройств, появляется NotFoundError.
Полный список API для интерфейса MediaDevices доступен по ссылке &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices">https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices&lt;/a>&lt;/p>
&lt;h2 id="обращение-к-мультимедиа-устройствам">Обращение к мультимедиа-устройствам&lt;/h2>
&lt;p>В более сложных приложениях, мы скорее всего захотим проверить все подключенные камеры и микрофоны и дать соответствующий отчет пользователю. Это можно сделать через запрос функции enumerateDevices(). Она возвращает промис, который преобразуется в массив MediaDevicesInfo, описывающий каждое известное мультимедиа-устройство. Через него мы можем предоставить пользовательский интерфейс пользователю, который позволит выбрать те или иные устройства. Каждый список MediaDevicesInfo содержит свойства, которые называются kind с значениями audioinput, audiooutput или videoinput, отражая, какой это тип мультимедиа-устройства.&lt;/p>
&lt;p>&lt;em>Через промисы&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">function&lt;/span> getConnectedDevices(type, callback) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> navigator.mediaDevices.enumerateDevices()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .then(devices =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> filtered &lt;span style="color:#666">=&lt;/span> devices.filter(device =&amp;gt; device.kind &lt;span style="color:#666">===&lt;/span> type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> callback(filtered);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>getConnectedDevices(&lt;span style="color:#4070a0">&amp;#39;videoinput&amp;#39;&lt;/span>, cameras =&amp;gt; console.log(&lt;span style="color:#4070a0">&amp;#39;Cameras found&amp;#39;&lt;/span>, cameras));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>через async/await&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">async&lt;/span> &lt;span style="color:#007020;font-weight:bold">function&lt;/span> getConnectedDevices(type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> devices &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> navigator.mediaDevices.enumerateDevices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> devices.filter(device =&amp;gt; device.kind &lt;span style="color:#666">===&lt;/span> type)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> videoCameras &lt;span style="color:#666">=&lt;/span> getConnectedDevices(&lt;span style="color:#4070a0">&amp;#39;videoinput&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>console.log(&lt;span style="color:#4070a0">&amp;#39;Cameras found:&amp;#39;&lt;/span>, videoCameras);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="отслеживание-изменений-в-статусах-устройств">Отслеживание изменений в статусах устройств&lt;/h2>
&lt;p>Большинство компьютеров поддерживают подключение различных устройств прямо во время работы. Это может быть веб-камера, подключенная через USB, Bluetooth-гарнитура или внешние динамики. Чтобы должным образом поддерживать все это, веб-приложение должно отслеживать изменения в статусах мультимедиа-устройств. Это можно сделать, добавив «отслеживатель» в navigator.mediaDevices для события devicechange.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Updates the select element with the provided set of cameras
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">function&lt;/span> updateCameraList(cameras) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> listElement &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="">‘&lt;/span>select&lt;span style="">#&lt;/span>availableCameras&lt;span style="">’&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listElement.innerHTML &lt;span style="color:#666">=&lt;/span> &lt;span style="">‘’&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cameras.map(camera =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> cameraOption &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.createElement(&lt;span style="">‘&lt;/span>option&lt;span style="">’&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cameraOption.label &lt;span style="color:#666">=&lt;/span> camera.label;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cameraOption.value &lt;span style="color:#666">=&lt;/span> camera.deviceId;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }).forEach(cameraOption =&amp;gt; listElement.add(cameraOption));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Fetch an array of devices of a certain type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">async&lt;/span> &lt;span style="color:#007020;font-weight:bold">function&lt;/span> getConnectedDevices(type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> devices &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> navigator.mediaDevices.enumerateDevices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> devices.filter(device =&amp;gt; device.kind &lt;span style="color:#666">===&lt;/span> type)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Get the initial set of cameras connected
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> videoCameras &lt;span style="color:#666">=&lt;/span> getConnectedDevices(&lt;span style="">‘&lt;/span>videoinput&lt;span style="">’&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>updateCameraList(videoCameras);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Listen for changes to media devices and update the list accordingly
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>navigator.mediaDevices.addEventListener(&lt;span style="">‘&lt;/span>devicechange&lt;span style="">’&lt;/span>, event =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> newCameraList &lt;span style="color:#666">=&lt;/span> getConnectedDevices(&lt;span style="">‘&lt;/span>video&lt;span style="">’&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updateCameraList(newCameraList);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ограничения-для-мультимедиа">Ограничения для мультимедиа&lt;/h2>
&lt;p>Объект ограничений, осуществляющий интерфейс MediaStreamConstraints и который мы отправляем в качестве параметра в getUserMedia(), позволяет нам открывать мультимедиа-устройство, которое отвечает определенным требованиям. Эти требования могут быть как очень расплывчатыми (аудио и/или видео), так и очень специфичными (минимальное разрешение камеры или точный ID устройства). Рекомендуем, чтобы приложения, использующие &lt;code>getUserMedia()&lt;/code> API, сначала проверяли существующие устройства, а затем определяли ограничения, которые соответствуют точному устройству через deviceID-ограничение. Устройства, по возможности, будут настроены в соответствии с ограничениями. Мы можем включить эхоподавление на микрофоне, установить определенную или минимальную ширину и высоту видео с камеры.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">async&lt;/span> &lt;span style="color:#007020;font-weight:bold">function&lt;/span> getConnectedDevices(type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> devices &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> navigator.mediaDevices.enumerateDevices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> devices.filter(device =&amp;gt; device.kind &lt;span style="color:#666">===&lt;/span> type)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Open camera with at least minWidth and minHeight capabilities
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">async&lt;/span> &lt;span style="color:#007020;font-weight:bold">function&lt;/span> openCamera(cameraId, minWidth, minHeight) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> constraints &lt;span style="color:#666">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;audio&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> {&lt;span style="color:#4070a0">&amp;#39;echoCancellation&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;video&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;deviceId&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> cameraId,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;width&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> {&lt;span style="color:#4070a0">&amp;#39;min&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> minWidth},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;height&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> {&lt;span style="color:#4070a0">&amp;#39;min&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> minHeight}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> navigator.mediaDevices.getUserMedia(constraints);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> cameras &lt;span style="color:#666">=&lt;/span> getConnectedDevices(&lt;span style="color:#4070a0">&amp;#39;videoinput&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">if&lt;/span> (cameras &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> cameras.length &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Open first available video camera with a resolution of 1280x720 pixels
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> stream &lt;span style="color:#666">=&lt;/span> openCamera(cameras[&lt;span style="color:#40a070">0&lt;/span>].deviceId, &lt;span style="color:#40a070">1280&lt;/span>, &lt;span style="color:#40a070">720&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Полную документацию для интерфейса MediaStreamConstraints можно найти по ссылке: &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints">https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints&lt;/a>&lt;/p>
&lt;h2 id="локальное-воспроизведение">Локальное воспроизведение&lt;/h2>
&lt;p>Как только мультимедиа-устройство открыто и есть доступный MediaStream, мы можем назначить его для его видео- или аудио-элемента локальное воспроизведение потока.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">async&lt;/span> &lt;span style="color:#007020;font-weight:bold">function&lt;/span> playVideoFromCamera() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> constraints &lt;span style="color:#666">=&lt;/span> {&lt;span style="color:#4070a0">&amp;#39;video&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;audio&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> stream &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> navigator.mediaDevices.getUserMedia(constraints);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> videoElement &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="color:#4070a0">&amp;#39;video#localVideo&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> videoElement.srcObject &lt;span style="color:#666">=&lt;/span> stream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#007020;font-weight:bold">catch&lt;/span>(error) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.error(&lt;span style="color:#4070a0">&amp;#39;Error opening video camera.&amp;#39;&lt;/span>, error);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Обычно код HTML, необходимый для типичного видео-элемента с getUserMedia(), имеет атрибуты autoplay и playsinline. Атрибут autoplay запускает воспроизведение новых потоков, связанных с элементом, автоматически. Атрибут playsinline позволяет проигрывать встроенное видео вместо видео на весь экран, в некоторых мобильных браузерах. Также рекомендуем использовать controls = “false” для прямых эфиров, если у пользователя нет необходимости ставить их на паузу.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#062873;font-weight:bold">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#062873;font-weight:bold">head&lt;/span>&amp;gt;&amp;lt;&lt;span style="color:#062873;font-weight:bold">title&lt;/span>&amp;gt;Local video playback&amp;lt;/&lt;span style="color:#062873;font-weight:bold">video&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#062873;font-weight:bold">head&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#062873;font-weight:bold">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#062873;font-weight:bold">video&lt;/span> &lt;span style="color:#4070a0">id&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;localVideo&amp;#34;&lt;/span> &lt;span style="color:#4070a0">autoplay&lt;/span> &lt;span style="color:#4070a0">playsinline&lt;/span> &lt;span style="color:#4070a0">controls&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;false&amp;#34;&lt;/span>/&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#062873;font-weight:bold">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#062873;font-weight:bold">html&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Захват мультимедиа и ограничения</title><link>https://romankurnovskii.com/ru/tracks/webrtc/media-capture-and-constraints/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/media-capture-and-constraints/</guid><description>&lt;h3 id="захват-мультимедиа-и-ограничения">Захват мультимедиа и ограничения&lt;/h3>
&lt;p>Мультимедиа-часть WebRTC показывает, как получить доступ к оборудованию, способному записывать видео и аудио (например, камеры и микрофоны), а также как работают медиа-потоки. И помимо этого – средства отображения, которые позволяют делать захват экрана.&lt;/p>
&lt;h2 id="мультимедиа-устройства">Мультимедиа-устройства&lt;/h2>
&lt;p>Все камеры и микрофоны, поддерживаемые браузером, доступны и управляются через объект navigator.mediaDevices. Приложения могут получать текущий список подсоединенных устройств и отслеживать изменения, т.к. многие камеры и микрофоны подсоединены через USB, и могут подключаться/отключаться в течение работы приложения. Поскольку статус мультимедиа-устройства может меняться в любой момент времени, рекомендуем, чтоб приложения регистрировали все изменения в статусе устройства для правильной обработки статусов изменений.&lt;/p>
&lt;h2 id="ограничения">Ограничения&lt;/h2>
&lt;p>При получении доступа к мультимедиа-устройствам, хорошо бы обеспечить настолько подробные ограничения, насколько это возможно. И хотя можно открыть камеру и микрофон по умолчанию с простым ограничением, это может привести к тому, что медиапоток будет далеко не самым оптимальным для приложения.&lt;/p>
&lt;p>Конкретные ограничения определяются в объекте &lt;code>MediaTrackConstraint&lt;/code> (одно для аудио, одно для видео). Атрибуты в этом объекте типа &lt;code>ConstraintLong&lt;/code>, &lt;code>ConstraintBoolean&lt;/code>, &lt;code>ConstraintDouble&lt;/code> или &lt;code>ConstraintDOMString&lt;/code>. Данные могут быть как конкретным значением (например, число, Boolean или String), диапазоном (LongRange или DoubleRange с минимальным и максимальным значением) или объектом c ideal или exact определением. Для конкретных значений браузер будет пытаться выбрать что-то наиболее близкое. Для диапазонных будет использоваться лучшее значение из диапазона. Для exact – будет передаваться только тот медиа-поток, который точно соответствует заданным ограничениям.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>NEAR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// Camera with a resolution as close to 640x480 as possible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;video&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;width&amp;#34;: 640,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;height&amp;#34;: 480
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// Camera with a resolution in the range 640x480 to 1024x768
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;video&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;width&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;min&amp;#34;: 640,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;max&amp;#34;: 1024
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;height&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;min&amp;#34;: 480,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;max&amp;#34;: 768
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EXACT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// Camera with the exact resolution of 1024x768
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;video&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;width&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;exact&amp;#34;: 1024
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;height&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;exact&amp;#34;: 768
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Чтобы определить актуальную конфигурацию конкретной дорожки медиа-потока, мы можем воспользоваться запросом &lt;code>MediaStreamTrack.getSettings()&lt;/code>, который возвращает набор настроек &lt;strong>MediaTrackSettings&lt;/strong>, используемых в данные момент.&lt;/p>
&lt;p>Также можно обновить ограничения дорожки с мультимедиа-устройства, которое открываем через &lt;code>applyConstraints()&lt;/code>. Это позволяет приложению перенастроить устройство без прерывания текущего потока.&lt;/p>
&lt;h2 id="захват-экрана">Захват экрана&lt;/h2>
&lt;p>Приложение, которое потенциально может выполнять захват и запись экрана, должно использовать &lt;strong>Display Media API&lt;/strong>. Функция &lt;code>getDisplayMedia()&lt;/code> (которая является частью navigator.mediaDevices), аналогична &lt;code>getUserMedia()&lt;/code> и используется, чтобы открыть содержимое дисплея (или его части, например, окна). Возвращенный &lt;strong>MediaStream&lt;/strong> работает также, как при использовании &lt;code>getUserMedia()&lt;/code>.&lt;/p>
&lt;p>Ограничения для getDisplayMedia() отличаются от ограничений, используемых для обычных входящих видео- и аудио-потоков.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> video: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor: ‘always’ | ‘motion’ | ‘never’,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> displaySurface: ‘application’ | ‘browser’ | ‘monitor’ | ‘window’
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Фрагмент кода выше показывает, как работают специальные ограничения для записи экрана. Обратите внимание, что они могут не поддерживаться некоторыми браузерами, поддерживающими отображение мультимедиа.&lt;/p>
&lt;h2 id="потоки-и-дорожки">Потоки и дорожки&lt;/h2>
&lt;p>MediaStream представляет собой поток медиаконтента, который состоит из аудио- и видео- дорожек (&lt;strong>MediaStreamTrack&lt;/strong>). Можно достать все дорожки из MediaStream, вызвав команду &lt;code>MediaStream.getTracks()&lt;/code>, которая возвращает массив объектов из &lt;strong>MediaStreamTrack&lt;/strong>.&lt;/p>
&lt;h2 id="mediastreamtrack">MediaStreamTrack&lt;/h2>
&lt;p>MediaStreamTrack обладает свойством &lt;strong>kind&lt;/strong> (audio или video, указывающий тип мультимедиа, который он воспроизводит). Каждую дорожку можно выключить, переключив ее свойство &lt;strong>enabled&lt;/strong>. У дорожки есть логическое свойство remote, которое показывает, является ли она источником &lt;code>RTCPeerConnection&lt;/code> и идет ли она от удаленного узла.&lt;/p></description></item><item><title>Одноранговые соединения</title><link>https://romankurnovskii.com/ru/tracks/webrtc/peer-connections/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/peer-connections/</guid><description>&lt;h2 id="начало-работы-с-одноранговыми-соединениями">Начало работы с одноранговыми соединениями&lt;/h2>
&lt;p>Одноранговые соединения – часть спецификации WebRTC, которая занимается связью двух приложений на различных компьютерах для коммуникации через P2P-протокол. Коммуникация между узлами может быть видео-, аудио- или произвольными двоичными данными (для клиентов, поддерживающих RTCDataChannel API). Чтобы выяснить, как два узла могут быть соединены, оба клиента должны предоставить конфигурацию ICE-Server. Это или STUN, или TURN-сервер, и их роль – обеспечить ICE-кандидатов для каждого клиента, который затем передается на удаленный узел. Эта «передача» ICE-кандидатов обычно называется «сигналинг».&lt;/p>
&lt;h2 id="сигналинг">Сигналинг&lt;/h2>
&lt;p>Спецификации WebRTC включают API для коммуникации с ICE-сервером (ICE =Internet Connectivity Establishment, установление интерактивного подключения), но компонент сигналинга не является частью этого сервера. Сигналинг необходим, чтобы два узла могли использовать один и тот же способ подключения. Обычно это можно решить через обычный Web API на базе HTTP (то есть службу REST или другой механизм RPC), где веб-приложения могут передавать необходимую информацию до того, как будет установлено соединение.
Следующий фрагмент кода показывает, как эту придуманную службу сигналинга можно использовать для отправки и получения асинхронных сообщений. Мы будем использовать по необходимости этот прием в оставшихся примерах в этом гайде.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Set up an asynchronous communication channel that will be
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// used during the peer connection setup
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> signalingChannel &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> SignalingChannel(remoteClientId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signalingChannel.addEventListener(&lt;span style="color:#4070a0">&amp;#39;message&amp;#39;&lt;/span>, message =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// New message from remote client received
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Send an asynchronous message to the remote client
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>signalingChannel.send(&lt;span style="color:#4070a0">&amp;#39;Hello!&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Сигналинг может быть реализован разными способами, и спецификация WebRTC не отдает предпочтений какому-то определенному варианту.&lt;/p>
&lt;h2 id="инициирование-одноранговых-соединений">Инициирование одноранговых соединений&lt;/h2>
&lt;p>Каждое одноранговое соединение управляется объектом RTCPeerConnection. Конструктор для этого класса берет в качестве параметра одиночный объект RTCConfiguration. Этот объект определяет, как одноранговое соединение устанавливается, и какую информацию должен содержать об используемых ICE-серверах.&lt;/p>
&lt;p>После того, как RTCPeerConnection установлено, мы должны задать SDP-запрос/ответ, в зависимости от того, являемся мы вызывающим или принимающим узлом. После того, как SDP-запрос/ответ создан, он должен быть отправлен на удаленный узел через другой канал. Передача SDP-объектов на удаленные узлы называется сигналингом и не рассматривается в WebRTC спецификации.&lt;/p>
&lt;p>Для установки однорангового соединения с вызывающей стороны, мы создаем объект RTCPeerConnection, и затем вызываем createOffer() для создания объекта RTCSessionDescription. Описание этого сеанса устанавливается как локальное описание с использованием setLocalDescription(), и затем отправляется через наш сигналинг-канал получающей стороне. Мы также устанавливаем «прослушиватель» для нашего сигналинг-канала, чтобы знать, когда получающей стороной будет получен ответ на описание нашего запрошенного сеанса.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">async&lt;/span> &lt;span style="color:#007020;font-weight:bold">function&lt;/span> makeCall() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> configuration &lt;span style="color:#666">=&lt;/span> {&lt;span style="color:#4070a0">&amp;#39;iceServers&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> [{&lt;span style="color:#4070a0">&amp;#39;urls&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#4070a0">&amp;#39;stun:stun.l.google.com:19302&amp;#39;&lt;/span>}]}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> peerConnection &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCPeerConnection(configuration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> signalingChannel.addEventListener(&lt;span style="color:#4070a0">&amp;#39;message&amp;#39;&lt;/span>, &lt;span style="color:#007020;font-weight:bold">async&lt;/span> message =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (message.answer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> remoteDesc &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCSessionDescription(message.answer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> peerConnection.setRemoteDescription(remoteDesc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> offer &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> peerConnection.createOffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> peerConnection.setLocalDescription(offer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> signalingChannel.send({&lt;span style="color:#4070a0">&amp;#39;offer&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> offer});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>На получающей стороне мы ждем входящий запрос до того, как мы создали пример RTCPeerConnection. После этого мы устанавливаем полученный запрос, используя setRemoteDescription().&lt;/p>
&lt;p>Далее, мы делаем запрос createAnswer() для создания ответа на полученный запрос. Этот ответ устанавливается как локальное описание через использование setLocalDescription() и затем отправляется набирающей стороне через наш сигналинг-сервер.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> peerConnection &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCPeerConnection(configuration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signalingChannel.addEventListener(&lt;span style="color:#4070a0">&amp;#39;message&amp;#39;&lt;/span>, &lt;span style="color:#007020;font-weight:bold">async&lt;/span> message =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (message.offer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> peerConnection.setRemoteDescription(&lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCSessionDescription(message.offer));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> answer &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> peerConnection.createAnswer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> peerConnection.setLocalDescription(answer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> signalingChannel.send({&lt;span style="color:#4070a0">&amp;#39;answer&amp;#39;&lt;/span>&lt;span style="color:#666">:&lt;/span> answer});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Как только два узла установили описания и локального, и удаленного сеансов, становятся доступны возможности удаленного узла. Это еще не означает, что соединение между узлами готово. Для работы необходимо собрать ICE-кандидатов на каждом узле и передать (по сигналинг-каналу) другому узлу.&lt;/p>
&lt;h2 id="ice-кандидаты">ICE-кандидаты&lt;/h2>
&lt;p>До того, как два узла смогут коммуницировать через WebRTC, им необходимо обменяться информацией о подключении. Так как условия сети могут отличаться в зависимости от ряда факторов, для обнаружения возможных кандидатов на соединение с узлом обычно используется внешний сервис.
Этот сервис называется ICE и использует серверы STUN или TURN. STUN – это аббревиатура от Session Traversal for NAT, и обычно косвенно используется в большинстве WebRTC приложениях.&lt;/p>
&lt;p>TURN (Traversal Using Relay NAT) более продвинутое решение, которое включает в себя протоколы STUN, и большинство коммерческих служб WebRTC используют TURN сервер для установки соединения между узлами.&lt;/p>
&lt;p>API WebRTC напрямую поддерживает как STUN, так и TURN, и объединяется под более полным термином ICE (Internet Connectivity Establishment - «Установление подключения к Интернету»). При установке WebRTC-соединения мы обычно предоставляем один или несколько ICE-серверов в конфигурации для объекта RTCPeerConnection.&lt;/p>
&lt;h2 id="trickle-ice">Trickle ICE&lt;/h2>
&lt;p>После создания объекта RTCPeerConnection, исходный фреймворк использует предоставленные ICE-серверы для сбора кандидатов на установление соединения (кандидатов ICE).&lt;/p>
&lt;p>Событие icegatheringstatechange на RTCPeerConnection передает информацию о том, в каком состоянии находится ICE-сбор (new, gathering или complete).
Несмотря на то, что для узла возможно просто дождаться, пока ICE-сбор будет завершен, обычно гораздо эффективнее использовать метод «trickle ice» и передавать каждого вновь обнаруженного ICE-кандидата удаленному узлу. Это значительно сократит время настройки однорангового соединения и позволит начать видео-звонок с меньшими задержками.&lt;/p>
&lt;p>Для сбора ICE-кандидатов, просто добавьте «прослушиватель» в событие icecandidate. Объект RTCPeerConnectionIceEvent, созданный этим «прослушивателем», будет содержать свойство candidate, представляющее нового кандидата, которого нужно отправить удаленному узлу (см. Сигналинг)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Listen for local ICE candidates on the local RTCPeerConnection
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>peerConnection.addEventListener(&lt;span style="">‘&lt;/span>icecandidate&lt;span style="">’&lt;/span>, event =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (event.candidate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> signalingChannel.send({&lt;span style="">‘&lt;/span>&lt;span style="color:#007020;font-weight:bold">new&lt;/span>&lt;span style="color:#666">-&lt;/span>ice&lt;span style="color:#666">-&lt;/span>candidate&lt;span style="">’&lt;/span>&lt;span style="color:#666">:&lt;/span> event.candidate});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Listen for remote ICE candidates and add them to the local RTCPeerConnection
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>signalingChannel.addEventListener(&lt;span style="">‘&lt;/span>message&lt;span style="">’&lt;/span>, &lt;span style="color:#007020;font-weight:bold">async&lt;/span> message =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (message.iceCandidate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> peerConnection.addIceCandidate(message.iceCandidate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#007020;font-weight:bold">catch&lt;/span> &lt;span style="">€&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> console.error(&lt;span style="">‘&lt;/span>&lt;span style="color:#007020">Error&lt;/span> adding received ice candidate&lt;span style="">’&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="соединение-установлено">Соединение установлено&lt;/h2>
&lt;p>После того, как ICE-кандидаты получены, нужно дождаться, пока состояние нашего однорангового соединения изменится на подключенное состояние. Чтобы отследить это, добавим «прослушиватель» в наш RTCPeerConnection, где можно просматривать изменения события connectionstatechange.&lt;/p></description></item><item><title>Удаленные потоки</title><link>https://romankurnovskii.com/ru/tracks/webrtc/remote-streams/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/remote-streams/</guid><description>&lt;h2 id="начало-работы-с-удаленными-потоками">Начало работы с удаленными потоками&lt;/h2>
&lt;p>Как только RTCPeerConnection подключился к удаленному узлу, между ними можно передавать аудио- и видео-потоки. Это точка, в которой мы подключаем поток, полученный от getUserMedia(), к RTCPeerConnection. Медиаопоток состоит как минимум из одной дорожки мультимедиа, и они по отдельности добавляются в RTCPeerConnection, когда мы хотим передать данные удаленному узлу.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> localStream &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">await&lt;/span> getUserMedia({vide&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>, audio&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#007020;font-weight:bold">true&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> peerConnection &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCPeerConnection(iceConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>localStream.getTracks().forEach(track =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> peerConnection.addTrack(track, localStream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Дорожки можно добавлять в RTCPeerConnection до подключения к удаленному узлу, поэтому имеет смысл выполнить эту настройку как можно раньше, а не ждать завершения соединения.&lt;/p>
&lt;h2 id="добавление-удаленных-дорожек">Добавление удаленных дорожек&lt;/h2>
&lt;p>Для получения удаленных дорожек, которые были добавлены другим узлом, мы регистрируем «прослушиватель» на локальном RTCPeerConnection, отслеживая изменения в событии track. RTCTrackEvent содержит массив объектов MediaStream, которые имеют те же значения MediaStream.id, что и соответствующие локальные потоки узла. В нашем примере каждая дорожка связана только с одним потоком.&lt;/p>
&lt;p>Обратите внимание, что, хотя ID из MediaStream совпадают на обеих сторонах однорангового соединения, в общем случае это не работает для ID MediaStreamTrack.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> remoteVideo &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="color:#4070a0">&amp;#39;#remoteVideo&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>peerConnection.addEventListener(&lt;span style="color:#4070a0">&amp;#39;track&amp;#39;&lt;/span>, &lt;span style="color:#007020;font-weight:bold">async&lt;/span> (event) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> [remoteStream] &lt;span style="color:#666">=&lt;/span> event.streams;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remoteVideo.srcObject &lt;span style="color:#666">=&lt;/span> remoteStream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Каналы данных</title><link>https://romankurnovskii.com/ru/tracks/webrtc/data-channels/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/data-channels/</guid><description>&lt;p>Стандарт WebRTC также охватывает API для отправки произвольных данных через RTCPeerConnection. Это происходит через запрос createDataChannel() для объекта RTCPeerConnection, который возвращает объект RTCDataChannel.&lt;/p>
&lt;p>const peerConnection = new RTCPeerConnection(configuration);
const dataChannel = peerConnection.createDataChannel();&lt;/p>
&lt;p>Удаленный узел может получать каналы данных через отслеживание события datachannel в объекте RTCPeerConnection. Полученное событие имеет тип RTCDataChannelEvent и содержит свойство channel, которое представляет RTCDataChannel между двумя узлами.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> peerConnection &lt;span style="color:#666">=&lt;/span> new RTCPeerConnection(configuration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>peerConnection&lt;span style="color:#666">.&lt;/span>addEventListener(&lt;span style="color:#4070a0">&amp;#39;datachannel&amp;#39;&lt;/span>, event &lt;span style="color:#666">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> dataChannel &lt;span style="color:#666">=&lt;/span> event&lt;span style="color:#666">.&lt;/span>channel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="события-open-и-close">События Open и Close&lt;/h2>
&lt;p>Прежде чем канал данных можно будет использовать для отправки данных, клиент должен дождаться его открытия. Это происходит через прослушивание события open. Точно так же существует событие close, когда одна из сторон закрывает канал.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> messageBox &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="color:#4070a0">&amp;#39;#messageBox&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> sendButton &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="color:#4070a0">&amp;#39;#sendButton&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> peerConnection &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCPeerConnection(configuration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> dataChannel &lt;span style="color:#666">=&lt;/span> peerConnection.createDataChannel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Enable textarea and button when opened
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>dataChannel.addEventListener(&lt;span style="color:#4070a0">&amp;#39;open&amp;#39;&lt;/span>, event =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> messageBox.disabled &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> messageBox.focus();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sendButton.disabled &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Disable input when closed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>dataChannel.addEventListener(&lt;span style="color:#4070a0">&amp;#39;close&amp;#39;&lt;/span>, event =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> messageBox.disabled &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sendButton.disabled &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="сообщения">Сообщения&lt;/h2>
&lt;p>Отправка сообщения в RTCDataChannel выполняется через вызов функции send() с данными, которые мы хотим отправить. Параметр data для этой функции может быть типа String, Blob, ArrayBuffer или ArrayBufferView.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> messageBox &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="color:#4070a0">&amp;#39;#messageBox&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> sendButton &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="color:#4070a0">&amp;#39;#sendButton&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Send a simple text message when we click the button
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>sendButton.addEventListener(&lt;span style="color:#4070a0">&amp;#39;click&amp;#39;&lt;/span>, event =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> message &lt;span style="color:#666">=&lt;/span> messageBox.textContent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dataChannel.send(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Удаленный узел будет получать сообщения, отправленные на RTCDataChannel, через отслеживание события message.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> incomingMessages &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">document&lt;/span>.querySelector(&lt;span style="color:#4070a0">&amp;#39;#incomingMessages&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> peerConnection &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCPeerConnection(configuration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> dataChannel &lt;span style="color:#666">=&lt;/span> peerConnection.createDataChannel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Append new messages to the box of incoming messages
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>dataChannel.addEventListener(&lt;span style="color:#4070a0">&amp;#39;message&amp;#39;&lt;/span>, event =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> message &lt;span style="color:#666">=&lt;/span> event.data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> incomingMessages.textContent &lt;span style="color:#666">+=&lt;/span> message &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#4070a0">&amp;#39;\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>TURN сервер</title><link>https://romankurnovskii.com/ru/tracks/webrtc/turn-server/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/turn-server/</guid><description>&lt;p>Для работы большинства приложений WebRTC необходим сервер для ретрансляции трафика между узлами, поскольку прямой сокет часто невозможен между клиентами (если только они не находятся в одной локальной сети). Обычный способ решить эту проблему — использовать TURN-сервер (Traversal Using Relay NAT), который представляет собой протокол ретрансляции сетевого трафика.&lt;/p>
&lt;p>В настоящее время существует несколько вариантов TURN-серверов, доступных в Интернете, как в виде самостоятельных приложений (например, проект COTURN с открытым исходным кодом), так и в виде облачных сервисов.&lt;/p>
&lt;p>Если у вас есть доступный онлайн TURN-сервер, то все, что вам нужно - это правильная &lt;code>RTCConfiguration&lt;/code> для вашего клиентского приложения. Следующий фрагмент кода иллюстрирует пример конфигурации для &lt;code>RTCPeerConnection&lt;/code>, где TURN-сервер hostname &lt;code>my-turn-server.mycompany&lt;/code>.com работает на порту &lt;code>19403&lt;/code>.&lt;/p>
&lt;p>Объект конфигурации также поддерживает свойства username и credentials для защиты доступа к серверу. Они необходимы при подключении к TURN-серверу.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> iceConfiguration &lt;span style="color:#666">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iceServers&lt;span style="color:#666">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> urls&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#4070a0">&amp;#39;turn:my-turn-server.mycompany.com:19403&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> username&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#4070a0">&amp;#39;optional-username&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> credentials&lt;span style="color:#666">:&lt;/span> &lt;span style="color:#4070a0">&amp;#39;auth-token&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">const&lt;/span> peerConnection &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">new&lt;/span> RTCPeerConnection(iceConfiguration);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Тестирование приложений WebRTC</title><link>https://romankurnovskii.com/ru/tracks/webrtc/testing/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/testing/</guid><description>&lt;p>При написании автоматических тестов для приложений WebRTC, существуют полезные конфигурации, которые можно включить для браузеров, и которые упростят разработку и тестирование.&lt;/p>
&lt;h2 id="chrome">Chrome&lt;/h2>
&lt;p>При запуске автоматических тестов в Chrome полезны следующие функции:&lt;/p>
&lt;ul>
&lt;li>&amp;ndash;allow-file-access-from-files — дает API-доступ для file://URLs&lt;/li>
&lt;li>&amp;ndash;disable-translate — отключает всплывающие окна&lt;/li>
&lt;li>&amp;ndash;use-fake-ui-for-media-stream — Представляет поддельные медиапотоки. Полезно при работе на CI-серверах.&lt;/li>
&lt;li>&amp;ndash;use-file-for-fake-audio-capture=&lt;filename> — дает возможность использовать файл при захвате звука.&lt;/li>
&lt;li>&amp;ndash;use-file-for-fake-video-capture=&lt;filename> — дает возможность использовать файл при захвате видео.&lt;/li>
&lt;li>&amp;ndash;headless - Запустить в автономном режиме. Полезно при работе на CI-серверах.&lt;/li>
&lt;li>&amp;ndash;mute-audio - Отключить аудио.&lt;/li>
&lt;/ul>
&lt;h2 id="firefox">Firefox&lt;/h2>
&lt;p>При запуске автоматических тестов в Firefox, необходимо указать набор ключей предпочтений, которые будут использоваться в запущенном соединении. Ниже приведена конфигурация, используемая для автоматических тестов образцов WebRTC:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>&amp;#34;prefs&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.cache.disk.enable&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.cache.disk.capacity&amp;#34;: 0,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.cache.disk.smart_size.enabled&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.cache.disk.smart_size.first_run&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.sessionstore.resume_from_crash&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.startup.page&amp;#34;: 0,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;media.navigator.streams.fake&amp;#34;: true,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;media.navigator.permission.disabled&amp;#34;: true,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;device.storage.enabled&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;media.gstreamer.enabled&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.startup.homepage&amp;#34;: &amp;#34;about:blank&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.startup.firstrunSkipsHomepage&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;extensions.update.enabled&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;app.update.enabled&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;network.http.use-cache&amp;#34;: false,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;browser.shell.checkDefaultBrowser&amp;#34;: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Формат SDP унифицированного плана – план перехода</title><link>https://romankurnovskii.com/ru/tracks/webrtc/unified-plan-transition-guide/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/webrtc/unified-plan-transition-guide/</guid><description>&lt;p>Google планирует перевести реализацию WebRTC в Chrome с текущего SDP-формата (называемого «Plan B») на формат соответствующих стандартов («Unified Plan», draft-ietf-rtcweb-jsep) в течение следующих нескольких кварталов.
План включает 5 этапов и одну временную функцию API.&lt;/p>
&lt;h2 id="кто-будет-затронут">Кто будет затронут?&lt;/h2>
&lt;p>Людям, которые используют несколько аудиодорожек или несколько видеодорожек в одном PeerConnection, придется протестировать свой продукт в рамках Унифицированного Плана и, соответственно, адаптироваться. В случае, когда вызов инициируется с конечной точки не из Chrome, и на него отвечают в Chrome, форма запросов может измениться.&lt;/p>
&lt;p>Людям, выполняющим детальный анализ SDP и заботящимся о msid атрибутах, придется убедиться, что их код синтаксического анализа поддерживает новый формат (a=msid). Подробная информация о том, потребуются ли изменения и как должны измениться приложения, будет зависеть от приложения. Мы думаем, что почти все приложения, которые используют только одну аудио- и одну видеодорожку для каждого RTCPeerConnection, - их эти изменения не коснутся.&lt;/p>
&lt;h2 id="функция-api">Функция API&lt;/h2>
&lt;p>Мы добавляем новую функцию в RTCConfiguration RTCPeerConnection:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">enum&lt;/span> SdpSemantics {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;plan-b&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;unified-plan&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>partial dictionary RTCConfiguration {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SdpSemantics sdpSemantics;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RTCConfiguration может быть передана конструктору из RTCPeerConnection, и все запросы и ответы будут в формате Унифицированного Плана. Запросы в setLocalDescription и setRemoteDescription также будут ожидать, что SDP будет в формате Унифицированного Плана; если он в устаревшем формате Chrome, то все, кроме первой звуковой дорожки и первой видеодорожки, будут игнорироваться.&lt;/p>
&lt;p>Также есть флаг командной строки (–enable-features=RTCUnifiedPlanByDefault в версии Chrome M71 и выше, –enable-blink-features=RTCUnifiedPlanByDefault в более ранних версиях), который позволяет установить для этого флага значение по умолчанию в «Unified-plan».&lt;/p>
&lt;h2 id="этапы">Этапы&lt;/h2>
&lt;h3 id="этап-1-внедрение-унифицированного-плана">Этап 1. Внедрение Унифицированного Плана&lt;/h3>
&lt;p>На этом этапе Унифицированный План разрабатывался под флагом экспериментов, доступным с версии M65. До этапа 2 разумнее всего было тестировать Chrome Canary, используя «–enable-blink-features=RTCUnifiedPlan».&lt;/p>
&lt;h3 id="этап-2-сделать-функцию-api-общедоступной">Этап 2. Сделать функцию API общедоступной&lt;/h3>
&lt;p>Представлено в версии M69 (бета-август 2018 г., стабильная версия в сентябре 2018 г.)&lt;/p>
&lt;p>На этом этапе значением по умолчанию флага sdpSemantics было «plan-b». На этапе 2 люди, у которых были реализации, зависящие от формата SDP, должны были протестировать, работают ли их приложения при использовании Унифицированного Плана. Для приложений, поддерживающих Firefox, это очень простое упражнение: просто делайте то же, что делали до этого в Firefox.
Значение по умолчанию флага sdpSemantics можно изменить в «chrome://flags»; найдите функцию «WebRTC: Use Unified Plan SDP Semantics by default».&lt;/p>
&lt;h3 id="этап-3-переключите-значение-по-умолчанию">Этап 3 Переключите значение по умолчанию&lt;/h3>
&lt;p>Датой перехода была версия M72 (бета-декабрь 2018 г., стабильная версия — январь 2019 г.).
На этом этапе было изменено значение флага sdpSemantics по умолчанию на «unified plan». Приложения, которые обнаружили, что стали работать медленнее, переустановили флаг sdpSemantics в «plan-b», чтобы вернуться к предыдущему поведению.&lt;/p>
&lt;h3 id="этап-4-бросьте-план-б">Этап 4: бросьте «План Б»&lt;/h3>
&lt;p>На этом этапе установка флага sdpSemantics в значение «plan-b» приводит к возникновению исключения. Это было сделано при переходе от версии Canary к M93. Что касается M96, исключение работает как в Canary, так и на Beta. План состоит в том, чтобы добавить его и в стабильную версию. Мы следим за использованием Plan B.
На этом этапе доступна пробная версия, которая позволяет использовать план Б без создания исключений. Эта пробная версия перестала работать 29 декабря 2021 г.&lt;/p>
&lt;h3 id="этап-5-уберите-план-б">Этап 5: Уберите «План Б»&lt;/h3>
&lt;p>После окончания пробного периода Plan B будет удален из Chrome. На этом этапе флаг sdpSemantics будет удален. Попытка установить его на «plan-b» не вызовет исключение, и перестанет работать.&lt;/p></description></item></channel></rss>