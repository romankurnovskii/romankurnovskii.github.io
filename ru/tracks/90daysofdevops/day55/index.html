<!doctype html><html lang=ru dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo "><title>55. State и Ingress в Kubernetes | Roman Kurnovskii</title><meta property="og:title" content="55. State и Ingress в Kubernetes | Roman Kurnovskii"><meta property="og:type" content="article"><meta property="og:image" content="https://romankurnovskii.com/images/icon.png"><meta property="og:url" content="https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/"><meta property="og:description" content="State и Ingress в Kubernetes В этом заключительном разделе, посвященном Kubernetes, мы рассмотрим State и ingress.
Все, о чем мы говорили до сих пор, касается stateless, stateless - это когда нашим приложениям не важно, какую сеть они используют, и им не нужно постоянное хранение данных. В то время как приложения с состоянием, например, базы данных, чтобы такое приложение функционировало правильно, вам нужно убедиться, что стручки могут обращаться друг к другу через уникальную идентификацию, которая не меняется (имена хостов, IP&mldr; и т."><meta property="og:locale" content="ru"><meta property="og:site_name" content="Roman Kurnovskii"><meta property="article:published_time" content="2022-06-14T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-11T09:25:30+02:00"><meta property="article:section" content="tracks"><meta property="article:tag" content="devops"><meta property="og:see_also" content="https://romankurnovskii.com/ru/tracks/90daysofdevops/day54/"><meta property="og:see_also" content="https://romankurnovskii.com/ru/tracks/90daysofdevops/day53/"><meta property="og:see_also" content="https://romankurnovskii.com/ru/tracks/90daysofdevops/day52/"><meta property="og:see_also" content="https://romankurnovskii.com/ru/tracks/90daysofdevops/day51/"><meta property="og:see_also" content="https://romankurnovskii.com/ru/tracks/90daysofdevops/day50/"><meta property="og:see_also" content="https://romankurnovskii.com/ru/tracks/90daysofdevops/day49/"><link rel=icon type=image/png sizes=32x32 href=https://romankurnovskii.com/images/icon_huc02d7296c9eb9353758cb2467c0d17b0_10773_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=https://romankurnovskii.com/images/icon_huc02d7296c9eb9353758cb2467c0d17b0_10773_180x180_fill_box_center_3.png><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css rel=stylesheet crossorigin=anonymous><script src=https://unpkg.com/flowbite@1.5.1/dist/flowbite.js></script>
<script src=https://unpkg.com/axios@0.27.2/dist/axios.min.js></script>
<script src=https://unpkg.com/lunr@2.3.9/lunr.min.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css integrity="sha512-1sCRPdkRXhBV2PBLUdRb4tMg1w2YPf37qatUFeS7zlBy7jJI8Lf4VHwWfZZfpXtYSLy85pkm9GaYVYMfw5BC1A==" media=print onload='this.media="all",this.onload=null' crossorigin><script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/js/all.min.js integrity=" sha512-8pHNiqTlsrRjVD4A/3va++W1sMbUHwWxxRPWNyVlql3T+Hgfd81Qc6FC5WMXDC+tSauxxzp1tgiAvSKFu1qIlA==" defer crossorigin></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Raleway:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600&display=swap" rel=stylesheet><link rel=stylesheet href=https://romankurnovskii.com/css/yalla.min.fb19244877382900ab3b6152f08adfeb0298a8bc00309667de678ae533dd761943bf6e7309eec55944b2a4435d7a4a30.css><script defer src=https://romankurnovskii.com/js/yalla.min.c10f88fac8e0f4c2c802131741be30a1f629861cc319c52238e2685191e08f721da37a6696906f314554e1ec7423f51c.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js crossorigin></script><meta name=description content="State и Ingress в Kubernetes В этом заключительном разделе, посвященном Kubernetes, мы рассмотрим State и ingress.
Все, о чем мы говорили до сих пор, касается stateless, stateless - это когда нашим приложениям не важно, какую сеть они используют, и им не нужно постоянное хранение данных. В то время как приложения с состоянием, например, базы данных, чтобы такое приложение функционировало правильно, вам нужно убедиться, что стручки могут обращаться друг к другу через уникальную идентификацию, которая не меняется (имена хостов, IP&mldr; и т."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Roadmaps","item":"https://romankurnovskii.com/ru/tracks/"},{"@type":"ListItem","position":2,"name":"90 дней DevOps","item":"https://romankurnovskii.com/ru/tracks/90daysofdevops/"},{"@type":"ListItem","position":3,"name":"55. State и Ingress в Kubernetes","item":"https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/"},"headline":"55. State и Ingress в Kubernetes | Roman Kurnovskii","datePublished":"2022-06-14T00:00:00+00:00","dateModified":"2023-02-11T09:25:30+02:00","wordCount":1822,"publisher":{"@type":"Person","name":"Roman Kurnovskii","logo":{"@type":"ImageObject","url":"https://romankurnovskii.com/images/icon.png"}},"description":"State и Ingress в Kubernetes В этом заключительном разделе, посвященном Kubernetes, мы рассмотрим State и ingress.\nВсе, о чем мы говорили до сих пор, касается stateless, stateless - это когда нашим приложениям не важно, какую сеть они используют, и им не нужно постоянное хранение данных. В то время как приложения с состоянием, например, базы данных, чтобы такое приложение функционировало правильно, вам нужно убедиться, что стручки могут обращаться друг к другу через уникальную идентификацию, которая не меняется (имена хостов, IP\u0026hellip; и т."}</script><link rel=preconnect href=https://www.google-analytics.com crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-26F2C5ZR4Y"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-26F2C5ZR4Y")</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js?v2","ym"),ym(87734724,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/87734724 style=position:absolute;left:-9999px alt></div></noscript><script>let storageColorScheme=localStorage.getItem("lightDarkMode");const isDark2=JSON.parse(localStorage.getItem("DarkMode")||"false");isDark2?storageColorScheme="Dark":storageColorScheme="Light",((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script></head><body class="flex min-h-screen flex-col"><header><div class="mx-auto w-full max-w-screen-xl"><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="open mobile menu">
<i class="fas fa-bars"></i></button>
<a href=/ru class="me-6 text-primary-text text-xl font-bold">Roman Kurnovskii</a><div id=mobile-burger-menu class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><ul id=menu><li class=parent><a href=/ru/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Заметки</a><ul class=child><li class=parent><a href=/ru/categories/roadmaps/>Руководства <span class=expand>»</span></a><ul class=child><li class=parent><a href=/ru/tracks/python101/>Справочник Python</a></li><li class=parent><a href=/ru/tracks/webrtc/>Справочник WebRTC</a></li><li class=parent><a href=/ru/tracks/disser/>Диссертация</a></li></ul></li><li class=parent><a href=/ru/categories/programming/>Программирование <span class=expand>»</span></a><ul class=child><li class=parent><a href=/en/tracks/algorithms-101/>Algorithms [EN]</a></li><li class=parent><a href=/ru/categories/hugo/>Hugo</a></li><li class=parent><a href=/ru/categories/javascript/>JavaScript</a></li><li class=parent><a href=/ru/categories/python/>Python</a></li></ul></li><li><a href=/en/p/links/>Links</a></li></ul></li><li class=parent><a href=/ru/apps/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Приложения</a></li><li class=parent><a href=/ru/p/publications class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Публикации</a></li></ul></div><div class=flex><div class="relative pt-4 md:pt-0"><form id=search class="flex items-center"><label for=search-input class=sr-only>Search</label><div class="relative w-full"><input type=text type=search id=search-input class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full pl-10 p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" placeholder=Search required></div></form></div><div class="relative pt-4 ps-2 md:pt-0"><button class="p-1 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700" onclick='location.href="/ru/search/"'>
<img width=13 src=https://img.icons8.com/ios-glyphs/30/null/search-more.png></button></div></div></nav></div><div id=is-open-mobile class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0"></div><script>document.addEventListener("DOMContentLoaded",()=>{switchMobileMenuBurger()})</script></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-2xl lg:px-2 xl:px-4"><div class=lg:pt-8><div class="flex flex-col md:flex-row bg-secondary-bg rounded"><div class="md:w-1/4 lg:w-1/5 border-e"><div class="sticky mt-12"><div id=sidebar-title class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text"><span class=font-semibold>Содержание</span>
<i class='fas fa-caret-right ms-1'></i></div><div id=sidebar-toc class="hidden overflow-y-auto md:block mx-6 md:mx-0 pe-2 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent"><div class="flex flex-wrap ms-1 -me-2 p-1 bg-secondary-bg md:bg-primary-bg rounded"><a class=hover:text-yalla href=https://romankurnovskii.com/ru/tracks/90daysofdevops/>90 дней DevOps</a></div><aside aria-label=Sidebar><div class="py-2 px-1"><ul id=doc__nav__sidebar class=space-y-1><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day01/><span>1. DevOps - общее представление</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day02/><span>2. Задачи DevOps-инженера</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day03/><span>3. Ориентированность на приложения</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day04/><span>4. DevOps и Agile</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day05/><span>5. Plan > Code > Build > Testing > Release > Deploy > Operate > Monitor</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day06/><span>6. DevOps - Истории</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day07/><span>7. DevOps - изучение языка программирования</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day08/><span>8. Настройка DevOps окружения для запуска Hello World на Go</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day09/><span>9. Как работает hello-world на Golang</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day10/><span>10. Окружение Go</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day11/><span>11. Переменные и константы в Go</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day12/><span>12. Golang - чтение данных и указатели</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day13/><span>13. Go - подключение Twitter API</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day14/><span>14. DevOps и Linux</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day15/><span>15. Команды Linux в DevOps</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day16/><span>16. Управление системой, файловой системой и хранилищем в Linux</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day17/><span>17. Текстовые редакторы Nano/Vim</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day18/><span>18. Web Сервер и SSH</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day19/><span>19. Автоматизация задачи с помощью bash-скриптов</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day20/><span>20. Настройка рабочей среды DevOps</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day21/><span>21. DevOps настройка сети</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day22/><span>22. Открытая сетевая модель OSI</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day23/><span>23. Протоколы сети</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day24/><span>24. Автоматизация сети</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day25/><span>25. Автоматизация сети с помощью Python</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day26/><span>26. Развертывание виртуальной лаборатории EVE-NG в домашних условиях</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day27/><span>27. Работа с сетью в Python</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day28/><span>28. DevOps в облаке</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day29/><span>29. Знакомство с Microsoft Azure</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day30/><span>30. Модули безопасности Microsoft Azure</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day31/><span>31. Microsoft Azure Среда выполнения приложений</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day32/><span>32. Модели хранилища Microsoft Azure</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day33/><span>33. Сетевые модели Microsoft Azure + Управление Azure</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day34/><span>34. Практические скрипты Microsoft Azure</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day35/><span>35. Git — контроль версий</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day36/><span>36. Установка и настройка Git</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day37/><span>37. Шпаргалка по Git</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day38/><span>38. Staging и Изменения</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day39/><span>39. Просмотр, удаление, отмена и восстановление</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day40/><span>40. GitHub | GitLab | BitBucket</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day41/><span>41. Рабочий процесс с открытым исходным кодом</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day42/><span>42. Контейнеры</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day43/><span>43. Установка Docker</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day44/><span>44. Установка образов Docker в Docker Desktop</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day45/><span>45. Что из себя представляет оьбраз Docker</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day46/><span>46. Docker Compose</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day47/><span>47. Сетевое взаимодействие Docker и безопасность</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day48/><span>48. Альтернативы Docker</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day49/><span>49. Основы Kubernetes</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day50/><span>50. Выбор платформы Kubernetes для проекта</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day51/><span>51. Установка minikube</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day52/><span>52. Настройка многоузлового кластера Kubernetes</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day53/><span>53. Обзор Rancher</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day54/><span>54. Развертывание приложений Kubernetes</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day55/ class=bg-tertiary-bg><span>55. State и Ingress в Kubernetes</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day56/><span>56. Обзор IaC</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day57/><span>57. Введение в Terraform</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day58/><span>58. Язык конфигурации HashiCorp (HCL)</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day59/><span>59. Создание виртуальной машины с помощью Terraform</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day60/><span>60. Контейнеры, провайдеры и модули Docker</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day61/><span>61. Kubernetes и множественные среды</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day62/><span>62. Terraform - Тестирование, инструменты и альтернативы</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day63/><span>63. Инструменты управления конфигурацией - Ansible/Terraform</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day64/><span>64. Ansible Введение</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day65/><span>65. Ansible Playbooks - Часть 1</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day66/><span>66. Ansible Playbooks - Часть 2</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day67/><span>67. Роли и развертывание балансировщика нагрузки</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day68/><span>68. Теги, переменные, инвентаризация и конфигурация сервера базы данных</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day69/><span>69. Ansible - контроллер автоматизации (Tower), AWX, Vault</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day70/><span>70. Конвейеры CI/CD</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day71/><span>71. Введение в Jenkins</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day72/><span>72. Работа с Jenkins</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day73/><span>73. Построение конвейера Jenkins</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day74/><span>74. Hello World - Jenkinsfile App Pipeline</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day75/><span>75. Обзор GitHub Actions</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day76/><span>76. Обзор ArgoCD</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day77/><span>77. Мониторинг</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day78/><span>78. Hands-On Monitoring Tools</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day79/><span>79. Log Management</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day80/><span>80. ELK Stack</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day81/><span>81. Fluentd и FluentBit</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day82/><span>82. EFK Stack</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day83/><span>83. Визуализация данных - Grafana</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day84/><span>84. Управление данными</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day85/><span>85. Службы данных</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day86/><span>86. Резервное копирование всех платформ</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day87/><span>87. Резервное копирование и восстановление</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day88/><span>88. Резервное копирование, ориентированное на приложения</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day89/><span>89. Аварийное восстановление</span></a></li><li><a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day90/><span>90. Мобильность данных и приложений</span></a></li></ul></div></aside></div></div></div><div class="w-full md:w-3/4 lg:w-4/5 pb-2 pt-2 md:pt-2"><div class=flex><div class="w-full lg:w-3/4 px-6"><article class=prose><h1>55. State и Ingress в Kubernetes</h1><div class="text-tertiary-text text-sm not-prose mt-2 flex flex-row flex-wrap items-center"><div class=me-4><i class="fa-regular fa-calendar-days"></i>
<span>Обновлено: 2023-02-11</span></div><div class=me-4><i class="fa-regular fa-clock"></i>
<span>9 мин</span></div><div id=page__views__div class="me-4 my-2"><i class="fa-regular fa-eye me-1"></i>
<span id=page__views></span></div></div><div class="block lg:hidden"><h3 class=text-lg>Содержание</h3><div class=break-words><nav id=TableOfContents><ul><li><a href=#state-и-ingress-в-kubernetes>State и Ingress в Kubernetes</a><ul><li><a href=#stateful-application>Stateful Application</a></li><li><a href=#развертывание-против-statefulset>Развертывание против StatefulSet</a></li><li><a href=#постоянный-том>Постоянный том</a></li><li><a href=#утверждение-о-постоянном-томе>Утверждение о постоянном томе</a></li><li><a href=#configmaps--secrets>ConfigMaps | Secrets</a></li><li><a href=#storageclass>StorageClass</a></li><li><a href=#время-просмотра>Время просмотра</a></li><li><a href=#конфигурация-класса-хранилища>Конфигурация класса хранилища</a></li><li><a href=#играем-в-игру--я-имею-в-виду-доступ-к-нашему-критически-важному-приложению>Играем в игру | Я имею в виду доступ к нашему критически важному приложению</a></li><li><a href=#ingress-объяснено>Ingress объяснено</a></li><li><a href=#что-такое-ingress>Что такое ingress?</a></li><li><a href=#когда-вам-нужен-ingress>Когда вам нужен ingress?</a></li><li><a href=#настройка-ingress-на-minikube>Настройка Ingress на Minikube</a></li></ul></li><li><a href=#ресурсы>Ресурсы</a></li></ul></nav></div></div><h2 id=state-и-ingress-в-kubernetes>State и Ingress в Kubernetes</h2><p>В этом заключительном разделе, посвященном Kubernetes, мы рассмотрим State и ingress.</p><p>Все, о чем мы говорили до сих пор, касается stateless, stateless - это когда нашим приложениям не важно, какую сеть они используют, и им не нужно постоянное хранение данных. В то время как приложения с состоянием, например, базы данных, чтобы такое приложение функционировало правильно, вам нужно убедиться, что стручки могут обращаться друг к другу через уникальную идентификацию, которая не меняется (имена хостов, IP&mldr; и т.д.). Примерами stateful-приложений являются кластеры MySQL, Redis, Kafka, MongoDB и другие. В принципе, любое приложение, которое хранит данные.</p><h3 id=stateful-application>Stateful Application</h3><p>StatefulSets представляют собой набор Pods с уникальными, постоянными идентификаторами и стабильными именами хостов, которые Kubernetes поддерживает независимо от того, где они запланированы. Информация о состоянии и другие устойчивые данные для любого данного StatefulSet Pod хранятся в постоянном дисковом хранилище, связанном с StatefulSet.</p><h3 id=развертывание-против-statefulset>Развертывание против StatefulSet</h3><ul><li>Репликация stateful-приложений является более сложной задачей.</li><li>Репликация наших стручков в развертывании (Stateless Application) идентична и взаимозаменяема.</li><li>Создаем капсулы в случайном порядке со случайными хэшами</li><li>Один сервис, который балансирует нагрузку на любой стручок.</li></ul><p>Когда дело доходит до StatefulSets или Stateful Applications, вышеописанное становится сложнее.</p><ul><li>Невозможно одновременно создавать и удалять.</li><li>Не может быть случайного обращения.</li><li>реплики Pods не являются идентичными.</li></ul><p>То, что вы увидите в нашей демонстрации в ближайшее время, заключается в том, что каждая копия имеет свою собственную идентичность. В приложении без статического состояния вы увидите случайные имена. Например, <code>app-7469bbb6d7-9mhxd</code>, в то время как Stateful Application будет иметь имя <code>mongo-0</code>, а затем при масштабировании создаст новую капсулу под названием <code>mongo-1</code>.</p><p>Эти стручки создаются на основе одной и той же спецификации, но они не взаимозаменяемы. Каждая капсула StatefulSet имеет постоянный идентификатор при любом повторном планировании. Это необходимо, потому что когда нам требуются нагрузки с учетом состояния, такие как база данных, где требуется запись и чтение в базу данных, мы не можем иметь две капсулы, пишущие в одно и то же время без осведомленности, так как это приведет к несогласованности данных. Нам нужно убедиться, что в любой момент времени только один из наших стручков записывает данные в базу данных, однако мы можем иметь несколько стручков, читающих эти данные.</p><p>Каждый стручок в StatefulSet будет иметь доступ к своему собственному постоянному тому и копии базы данных для чтения, которая постоянно обновляется с главного сервера. Также интересно отметить, что каждый pod будет хранить свое состояние pod в этом постоянном томе, если <code>mongo-0</code> умрет, то при инициализации нового pod он возьмет состояние pod, хранящееся в хранилище.</p><p>TLDR; StatefulSets vs Deployments</p><ul><li>Predicatable pod name = <code>mongo-0</code></li><li>Fixed individual DNS name</li><li>Pod Identity - Retain State, Retain Role</li><li>Replicating stateful apps is complex<ul><li>There are lots of things you must do:<ul><li>Configure cloning and data synchronisation.</li><li>Make remote shared storage available.</li><li>Management & backup</li></ul></li></ul></li></ul><p>Как сохранять данные в Kubernetes?</p><p>Мы упоминали выше, что когда у нас есть приложение с состоянием, нам нужно где-то хранить состояние, и именно здесь возникает необходимость в томе, поскольку из коробки Kubernetes не обеспечивает постоянство данных.</p><p>Нам нужен уровень хранения, который не зависит от жизненного цикла стручка. Это хранилище должно быть доступно со всех наших узлов Kubernetes. Хранилище также должно находиться вне кластера Kubernetes, чтобы иметь возможность выжить, даже если кластер Kubernetes потерпит крах.</p><h3 id=постоянный-том>Постоянный том</h3><ul><li>Ресурс кластера (например, процессор и оперативная память) для хранения данных.</li><li>Создается с помощью файла YAML.</li><li>Требуется реальное физическое хранилище (NAS)</li><li>Внешняя интеграция в ваш кластер Kubernetes.</li><li>В вашем хранилище могут быть доступны различные типы хранилищ.</li><li>PV не имеют пространства имен</li><li>Локальное хранилище доступно, но оно будет специфично для одного узла в кластере</li><li>Персистентность базы данных должна использовать удаленное хранилище (NAS)</li></ul><h3 id=утверждение-о-постоянном-томе>Утверждение о постоянном томе</h3><p>Постоянный том, как описано выше, может существовать и быть доступным, но пока он не заявлен приложением, он не используется.</p><ul><li>Создается с помощью файла YAML</li><li>Утверждение постоянного тома используется в конфигурации стручка (атрибут volumes)</li><li>PVC находятся в том же пространстве имен, что и pod</li><li>Том монтируется в капсулу</li><li>Стручки могут иметь несколько различных типов томов (ConfigMap, Secret, PVC).</li></ul><p>Другой способ представить PVs и PVCs заключается в следующем</p><p>PVs создаются администратором Kubernetes Admin
PVC создаются пользователем или разработчиком приложения.</p><p>У нас также есть два других типа томов, которые мы не будем подробно описывать, но о которых стоит упомянуть:</p><h3 id=configmaps--secrets>ConfigMaps | Secrets</h3><ul><li>Конфигурационный файл для вашего стручка.</li><li>Файл сертификата для вашей капсулы.</li></ul><h3 id=storageclass>StorageClass</h3><ul><li>Создается с помощью файла YAML</li><li>Предоставляет постоянные тома динамически, когда PVC заявляет об этом.</li><li>Каждый бэкенд хранилища имеет свой собственный провизор</li><li>Бэкенд хранилища определяется в YAML (через атрибут provisioner)</li><li>Абстракции базового провайдера хранения</li><li>Определяет параметры для этого хранилища</li></ul><h3 id=время-просмотра>Время просмотра</h3><p>Во вчерашней сессии мы рассмотрели создание приложения без статических данных, здесь мы хотим сделать то же самое, но использовать наш кластер minikube для развертывания рабочей нагрузки с статическими данными.</p><p>Напомним команду minikube, которую мы используем, чтобы иметь возможность и аддоны для использования персистентности: <code>minikube start --addons volumesnapshots,csi-hostpath-driver --apiserver-port=6443 --container-runtime=containerd -p mc-demo --kubernetes-version=1.21.2</code>.</p><p>Эта команда использует драйвер csi-hostpath-driver, который дает нам наш класс хранилища, что я покажу позже.</p><p>Сборка приложения выглядит следующим образом:</p><p><p class=md__image><img src=../images/Day55_Kubernetes1.png?v1 id=zoom-default alt loading=lazy></p></p><p>Вы можете найти файл конфигурации YAML для этого приложения здесь <a href=../Kubernetes/pacman-stateful-demo.yaml>pacman-stateful-demo.yaml</a></p><h3 id=конфигурация-класса-хранилища>Конфигурация класса хранилища</h3><p>Есть еще один шаг, который мы должны выполнить перед началом развертывания нашего приложения, а именно убедиться, что наш класс хранилища (csi-hostpath-sc) является классом по умолчанию. Сначала мы можем проверить это, выполнив команду <code>kubectl get storageclass</code>, но из коробки кластер minikube будет показывать стандартный класс хранения по умолчанию, поэтому мы должны изменить его с помощью следующих команд.</p><p>Первая команда сделает наш класс хранилища csi-hostpath-sc классом по умолчанию.</p><p><code>kubectl patch storageclass csi-hostpath-sc -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class": "true"}}}'</code>}''</p><p>Эта команда удалит аннотацию по умолчанию из стандартного StorageClass.</p><p><code>kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class": "false"}}}'</code>}''</p><p><p class=md__image><img src=../images/Day55_Kubernetes2.png?v1 id=zoom-default alt loading=lazy></p></p><p>Начнем с того, что в нашем кластере нет пространства имен pacman. <code>kubectl get namespace</code></p><p><p class=md__image><img src=../images/Day55_Kubernetes3.png?v1 id=zoom-default alt loading=lazy></p></p><p>Затем мы развернем наш YAML-файл. <code>kubectl create -f pacman-stateful-demo.yaml</code> Из этой команды видно, что мы создаем ряд объектов в нашем кластере Kubernetes.</p><p><p class=md__image><img src=../images/Day55_Kubernetes4.png?v1 id=zoom-default alt loading=lazy></p></p><p>Теперь у нас есть наше только что созданное пространство имен.</p><p><p class=md__image><img src=../images/Day55_Kubernetes5.png?v1 id=zoom-default alt loading=lazy></p></p><p>Из следующего изображения и команды <code>kubectl get all -n pacman</code> видно, что в нашем пространстве имен происходит несколько вещей. У нас есть pods, запускающий наш NodeJS web front end, у нас есть mongo, запускающий нашу backend базу данных. Есть сервисы для pacman и mongo для доступа к этим стручкам. У нас есть развертывание для pacman и statefulset для mongo.</p><p><p class=md__image><img src=../images/Day55_Kubernetes6.png?v1 id=zoom-default alt loading=lazy></p></p><p>У нас также есть наши постоянные тома и утверждения постоянных томов. Выполнив команду <code>kubectl get pv</code>, мы получим наши постоянные тома, не связанные с именами, а выполнив команду <code>kubectl get pvc -n pacman</code>, мы получим наши утверждения постоянных томов, связанные с именами.<p class=md__image><img src=../images/Day55_Kubernetes7.png?v1 id=zoom-default alt loading=lazy></p></p><h3 id=играем-в-игру--я-имею-в-виду-доступ-к-нашему-критически-важному-приложению>Играем в игру | Я имею в виду доступ к нашему критически важному приложению</h3><p>Поскольку мы используем Minikube, как уже упоминалось в приложении без статических данных, нам предстоит преодолеть несколько препятствий, когда дело доходит до доступа к нашему приложению. Однако если бы у нас был доступ к ingress или балансировщику нагрузки в нашем кластере, служба настроена на автоматическое получение IP-адреса от него для получения доступа извне. (Вы можете видеть это выше на изображении всех компонентов в пространстве имен pacman).</p><p>В данном демонстрационном примере мы будем использовать метод проброса портов для доступа к нашему приложению. Открыв новый терминал и выполнив следующую команду <code>kubectl port-forward svc/pacman 9090:80 -n pacman</code>, открыв браузер, мы получим доступ к нашему приложению. Если вы запускаете это в AWS или в определенных местах, то это также сообщит об облаке и зоне, а также о хосте, который равен вашему стручку в Kubernetes, опять же, вы можете оглянуться назад и увидеть это имя стручка на наших скриншотах выше.</p><p><p class=md__image><img src=../images/Day55_Kubernetes8.png?v1 id=zoom-default alt loading=lazy></p></p><p>Теперь мы можем пойти и создать высокий балл, который затем будет сохранен в нашей базе данных.</p><p><p class=md__image><img src=../images/Day55_Kubernetes9.png?v1 id=zoom-default alt loading=lazy></p></p><p>Хорошо, у нас есть высокий балл, но что произойдет, если мы удалим наш <code>mongo-0</code> pod? Выполнив команду <code>kubectl delete pod mongo-0 -n pacman</code>, я могу удалить его, и если вы все еще находитесь в приложении, вы увидите, что высокий балл недоступен, по крайней мере, в течение нескольких секунд.</p><p><p class=md__image><img src=../images/Day55_Kubernetes10.png?v1 id=zoom-default alt loading=lazy></p></p><p>Теперь, если я вернусь в свою игру, я смогу создать новую игру и увидеть свои высокие баллы. Единственный способ поверить мне в это - попробовать и поделиться в социальных сетях своими высокими результатами!</p><p><p class=md__image><img src=../images/Day55_Kubernetes11.png?v1 id=zoom-default alt loading=lazy></p></p><p>С развертыванием мы можем увеличить масштаб с помощью команд, которые мы рассматривали в предыдущей сессии, но в частности здесь, особенно если вы хотите устроить огромную вечеринку pacman, вы можете увеличить масштаб с помощью <code>kubectl scale deployment pacman --replicas=10 -n pacman</code>.</p><p><p class=md__image><img src=../images/Day55_Kubernetes12.png?v1 id=zoom-default alt loading=lazy></p></p><h3 id=ingress-объяснено>Ingress объяснено</h3><p>Прежде чем мы закончим с Kubernetes, я также хотел бы затронуть важный аспект Kubernetes, и это - ingress.</p><h3 id=что-такое-ingress>Что такое ingress?</h3><p>До сих пор в наших примерах мы использовали port-forward или определенные команды в minikube, чтобы получить доступ к нашим приложениям, но в производстве это не сработает. Нам нужен лучший способ доступа к нашим приложениям в масштабе с множеством пользователей.</p><p>Мы также говорили о возможности использования NodePort, но это опять же должно быть только в тестовых целях.</p><p>Ingress дает нам лучший способ открыть наши приложения, он позволяет нам определить правила маршрутизации в нашем кластере Kubernetes.</p><p>Для ingress мы создадим запрос на внутреннюю службу нашего приложения.</p><h3 id=когда-вам-нужен-ingress>Когда вам нужен ingress?</h3><p>Если вы используете облачный провайдер, управляемое предложение Kubernetes, то, скорее всего, у них будет своя опция ingress для вашего кластера или они предоставят вам свой собственный балансировщик нагрузки. Вам не придется реализовывать это самостоятельно, что является одним из преимуществ управляемого Kubernetes.</p><p>Если вы управляете собственным кластером, вам необходимо настроить точку входа.</p><h3 id=настройка-ingress-на-minikube>Настройка Ingress на Minikube</h3><p>На моем конкретном запущенном кластере под названием mc-demo я могу выполнить следующую команду, чтобы включить ingress на моем кластере.</p><p><code>minikube --profile='mc-demo' addons enable ingress</code>.</p><p><p class=md__image><img src=../images/Day55_Kubernetes13.png?v1 id=zoom-default alt loading=lazy></p></p><p>Если теперь мы проверим наши пространства имен, то увидим, что у нас есть новое пространство имен ingress-nginx. <code>kubectl get ns</code></p><p><p class=md__image><img src=../images/Day55_Kubernetes14.png?v1 id=zoom-default alt loading=lazy></p></p><p>Теперь мы должны создать YAML-конфигурацию ingress для запуска нашего сервиса Pacman. Я добавил этот файл в репозиторий <a href=../Kubernetes/pacman-ingress.yaml>pacman-ingress.yaml</a>.</p><p>Затем мы можем создать его в нашем пространстве имен ingress с помощью <code>kubectl create -f pacman-ingress.yaml</code>.</p><p><p class=md__image><img src=../images/Day55_Kubernetes15.png?v1 id=zoom-default alt loading=lazy></p></p><p>Затем, если мы запустим <code>kubectl get ingress -n pacman</code></p><p><p class=md__image><img src=../images/Day55_Kubernetes16.png?v1 id=zoom-default alt loading=lazy></p></p><p>Затем мне говорят, что поскольку мы используем minikube, работающий на WSL2 в Windows, мы должны создать туннель minikube, используя <code>minikube tunnel --profile=mc-demo</code>.</p><p>Но я все еще не могу получить доступ к 192.168.49.2 и играть в свою игру pacman.</p><p>Если у кого-нибудь есть или есть возможность заставить это работать под Windows и WSL, я буду благодарен за отзывы. Я подниму вопрос об этом в репозитории и вернусь к нему, как только у меня появится время и исправление.</p><p>UPDATE: Мне кажется, что этот блог помогает определить причину того, что игра не работает на WSL <a href=https://hellokube.dev/posts/configure-minikube-ingress-on-wsl2/>Configuring Ingress to run Minikube on WSL2 using Docker runtime</a></p><h2 id=ресурсы>Ресурсы</h2><ul><li><a href="https://www.youtube.com/watch?v=pPQKAR1pA9U">Kubernetes StatefulSet simply explained</a></li><li><a href="https://www.youtube.com/watch?v=0swOh5C3OVM">Kubernetes Volumes explained</a></li><li><a href="https://www.youtube.com/watch?v=80Ew_fsV4rM">Kubernetes Ingress Tutorial for Beginners</a></li><li><a href=https://kubernetes.io/docs/home/>Kubernetes Documentation</a></li><li><a href="https://www.youtube.com/watch?v=X48VuDVv0do">TechWorld with Nana - Kubernetes Tutorial for Beginners [FULL COURSE in 4 Hours]</a></li><li><a href="https://www.youtube.com/watch?v=s_o8dwzRlu4">TechWorld with Nana - Kubernetes Crash Course for Absolute Beginners</a></li><li><a href="https://www.youtube.com/watch?v=KVBON1lA9N8">Kunal Kushwaha - Kubernetes Tutorial for Beginners | What is Kubernetes? Architecture Simplified!</a></li></ul><p>На этом мы завершаем раздел Kubernetes. Существует так много дополнительных материалов, которые мы могли бы осветить на тему Kubernetes, и 7 дней дают нам базовые знания, но есть люди, которые проходят <a href=https://100daysofkubernetes.io/overview.html>100DaysOfKubernetes</a>, где вы можете погрузиться в самую гущу событий.</p><p>Далее мы рассмотрим инфраструктуру как код и ту важную роль, которую она играет с точки зрения DevOps.</p></article><div class=my-4><a href=https://romankurnovskii.com/ru/tags/devops/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-yalla">#devops</a></div><div class="-mx-2 mt-4 flex flex-col border-t border-b pb-1 px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">Ранее</span>
<a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day54/ class=block>54. Развертывание приложений Kubernetes</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">Далее</span>
<a href=https://romankurnovskii.com/ru/tracks/90daysofdevops/day56/ class=block>56. Обзор IaC</a></div></div><div id=open_comments_block></div><script src=/opencomments.js renderdivid=open_comments_block server=https://eyt4njm3se.execute-api.eu-west-1.amazonaws.com/comments awstag defer></script></div><div class="hidden lg:block lg:w-1/4"><div class="bg-primary-bg prose sticky top-7 z-10 hidden
px-6 lg:block"><h3 class=text-lg>Содержание</h3></div><div class="sticky-toc hidden px-0 pb-6 lg:block"><nav id=TableOfContents><ul><li><a href=#state-и-ingress-в-kubernetes>State и Ingress в Kubernetes</a><ul><li><a href=#stateful-application>Stateful Application</a></li><li><a href=#развертывание-против-statefulset>Развертывание против StatefulSet</a></li><li><a href=#постоянный-том>Постоянный том</a></li><li><a href=#утверждение-о-постоянном-томе>Утверждение о постоянном томе</a></li><li><a href=#configmaps--secrets>ConfigMaps | Secrets</a></li><li><a href=#storageclass>StorageClass</a></li><li><a href=#время-просмотра>Время просмотра</a></li><li><a href=#конфигурация-класса-хранилища>Конфигурация класса хранилища</a></li><li><a href=#играем-в-игру--я-имею-в-виду-доступ-к-нашему-критически-важному-приложению>Играем в игру | Я имею в виду доступ к нашему критически важному приложению</a></li><li><a href=#ingress-объяснено>Ingress объяснено</a></li><li><a href=#что-такое-ingress>Что такое ingress?</a></li><li><a href=#когда-вам-нужен-ingress>Когда вам нужен ingress?</a></li><li><a href=#настройка-ingress-на-minikube>Настройка Ingress на Minikube</a></li></ul></li><li><a href=#ресурсы>Ресурсы</a></li></ul></nav><div class="feedback-links mt-4 text-sm"><hr><div><a href=https://github.com/romankurnovskii/romankurnovskii.github.io/edit/main/content/tracks/90daysofdevops/day55.ru.md title="Edit this page" target=_blank><i class="fas fa-edit me-1"></i>
<span>Редактировать страницу</span></a></div><div><a href="https://github.com/romankurnovskii/romankurnovskii.github.io/issues/new/?body=File:%20[/content/tracks/90daysofdevops/day55.ru.md/]%28/https:/romankurnovskii.com/ru/tracks/90daysofdevops/day55/%29" title="Request issue" target=_blank><i class="fas fa-check me-1" aria-hidden=true></i>
<span>Запросить изменения</span></a></div></div></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div></div></div></div></div><script>document.addEventListener("DOMContentLoaded",()=>{changeSidebarHeight(),switchDocToc()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2023 <a href=https://romankurnovskii.com>Roman Kurnovskii</a> personal page
&#183;
<a href=https://romankurnovskii.com/ru/index.xml target=_blank>RSS</a> &#183;
<a href=https://gohugo.io>Hugo</a> &#183;
Updated <a href=https://github.com/romankurnovskii/romankurnovskii.github.io/commit/40d4080 target=_blank>2023-02-11</a></p></div><script src=/js/lunr.stemmer.support.min.js></script>
<script src=/js/lunr.ru.min.js></script>
<script src=/js/lunr.multi.min.js></script>
<script src=/js/search.js?v2 languagemode=ru></script><div id=search-result tabindex=-1 class="overflow-y-auto overflow-x-hidden fixed top-0 right-0 left-0 z-50 max-w-xs" hidden><div class="relative p-4 w-full max-w-xs h-full md:h-auto"><div class="relative bg-white rounded-lg shadow dark:bg-gray-700"><div class=p-6><h3>Search results</h3><div id=popup_search_results class=prose></div></div></div></div></div><script src=/js/search-page.js?v3></script>
<script src=/js/base.js?7 languagemode=ru></script></div></footer><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js defer></script>
<script src=/js/zoom-image/placeholders.js?4 defer></script>
<script src=/js/zoom-image/index.js?4 defer></script></body></html>