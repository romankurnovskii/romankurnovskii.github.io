<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/categories/algorithms/</link><description>Recent content in Algorithms on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Tue, 12 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/categories/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>4. Median of Two Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</guid><description>LeetCode задача 4
Задача Даны два отсортированных массива nums1 и nums2 размера m и n соответственно. Найти медиану двух отсортированных массивов.
Подсказки Чтобы найти медиану, нужно сначала объединить два массива и отсортировать их. После этого медиана будет либо средним элементом, если общее количество элементов нечетное, либо средним значением двух центральных элементов, если общее количество элементов четное.
Подход Мы можем объединить два массива в один большой отсортированный массив и найти медиану этого массива. Этот подход не самый эффективный, но он прост и понятен.</description></item><item><title>9. Palindrome Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/9/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/9/</guid><description>LeetCode задача
Задача Определите, является ли целое число палиндромом, не преобразуя его в строку.
Подсказки Переворачивая число и сравнивая его с оригиналом, мы можем определить, является ли оно палиндромом.
Подход Вместо того чтобы преобразовывать число в строку, мы можем перевернуть его цифры с использованием математических операций, а затем сравнить перевернутое число с оригинальным.
Алгоритм Если число отрицательное, то это не палиндром. Инициализируем переменную для перевернутого числа: мы будем создавать это число шаг за шагом. Переворачиваем число: Это достигается путем последовательного взятия последней цифры числа и добавления её к текущему общему количеству после сдвига текущих цифр этого общего числа.</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</guid><description>LeetCode задача 11
Задача Вам дан массив, в котором каждый элемент представляет высоту стены. Высоты стен разные. Две стены и пространство между ними образуют контейнер. Ваша задача - найти контейнер, который может вместить максимальное количество воды.
Подсказки Метод &amp;ldquo;Two Pointers&amp;rdquo;.
Подход Цель этой задачи - найти пару &amp;ldquo;стен&amp;rdquo;, между которыми будет находиться максимальное количество &amp;ldquo;воды&amp;rdquo;. Вместимость контейнера определяется двумя факторами: расстоянием между стенками и минимальной высотой из двух стенок.
Идея алгоритма заключается в следующем: начнем с самых &amp;ldquo;дальних&amp;rdquo; друг от друга стенок и будем постепенно &amp;ldquo;сужать&amp;rdquo; интервал, сдвигая одну из стенок внутрь массива.</description></item><item><title>42. Trapping Rain Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</guid><description>LeetCode задача 42
Задача Дан массив неотрицательных целых чисел, представляющих собой карту высот, где ширина каждой стойки равна 1. Вычислите, сколько воды может удерживать этот массив после дождя.
Подсказки Мы можем решить эту задачу, двигаясь от краев массива к его центру, отслеживая текущую максимальную высоту с обеих сторон.
Подход Простой и понятный способ решения этой задачи - пройтись по массиву и для каждого элемента вычислить, сколько воды он может удержать.
Алгоритм Инициализируем переменную для хранения общего объема воды, который может быть удержан.</description></item><item><title>92. Reverse Linked List II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</guid><description>LeetCode задача 92
Задача Дан односвязный список и два целых числа left и right, где left &amp;lt;= right. Задача заключается в том, чтобы перевернуть узлы списка с позиции left до right
Т.е. если список 1-2-3-4-5-6-7-8-9, left=2, right=7, то итоговый список будет 1-7-6-5-4-3-2-8-9.
Подсказки Для решения задачи удобно использовать два указателя: один для сохранения начальной позиции участка, который нужно перевернуть, и второй для выполнения самого разворота.
Подход Основная идея решения заключается в использовании двух указателей: одного для начала подсписка, который нужно перевернуть, и второго для его конца.</description></item><item><title>104. Maximum Depth of Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/104/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/104/</guid><description>LeetCode задача 104
Задача Дан корень бинарного дерева. Задача состоит в том, чтобы найти его максимальную глубину. Глубина бинарного дерева определяется как максимальное количество узлов на пути от корня дерева до любого листового узла, включая сам корень.
Подсказки Бинарное дерево представляет собой иерархическую структуру, в которой каждый узел имеет максимум двух потомков: левого и правого.
Подход / Идея решения Чтобы найти максимальную глубину бинарного дерева, можно использовать рекурсивный метод. Для каждого узла дерева, максимальная глубина поддерева с этим узлом в качестве корня будет равна максимуму из глубин левого и правого поддеревьев, увеличенному на 1 (сам узел).</description></item><item><title>118. Pascal's Triangle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</guid><description>LeetCode задача 118
Задача Дано целое число numRows. Верните первые numRows строк Треугольника Паскаля.
В Треугольнике Паскаля каждое число является суммой двух чисел, находящихся непосредственно над ним.
Подсказки Для построения каждой следующей строки можно использовать последнюю строку в текущей итерации. Например, если есть строка [1, 2, 1], то следующая строка начнется и закончится с 1, а числа внутри будут получены путем сложения пар чисел: 1+2 и 2+1.
Подход Для того чтобы построить Треугольник Паскаля, начнем с первой строки, состоящей только из числа 1.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode задача 138
Задача Дан односвязный список, каждый узел которого содержит дополнительный &amp;ldquo;произвольный&amp;rdquo; указатель, который может указывать на любой узел в списке или быть null. Задача состоит в том, чтобы создать глубокую копию этого списка.
Подсказки Простое копирование значений не сработает. Нам нужно создать новые узлы и корректно установить как основные, так и &amp;ldquo;произвольные&amp;rdquo; указатели.
Подход / Идея решения Идея решения заключается в двухпроходном методе. В первом проходе мы создаем копии всех узлов исходного списка и сохраняем их в словаре, где ключом будет оригинальный узел, а значением — его копия.</description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</guid><description>LeetCode задача 151
Задача На вход подается строка s. Нам необходимо перевернуть порядок слов в этой строке. Слова определяются как последовательность символов без пробелов. Слова в s разделены хотя бы одним пробелом. Нужно вернуть строку, в которой слова расположены в обратном порядке, разделенные одним пробелом.
Важно: строка s может содержать начальные или конечные пробелы или множественные пробелы между двумя словами. В возвращаемой строке должен быть только один пробел, разделяющий слова. Лишние пробелы не включаем.
Подход Для решения задачи мы можем разделить строку на слова, используя пробел в качестве разделителя, а затем просто объединить их в обратном порядке.</description></item><item><title>206. Reverse Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/206/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/206/</guid><description>LeetCode задача 206
Задача Дана голова односвязного списка. Задача состоит в том, чтобы развернуть этот список и вернуть его развернутую версию.
Подсказки В этой задаче нам нужно просто обойти односвязный список и изменить направление его указателей.
Подход Задача заключается в изменении направления указателей односвязного списка. Она может быть решена с помощью итеративного метода, при котором мы будем двигаться по списку, сохраняя предыдущий элемент, текущий и следующий. Затем мы просто изменим направление указателя next для текущего элемента, чтобы он указывал на предыдущий элемент.</description></item><item><title>210. Course Schedule II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</guid><description>LeetCode задача 210
Задача Вам дано ( n ) курсов для изучения, пронумерованных от ( 0 ) до ( n-1 ), и массив ( prerequisites ), где ( prerequisites[i] = [a, b] ) означает, что для изучения курса ( a ) предварительно необходимо пройти курс ( b ).
Напишите функцию для нахождения порядка, в котором можно пройти курсы. Если это невозможно, верните пустой массив.
Подсказки Топологическая сортировка может быть использована для решения этой задачи.
Подход Создадим граф, представляющий предварительные требования для каждого курса.</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</guid><description>LeetCode задача 215
Задача Найти k-тый по величине элемент в неотсортированном массиве. Примечание: это k-тый по величине элемент в отсортированном порядке, а не k-тый различный элемент.
Подсказки Можно отсортировать массив и просто взять k-тый элемент с конца. Для более эффективного решения можно использовать алгоритм быстрой выборки. Подход В самом простом случае мы можем отсортировать массив и взять k-тый элемент с конца.
Алгоритм Сортируем массив. Возвращаем k-тый элемент с конца. Решение def findKthLargest(nums, k): nums.sort() return nums[-k]</description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</guid><description>LeetCode задача 236
Задача Найдите наименьшего общего предка (LCA) двух заданных узлов в бинарном дереве.
Подсказки Используйте метод обхода в глубину (DFS) для решения этой задачи.
Подход Обход в глубину (DFS): Используйте рекурсивный метод для обхода дерева. Поиск узлов: При обходе дерева ищите заданные узлы p и q. Возврат значения: Если найден один из узлов, верните его как потенциального предка. Сравнение результатов: Если оба поддерева возвращают узлы, текущий узел является LCA. Пропуск пустых узлов: Если узел пуст, верните None.</description></item><item><title>237. Delete Node in a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</guid><description>LeetCode задача 237
Задача Написать функцию для удаления узла (за исключением хвостового) в односвязном списке, дан только доступ к этому узлу.
Подсказки Обычно, для удаления узла из односвязного списка, нам нужен доступ к предыдущему узлу. В этом случае, у нас такого доступа нет. Как это обойти? Подход Поскольку доступа к предыдущему узлу нет, мы не можем просто &amp;ldquo;вырезать&amp;rdquo; текущий узел. Однако мы можем переписать значение текущего узла значением следующего узла и затем удалить следующий узел.
Алгоритм Перезаписываем значение текущего узла значением следующего узла.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</guid><description>LeetCode задача 238
Задача Дан целочисленный массив nums. Нужно вернуть массив answer, такой что answer[i] равен произведению всех элементов nums, кроме nums[i].
Подсказки Чтобы не использовать операцию деления и оставаться в рамках времени $O(n)$, можно использовать концепцию префиксного и суффиксного произведения для каждого элемента.
Подход Создадим два массива: prefix и suffix.
prefix[i] будет содержать произведение всех чисел слева от i suffix[i] будет содержать произведение всех чисел справа от i. Ответ для i будет равен prefix[i] * suffix[i]. Алгоритм Создадим два массива: prefix и suffix с таким же размером, что и nums.</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</guid><description>LeetCode задача 240
Задача Вам дана двумерная матрица размера m x n, представляющая прямоугольник, и целое число target. Отсортированные строки матрицы по неубыванию с лева направо и столбцы отсортированы по неубыванию сверху вниз.
Найдите элемент target в матрице. Верните True, если элемент target есть в матрице, и False, если его нет.
Подсказки Попробуйте использовать двоичный поиск для каждого ряда.
Подход Самый простой подход - использовать двоичный поиск для каждого ряда. Хотя это не самый эффективный метод, он достаточно прост для понимания.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</guid><description>LeetCode задача 251
Задача Дизайн и реализация итератора для 2D вектора. Итератор должен быть инициализирован 2D вектором (vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;) и должен поддерживать следующие операции:
next(): Возвращает следующий элемент из 2D вектора. Если нет больше элементов, возвращает 0. hasNext(): Возвращает True, если в 2D векторе есть следующий элемент, и False в противном случае. Подход Мы можем использовать две переменные: одну для текущего индекса строки и одну для текущего индекса столбца, чтобы навигироваться по 2D вектору.
Алгоритм Инициализируем переменные row и col в конструкторе.</description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</guid><description>LeetCode задача 277
Задача Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?
Имплементируйте функцию int findCelebrity(n), которая вернет знаменитость если она есть, иначе вернёт -1.
Вам дана функция bool knows(a, b), которая скажет вам, знает ли a человека b.
Подход Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.
Алгоритм Инициализируем переменную candidate значением 0.</description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</guid><description>LeetCode задача
Задача Дан целочисленный массив nums. Нам необходимо переместить все 0 в конец массива, сохраняя относительный порядок ненулевых элементов.
Примечание: вы должны сделать это на месте, без создания копии массива.
Подсказки Используйте два указателя: один будет указывать на текущий элемент, а другой будет указывать на первое место в массиве, куда можно поместить ненулевой элемент.
Подход Мы можем использовать два указателя: один для прохода по массиву и другой для отслеживания местоположения, куда следует поместить следующий ненулевой элемент. Этот метод позволяет нам сделать минимальное количество операций и изменений в массиве.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode задача 287
Задача Дан массив nums размера n + 1, в котором каждый элемент принимает значение от 1 до n, что означает, что как минимум одно число будет дублироваться.
Найдите это дублирующееся число.
Подход Один из способов решения задачи — использование двух указателей (tortoise и hare), что известно как &amp;ldquo;алгоритм зайца и черепахи&amp;rdquo; для нахождения цикла в связанном списке.
Алгоритм Инициализируем два указателя: tortoise и hare. Используем их для прохода по массиву: tortoise двигается на один шаг, а hare — на два.</description></item><item><title>300. Longest Increasing Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</guid><description>LeetCode задача 300
Задача Дан массив чисел, ваша задача — найти длину наибольшей возрастающей подпоследовательности.
Подсказки Для решения этой задачи вы можете использовать динамическое программирование.
Подход Инициализация: Инициализируйте массив, который будет хранить длины наибольших возрастающих подпоследовательностей для каждого элемента массива. Обход массива: Обойдите массив, и для каждого элемента обновите массив длин наибольших возрастающих подпоследовательностей. Максимум: По окончании обхода найдите максимальное значение в массиве длин. Простейший способ решения — это использовать двойной цикл для обхода массива и поиска наибольшей возрастающей подпоследовательности для каждого элемента.</description></item><item><title>328. Odd Even Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</guid><description>LeetCode задача 328
Задача Дан односвязный список и задача переставить его узлы таким образом, чтобы все узлы с нечетными индексами шли перед всеми узлами с четными индексами.
Вариант решения 1 Рассмотрим вариант решения более простой для понимания и реализации.
Подсказки Использовать два связных списка.
Подход Во время прохода по связному списку указатель для чётных узлов добавлять связанный список с четными, то же самое делать с нечетными.
В конце прохода список с четными узлами добавить в конец списка с нечетными узлами.</description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</guid><description>LeetCode problem
Задача Дан целочисленный массив nums. Вернуть true, если существует тройка индексов (i, j, k) таких, что
i &amp;lt; j &amp;lt; k и nums[i] &amp;lt; nums[j] &amp;lt; nums[k]. Если таких индексов нет, вернуть false.
Подсказки Для решения этой задачи вам необходимо найти возможное максимальное и минимальное число до текущего числа, не используя дополнительное пространство памяти.
Подход Мы можем обойти список, используя два указателя, чтобы хранить первое минимальное и последующие &amp;ldquo;два&amp;rdquo; минимальные значения, которые мы встретили до сих пор.</description></item><item><title>341. Flatten Nested List Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</guid><description>Задача Дан вложенный список целых чисел. Реализуйте итератор, который &amp;ldquo;разворачивает&amp;rdquo; этот вложенный список.
Подход Задача состоит в реализации итератора, который будет последовательно возвращать все элементы из вложенного списка. Вложенный список может содержать как обычные числа, так и другие вложенные списки. Наивное решение заключается в том, чтобы сначала полностью &amp;ldquo;развернуть&amp;rdquo; весь вложенный список в одномерный список, а затем реализовать итератор для этого одномерного списка.
Алгоритм Инициализация: Создать одномерный список и заполнить его элементами из вложенного списка. next(): Возвращает следующий элемент одномерного списка.</description></item><item><title>345. Reverse Vowels of a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/345/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/345/</guid><description>LeetCode задача 345
Задача Задана строка s. Необходимо перевернуть только гласные буквы в этой строке и вернуть результат.
Гласные буквы: 'a', 'e', 'i', 'o', 'u'. Они могут встречаться в верхнем и нижнем регистрах, и более одного раза.
Подсказки Для решения задачи можно использовать два указателя: один с начала строки, другой с конца. Затем можно двигаться этими указателями к центру строки, меняя местами гласные буквы.
Подход Используем два указателя для итерации по строке: один с начала (left), другой с конца (right).</description></item><item><title>377. Combination Sum IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</guid><description>LeetCode задача 377
Задача Дан массив различных целых чисел nums и целевое целое число target от 1 до 1000. Нужно вернуть количество возможных комбинаций, которые в сумме дают target.
Подсказки Построить дерево решений Задачу можно решить путем разложения ее на меньшие подзадачи с помощью динамического программирования. Нахождение целевого значения в дереве решений
Your browser does not support the video tag. LeetCode 377 Решение Подход Если целевое значение - target=7 и nums=[2, 3, 4], то в дереве решений может быть несколько путей до этого числа.</description></item><item><title>384. Shuffle an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</guid><description>LeetCode задача 384
Задача Реализуйте класс, который принимает массив чисел в конструкторе и предоставляет метод для их случайного перемешивания, а также метод для возвращения исходного массива.
Подсказки Для создания случайного порядка элементов можно использовать алгоритм Фишера-Йетса или другие методы перемешивания.
Подход Инициализация: Сохранить исходный массив в переменной класса для дальнейшего использования. reset(): Вернуть исходный массив. shuffle(): Вернуть перемешанный массив. Из всех возможных подходов к решению этой задачи, наиболее простым является использование встроенного метода random.shuffle() из Python стандартной библиотеки для перемешивания массива.</description></item><item><title>387. First Unique Character in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/387/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/387/</guid><description>LeetCode задача 387
Задача Дана строка s. Найдите первый уникальный символ в строке и верните его индекс. Если такого символа нет, верните -1.
Подсказки Использование хеш-таблицы может ускорить процесс поиска уникальных символов.
Подход Инициализация: Создайте хеш-таблицу для хранения частоты каждого символа в строке. Первый проход: Пройдите по строке и заполните хеш-таблицу. Второй проход: Пройдите по строке второй раз и проверьте частоту каждого символа в хеш-таблице. Первый символ с частотой 1 будет ответом. Этот подход прост для понимания и реализации.</description></item><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/392/</guid><description>LeetCode задача 392
Задача Даны две строки s и t. Верните true, если s является подпоследовательностью t, или false в противном случае.
Подпоследовательность строки - это новая строка, которая формируется из исходной строки путем удаления некоторых (может быть ни одного) символов без нарушения относительных позиций оставшихся символов. (например, &amp;ldquo;ace&amp;rdquo; является подпоследовательностью &amp;ldquo;abcde&amp;rdquo;, в то время как &amp;ldquo;aec&amp;rdquo; - нет).
Подсказки Следуя за обеими строками одновременно с помощью двух указателей, вы можете определить, является ли одна строка подпоследовательностью другой.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode задача 394
Задача На вход подается закодированная строка, необходимо вернуть её декодированное представление.
Правило кодирования таково: k[encoded_string], где encoded_string - строка внутри квадратных скобок, повторяется ровно k раз. k - это всегда положительное целое число.
Подсказки Для решения этой задачи можно использовать стек, т.к. число[строка] могут быть вложенными.
Подход Всё, что нам нужно, это итерировать строку символ за символом и обрабатывать четыре случая: числа, буквы и скобки. Мы будем использовать один стек для хранения пар вида (префикс строки, число).</description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</guid><description>LeetCode задача 437
Задача Дан корень бинарного дерева и целое число targetSum. Верните количество путей, где сумма значений вдоль пути равна targetSum.
Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).
Подсказки Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.
Подход Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня.</description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</guid><description>LeetCode задача 443
Задача Дан массив символов chars, ваша задача — сжать его с помощью следующего алгоритма: Заменить последовательность одинаковых символов одним символом, за которым идет его количество.
Пример: &amp;ldquo;aaabbaaa&amp;rdquo; =&amp;gt; &amp;ldquo;a3b2a3&amp;rdquo;
Подход В этой задаче у нас есть два указателя: один для чтения элементов из исходного массива (read_ptr) и второй для записи результата сжатия в тот же массив (write_ptr). Сначала оба указателя стоят на начале массива. Далее, read_ptr движется вправо, считая количество повторяющихся символов. После подсчета, мы записываем символ и его количество в массив, используя write_ptr.</description></item><item><title>454. 4Sum II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</guid><description>LeetCode задача 454
Задача Даны четыре списка A, B, C, D целых чисел. Вычислите, сколько существует таких кортежей (i, j, k, l), что ( A[i] + B[j] + C[k] + D[l] = 0 ).
Подсказки Используйте хэш-таблицу для ускорения решения.
Подход Создание хэш-таблицы: Сначала создайте хэш-таблицу, которая будет хранить суммы пар чисел из массивов A и B. Подсчет сумм: Для каждой пары (i, j) из A и B, увеличьте соответствующий элемент хэш-таблицы на 1. Поиск в хэш-таблице: Для каждой пары (k, l) из C и D, проверьте, существует ли -(C[k] + D[l]) в хэш-таблице.</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode задача 605
Задача Дана длинная грядка, на которой некоторые участки уже засажены, а некоторые нет. Однако цветы нельзя сажать на соседние участки.
Подход Чтобы решить эту задачу, мы будем итерироваться по каждому участку грядки. Если участок пустой и его соседи (если они существуют) тоже пусты, мы сажаем цветок и уменьшаем наш счетчик.
Алгоритм Итерируемся по каждому участку грядки. Если участок пустой, проверяем его соседей. Если левый сосед пустой или его нет (начало грядки), проверяем правого соседа. Если правый сосед пустой или его нет (конец грядки), сажаем цветок на текущий участок и уменьшаем n.</description></item><item><title>649. Dota2 Senate</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</guid><description>LeetCode задача 649
Задача В игре Dota2, сенат состоит из двух партий: партии &amp;ldquo;Radiant&amp;rdquo; и партии &amp;ldquo;Dire&amp;rdquo;. Сенат решает, когда будет следующая игра, и каждый сенатор может голосовать за бан одного из сенаторов из другой партии.
Забаненные сенаторы не могут делать действий и не участвуют в процессе подготовки следующего раунда.
Предположим, у нас есть строка &amp;ldquo;RRDDD&amp;rdquo;. Здесь первый сенатор принадлежит партии Radiant, второй тоже к Radiant, третий, четвертый и пятый к Dire. Сначала первый сенатор Radiant делает ход, затем первый сенатор Dire, и так далее.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode задача 725
Задача Дан односвязный список и целое число k. Задача заключается в том, чтобы разделить односвязный список на k последовательных частей.
Длина каждой части должна быть максимально равномерной: любые две части не должны отличаться по размеру более чем на одну единицу. Это может привести к тому, что некоторые части будут пустыми (null).
Части должны идти в том порядке, в котором они встречаются в исходном списке, и ранее встречающиеся части всегда должны иметь размер больше или равный позднее встречающимся.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode задача 735
Задача Мы имеем массив asteroids целых чисел, представляющих астероиды в ряду. Для каждого астероида абсолютное значение представляет его размер, а знак представляет его направление (положительное означает вправо, отрицательное влево). Все астероиды движутся с одинаковой скоростью. Необходимо определить состояние астероидов после всех столкновений.
Подсказки Для решения задачи можно использовать стек.
Подход Мы будем использовать стек для отслеживания движущихся вправо астероидов. Когда мы видим астероид, движущийся влево, мы проверяем, будет ли он сталкиваться с верхним элементом стека (астероидом, движущимся вправо).</description></item><item><title>872. Leaf-Similar Trees</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/872/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/872/</guid><description>LeetCode задача 872
Задача Даны два бинарных дерева с корнями root1 и root2. Проверьте, являются ли эти деревья &amp;ldquo;листоподобными&amp;rdquo; (leaf-similar). Деревья считаются &amp;ldquo;листоподобными&amp;rdquo;, если последовательность листовых узлов каждого дерева одинакова.
Подсказки Листовые узлы бинарного дерева — это узлы, у которых нет потомков. Для проверки &amp;ldquo;листоподобности&amp;rdquo; двух деревьев нужно сравнить последовательности листовых узлов этих деревьев.
Подход / Идея решения Идея решения заключается в построении списков листовых узлов для каждого дерева, а затем сравнении этих списков. Мы можем рекурсивно обойти каждое дерево, проверяя при каждом узле, является ли он листовым.</description></item><item><title>933. Number of Recent Calls</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/933/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/933/</guid><description>LeetCode задача 933
Задача Реализуйте класс RecentCounter для подсчета вызовов ping за последние 3000 миллисекунд.
Т.е. для вызова t=100, нужно подсчитать количество таких вызовов, время которых меньше t-3000 и учесть сам вызов.
Подход В данной задаче нужно отслеживать количество вызовов ping за последние 3000 миллисекунд.
Можно использовать очередь для хранения времени вызовов ping. При каждом новом вызове будем добавлять текущее время в конец очереди и удалять из начала все времена, которые не попадают в интервал последних 3000 миллисекунд.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1004/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1004/</guid><description>LeetCode задача 1004
Задача Дан массив A состоящий из 0 и 1, и число K. Найти максимальную длину подпоследовательности единиц, которую можно получить, преобразовав не более K нулей в единицы.
Подсказки Использование скользящего окна может значительно ускорить решение задачи.
Подход Инициализация: Создайте переменные для хранения начала и конца &amp;ldquo;окна&amp;rdquo; и максимальной длины подпоследовательности. Проход по массиву: Перемещайте &amp;ldquo;окно&amp;rdquo; по массиву, подсчитывая количество нулей внутри. Сдвиг окна: Если количество нулей превышает K, сдвигайте левый край окна, пока это не станет истиной.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode задача 1071
Задача Для двух строк str1 и str2, вернуть наибольший общий делитель (НОД). Если такового не существует, вернуть пустую строку.
Подход Если строки str1 и str2 имеют НОД строки X, то str1 и str2 могут быть представлены в форме Xn и Xm (где n и m — это натуральные числа), соответственно. Это означает, что str1 должна начинаться с str2 или наоборот.
Алгоритм Проверка начала строк: если str1 не начинается с str2 или наоборот, то НОД не существует.</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</guid><description>LeetCode задача 1359
Задача Дано n заказов, каждый заказ состоит из услуг по приему и доставке.
Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).
Так как ответ может быть очень большим, верните его по модулю 10^9 + 7.
Подсказки Использовать комбинаторный подход.
Для каждого нового заказа у нас есть 2 * (2n-1) способов добавить его в текущую последовательность.
Мы используем данную формулу, так как:
Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест).</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1372/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1372/</guid><description>LeetCode задача 1372
Задача Найти самый длинный &amp;ldquo;ZigZag&amp;rdquo; путь в бинарном дереве. Путь &amp;ldquo;ZigZag&amp;rdquo; означает альтернативное движение влево и вправо при переходе от одного узла к другому.
Подсказки Используйте Depth-First Search (DFS) для решения задачи.
Подход DFS с состоянием: Запустите DFS с дополнительным аргументом, который будет отслеживать, в какую сторону нужно двигаться следующим (влево или вправо). Обновление максимума: На каждом уровне рекурсии проверьте, не превышает ли текущая длина пути максимальную известную длину. Рекурсивный вызов: Продолжайте движение в обоих направлениях, но учитывайте, что направление должно изменяться.</description></item><item><title>1448. Count Good Nodes in Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1448/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1448/</guid><description>LeetCode задача 1448
Задача Дано бинарное дерево. Задача подсчитать количество &amp;ldquo;хороших&amp;rdquo; узлов. Узел считается &amp;ldquo;хорошим&amp;rdquo;, если на пути от корня дерева до этого узла (включительно) не встречается узлов с большим значением.
Подсказки &amp;ldquo;Хороший&amp;rdquo; узел в дереве — это узел, для которого все узлы на пути от корня до этого узла имеют значение не больше, чем значение этого узла.
Использовать метод обхода в глубину (DFS) для решения этой задачи.
Подход Идея решения задачи заключается в рекурсивном обходе дерева с сохранением максимального значения на пути от корня к текущему узлу.</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</guid><description>LeetCode задача 1647
Задача Строка s называется хорошей, если в ней нет двух разных символов с одинаковой частотой.
Дана строка s, верните минимальное количество символов, которое необходимо удалить, чтобы сделать s хорошим.
Подход Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.
Если проверять встречалась ли частота текущего символа ранее, то
Алгоритм / Абстрактный алгоритм Считаем частоты всех символов в строке. Сортируем частоты в порядке убывания.</description></item><item><title>1679. Max Number of K-Sum Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</guid><description>LeetCode задача 1679
Задача Вам дан массив чисел nums и целое число k. Задача — найти максимальное количество пар в массиве, сумма элементов которых равна k.
Подсказки Используйте технику двух указателей(pointers) после сортировки массива для оптимизации поиска пар.
Подход Центральная идея решения задачи заключается в использовании техники двух указателей для быстрого нахождения пар чисел с заданной суммой k. Прежде чем применить эту технику, массив сортируется в возрастающем порядке. Затем создаются два указателя: один, указывающий на начало массива, и второй — на конец.</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1732/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1732/</guid><description>LeetCode задача 1732
Задача Велосипедист совершает путешествие, которое состоит из n + 1 точек на разных высотах. Путешествие начинается с точки 0, где высота равна 0.
Дан целочисленный массив gain длиной n, где gain[i] — это прирост высоты между точками i и i + 1 для всех (0 &amp;lt;= i &amp;lt; n).
Задача - вернуть самую высокую высоту точки.
Подход В этой задаче, вам нужно пройти по массиву gain и вычислить текущую высоту на каждом этапе. При этом следует отслеживать самую высокую высоту, которую вы достигли.</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</guid><description>LeetCode задача 1768
Задача Вам даны две строки word1 и word2. Объедините эти строки, добавляя буквы в чередующем порядке, начиная с word1. Если одна строка длиннее другой, дополнительные буквы добавляются в конец результирующей строки.
Подход Чтобы решить эту задачу, мы можем использовать два указателя для каждого слова. Начнем с первого символа каждой строки и будем чередовать их, пока одна из строк не закончится. После этого, мы просто добавляем оставшиеся символы из более длинного слова к результирующей строке.
Алгоритм Инициализация результирующей строки и двух указателей для word1 и word2.</description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</guid><description>LeetCode задача 2095
Задача Дан связный список (linked list). Задача — удалить средний узел из этого списка и вернуть начало(head) измененного списка.
Подсказки Мы можем использовать метод двух указателей для того, чтобы найти средний узел в одном проходе по списку, где второй указатель проходит весь список в два раза быстрее первого указателя.
Подход Используем два указателя для прохода по списку: один медленный и один быстрый. Оба начинают с головного узла списка. Быстрый указатель будет двигаться в два раза быстрее медленного.</description></item><item><title>2130. Maximum Twin Sum of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</guid><description>LeetCode задача 2130
Задача Дан односвязный список четной длины. Узлы в этом списке имеют &amp;ldquo;близнецов&amp;rdquo; по определенным правилам. Задача — найти максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.
Т.е. у первой половины узлов списка есть свой близнец из второй половины.
Пример: для списка длиной n = 8 i = 0, twin = n-1-i = 8-1-0 = 7 i = 1, twin = n-1-1 = 6 i = 2, twin = n-1-2 = 5 &amp;hellip;
Подсказки У первой половины узлов списка есть свой близнец из второй половины, т.</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode задача 2352
Задача Дана квадратная матрица целых чисел grid размером n×n. Задача состоит в том, чтобы определить, сколько пар строк и столбцов в матрице идентичны по своему содержанию и порядку.
Строка и столбец считаются равными, если они содержат одни и те же элементы в том же порядке.
Подсказки Для решения задачи можно воспользоваться тем фактом, что каждая строка и столбец представляют собой набор чисел. Если мы конвертируем их в строки, то можем сравнивать их друг с другом.</description></item><item><title>Codeforces</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/codeforces/</link><pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/codeforces/</guid><description> Codeforces Решения Codeforces Туториал</description></item></channel></rss>