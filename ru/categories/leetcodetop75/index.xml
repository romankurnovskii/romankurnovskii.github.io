<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCodeTop75 on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/categories/leetcodetop75/</link><description>Recent content in LeetCodeTop75 on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2025</copyright><lastBuildDate>Mon, 04 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/categories/leetcodetop75/index.xml" rel="self" type="application/rss+xml"/><item><title>9. Palindrome Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/9/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/9/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/palindrome-number/">LeetCode задача&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Определите, является ли целое число палиндромом, не преобразуя его в строку.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Переворачивая число и сравнивая его с оригиналом, мы можем определить, является ли оно палиндромом.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Вместо того чтобы преобразовывать число в строку, мы можем перевернуть его цифры с использованием математических операций, а затем сравнить перевернутое число с оригинальным.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Если число отрицательное, то это не палиндром.&lt;/li>
&lt;li>Инициализируем переменную для перевернутого числа: мы будем создавать это число шаг за шагом.&lt;/li>
&lt;li>Переворачиваем число:
&lt;ul>
&lt;li>Это достигается путем последовательного взятия последней цифры числа и добавления её к текущему общему количеству после сдвига текущих цифр этого общего числа.&lt;/li>
&lt;li>Например, если у вас есть число 123, мы сначала возьмем 3, затем 2, и, наконец, 1, чтобы создать перевернутое число 321.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Сравним: Если перевернутое число равно оригинальному, то это палиндром.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">isPalindrome&lt;/span>(x: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Отрицательные числа не могут быть палиндромами&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> x &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализируем переменную для перевернутого числа со значением 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reversed_num &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Используем временную переменную, чтобы не менять оригинальное число&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#666">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Переворачиваем число&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> temp:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Извлекаем последнюю цифру текущего числа&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last_digit &lt;span style="color:#666">=&lt;/span> temp &lt;span style="color:#666">%&lt;/span> &lt;span style="color:#40a070">10&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># 12345 % 10 =&amp;gt; 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Сдвигаем текущие цифры перевернутого числа и добавляем последнюю цифру из temp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reversed_num &lt;span style="color:#666">=&lt;/span> reversed_num &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#40a070">10&lt;/span> &lt;span style="color:#666">+&lt;/span> last_digit &lt;span style="color:#60a0b0;font-style:italic"># 1. 0 * 10 + 5 =&amp;gt; 5, 2. 5 * 10 + 4 =&amp;gt; 54&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Удаляем последнюю цифру из temp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#666">//=&lt;/span> &lt;span style="color:#40a070">10&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># 12345 // 10 =&amp;gt; 1234&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Сравниваем перевернутое число с оригиналом&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> reversed_num &lt;span style="color:#666">==&lt;/span> x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/11/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/container-with-most-water/">LeetCode задача 11&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Вам дан массив, в котором каждый элемент представляет высоту стены. Высоты стен разные. Две стены и пространство между ними образуют контейнер. Ваша задача - найти контейнер, который может вместить максимальное количество воды.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Метод &amp;ldquo;Two Pointers&amp;rdquo;.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Цель этой задачи - найти пару &amp;ldquo;стен&amp;rdquo;, между которыми будет находиться максимальное количество &amp;ldquo;воды&amp;rdquo;. Вместимость контейнера определяется двумя факторами: расстоянием между стенками и минимальной высотой из двух стенок.&lt;/p>
&lt;p>Идея алгоритма заключается в следующем: начнем с самых &amp;ldquo;дальних&amp;rdquo; друг от друга стенок и будем постепенно &amp;ldquo;сужать&amp;rdquo; интервал, сдвигая одну из стенок внутрь массива. При этом всегда сдвигаем ту стенку, которая ниже, потому что движение более высокой стенки внутрь не приведёт к увеличению объёма контейнера (меньшая высота ограничивает его).&lt;/p>
&lt;p>Этот подход эффективен, потому что мы однократно проходим по всему массиву, каждый раз вычисляя и сравнивая вместимость текущего &amp;ldquo;контейнера&amp;rdquo; с максимальной найденной ранее.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Инициализация&lt;/strong>: Создаем два указателя, один на начале массива и другой на конце.&lt;/li>
&lt;li>&lt;strong>Выбор стенки&lt;/strong>: Сначала у нас есть весь массив для выбора стенки. Мы можем взять две крайние стенки, так как расстояние между ними максимально.&lt;/li>
&lt;li>&lt;strong>Перемещение указателей&lt;/strong>: После каждого шага, мы двигаем один из указателей внутрь массива. Указатель на меньшую стенку двигается внутрь, потому что движение указателя на большую стенку не может привести к большему контейнеру.&lt;/li>
&lt;li>&lt;strong>Обновление максимума&lt;/strong>: На каждом шаге мы проверяем, больше ли текущий контейнер предыдущего максимума. Если да, обновляем максимум.&lt;/li>
&lt;li>&lt;strong>Возврат результата&lt;/strong>: В конце работы алгоритма, возвращаем размер максимального контейнера.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxArea&lt;/span>(height: &lt;span style="color:#007020">list&lt;/span>[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализация указателей и максимума&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(height) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_area &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> left &lt;span style="color:#666">&amp;lt;&lt;/span> right:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_height &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">min&lt;/span>(height[left], height[right])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> area &lt;span style="color:#666">=&lt;/span> min_height &lt;span style="color:#666">*&lt;/span> (right &lt;span style="color:#666">-&lt;/span> left)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_area &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_area, area)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> height[left] &lt;span style="color:#666">&amp;lt;=&lt;/span> height[right]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_area
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/13/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/13/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/roman-to-integer/">LeetCode problem&lt;/a>&lt;/p>
&lt;p>Roman numerals are represented by seven different symbols: &lt;code>I&lt;/code>, &lt;code>V&lt;/code>, &lt;code>X&lt;/code>, &lt;code>L&lt;/code>, &lt;code>C&lt;/code>, &lt;code>D&lt;/code> and &lt;code>M&lt;/code>.&lt;/p>
&lt;pre>&lt;code>Symbol Value
I 1
V 5
X 10
L 50
C 100
D 500
M 1000
&lt;/code>&lt;/pre>
&lt;p>For example, &lt;code>2&lt;/code> is written as &lt;code>II&lt;/code> in Roman numeral, just two ones added together. 12 is written as &lt;code>XII&lt;/code>, which is simply &lt;code>X + II&lt;/code>. The number 27 is written as &lt;code>XXVII&lt;/code>, which is &lt;code>XX + V + II&lt;/code>.&lt;/p>
&lt;p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not &lt;code>IIII&lt;/code>. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:&lt;/p>
&lt;p>I can be placed before &lt;code>V&lt;/code> (5) and &lt;code>X&lt;/code> (10) to make 4 and 9.
X can be placed before &lt;code>L&lt;/code> (50) and &lt;code>C&lt;/code> (100) to make 40 and 90.
C can be placed before &lt;code>D&lt;/code> (500) and &lt;code>M&lt;/code> (1000) to make 400 and 900.&lt;/p>
&lt;p>Given a roman numeral, convert it to an integer.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre>&lt;code>Input: s = &amp;quot;III&amp;quot;
Output: 3
Explanation: III = 3.
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre>&lt;code>Input: s = &amp;quot;MCMXCIV&amp;quot;
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;/code>&lt;/pre>
&lt;h2 id="first-accepted">First accepted&lt;/h2>
&lt;p>&lt;p class="md__image">
&lt;img
src="../../assets/13.jpg"
id="zoom-default"
alt="test-case"
loading="lazy"
/>
&lt;/p>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">romanToInt&lt;/span>(self, s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">dict&lt;/span> &lt;span style="color:#666">=&lt;/span> {&lt;span style="color:#4070a0">&amp;#39;I&amp;#39;&lt;/span>:&lt;span style="color:#40a070">1&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;V&amp;#39;&lt;/span>:&lt;span style="color:#40a070">5&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;X&amp;#39;&lt;/span>:&lt;span style="color:#40a070">10&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;L&amp;#39;&lt;/span>:&lt;span style="color:#40a070">50&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;C&amp;#39;&lt;/span>:&lt;span style="color:#40a070">100&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;D&amp;#39;&lt;/span>:&lt;span style="color:#40a070">500&lt;/span>,&lt;span style="color:#4070a0">&amp;#39;M&amp;#39;&lt;/span>:&lt;span style="color:#40a070">1000&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> c &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">reversed&lt;/span>(s):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">dict&lt;/span>[c]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">-&lt;/span>n &lt;span style="color:#007020;font-weight:bold">if&lt;/span> n &lt;span style="color:#007020;font-weight:bold">in&lt;/span> (&lt;span style="color:#40a070">1&lt;/span>,&lt;span style="color:#40a070">10&lt;/span>,&lt;span style="color:#40a070">100&lt;/span>) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> prev &lt;span style="color:#007020;font-weight:bold">in&lt;/span> (n&lt;span style="color:#666">*&lt;/span>&lt;span style="color:#40a070">5&lt;/span>, n&lt;span style="color:#666">*&lt;/span>&lt;span style="color:#40a070">10&lt;/span>) &lt;span style="color:#007020;font-weight:bold">else&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n_sum &lt;span style="color:#666">+=&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">abs&lt;/span>(n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n_sum
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>104. Maximum Depth of Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/104/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/104/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">LeetCode задача 104&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан корень бинарного дерева. Задача состоит в том, чтобы найти его максимальную глубину. Глубина бинарного дерева определяется как максимальное количество узлов на пути от корня дерева до любого листового узла, включая сам корень.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Бинарное дерево представляет собой иерархическую структуру, в которой каждый узел имеет максимум двух потомков: левого и правого.&lt;/p>
&lt;h2 id="подход--идея-решения">Подход / Идея решения&lt;/h2>
&lt;p>Чтобы найти максимальную глубину бинарного дерева, можно использовать рекурсивный метод. Для каждого узла дерева, максимальная глубина поддерева с этим узлом в качестве корня будет равна максимуму из глубин левого и правого поддеревьев, увеличенному на 1 (сам узел).&lt;/p>
&lt;p>Сам алгоритм кажется интуитивно понятным, если представить дерево как иерархию: чтобы узнать, насколько &amp;ldquo;глубоко&amp;rdquo; уходит каждая ветвь, просто спуститесь по ней, пока не достигнете конца, затем вернитесь, собирая информацию о глубине каждого поддерева.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Если узел пуст, вернуть 0 (глубина пустого дерева равна 0).&lt;/li>
&lt;li>Рекурсивно найти глубину левого поддерева.&lt;/li>
&lt;li>Рекурсивно найти глубину правого поддерева.&lt;/li>
&lt;li>Максимальная глубина для текущего узла равна максимуму из глубин левого и правого поддеревьев, увеличенному на 1.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Определение для бинарного дерева.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class TreeNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, left=None, right=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.left = left&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.right = right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxDepth&lt;/span>(root):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_depth &lt;span style="color:#666">=&lt;/span> maxDepth(root&lt;span style="color:#666">.&lt;/span>left)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_depth &lt;span style="color:#666">=&lt;/span> maxDepth(root&lt;span style="color:#666">.&lt;/span>right)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">max&lt;/span>(left_depth, right_depth) &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/151/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reverse-words-in-a-string/">LeetCode задача 151&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>На вход подается строка &lt;code>s&lt;/code>. Нам необходимо перевернуть порядок слов в этой строке. Слова определяются как последовательность символов без пробелов. Слова в &lt;code>s&lt;/code> разделены хотя бы одним пробелом. Нужно вернуть строку, в которой слова расположены в обратном порядке, разделенные одним пробелом.&lt;/p>
&lt;p>&lt;mark>Важно:&lt;/mark> строка &lt;code>s&lt;/code> может содержать начальные или конечные пробелы или множественные пробелы между двумя словами. В возвращаемой строке должен быть только один пробел, разделяющий слова. Лишние пробелы не включаем.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Для решения задачи мы можем разделить строку на слова, используя пробел в качестве разделителя, а затем просто объединить их в обратном порядке.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Разделяем строку на слова.&lt;/li>
&lt;li>Переворачиваем список слов.&lt;/li>
&lt;li>Объединяем слова в строку, разделяя их одним пробелом.&lt;/li>
&lt;/ol>
&lt;h2 id="python-solution">Python Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reverseWords&lt;/span>(s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Разделяем строку на слова и сохраняем их в список&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> words &lt;span style="color:#666">=&lt;/span> s&lt;span style="color:#666">.&lt;/span>split()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Переворачиваем список слов&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> words&lt;span style="color:#666">.&lt;/span>reverse()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Объединяем слова в строку, разделяя их одним пробелом&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#666">.&lt;/span>join(words)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>206. Reverse Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/206/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/206/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reverse-linked-list/">LeetCode задача 206&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дана голова односвязного списка. Задача состоит в том, чтобы развернуть этот список и вернуть его развернутую версию.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>В этой задаче нам нужно просто обойти односвязный список и изменить направление его указателей.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Задача заключается в изменении направления указателей односвязного списка. Она может быть решена с помощью итеративного метода, при котором мы будем двигаться по списку, сохраняя предыдущий элемент, текущий и следующий. Затем мы просто изменим направление указателя &lt;code>next&lt;/code> для текущего элемента, чтобы он указывал на предыдущий элемент.&lt;/p>
&lt;p>Этот процесс можно визуализировать как переворачивание стрелок между узлами списка в обратном направлении. Изначально указатели направлены от головы списка к его концу. После разворота они будут направлены от конца к голове, превращая последний элемент в новую голову списка.&lt;/p>
&lt;p>&lt;strong>Пример:&lt;/strong>&lt;/p>
&lt;p>Начальный список: [1 -&amp;gt; 2] должен стать [1 &amp;lt;- 2], а точнее [None &amp;lt;- 1 &amp;lt;- 2]&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Имеем следующие значения:&lt;/p>
&lt;ol>
&lt;li>current = 1&lt;/li>
&lt;li>next = 2 (current.next)&lt;/li>
&lt;li>prev = None&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Переставляем местами в определенном порядке:&lt;/p>
&lt;ol>
&lt;li>next = current.next (2)&lt;/li>
&lt;li>current.next -&amp;gt; None (prev)&lt;/li>
&lt;li>prev = current (1)&lt;/li>
&lt;li>current = next (2)&lt;/li>
&lt;li>После данных перестановок текущий указатель смотрит на 2, следующий по счету узел.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Инициализация&lt;/strong>: Инициализируем два указателя — один (&lt;code>curr&lt;/code>) для текущего элемента и другой (&lt;code>prev&lt;/code>) для предыдущего. Изначально &lt;code>prev&lt;/code> будет &lt;code>None&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Обход списка&lt;/strong>: В цикле, пока текущий элемент не станет &lt;code>None&lt;/code>, делаем следующее:&lt;/p>
&lt;ol>
&lt;li>Сохраняем указатель на следующий элемент (&lt;code>next&lt;/code>).&lt;/li>
&lt;li>Изменяем указатель &lt;code>next&lt;/code> текущего элемента, чтобы он указывал на &lt;code>prev&lt;/code>.&lt;/li>
&lt;li>Перемещаем &lt;code>prev&lt;/code> и &lt;code>curr&lt;/code> на одну позицию вперед.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Возврат результата&lt;/strong>: В конце &lt;code>prev&lt;/code> будет указывать на новую голову списка.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Определение для односвязного списка.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class ListNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, next=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.next = next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reverseList&lt;/span>(head):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализируем предыдущий элемент как None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#666">=&lt;/span> head &lt;span style="color:#60a0b0;font-style:italic"># текущий&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> curr:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">next&lt;/span> &lt;span style="color:#666">=&lt;/span> curr&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#60a0b0;font-style:italic"># Сохраняем следующий элемент&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> prev &lt;span style="color:#60a0b0;font-style:italic"># Меняем направление указателя&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> curr &lt;span style="color:#60a0b0;font-style:italic"># Перемещаем предыдущий элемент вперед&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Перемещаем текущий элемент вперед&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> prev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/238/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/product-of-array-except-self/">LeetCode задача 238&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан целочисленный массив &lt;code>nums&lt;/code>. Нужно вернуть массив &lt;code>answer&lt;/code>, такой что &lt;code>answer[i]&lt;/code> равен произведению всех элементов &lt;code>nums&lt;/code>, кроме &lt;code>nums[i]&lt;/code>.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Чтобы не использовать операцию деления и оставаться в рамках времени $O(n)$, можно использовать концепцию &lt;mark>префиксного и суффиксного произведения&lt;/mark> для каждого элемента.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Создадим два массива: &lt;code>prefix&lt;/code> и &lt;code>suffix&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>prefix[i]&lt;/code> будет содержать произведение всех чисел слева от &lt;code>i&lt;/code>&lt;/li>
&lt;li>&lt;code>suffix[i]&lt;/code> будет содержать произведение всех чисел справа от &lt;code>i&lt;/code>.&lt;/li>
&lt;li>Ответ для &lt;code>i&lt;/code> будет равен &lt;code>prefix[i] * suffix[i]&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Создадим два массива: &lt;code>prefix&lt;/code> и &lt;code>suffix&lt;/code> с таким же размером, что и &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>Проходим по &lt;code>nums&lt;/code> слева направо, заполнив массив &lt;code>prefix&lt;/code>, где &lt;code>prefix[i]&lt;/code> - это произведение всех предыдущих элементов.
&lt;ol>
&lt;li>Начинаем с 2-го элемента(&lt;code>index=1&lt;/code>), т.к. нету элементов левее самого первого&lt;/li>
&lt;li>В каждую ячейку &lt;code>prefix[i]&lt;/code> записываем результат произведения значения слева от числа &lt;code>nums[i]&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Проходим по &lt;code>nums&lt;/code> справа налево, заполнив массив &lt;code>suffix&lt;/code> таким же образом.
&lt;ol>
&lt;li>Начинаем с предпоследнего, т.к. нет элемента правее правого&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Перемножаем произведения
&lt;ol>
&lt;li>Для каждого &lt;code>i&lt;/code>, &lt;code>answer[i] = prefix[i] * suffix[i]&lt;/code>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.python.org/3/library/functions.html#func-range">class range(start, stop, step=1)&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">productExceptSelf&lt;/span>(nums: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> List[&lt;span style="color:#007020">int&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prefix &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prefix[i] &lt;span style="color:#666">=&lt;/span> prefix[i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> nums[i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> suffix &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">2&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>, &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> suffix[i] &lt;span style="color:#666">=&lt;/span> suffix[i &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> nums[i &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer&lt;span style="color:#666">.&lt;/span>append(prefix[i] &lt;span style="color:#666">*&lt;/span> suffix[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> answer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="с-комментарием">С комментарием&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">productExceptSelf&lt;/span>(nums: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> List[&lt;span style="color:#007020">int&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Слева от текущего. Направление -&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prefix &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#40a070">1&lt;/span>, n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prefix[i] &lt;span style="color:#666">=&lt;/span> prefix[i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> nums[i &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 0. nums = [2,3,4,5], res = [1,1,1,1]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 1. i=1, res = [1, 1*2, 1, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 2. i=2, res = [1, 2, 2*3, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># 3. i=3, res = [1, 2, 6, 6*4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Справа от текущего. Направление &amp;lt;-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> suffix &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start &lt;span style="color:#666">=&lt;/span> n &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stop &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Включая 0-й индекс&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> step &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># в обратном порядке, справа налево&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(start, stop, step):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># перемножаем элемент и результат предыдущего вычисления, что справа&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> suffix[i] &lt;span style="color:#666">=&lt;/span> suffix[i &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">*&lt;/span> nums[i &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res&lt;span style="color:#666">.&lt;/span>append(prefix[i] &lt;span style="color:#666">*&lt;/span> suffix[i])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;video width="100%" controls>
&lt;source src="../../assets/238.ru.mp4" type="video/mp4">
Your browser does not support the video tag.
&lt;/video>
&lt;figcaption>LeetCode 238 Решение&lt;/figcaption></description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/283/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/move-zeroes/">LeetCode задача&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан целочисленный массив &lt;code>nums&lt;/code>. Нам необходимо переместить все &lt;code>0&lt;/code> в конец массива, сохраняя относительный порядок ненулевых элементов.&lt;/p>
&lt;p>&lt;em>Примечание:&lt;/em> вы должны сделать это на месте, без создания копии массива.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Используйте два указателя: один будет указывать на текущий элемент, а другой будет указывать на первое место в массиве, куда можно поместить ненулевой элемент.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Мы можем использовать два указателя: один для прохода по массиву и другой для отслеживания местоположения, куда следует поместить следующий ненулевой элемент. Этот метод позволяет нам сделать минимальное количество операций и изменений в массиве.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем два указателя на начало массива.
&lt;ol>
&lt;li>Первый указатель - это индексы массива. Второй с начальным значением 0,&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Используя первый указатель, проходим по массиву.
&lt;ol>
&lt;li>Если текущий элемент не равен нулю, помещаем его на позицию, указанную вторым указателем (меняем значения местами), и перемещаем второй указатель на одну позицию вперед.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>После завершения прохода, все числа после второго указателя должны быть установлены в 0.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">moveZeroes&lt;/span>(nums: List[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># Указатель для ненулевых элементов&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[i] &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic"># Если текущий элемент не 0, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums[i], nums[pos] &lt;span style="color:#666">=&lt;/span> nums[pos], nums[i] &lt;span style="color:#60a0b0;font-style:italic"># меняем его местами с элементом на позиции pos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>332. Reconstruct Itinerary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/332/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/332/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reconstruct-itinerary/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from &amp;ldquo;JFK&amp;rdquo;, thus, the itinerary must begin with &amp;ldquo;JFK&amp;rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>One naive solution would be to use backtracking and try all possible combinations of tickets to form a valid itinerary. While this could work for small inputs, it&amp;rsquo;s not efficient for larger numbers of tickets.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;ul>
&lt;li>Consider the tickets as a directed graph where each airport is a node, and a ticket between two airports represents a directed edge.&lt;/li>
&lt;li>For this problem, instead of a depth-first traversal, the solution employs an iterative approach using a stack.&lt;/li>
&lt;/ul>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>We can visualize this problem as a directed graph traversal task. Every ticket is a directed edge between two airports. The challenge is to find a path that uses all the directed edges and starts from JFK.&lt;/p>
&lt;p>The stack is an essential data structure for this solution, and here&amp;rsquo;s why:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>A stack helps in maintaining the path. When visiting an airport, we&amp;rsquo;re not sure if this path will lead to a solution (because it might end up in a dead-end). Hence, pushing the airports to the stack gives us the flexibility to backtrack easily (by popping out the last visited airport) if we reach a dead-end.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>When all destinations from an airport are exhausted, it means we have found the end of that particular path. At this moment, by adding the airport to our final result and removing it from the stack, we backtrack to find the remaining itinerary.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The graph for this solution is a dictionary (specifically, a &lt;code>defaultdict&lt;/code> for ease of handling non-existing keys). The keys of this dictionary are the source airports, and the values are a list of destination airports. Importantly, these destinations are sorted in reverse lexicographical order because we will be utilizing the &lt;code>pop()&lt;/code> function to retrieve and remove the last element from these lists. This ensures that we always get the smallest lexical destination available without any extra computational overhead.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Convert the given list of tickets into a graph where each node (airport) points to a list of its destinations.&lt;/li>
&lt;li>Sort the destinations in reverse lexicographical order to aid in retrieving the smallest lexical order when using pop().&lt;/li>
&lt;li>Use a stack to iteratively traverse the graph, always trying to go to the smallest lexical destination possible.&lt;/li>
&lt;li>When stuck at a node (airport) with no unvisited outbound paths, add it to the final itinerary.&lt;/li>
&lt;li>Continue the process until the stack is empty.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> defaultdict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findItinerary&lt;/span>(tickets):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph &lt;span style="color:#666">=&lt;/span> defaultdict(&lt;span style="color:#007020">list&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Convert tickets into a graph with destinations for each departure&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> src, dest &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(tickets, reverse&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">True&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[src]&lt;span style="color:#666">.&lt;/span>append(dest)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#4070a0">&amp;#34;JFK&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> stack: &lt;span style="color:#60a0b0;font-style:italic"># Traverse the graph using the stack&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> graph[stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>]]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append(graph[stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>]]&lt;span style="color:#666">.&lt;/span>pop())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(stack&lt;span style="color:#666">.&lt;/span>pop())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result[::&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#60a0b0;font-style:italic"># The result will be in reverse order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># because of the way nodes are added to the result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/334/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/increasing-triplet-subsequence/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан целочисленный массив &lt;code>nums&lt;/code>. Вернуть &lt;code>true&lt;/code>, если существует тройка индексов &lt;code>(i, j, k)&lt;/code> таких, что&lt;/p>
&lt;ul>
&lt;li>&lt;code>i &amp;lt; j &amp;lt; k&lt;/code> и&lt;/li>
&lt;li>&lt;code>nums[i] &amp;lt; nums[j] &amp;lt; nums[k]&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Если таких индексов нет, вернуть &lt;code>false&lt;/code>.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения этой задачи вам необходимо найти возможное максимальное и минимальное число до текущего числа, не используя дополнительное пространство памяти.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Мы можем обойти список, используя два указателя, чтобы хранить &lt;mark>первое минимальное и последующие &amp;ldquo;два&amp;rdquo; минимальные&lt;/mark> значения, которые мы встретили до сих пор.&lt;/p>
&lt;p>Затем, если мы находим число, которое больше обоих, это значит, что у нас есть тройка в последовательности.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;p>Алгоритм основан на идее поиска последовательности из трех возрастающих чисел.&lt;/p>
&lt;p>Мы ищем два наименьших числа &lt;code>min1&lt;/code> и &lt;code>min2&lt;/code> из массива, и если мы находим третье число &lt;code>array[i]&lt;/code>, которое больше &lt;code>min2&lt;/code>, то мы нашли требуемую последовательность.&lt;/p>
&lt;p>В противном случае мы возвращаем &lt;code>false&lt;/code>, так как набор чисел не удовлетворяет условиям задачи.&lt;/p>
&lt;ol>
&lt;li>Объявляем две переменные - &lt;code>min1&lt;/code> и &lt;code>min2&lt;/code> - и инициализируем их максимально возможными значениями (INT_MAX).&lt;/li>
&lt;li>Проходим через входной массив поэлементно.&lt;/li>
&lt;li>Если текущий элемент &lt;code>array[i]&lt;/code> меньше &lt;code>min1&lt;/code>, обновляем &lt;code>min1&lt;/code> на &lt;code>array[i]&lt;/code>.&lt;/li>
&lt;li>Если текущий элемент &lt;code>array[i]&lt;/code> больше &lt;code>min1&lt;/code>, но меньше &lt;code>min2&lt;/code>, обновляем min2 на &lt;code>array[i]&lt;/code>.&lt;/li>
&lt;li>Если текущий элемент &lt;code>array[i]&lt;/code> больше &lt;code>min2&lt;/code>, значит, у нас есть последовательность из трех чисел, удовлетворяющая условиям задачи. Возвращаем &lt;code>true&lt;/code>.&lt;/li>
&lt;li>Если после прохода по всем элементам мы не нашли такую последовательность, возвращаем &lt;code>false&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">increasingTriplet&lt;/span>(nums: &lt;span style="color:#007020">list&lt;/span>[&lt;span style="color:#007020">int&lt;/span>]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализация минимальных значений&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">float&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;inf&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">float&lt;/span>(&lt;span style="color:#4070a0">&amp;#39;inf&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> n &lt;span style="color:#007020;font-weight:bold">in&lt;/span> nums:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> n &lt;span style="color:#666">&amp;lt;=&lt;/span> min1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min1 &lt;span style="color:#666">=&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> n &lt;span style="color:#666">&amp;lt;=&lt;/span> min2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min2 &lt;span style="color:#666">=&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если число больше min2, значит у нас есть возрастающая тройка&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>345. Reverse Vowels of a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/345/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/345/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">LeetCode задача 345&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Задана строка &lt;code>s&lt;/code>. Необходимо перевернуть только гласные буквы в этой строке и вернуть результат.&lt;/p>
&lt;p>Гласные буквы: &lt;code>'a', 'e', 'i', 'o', 'u'&lt;/code>. Они могут встречаться в верхнем и нижнем регистрах, и более одного раза.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения задачи можно использовать &lt;mark>два указателя&lt;/mark>: один с начала строки, другой с конца. Затем можно двигаться этими указателями к центру строки, меняя местами гласные буквы.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Используем два указателя для итерации по строке: один с начала (&lt;code>left&lt;/code>), другой с конца (&lt;code>right&lt;/code>). Двигаем их к центру, меняя местами гласные буквы, которые они встречают.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем два указателя: &lt;code>left&lt;/code> на начало строки, &lt;code>right&lt;/code> на конец.&lt;/li>
&lt;li>Конвертируем строку в список для удобства манипуляций.&lt;/li>
&lt;li>Пока &lt;code>left&lt;/code> &amp;lt; &lt;code>right&lt;/code>:
&lt;ol>
&lt;li>Находим следующую гласную букву с начала, двигая &lt;code>left&lt;/code> вправо.&lt;/li>
&lt;li>Находим следующую гласную букву с конца, двигая &lt;code>right&lt;/code> влево.&lt;/li>
&lt;li>Меняем местами гласные буквы.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Возвращаем преобразованный список как строку.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">reverseVowels&lt;/span>(s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vowels &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>(&lt;span style="color:#4070a0">&amp;#34;aeiouAEIOU&amp;#34;&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Создадим множество гласных букв для быстрого поиска&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s_list &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">list&lt;/span>(s) &lt;span style="color:#60a0b0;font-style:italic"># Преобразуем строку в список&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left, right &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#007020">len&lt;/span>(s) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># указатели&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> left &lt;span style="color:#666">&amp;lt;&lt;/span> right:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Находим следующую гласную с начала строки&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> left &lt;span style="color:#666">&amp;lt;&lt;/span> right &lt;span style="color:#007020;font-weight:bold">and&lt;/span> s_list[left]&lt;span style="color:#666">.&lt;/span>lower() &lt;span style="color:#007020;font-weight:bold">not&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Находим следующую гласную с конца строки&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> left &lt;span style="color:#666">&amp;lt;&lt;/span> right &lt;span style="color:#007020;font-weight:bold">and&lt;/span> s_list[right]&lt;span style="color:#666">.&lt;/span>lower() &lt;span style="color:#007020;font-weight:bold">not&lt;/span> &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Меняем гласные местами&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s_list[left], s_list[right] &lt;span style="color:#666">=&lt;/span> s_list[right], s_list[left]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Двигаем указатели&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">.&lt;/span>join(s_list)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/392/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/is-subsequence/">LeetCode задача 392&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Даны две строки &lt;code>s&lt;/code> и &lt;code>t&lt;/code>. Верните &lt;code>true&lt;/code>, если &lt;code>s&lt;/code> является подпоследовательностью &lt;code>t&lt;/code>, или &lt;code>false&lt;/code> в противном случае.&lt;/p>
&lt;p>Подпоследовательность строки - это новая строка, которая формируется из исходной строки путем удаления некоторых (может быть ни одного) символов без нарушения относительных позиций оставшихся символов. (например, &amp;ldquo;ace&amp;rdquo; является подпоследовательностью &amp;ldquo;abcde&amp;rdquo;, в то время как &amp;ldquo;aec&amp;rdquo; - нет).&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Следуя за обеими строками одновременно с помощью двух указателей, вы можете определить, является ли одна строка подпоследовательностью другой.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Мы можем использовать &lt;mark>два указателя&lt;/mark>, проходясь по каждому символу в строке &lt;code>t&lt;/code> и проверяя, соответствует ли он текущему символу в строке &lt;code>s&lt;/code>.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем два указателя, один для строки &lt;code>s&lt;/code>, другой для строки &lt;code>t&lt;/code> с 0.&lt;/li>
&lt;li>Пока оба указателя находятся в пределах своих строк:
&lt;ol>
&lt;li>Если символы, на которые указывают указатели, &lt;strong>совпадают&lt;/strong>, перемещаем указатель для &lt;code>s&lt;/code> на следующий символ.&lt;/li>
&lt;li>Перемещаем указатель для &lt;code>t&lt;/code> на следующий символ, независимо от того, совпали символы или нет.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Если указатель для &lt;code>s&lt;/code> достиг конца строки, это означает, что &lt;code>s&lt;/code> является подпоследовательностью &lt;code>t&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">isSubsequence&lt;/span>(s: &lt;span style="color:#007020">str&lt;/span>, t: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">bool&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pointer_s, pointer_t &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Пока указатели в пределах своих строк&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> pointer_s &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(s) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> pointer_t &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(t):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если символы совпадают, перемещаем указатель для s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> s[pointer_s] &lt;span style="color:#666">==&lt;/span> t[pointer_t]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pointer_s &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Перемещаем указатель для t&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pointer_t &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если указатель для s достиг конца строки, s является подпоследовательностью t&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> pointer_s &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#007020">len&lt;/span>(s)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/394/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/decode-string/">LeetCode задача 394&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>На вход подается закодированная строка, необходимо вернуть её декодированное представление.&lt;/p>
&lt;p>Правило кодирования таково: &lt;code>k[encoded_string]&lt;/code>, где &lt;code>encoded_string&lt;/code> - строка внутри квадратных скобок, повторяется ровно &lt;code>k&lt;/code> раз. &lt;code>k&lt;/code> - это всегда положительное целое число.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения этой задачи можно использовать стек, т.к. &lt;code>число[строка]&lt;/code> могут быть вложенными.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Всё, что нам нужно, это итерировать строку символ за символом и обрабатывать &lt;mark>четыре случая: числа, буквы и скобки&lt;/mark>. Мы будем использовать один стек для хранения пар вида (префикс строки, число).&lt;/p>
&lt;p>Т.к. число и строка могут быть внутри другой строки (&lt;code>3[a2[c]] = 3 * (a + 2 * c)&lt;/code>). То используя стек, в котором можем хранить текущую строку до тех пор пока не увидим закрывающуюся скобку для этой строки.&lt;/p>
&lt;p>Например:&lt;/p>
&lt;ol>
&lt;li>Число 3&lt;/li>
&lt;li>Открывается скобка. Мы еще не знаем какая будет строка далее, но открывающаяся &lt;code>[&lt;/code> скобка сообщает, что мы уже точно знаем строку(или ее префикс), которая была &lt;strong>до&lt;/strong> это скобки.
&lt;ol>
&lt;li>
&lt;p>В данном случае при первой скобке строка до нее пустая.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>А при первой скобке после 2, строка равна &lt;code>a&lt;/code>. Вот эту строку мы и будем складывать с той строкой, которая будет перед следующей открывающейся скобкой.&lt;/p>
&lt;ol>
&lt;li>В таком случае получится начало &lt;code>'' + 3 * ('a' + 2 * ... )&lt;/code>&lt;/li>
&lt;li>B стек будет следующего вида:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>, 3&lt;span style="color:#666">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#4070a0">&amp;#39;a&amp;#39;&lt;/span>, 2&lt;span style="color:#666">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Когда доходим до следующей строки и видим скобку закрытия &amp;lsquo;]&amp;rsquo;, то берем последние данные из стека и складываем предыдущую строку с умноженной текущей строкой.
&lt;ol>
&lt;li>&lt;code>a + 2*c = acc&lt;/code>&lt;/li>
&lt;li>&lt;code>'' * 3 * acc&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем пустой стек и две переменные для текущей строки и текущего числа.&lt;/li>
&lt;li>Итерируемся по каждому символу в входной строке.
&lt;ol>
&lt;li>Если символ является числом, определяем всё число (возможно, из нескольких цифр).&lt;/li>
&lt;li>Если символ открывающая скобка, добавляем пару (текущая строка, текущее число) в стек и сбрасываем переменные.&lt;/li>
&lt;li>Если символ закрывающая скобка, вытаскиваем последнюю пару из стека, и обновляем текущую строку.&lt;/li>
&lt;li>Если символ является буквой, добавляем его к текущей строке.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">decodeString&lt;/span>(s: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#666">=&lt;/span> [] &lt;span style="color:#60a0b0;font-style:italic"># стек для пар (строка, число)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># текущая декодированная строка&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_num &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># текущее число&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> char &lt;span style="color:#007020;font-weight:bold">in&lt;/span> s:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> char&lt;span style="color:#666">.&lt;/span>isdigit():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_num &lt;span style="color:#666">+=&lt;/span> char
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> char &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;[&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># сохраним, что есть на текущий момент&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append((curr_str, &lt;span style="color:#007020">int&lt;/span>(curr_num)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_num &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> char &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#34;]&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev_str, num &lt;span style="color:#666">=&lt;/span> stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">=&lt;/span> prev_str &lt;span style="color:#666">+&lt;/span> num &lt;span style="color:#666">*&lt;/span> curr_str
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr_str &lt;span style="color:#666">+=&lt;/span> char
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> curr_str
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;video width="100%" controls>
&lt;source src="../../assets/394.ru.mp4" type="video/mp4">
Your browser does not support the video tag.
&lt;/video>
&lt;figcaption>LeetCode 394 Решение&lt;/figcaption></description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/437/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/path-sum-iii/">LeetCode задача 437&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан корень бинарного дерева и целое число &lt;code>targetSum&lt;/code>. Верните количество путей, где сумма значений вдоль пути равна &lt;code>targetSum&lt;/code>.&lt;/p>
&lt;p>Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня. При этом на каждом уровне рекурсии мы проверяем, есть ли путь от &lt;strong>текущего узла&lt;/strong>, сумма которого равна &lt;code>targetSum&lt;/code>.&lt;/p>
&lt;p>&lt;mark>Часть 1: Обновлять корневой узел на каждом уровне рекурсии&lt;/mark>&lt;/p>
&lt;p>Под &lt;strong>текущим узлом&lt;/strong> будем иметь ввиду корневой узел (&lt;code>root&lt;/code>).&lt;/p>
&lt;p>Например, при дереве с узлами: &lt;code>[10,5,-3,3,2,null,11,3,-2,null,1]&lt;/code> и &lt;code>targetSum=8&lt;/code>&lt;/p>
&lt;p>&lt;strong>Итого каждый узел будет в какой-то момент корневым узлом.&lt;/strong>&lt;/p>
&lt;p>Текущий корневой узел (&lt;code>root&lt;/code>) = 10.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Мы обходим все возможные отрезки от текущего&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Сверяем суммы этих отрезков с &lt;code>targetSum&lt;/code> :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span> ([10], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 3, -2], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 2], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 5, 2, 1], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([10, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>После того как рассмотрели все возможные отрезки от текущего &lt;code>root=10&lt;/code>, мы идем рассматривать все возможные отрезки от нового &lt;code>root&lt;/code>.&lt;/p>
&lt;p>Новые &lt;code>root&lt;/code> становятся &lt;code>root.left&lt;/code> и &lt;code>root.right&lt;/code>.&lt;/p>
&lt;p>Тогда следующая итерация будет выглядеть следующим образом:&lt;/p>
&lt;p>Текущий корневой узел (&lt;code>root&lt;/code>) = 5.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span> ([5], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([5, 3], 8) !! нашли один отрезок
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ([5, 3, 3], 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>&lt;mark>Часть 2: Правильный подсчет сумм от корня дерева до текущего узла&lt;/mark>&lt;/p>
&lt;p>Когда корневой узел был 10, мы должны были ничего предпринимать.&lt;/p>
&lt;p>Но когда во время рекурсии корневой узел будет на уровень меньше, например 5, функция должна понимать, что сумму текущего отрезка и всех его дочерних нужно считать от нового корня дерева, т.е. от 5, и так далее.&lt;/p>
&lt;p>Например: текущий корень 10, а узел 3, т.е. мы должны посчитать равен ли отрезок [10,5,3] целевому числу 8.&lt;/p>
&lt;p>Для этого узел 3 должен знать значения, которые были до него.&lt;/p>
&lt;p>Решение:&lt;/p>
&lt;ol>
&lt;li>функция с данным узлом может принимать сумму отрезка, пройденного до него&lt;/li>
&lt;li>после этого функция считает равна ли сумма значению до текущего узла и значение самого узла целевому числу &lt;code>targetSum&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>В данном случае [10,5,3] сумма до текущего узла равна $10+5=15$. Если $15+3 == 8$, то текущий отрезок подходит.&lt;/p>
&lt;h2 id="алгоритм--абстрактный-алгоритм">Алгоритм / Абстрактный алгоритм&lt;/h2>
&lt;ol>
&lt;li>Обходим дерево, начиная с корня дерева.&lt;/li>
&lt;li>Для каждого узла, проверяем существует ли путь &lt;strong>от этого узла&lt;/strong>, сумма которого равна &lt;code>targetSum&lt;/code>, перебирая все возможные дочерние пути.&lt;/li>
&lt;li>Рекурсивно выполняем шаги 1 и 2 для всех дочерних узлов.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Definition for a binary tree node.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class TreeNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, left=None, right=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.left = left&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.right = right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">pathSum&lt;/span>(self, root, targetSum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">dfs&lt;/span>(node, current_path_sum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> node:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_path_sum &lt;span style="color:#666">+=&lt;/span> node&lt;span style="color:#666">.&lt;/span>val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> current_path_sum &lt;span style="color:#666">==&lt;/span> targetSum: &lt;span style="color:#60a0b0;font-style:italic"># Равна ли текущая сумма целевому значению&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>left, current_path_sum) &lt;span style="color:#60a0b0;font-style:italic"># Считаем пути для левого &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> dfs(node&lt;span style="color:#666">.&lt;/span>right, current_path_sum) &lt;span style="color:#60a0b0;font-style:italic"># и правого дочернего узла&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root_count &lt;span style="color:#666">=&lt;/span> dfs(root, &lt;span style="color:#40a070">0&lt;/span>) &lt;span style="color:#60a0b0;font-style:italic"># Считаем все отрезки для текущего корня дерева&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_count &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>pathSum(root&lt;span style="color:#666">.&lt;/span>left, targetSum) &lt;span style="color:#60a0b0;font-style:italic"># новый корневой узел (левый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_count &lt;span style="color:#666">=&lt;/span> self&lt;span style="color:#666">.&lt;/span>pathSum(root&lt;span style="color:#666">.&lt;/span>right, targetSum) &lt;span style="color:#60a0b0;font-style:italic"># и правый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> root_count &lt;span style="color:#666">+&lt;/span> left_count &lt;span style="color:#666">+&lt;/span> right_count
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/443/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/string-compression/">LeetCode задача 443&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан массив символов &lt;code>chars&lt;/code>, ваша задача — сжать его с помощью следующего алгоритма: Заменить последовательность одинаковых символов одним символом, за которым идет его количество.&lt;/p>
&lt;p>Пример: &amp;ldquo;aaabbaaa&amp;rdquo; =&amp;gt; &amp;ldquo;a3b2a3&amp;rdquo;&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>В этой задаче у нас есть два указателя: один для чтения элементов из исходного массива (&lt;code>read_ptr&lt;/code>) и второй для записи результата сжатия в тот же массив (&lt;code>write_ptr&lt;/code>). Сначала оба указателя стоят на начале массива. Далее, &lt;code>read_ptr&lt;/code> движется вправо, считая количество повторяющихся символов. После подсчета, мы записываем символ и его количество в массив, используя &lt;code>write_ptr&lt;/code>.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем указатели &lt;code>read_ptr&lt;/code> и &lt;code>write_ptr&lt;/code> на начало массива.&lt;/li>
&lt;li>Пока &lt;code>read_ptr&lt;/code> не достигнет конца массива:
&lt;ul>
&lt;li>Считаем количество повторяющихся символов, начиная с текущего &lt;code>read_ptr&lt;/code>.&lt;/li>
&lt;li>Записываем символ и его количество в массив, используя &lt;code>write_ptr&lt;/code>.&lt;/li>
&lt;li>Сдвигаем &lt;code>write_ptr&lt;/code> на количество записанных символов.&lt;/li>
&lt;li>Перемещаем &lt;code>read_ptr&lt;/code> вправо.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">compress&lt;/span>(chars) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> read_ptr, write_ptr &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> read_ptr &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(chars):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> char &lt;span style="color:#666">=&lt;/span> chars[read_ptr]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> read_ptr &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(chars) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> chars[read_ptr] &lt;span style="color:#666">==&lt;/span> char:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> read_ptr &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chars[write_ptr] &lt;span style="color:#666">=&lt;/span> char
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write_ptr &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> count &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> digit &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">str&lt;/span>(count):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chars[write_ptr] &lt;span style="color:#666">=&lt;/span> digit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write_ptr &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> write_ptr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/605/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/can-place-flowers/">LeetCode задача 605&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дана длинная грядка, на которой некоторые участки уже засажены, а некоторые нет. Однако цветы нельзя сажать на соседние участки.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Чтобы решить эту задачу, мы будем итерироваться по каждому участку грядки. Если участок пустой и его соседи (если они существуют) тоже пусты, мы сажаем цветок и уменьшаем наш счетчик.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Итерируемся по каждому участку грядки.&lt;/li>
&lt;li>Если участок пустой, проверяем его соседей.
&lt;ul>
&lt;li>Если левый сосед пустой или его нет (начало грядки), проверяем правого соседа.&lt;/li>
&lt;li>Если правый сосед пустой или его нет (конец грядки), сажаем цветок на текущий участок и уменьшаем &lt;code>n&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>В конце проверяем, достиг ли &lt;code>n&lt;/code> нуля или стал отрицательным.
&lt;ul>
&lt;li>Если да, то это означает, что мы можем посадить все цветы.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">canPlaceFlowers&lt;/span>(flowerbed, n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">check_neighbors&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> i &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(flowerbed) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> flowerbed[i&lt;span style="color:#666">+&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic">#2.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flowerbed[i] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flowerbed[i] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(flowerbed)): &lt;span style="color:#60a0b0;font-style:italic">#1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> flowerbed[i] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic">#2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> i &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> flowerbed[i&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>: &lt;span style="color:#60a0b0;font-style:italic">#2.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> check_neighbors(n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> check_neighbors(n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> n &lt;span style="color:#666">&amp;lt;=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">#3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>643. Maximum Average Subarray I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/643/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/643/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-average-subarray-i/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an integer array &lt;code>nums&lt;/code> consisting of &lt;code>n&lt;/code> elements and an integer &lt;code>k&lt;/code>, find a contiguous subarray whose length is equal to &lt;code>k&lt;/code> that has the maximum average value and return this value. The result must be accurate up to a decimal point of 10^(-5).&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A straightforward approach would be to calculate the average for every possible subarray of length &lt;code>k&lt;/code>. For each starting point, sum the next &lt;code>k&lt;/code> numbers and determine the average. This will take O(n*k) time which is not efficient for large values of &lt;code>n&lt;/code> and &lt;code>k&lt;/code>.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>One way to improve the naive solution is by observing the overlapping computations. As we move from one subarray to the next, we are recalculating the sum for mostly the same numbers except for the first and the last numbers. This observation points towards the sliding window technique which can be very efficient for such problems.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>We use the &lt;a href="https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/#sliding-window">sliding window technique&lt;/a>. The idea is to maintain a window of size &lt;code>k&lt;/code> and slide it across the array. The sliding window technique is particularly useful in problems where the array input and the window size remain static, but the starting point of the sliding window moves.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Calculate the sum of the first &lt;code>k&lt;/code> numbers.&lt;/li>
&lt;li>Slide the window by one position at a time. For every slide, subtract the number that is left behind and add the new number that comes into the window. This will give the sum for the next window of &lt;code>k&lt;/code> numbers.&lt;/li>
&lt;li>Keep track of the maximum sum as we slide the window.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findMaxAverage&lt;/span>(nums, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Calculate the sum of the first k numbers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> window_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(nums[:k])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_sum &lt;span style="color:#666">=&lt;/span> window_sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums) &lt;span style="color:#666">-&lt;/span> k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> window_sum &lt;span style="color:#666">=&lt;/span> window_sum &lt;span style="color:#666">-&lt;/span> nums[i] &lt;span style="color:#666">+&lt;/span> nums[i&lt;span style="color:#666">+&lt;/span>k]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_sum, window_sum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_sum &lt;span style="color:#666">/&lt;/span> k
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>621. Task Scheduler</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/621/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/621/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems//task-scheduler/">LeetCode problem 621&lt;/a>&lt;/p>
&lt;h1 id="idea">Idea&lt;/h1>
&lt;p>Think about how you can arrange the tasks with the highest frequency to minimize the idle times.&lt;/p>
&lt;p>The key to solving this problem is to focus on how to efficiently arrange tasks with the highest frequency. We can calculate the frequency of each task and start scheduling the most frequent tasks first, inserting idle slots if needed. The maximum number of idle slots is determined by the frequency of the most frequent task.&lt;/p>
&lt;p>Approach&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;ol>
&lt;li>Count Frequencies: Calculate the frequency of each task.&lt;/li>
&lt;li>Max Frequency Task: Identify the task with the maximum frequency. This task will dictate the minimum time required to complete all tasks considering the cooling period.&lt;/li>
&lt;li>Calculate Idle Slots: Calculate the number of idle slots needed by subtracting the number of tasks from the maximum slots needed.&lt;/li>
&lt;li>Reduce Idle Slots: Iterate over the frequencies of tasks to reduce the number of idle slots by placing other tasks in these slots.&lt;/li>
&lt;li>Calculate Total Time: The total time required is the sum of all tasks and any remaining idle slots.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Solution&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">leastInterval&lt;/span>(self, tasks: List[&lt;span style="color:#007020">str&lt;/span>], n: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task_counts &lt;span style="color:#666">=&lt;/span> Counter(tasks)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_freq &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(task_counts&lt;span style="color:#666">.&lt;/span>values())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_freq_tasks &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(freq &lt;span style="color:#666">==&lt;/span> max_freq &lt;span style="color:#007020;font-weight:bold">for&lt;/span> freq &lt;span style="color:#007020;font-weight:bold">in&lt;/span> task_counts&lt;span style="color:#666">.&lt;/span>values())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part_count &lt;span style="color:#666">=&lt;/span> max_freq &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part_length &lt;span style="color:#666">=&lt;/span> n &lt;span style="color:#666">-&lt;/span> (max_freq_tasks &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> empty_slots &lt;span style="color:#666">=&lt;/span> part_count &lt;span style="color:#666">*&lt;/span> part_length
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> available_tasks &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(tasks) &lt;span style="color:#666">-&lt;/span> max_freq &lt;span style="color:#666">*&lt;/span> max_freq_tasks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idles &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(&lt;span style="color:#40a070">0&lt;/span>, empty_slots &lt;span style="color:#666">-&lt;/span> available_tasks)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(tasks) &lt;span style="color:#666">+&lt;/span> idles
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>649. Dota2 Senate</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/649/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/dota2-senate/">LeetCode задача 649&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>В игре Dota2, сенат состоит из двух партий: партии &amp;ldquo;Radiant&amp;rdquo; и партии &amp;ldquo;Dire&amp;rdquo;. Сенат решает, когда будет следующая игра, и каждый сенатор может голосовать за бан одного из сенаторов из другой партии.&lt;/p>
&lt;p>Забаненные сенаторы не могут делать действий и не участвуют в процессе подготовки следующего раунда.&lt;/p>
&lt;p>Предположим, у нас есть строка &amp;ldquo;RRDDD&amp;rdquo;. Здесь первый сенатор принадлежит партии Radiant, второй тоже к Radiant, третий, четвертый и пятый к Dire. Сначала первый сенатор Radiant делает ход, затем первый сенатор Dire, и так далее.&lt;/p>
&lt;p>Когда сенатор делает ход, он может забанить сенатора из другой партии. Если он это делает, этот сенатор больше не участвует в игре. Цель — оставить в игре только сенаторов своей партии.&lt;/p>
&lt;p>Задача определить, какая партия победит и объявит игру.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Использовать &lt;mark>очередь&lt;/mark> для хранения позиций сенаторов из каждой партии. Позиции важны, потому что по условию задачи сенаторы &amp;ldquo;голосуют&amp;rdquo; в заданном порядке.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Важно понимать, что сенаторы действуют в определенной последовательности, и это влияет на исход игры.&lt;/p>
&lt;ol>
&lt;li>Мы можем определить, какой сенатор голосует первым, путем нахождения его индекса в строке &lt;code>senate&lt;/code>.&lt;/li>
&lt;li>После того, как мы определили кто голосует первым, мы знаем, что задача первого забанить сенатора из другой партии, а это означает что сам он продолжает играть дальше и перейдет на следующий раунд.
&lt;ol>
&lt;li>т.е. Если порядок сенаторов такой: &lt;code>RDD&lt;/code>, то первый сенатор &lt;code>R&lt;/code> банит первого сенатора &lt;code>D&lt;/code> и переходит на второй раунд. В строке это бы отобразилось таким образом: &lt;del>R~~~~D&lt;/del>D&lt;strong>R&lt;/strong>. И теперь начинается ход второго оставшегося сенатора &lt;code>D&lt;/code>, который забанит &lt;em>первого&lt;/em> сенатора &lt;code>R&lt;/code>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Таким образом, мы можем определить текущий индекс/позицию каждого сенатора и переставлять их на конец очереди если они голосуют.
&lt;ol>
&lt;li>А во время этого хода сенатор противоположной партии банится.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Как определить, кто сейчас голосует и чей ход?&lt;/strong> - Сравнить индексы каждого сенатора из разных партий. Чей индекс(позиция) раньше, тот и голосует. Соответсвенно, сенатор под самым маленьким индексом из другой партии будет забанен.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Создаем две очереди для хранения индексов(порядка) сенаторов обеих партий.
&lt;ol>
&lt;li>Итерируем по всем сенаторам и добавляем их в соответствующие очереди.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Пока обе очереди не пусты:
&lt;ul>
&lt;li>Сравниваем первых(в очереди) сенаторов в каждой очереди.&lt;/li>
&lt;li>Забаним сенатора с большим до следующего хода. Как? - не добавим его в конец очереди для следующего раунда.&lt;/li>
&lt;li>Сенатор, который не был забанен, возвращается в конец очереди (его индекс увеличивается на общее количество сенаторов)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>В результате остается одна очередь - победитель. Когда одна из очередей станет пустой, партия, чья очередь осталась, побеждает.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> deque
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">predictPartyVictory&lt;/span>(senate: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radiant &lt;span style="color:#666">=&lt;/span> deque()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dire &lt;span style="color:#666">=&lt;/span> deque()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Заполнение очередей&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, s &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">enumerate&lt;/span>(senate):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> s &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#4070a0">&amp;#39;R&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radiant&lt;span style="color:#666">.&lt;/span>append(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dire&lt;span style="color:#666">.&lt;/span>append(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(senate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Процесс голосования&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> radiant &lt;span style="color:#007020;font-weight:bold">and&lt;/span> dire:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#666">=&lt;/span> radiant&lt;span style="color:#666">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d &lt;span style="color:#666">=&lt;/span> dire&lt;span style="color:#666">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Сенатор с меньшим индексом банит сенатора с большим индексом&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># и переходит во второй раунд (текущий индекс + всего индексов в раунде)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> r &lt;span style="color:#666">&amp;lt;&lt;/span> d:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radiant&lt;span style="color:#666">.&lt;/span>append(r &lt;span style="color:#666">+&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dire&lt;span style="color:#666">.&lt;/span>append(d &lt;span style="color:#666">+&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Radiant&amp;#34;&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> radiant &lt;span style="color:#007020;font-weight:bold">else&lt;/span> &lt;span style="color:#4070a0">&amp;#34;Dire&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/724/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/find-pivot-index/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an array of integers &lt;code>nums&lt;/code>, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index. If the sums are equal, return the index. However, this approach has a time complexity of &lt;code>O(n^2)&lt;/code> which makes it inefficient for larger inputs.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>A more optimized solution would use the &lt;mark>&lt;a href="https://romankurnovskii.com/en/tracks/algorithms-101/algorithms/#prefix-sums">prefix and suffix sum&lt;/a>&lt;/mark> concept. Prefix sum is the sum of all elements to the left of the index, and suffix sum is the sum of all elements to the right of the index. We can calculate these sums in &lt;code>O(n)&lt;/code> time and use them to find the pivot index.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;p>We will calculate the total sum of the array first.&lt;/p>
&lt;p>Then, we will initialize a variable &lt;code>left_sum&lt;/code> to keep track of the sum of elements to the left of the current index.&lt;/p>
&lt;p>As we iterate over each index, we will update the total sum by subtracting the current element, which will give us the &lt;code>right sum&lt;/code>. We will then check if &lt;code>left_sum&lt;/code> is equal to the right sum &lt;code>(total sum - left_sum - current element)&lt;/code>.&lt;/p>
&lt;p>If they are equal, we return the index.&lt;/p>
&lt;p>After checking, we will update the &lt;code>left_sum&lt;/code> by adding the current element.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Calculate the total sum of the array.&lt;/li>
&lt;li>Initialize a variable left_sum to 0.&lt;/li>
&lt;li>Iterate over each index in the array.
&lt;ol>
&lt;li>Update the total sum by subtracting the current element.&lt;/li>
&lt;li>Check if left_sum is equal to the right sum (total sum - left_sum - current element). If true, return the index.&lt;/li>
&lt;li>Update the left_sum by adding the current element.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>If no pivot index is found, return -1.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">pivotIndex&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i, num &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">enumerate&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total_sum &lt;span style="color:#666">-=&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> left_sum &lt;span style="color:#666">==&lt;/span> total_sum:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_sum &lt;span style="color:#666">+=&lt;/span> num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/735/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/asteroid-collision/">LeetCode задача 735&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Мы имеем массив asteroids целых чисел, представляющих астероиды в ряду. Для каждого астероида абсолютное значение представляет его размер, а знак представляет его направление (положительное означает вправо, отрицательное влево). Все астероиды движутся с одинаковой скоростью. Необходимо определить состояние астероидов после всех столкновений.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения задачи можно использовать стек.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Мы будем использовать стек для отслеживания движущихся вправо астероидов. Когда мы видим астероид, движущийся влево, мы проверяем, будет ли он сталкиваться с верхним элементом стека (астероидом, движущимся вправо).&lt;/p>
&lt;p>Если сталкивается, то мы сравниваем их абсолютные значения и уничтожаем меньший астероид или оба, если их размеры равны. Это продолжается до тех пор, пока верхний элемент стека не будет больше текущего астероида или стек не опустеет.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем пустой стек.&lt;/li>
&lt;li>Проходимся по каждому астероиду:
&lt;ol>
&lt;li>Если астероид движется вправо, просто добавляем его в стек.&lt;/li>
&lt;li>Если астероид движется влево:
&lt;ol>
&lt;li>Сравниваем его с верхним элементом стека.&lt;/li>
&lt;li>Если верхний элемент меньше по абсолютному значению, удаляем его из стека.&lt;/li>
&lt;li>Если верхний элемент равен текущему астероиду по абсолютному значению, удаляем оба.&lt;/li>
&lt;li>Если верхний элемент больше текущего астероида по абсолютному значению, переходим к следующему астероиду&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Возвращаем стек в качестве результата.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">asteroidCollision&lt;/span>(asteroids):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> asteroid &lt;span style="color:#007020;font-weight:bold">in&lt;/span> asteroids:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если астероид движется вправо&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> asteroid &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append(asteroid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Пока в стеке есть астероиды, движущиеся вправо, и они меньше текущего астероида по абсолютному значению&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> stack &lt;span style="color:#007020;font-weight:bold">and&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#007020;font-weight:bold">and&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#666">-&lt;/span>asteroid:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если стек пуст или верхний элемент стека движется влево&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> stack &lt;span style="color:#007020;font-weight:bold">or&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>append(asteroid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если верхний элемент стека равен текущему астероиду по абсолютному значению&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> stack[&lt;span style="color:#666">-&lt;/span>&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#666">-&lt;/span>asteroid:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#666">.&lt;/span>pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> stack
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>872. Leaf-Similar Trees</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/872/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/872/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/leaf-similar-trees/">LeetCode задача 872&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Даны два бинарных дерева с корнями &lt;code>root1&lt;/code> и &lt;code>root2&lt;/code>. Проверьте, являются ли эти деревья &amp;ldquo;листоподобными&amp;rdquo; (leaf-similar). Деревья считаются &amp;ldquo;листоподобными&amp;rdquo;, если последовательность листовых узлов каждого дерева одинакова.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Листовые узлы бинарного дерева — это узлы, у которых нет потомков. Для проверки &amp;ldquo;листоподобности&amp;rdquo; двух деревьев нужно сравнить последовательности листовых узлов этих деревьев.&lt;/p>
&lt;h2 id="подход--идея-решения">Подход / Идея решения&lt;/h2>
&lt;p>Идея решения заключается в построении списков листовых узлов для каждого дерева, а затем сравнении этих списков. Мы можем рекурсивно обойти каждое дерево, проверяя при каждом узле, является ли он листовым. Если это так, добавляем значение этого узла в соответствующий список.&lt;/p>
&lt;p>Такой подход обеспечивает простое и понятное решение, несмотря на то, что он может быть не самым оптимальным по времени и памяти.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Обойти каждое дерево рекурсивно и собрать список листовых узлов.&lt;/li>
&lt;li>Сравнить полученные списки.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Определение для бинарного дерева.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># class TreeNode:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># def __init__(self, val=0, left=None, right=None):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.val = val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.left = left&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># self.right = right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">leafSimilar&lt;/span>(root1, root2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">getLeaves&lt;/span>(root):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root&lt;span style="color:#666">.&lt;/span>left &lt;span style="color:#007020;font-weight:bold">and&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> root&lt;span style="color:#666">.&lt;/span>right:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> [root&lt;span style="color:#666">.&lt;/span>val]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> getLeaves(root&lt;span style="color:#666">.&lt;/span>left) &lt;span style="color:#666">+&lt;/span> getLeaves(root&lt;span style="color:#666">.&lt;/span>right)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> getLeaves(root1) &lt;span style="color:#666">==&lt;/span> getLeaves(root2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>933. Number of Recent Calls</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/933/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/933/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/number-of-recent-calls/">LeetCode задача 933&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Реализуйте класс &lt;code>RecentCounter&lt;/code> для подсчета вызовов &lt;code>ping&lt;/code> за последние 3000 миллисекунд.&lt;/p>
&lt;p>Т.е. для вызова &lt;code>t=100&lt;/code>, нужно подсчитать количество таких вызовов, время которых меньше &lt;code>t-3000&lt;/code> и учесть сам вызов.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>В данной задаче нужно отслеживать количество вызовов &lt;code>ping&lt;/code> за последние 3000 миллисекунд.&lt;/p>
&lt;p>Можно использовать &lt;mark>очередь&lt;/mark> для хранения времени вызовов &lt;code>ping&lt;/code>. При каждом новом вызове будем добавлять текущее время в конец очереди и удалять из начала все времена, которые не попадают в интервал последних 3000 миллисекунд.&lt;/p>
&lt;p>Таким образом, размер очереди в любой момент времени будет равен числу вызовов &lt;code>ping&lt;/code> за последние 3000 миллисекунд.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализация: создать пустую очередь для хранения времени вызовов &lt;code>ping&lt;/code>.&lt;/li>
&lt;li>При каждом вызове &lt;code>ping(t)&lt;/code>:
&lt;ul>
&lt;li>Добавить &lt;code>t&lt;/code> в конец очереди.&lt;/li>
&lt;li>Удалить из начала очереди все элементы, меньшие чем &lt;code>t - 3000&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Вернуть размер очереди.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> deque
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">RecentCounter&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>queue &lt;span style="color:#666">=&lt;/span> deque()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">ping&lt;/span>(self, t: &lt;span style="color:#007020">int&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>queue&lt;span style="color:#666">.&lt;/span>append(t)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> self&lt;span style="color:#666">.&lt;/span>queue[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">&amp;lt;&lt;/span> t &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">3000&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>queue&lt;span style="color:#666">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(self&lt;span style="color:#666">.&lt;/span>queue)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1071/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/greatest-common-divisor-of-strings/">LeetCode задача 1071&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Для двух строк &lt;code>str1&lt;/code> и &lt;code>str2&lt;/code>, вернуть наибольший общий делитель (НОД). Если такового не существует, вернуть пустую строку.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Если строки &lt;code>str1&lt;/code> и &lt;code>str2&lt;/code> имеют НОД строки &lt;code>X&lt;/code>, то &lt;code>str1&lt;/code> и &lt;code>str2&lt;/code> могут быть представлены в форме &lt;code>Xn&lt;/code> и &lt;code>Xm&lt;/code> (где &lt;code>n&lt;/code> и &lt;code>m&lt;/code> — это натуральные числа), соответственно. Это означает, что &lt;code>str1&lt;/code> должна начинаться с &lt;code>str2&lt;/code> или наоборот.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Проверка начала строк: если &lt;code>str1&lt;/code> не начинается с &lt;code>str2&lt;/code> или наоборот, то НОД не существует.&lt;/li>
&lt;li>Вычисление остатка: удаляем начальный фрагмент одной строки, который совпадает с другой строкой. Это будет остаток &lt;code>remainder&lt;/code>.&lt;/li>
&lt;li>Рекурсивный вызов: повторяем процедуру для &lt;code>remainder&lt;/code> и меньшей из двух строк.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">gcdOfStrings&lt;/span>(str1: &lt;span style="color:#007020">str&lt;/span>, str2: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если одна строка не начинается с другой, НОД не существует&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> str1&lt;span style="color:#666">.&lt;/span>startswith(str2) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> str2&lt;span style="color:#666">.&lt;/span>startswith(str1):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Если строки равны, одна из них является НОД&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> str1 &lt;span style="color:#666">==&lt;/span> str2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> str1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Определение более короткой и более длинной строки&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">len&lt;/span>(str1) &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(str2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> longer, shorter &lt;span style="color:#666">=&lt;/span> str1, str2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> longer, shorter &lt;span style="color:#666">=&lt;/span> str2, str1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Вычисление остатка&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remainder &lt;span style="color:#666">=&lt;/span> longer[&lt;span style="color:#007020">len&lt;/span>(shorter):]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Рекурсивный вызов функции для остатка и более короткой строки&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> gcdOfStrings(remainder, shorter)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1207. Unique Number of Occurrences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1207/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1207/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/unique-number-of-occurrences/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to create a dictionary to store the count of each integer, then iterate over the dictionary and compare each count with the counts of other integers. This approach requires O(n^2) time complexity, where n is the length of the array. This is not efficient for large input sizes.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>To solve this problem efficiently, we can use Python&amp;rsquo;s built-in Counter class from the collections module. A Counter is a dictionary subclass for counting hashable objects. It&amp;rsquo;s a collection where elements are stored as dictionary keys, and their counts are stored as dictionary values.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;ol>
&lt;li>Create a Counter object from the input array.&lt;/li>
&lt;li>Convert the Counter object to a dictionary.&lt;/li>
&lt;li>Convert the dictionary values to a set.&lt;/li>
&lt;li>Compare the size of the set with the size of the dictionary. If they are equal, return true. Otherwise, return false.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Import the Counter class from the collections module.&lt;/li>
&lt;li>Create a Counter object from the input array &lt;code>arr&lt;/code>.&lt;/li>
&lt;li>Convert the Counter object to a dictionary &lt;code>dict_counts&lt;/code>.&lt;/li>
&lt;li>Convert the dictionary values to a set &lt;code>unique_counts&lt;/code>.&lt;/li>
&lt;li>Compare the size of the set with the size of the dictionary. If they are equal, return true. Otherwise, return false.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">uniqueOccurrences&lt;/span>(arr):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Create a Counter object from the input array&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dict_counts &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">dict&lt;/span>(Counter(arr)) &lt;span style="color:#60a0b0;font-style:italic"># {1: 3, 2: 2, 3: 1}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Convert the dictionary values to a set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_counts &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>(dict_counts&lt;span style="color:#666">.&lt;/span>values())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Compare the size of the set with the size of the dictionary&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020">len&lt;/span>(unique_counts) &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#007020">len&lt;/span>(dict_counts)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This function uses the Counter class to count the occurrences of each integer in the input array. It then converts the Counter object to a dictionary and the dictionary values to a set. Finally, it compares the size of the set with the size of the dictionary.&lt;/p>
&lt;p>If they are equal, it returns true. Otherwise, it returns false.&lt;/p></description></item><item><title>1431. Kids With the Greatest Number of Candies</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1431/</link><pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1431/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/kids-with-the-greatest-number-of-candies">LeetCode problem 1431. Kids With the Greatest Number of Candies&lt;/a>&lt;/p>
&lt;h3 id="problem-statement">Problem Statement&lt;/h3>
&lt;p>Imagine you&amp;rsquo;re in a classroom with a bunch of kids, and each kid has a certain number of candies. You, being super generous, have some extra candies to give away. Now, you&amp;rsquo;re wondering, if you give all these extra candies to one kid at a time, will that kid end up having the most candies in the class? And you want to check this for every kid in the class.&lt;/p>
&lt;h3 id="hint">Hint&lt;/h3>
&lt;p>To figure this out, first, find out who currently has the most candies in the class. Then, add the extra candies to each kid&amp;rsquo;s current candies and see if that total is at least as much as the most-candies kid.&lt;/p>
&lt;h3 id="approach">Approach&lt;/h3>
&lt;p>Let&amp;rsquo;s make it more relatable:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Find the Kid with Most Candies Now:&lt;/strong> Imagine you&amp;rsquo;re counting how many candies each kid has. The kid with the most candies sets the record for everyone to beat.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Give Extra Candies to Each Kid:&lt;/strong> Now, you give your extra candies to each kid, one by one, and see if their new total beats or matches the record.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Create a List of True or False:&lt;/strong> For each kid, if their total candies with the extra ones are as many or more than the record, write down &lt;code>True&lt;/code>; otherwise, write down &lt;code>False&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">kidsWithCandies&lt;/span>(candies, extra_candies):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_candies &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(candies)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> candy &lt;span style="color:#007020;font-weight:bold">in&lt;/span> candies:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(candy &lt;span style="color:#666">+&lt;/span> extra_candies &lt;span style="color:#666">&amp;gt;=&lt;/span> max_candies)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> result
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the &lt;code>kidsWithCandies&lt;/code> method, we first find the maximum number of candies any kid has. We then use list comprehension to create the result list.&lt;/p>
&lt;p>This problem shows how a problem that seems to require nested loops can be solved efficiently with a single pass over the array by making use of Python&amp;rsquo;s built-in functions and list comprehension. It&amp;rsquo;s a good practice problem for beginners to understand the concepts of array manipulation and using built-in functions.&lt;/p></description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1456/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">LeetCode Problem 1456&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a string &lt;code>s&lt;/code> and an integer &lt;code>k&lt;/code>, the task is to return the maximum number of vowel letters in any substring of &lt;code>s&lt;/code> with length &lt;code>k&lt;/code>.&lt;/p>
&lt;p>Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>The most straightforward solution to this problem is to take every possible substring of length &lt;code>k&lt;/code> and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length &lt;code>k&lt;/code>. The maximum count is then returned.&lt;/p>
&lt;p>However, this naive solution would be computationally expensive, with a time complexity of $O(n*k)$ where n is the length of the string &lt;code>s&lt;/code>.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>The problem can be efficiently solved using a technique called the sliding window approach.&lt;/p>
&lt;h2 id="approach-sliding-window">Approach: Sliding Window&lt;/h2>
&lt;p>The idea is to use a window of size &lt;code>k&lt;/code> and slide it across the string &lt;code>s&lt;/code>. Instead of counting the number of vowels in the entire window every time, we adjust the count by adding the new character and removing the leftmost character as the window slides.&lt;/p>
&lt;p>This way, the number of operations is reduced to just two for every slide, making it a more efficient solution.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize a counter for the number of vowels and a &lt;code>max_vowels&lt;/code> variable to keep track of the maximum number of vowels seen.&lt;/li>
&lt;li>Traverse through the first &lt;code>k&lt;/code> characters of the string, increasing the counter for each vowel seen.&lt;/li>
&lt;li>Set &lt;code>max_vowels&lt;/code> to the value of the counter.&lt;/li>
&lt;li>Start sliding the window from the &lt;code>k&lt;/code>th character. For every new character:
&lt;ul>
&lt;li>If it&amp;rsquo;s a vowel, increase the counter.&lt;/li>
&lt;li>Check the leftmost character of the previous window (i.e., &lt;code>s[i - k]&lt;/code>). If it&amp;rsquo;s a vowel, decrease the counter.&lt;/li>
&lt;li>Update &lt;code>max_vowels&lt;/code> if the counter is greater than its current value.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxVowels&lt;/span>(s, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vowels &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>([&lt;span style="color:#4070a0">&amp;#39;a&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;e&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;i&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;o&amp;#39;&lt;/span>, &lt;span style="color:#4070a0">&amp;#39;u&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">sum&lt;/span>(&lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> char &lt;span style="color:#007020;font-weight:bold">in&lt;/span> s[:k] &lt;span style="color:#007020;font-weight:bold">if&lt;/span> char &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_vowels &lt;span style="color:#666">=&lt;/span> count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(k, &lt;span style="color:#007020">len&lt;/span>(s)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Add the new character to the count if it&amp;#39;s a vowel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> s[i] &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Remove the leftmost character of the previous window from the count if it&amp;#39;s a vowel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">-=&lt;/span> s[i &lt;span style="color:#666">-&lt;/span> k] &lt;span style="color:#007020;font-weight:bold">in&lt;/span> vowels
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_vowels &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_vowels, count)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_vowels
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1493/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/">LeetCode Problem 1493&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given a binary array &lt;code>nums&lt;/code>, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s. This method, however, can be inefficient for larger arrays.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>Consider that we are allowed to have a subarray with a single zero. It might make things simpler! The sliding window approach will be handy here.&lt;/p>
&lt;h2 id="approach-sliding-window-with-a-twist">Approach: Sliding Window with a Twist&lt;/h2>
&lt;p>We can use the sliding window technique again for this problem. However, we need to adapt it slightly. This time, our window can contain at most one zero. Thus, while expanding the window, we should be mindful of the zeros.&lt;/p>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Initialize two pointers, &lt;code>left&lt;/code> and &lt;code>right&lt;/code>, to represent the window&amp;rsquo;s boundaries. Also, initialize a counter &lt;code>zeroCount&lt;/code> to track zeros in the current window.&lt;/li>
&lt;li>Expand the right boundary of the window by moving the &lt;code>right&lt;/code> pointer.&lt;/li>
&lt;li>If the current number is 0, increment the &lt;code>zeroCount&lt;/code>.&lt;/li>
&lt;li>If &lt;code>zeroCount&lt;/code> becomes 2, move the &lt;code>left&lt;/code> pointer to the right until a zero is excluded, and decrement the &lt;code>zeroCount&lt;/code>.&lt;/li>
&lt;li>Track the maximum length of the window found.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">longestSubarray&lt;/span>(nums):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zeroCount &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxLength &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> right &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(&lt;span style="color:#007020">len&lt;/span>(nums)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[right] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zeroCount &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> zeroCount &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> nums[left] &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zeroCount &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Subtract 1 because we need to delete one element.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxLength &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(maxLength, right &lt;span style="color:#666">-&lt;/span> left)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> maxLength
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1657. Determine if Two Strings Are Close</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1657/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1657/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/determine-if-two-strings-are-close/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Two strings are considered close if you can attain one from the other using two operations:&lt;/p>
&lt;ol>
&lt;li>Swap any two existing characters.&lt;/li>
&lt;li>Transform every occurrence of one existing character into another existing character, and do the same with the other character.&lt;/li>
&lt;/ol>
&lt;p>The challenge is to determine whether two given strings are close or not.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach might involve trying every possible combination of operations on the two strings until they match or until you&amp;rsquo;ve exhausted all possibilities. This approach is inefficient and not feasible for longer strings.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>A more efficient way to solve this problem is by understanding the core logic behind the operations. We can make use of frequency counts.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>Check for Unique Characters:&lt;/strong> Both strings should have the same unique characters for them to be close.&lt;/li>
&lt;li>&lt;strong>Frequency Counts Matter:&lt;/strong> The counts of characters in both strings should have the same frequency distribution.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Calculate the frequency of each character in both strings.&lt;/li>
&lt;li>Check if the sets of unique characters in both strings are the same.&lt;/li>
&lt;li>Check if the sorted list of frequency counts of characters in both strings are the same.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">collections&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Counter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">closeStrings&lt;/span>(word1, word2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Calculate character frequency for both words&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> counter1 &lt;span style="color:#666">=&lt;/span> Counter(word1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> counter2 &lt;span style="color:#666">=&lt;/span> Counter(word2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Check if unique characters are the same in both words&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">set&lt;/span>(counter1&lt;span style="color:#666">.&lt;/span>keys()) &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020">set&lt;/span>(counter2&lt;span style="color:#666">.&lt;/span>keys()):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Check if the frequency distribution is the same for both words&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(counter1&lt;span style="color:#666">.&lt;/span>values()) &lt;span style="color:#666">!=&lt;/span> &lt;span style="color:#007020">sorted&lt;/span>(counter2&lt;span style="color:#666">.&lt;/span>values()):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">True&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1679. Max Number of K-Sum Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1679/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/max-number-of-k-sum-pairs/">LeetCode задача 1679&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Вам дан массив чисел &lt;code>nums&lt;/code> и целое число &lt;code>k&lt;/code>. Задача — найти максимальное количество пар в массиве, сумма элементов которых равна &lt;code>k&lt;/code>.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Используйте технику двух указателей(pointers) после сортировки массива для оптимизации поиска пар.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Центральная идея решения задачи заключается в использовании техники двух указателей для быстрого нахождения пар чисел с заданной суммой &lt;code>k&lt;/code>. Прежде чем применить эту технику, массив сортируется в возрастающем порядке. Затем создаются два указателя: один, указывающий на начало массива, и второй — на конец. Двигая эти указатели в зависимости от суммы элементов, на которые они указывают, мы можем найти все пары с суммой &lt;code>k&lt;/code>.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Отсортируйте массив в возрастающем порядке.&lt;/li>
&lt;li>Инициализируйте два указателя: &lt;code>p1&lt;/code> на начало массива и &lt;code>p2&lt;/code> на конец.&lt;/li>
&lt;li>Пока &lt;code>p1&lt;/code> меньше &lt;code>p2&lt;/code>:
&lt;ul>
&lt;li>Если &lt;code>nums[p1] + nums[p2]&lt;/code> равно &lt;code>k&lt;/code>, увеличьте счетчик на 1, и сдвиньте оба указателя.&lt;/li>
&lt;li>Если сумма меньше &lt;code>k&lt;/code>, сдвиньте &lt;code>p1&lt;/code> вправо.&lt;/li>
&lt;li>Если сумма больше &lt;code>k&lt;/code>, сдвиньте &lt;code>p2&lt;/code> влево.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">maxOperations&lt;/span>(nums, k) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(nums) &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#666">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> p1 &lt;span style="color:#666">&amp;lt;&lt;/span> p2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s &lt;span style="color:#666">=&lt;/span> nums[p1] &lt;span style="color:#666">+&lt;/span> nums[p2]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> s &lt;span style="color:#666">==&lt;/span> k:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">elif&lt;/span> s &lt;span style="color:#666">&amp;lt;&lt;/span> k:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">-=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1732/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1732/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/find-the-highest-altitude/">LeetCode задача 1732&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Велосипедист совершает путешествие, которое состоит из &lt;code>n + 1&lt;/code> точек на разных высотах. Путешествие начинается с точки 0, где высота равна 0.&lt;/p>
&lt;p>Дан целочисленный массив &lt;code>gain&lt;/code> длиной &lt;code>n&lt;/code>, где &lt;code>gain[i]&lt;/code> — это прирост высоты между точками &lt;code>i&lt;/code> и &lt;code>i + 1&lt;/code> для всех (&lt;code>0 &amp;lt;= i &amp;lt; n&lt;/code>).&lt;/p>
&lt;p>Задача - вернуть самую высокую высоту точки.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>В этой задаче, вам нужно пройти по массиву &lt;code>gain&lt;/code> и вычислить текущую высоту на каждом этапе. При этом следует отслеживать самую высокую высоту, которую вы достигли.&lt;/p>
&lt;ol>
&lt;li>Прирост высоты между точками - это то, сколько велосипедист фактически проехал. Эти данные нам известны.&lt;/li>
&lt;li>Необходимо узнать, где велосипедист оказался после шага 1.
&lt;ol>
&lt;li>Чтобы узнать это - мы можем текущую к текущей позиции, где он сейчас, прибавить &amp;ldquo;прирост&amp;rdquo;.&lt;/li>
&lt;li>Тогда получаем, что из позиции 0 и прироста -5, велосипедист окажется в новой точке -5 (0 + (-5))&lt;/li>
&lt;li>С новой позиции -5 и прироста 1, окажется в точке -4 (-5 + 1) и т.д.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Остается посчитать и вернуть самую высокую позицию, в которой был велосипедист.&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем текущую высоту (&lt;code>current_altitude&lt;/code>) как 0 и максимальную высоту (&lt;code>max_altitude&lt;/code>) как 0.&lt;/li>
&lt;li>Проходим через каждый элемент массива &lt;code>gain&lt;/code>, увеличивая &lt;code>current_altitude&lt;/code> на значение этого элемента.&lt;/li>
&lt;li>Сравниваем &lt;code>current_altitude&lt;/code> с &lt;code>max_altitude&lt;/code>. Если &lt;code>current_altitude&lt;/code> больше, то устанавливаем &lt;code>max_altitude&lt;/code> равным &lt;code>current_altitude&lt;/code>.&lt;/li>
&lt;li>Возвращаем &lt;code>max_altitude&lt;/code> как ответ.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">largestAltitude&lt;/span>(gain):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_altitude &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># текущая высота&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_altitude &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># максимальная высота&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> i &lt;span style="color:#007020;font-weight:bold">in&lt;/span> gain:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_altitude &lt;span style="color:#666">+=&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_altitude &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">max&lt;/span>(max_altitude, current_altitude)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> max_altitude
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1768/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/merge-strings-alternately">LeetCode задача 1768&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Вам даны две строки &lt;code>word1&lt;/code> и &lt;code>word2&lt;/code>. Объедините эти строки, добавляя буквы в чередующем порядке, начиная с &lt;code>word1&lt;/code>. Если одна строка длиннее другой, дополнительные буквы добавляются в конец результирующей строки.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Чтобы решить эту задачу, мы можем использовать два указателя для каждого слова. Начнем с первого символа каждой строки и будем чередовать их, пока одна из строк не закончится. После этого, мы просто добавляем оставшиеся символы из более длинного слова к результирующей строке.&lt;/p>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализация результирующей строки и двух указателей для &lt;code>word1&lt;/code> и &lt;code>word2&lt;/code>.&lt;/li>
&lt;li>Итерация по каждому слову, добавление соответствующих символов в результирующую строку в чередующем порядке.&lt;/li>
&lt;li>Добавление оставшихся символов из более длинного слова к результирующей строке.&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">mergeAlternately&lt;/span>(word1: &lt;span style="color:#007020">str&lt;/span>, word2: &lt;span style="color:#007020">str&lt;/span>) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">str&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Инициализация результирующей строки и указателей&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#666">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i, j &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Итерация по каждому слову&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> i &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(word1) &lt;span style="color:#007020;font-weight:bold">and&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(word2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(word1[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(word2[j])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Добавление оставшихся символов&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> i &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(word1):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(word1[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> &lt;span style="color:#007020">len&lt;/span>(word2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#666">.&lt;/span>append(word2[j])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#666">.&lt;/span>join(result)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2095/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/">LeetCode задача 2095&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дан связный список (linked list). Задача — удалить средний узел из этого списка и вернуть начало(head) измененного списка.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Мы можем использовать метод двух указателей для того, чтобы найти средний узел в одном проходе по списку, где второй указатель проходит весь список в два раза быстрее первого указателя.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;ol>
&lt;li>Используем два указателя для прохода по списку: один медленный и один быстрый. Оба начинают с головного узла списка.&lt;/li>
&lt;li>Быстрый указатель будет двигаться в два раза быстрее медленного. Каждый шаг он перескакивает через два узла, в то время как медленный только на один. Таким образом, когда быстрый указатель достигнет конца список, первый указатель будет на середине.&lt;/li>
&lt;li>По мере продвижения указателей сохраняем узел, предшествующий медленному поинтеру (&lt;code>prev&lt;/code>), так как именно его &lt;code>next&lt;/code> нам нужно будет изменить.&lt;/li>
&lt;li>Когда быстрый указатель достигнет конца списка или окажется на последнем узле, медленный указатель будет указывать на средний узел.&lt;/li>
&lt;li>Удаляем средний узел.&lt;/li>
&lt;/ol>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Инициализируем два указателя: один медленный (&lt;code>p1&lt;/code>), другой быстрый (&lt;code>p2&lt;/code>), и третий указатель &lt;code>prev&lt;/code>.&lt;/li>
&lt;li>Обновляем указатели до момента достижения быстрым конца списка:
&lt;ul>
&lt;li>Быстрый указатель на каждом шаге &lt;em>перепрыгивает через&lt;/em> &lt;code>next&lt;/code>.&lt;/li>
&lt;li>Временный (&lt;code>prev&lt;/code>) указатель сохраняет ссылку на медленный указатель до его изменения&lt;/li>
&lt;li>Медленный указатель на каждом шаге обновляется до &lt;code>next&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Удаляем средний элемент путем обновления ссылки в указателе &lt;code>prev.next&lt;/code> на &lt;code>p1.next&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">class&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">ListNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">def&lt;/span> __init__(self, val&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#40a070">0&lt;/span>, &lt;span style="color:#007020">next&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>val &lt;span style="color:#666">=&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">deleteMiddleNode&lt;/span>(head: ListNode) &lt;span style="color:#666">-&amp;gt;&lt;/span> ListNode:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> head&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> head &lt;span style="color:#60a0b0;font-style:italic"># быстрый&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> head &lt;span style="color:#60a0b0;font-style:italic"># медленный&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span> &lt;span style="color:#60a0b0;font-style:italic"># предыдущий. Будет в середине&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> p2 &lt;span style="color:#007020;font-weight:bold">and&lt;/span> p2&lt;span style="color:#666">.&lt;/span>next:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#666">=&lt;/span> p1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1 &lt;span style="color:#666">=&lt;/span> p1&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2 &lt;span style="color:#666">=&lt;/span> p2&lt;span style="color:#666">.&lt;/span>next&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev&lt;span style="color:#666">.&lt;/span>next &lt;span style="color:#666">=&lt;/span> p1&lt;span style="color:#666">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> head
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2215. Find the Difference of Two Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2215/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2215/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/find-the-difference-of-two-arrays/">LeetCode problem&lt;/a>&lt;/p>
&lt;h2 id="problem-statement">Problem Statement&lt;/h2>
&lt;p>Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:&lt;/p>
&lt;ul>
&lt;li>answer[0] is a list of all distinct integers in nums1 which are not present in nums2.&lt;/li>
&lt;li>answer[1] is a list of all distinct integers in nums2 which are not present in nums1.&lt;/li>
&lt;/ul>
&lt;p>Note that the integers in the lists may be returned in any order.&lt;/p>
&lt;h2 id="naive-solution">Naive Solution&lt;/h2>
&lt;p>A naive approach would be to iterate over each element of the first array and check whether it&amp;rsquo;s in the second array. Similarly, iterate over each element of the second array and check whether it&amp;rsquo;s in the first array. This approach will take O(n*m) time, where n is the size of the first array and m is the size of the second array. This isn&amp;rsquo;t efficient for large input sizes.&lt;/p>
&lt;h2 id="hints--tips">Hints &amp;amp; Tips&lt;/h2>
&lt;p>We can solve this problem more efficiently by using Python&amp;rsquo;s built-in set data structure. A set is a collection of unique elements and allows for O(1) time complexity for lookup operations.&lt;/p>
&lt;h2 id="approach">Approach&lt;/h2>
&lt;ol>
&lt;li>Convert both arrays to sets.&lt;/li>
&lt;li>Find the difference between the two sets in both directions.&lt;/li>
&lt;li>Convert the results to lists and return them.&lt;/li>
&lt;/ol>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;ol>
&lt;li>Convert &lt;code>nums1&lt;/code> to a set &lt;code>set1&lt;/code> and &lt;code>nums2&lt;/code> to a set &lt;code>set2&lt;/code>.&lt;/li>
&lt;li>Find the difference between &lt;code>set1&lt;/code> and &lt;code>set2&lt;/code> and convert it to a list. This will give us all the elements that are in &lt;code>set1&lt;/code> but not in &lt;code>set2&lt;/code>.&lt;/li>
&lt;li>Find the difference between &lt;code>set2&lt;/code> and &lt;code>set1&lt;/code> and convert it to a list. This will give us all the elements that are in &lt;code>set2&lt;/code> but not in &lt;code>set1&lt;/code>.&lt;/li>
&lt;li>Return the results as a list of two lists.&lt;/li>
&lt;/ol>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">findDifference&lt;/span>(nums1, nums2):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>(nums1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">set&lt;/span>(nums2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> diff1 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">list&lt;/span>(set1 &lt;span style="color:#666">-&lt;/span> set2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> diff2 &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">list&lt;/span>(set2 &lt;span style="color:#666">-&lt;/span> set1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> [diff1, diff2]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2352/</guid><description>&lt;p>&lt;a href="https://leetcode.com/problems/equal-row-and-column-pairs/">LeetCode задача 2352&lt;/a>&lt;/p>
&lt;h2 id="задача">Задача&lt;/h2>
&lt;p>Дана квадратная матрица целых чисел &lt;code>grid&lt;/code> размером &lt;code>n×n&lt;/code>. Задача состоит в том, чтобы определить, сколько пар строк и столбцов в матрице &lt;strong>идентичны&lt;/strong> по своему содержанию и порядку.&lt;/p>
&lt;p>Строка и столбец считаются равными, если они содержат одни и те же элементы в том же порядке.&lt;/p>
&lt;h2 id="подсказки">Подсказки&lt;/h2>
&lt;p>Для решения задачи можно воспользоваться тем фактом, что каждая строка и столбец представляют собой набор чисел. Если мы конвертируем их в строки, то можем сравнивать их друг с другом.&lt;/p>
&lt;h2 id="подход">Подход&lt;/h2>
&lt;p>Вместо прямого сравнения каждой строки с каждым столбцом мы можем преобразовать каждую строку и столбец в кортеж(&lt;a href="https://romankurnovskii.com/ru/tracks/python-101/basis/tuples/">&lt;code>tuple&lt;/code>&lt;/a>) и использовать словарь(&lt;a href="https://romankurnovskii.com/ru/tracks/python-101/basis/dict/">&lt;code>dict&lt;/code>&lt;/a>) для учета количества вхождений каждой уникальной строки. При проходе по столбцам мы можем напрямую обращаться к нашему словарю, чтобы узнать, совпадает ли представление кортежа столбца с любой строкой.&lt;/p>
&lt;p>&lt;strong>Почему кортежи?&lt;/strong>&lt;/p>
&lt;p>Прежде чем углубляться в оптимизированный подход, важно понимать роль кортежей. Мы преобразуем строки и столбцы в кортежи, потому что:&lt;/p>
&lt;ul>
&lt;li>Кортежи неизменяемы: их содержимое не может быть изменено после создания.&lt;/li>
&lt;li>Они могут использоваться в качестве ключей в словарях, в отличие от списков или множеств. Это свойство критически важно для нашего решения.&lt;/li>
&lt;li>Кортежи сохраняют порядок элементов, что важно для требований нашей задачи.&lt;/li>
&lt;/ul>
&lt;h2 id="алгоритм">Алгоритм&lt;/h2>
&lt;ol>
&lt;li>Преобразуем каждую строку в кортеж и подсчитаем ее вхождения с помощью словаря.&lt;/li>
&lt;li>Пройдем каждый столбец, преобразуем его в кортеж.&lt;/li>
&lt;li>Проверим, существует ли кортеж столбца в нашем словаре.
&lt;ol>
&lt;li>Если да, увеличиваем счетчик на &lt;strong>количество вхождений&lt;/strong> этого кортежа.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="решение">Решение&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">equalPairs&lt;/span>(self, grid: List[List[&lt;span style="color:#007020">int&lt;/span>]]) &lt;span style="color:#666">-&amp;gt;&lt;/span> &lt;span style="color:#007020">int&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows &lt;span style="color:#666">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Храним кортежи строк и их количество вхождений&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> row &lt;span style="color:#007020;font-weight:bold">in&lt;/span> grid:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> row &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">tuple&lt;/span>(row)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows[row]&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">+&lt;/span> rows&lt;span style="color:#666">.&lt;/span>get(row, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Для каждого столбца проверяем, существует ли кортеж столбца в словаре строк&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">len&lt;/span>(grid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> c &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> col &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020">tuple&lt;/span>(grid[r][c] &lt;span style="color:#007020;font-weight:bold">for&lt;/span> r &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(n))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">+=&lt;/span> rows&lt;span style="color:#666">.&lt;/span>get(col, &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> count
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>