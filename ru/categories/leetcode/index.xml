<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/categories/leetcode/</link><description>Recent content in LeetCode on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Mon, 12 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Легкие</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</guid><description/></item><item><title>Средние</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</guid><description/></item><item><title>Тяжелые</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</guid><description/></item><item><title>4. Median of Two Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</guid><description>LeetCode задача 4
Задача Даны два отсортированных массива nums1 и nums2 размера m и n соответственно. Найти медиану двух отсортированных массивов.
Подсказки Чтобы найти медиану, нужно сначала объединить два массива и отсортировать их. После этого медиана будет либо средним элементом, если общее количество элементов нечетное, либо средним значением двух центральных элементов, если общее количество элементов четное.
Подход Мы можем объединить два массива в один большой отсортированный массив и найти медиану этого массива. Этот подход не самый эффективный, но он прост и понятен.</description></item><item><title>12. Integer to Roman</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/12/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/12/</guid><description>LeetCode problem 12
class Solution: def intToRoman(self, num: int) -&amp;gt; str: cs = (&amp;#39;M&amp;#39;, &amp;#39;CM&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;CD&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;XC&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;XL&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;IX&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;IV&amp;#39;, &amp;#39;I&amp;#39;) vs = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) res = [] for c, v in zip(cs, vs): while num &amp;gt;= v: num -= v res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/17/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/17/</guid><description>LeetCode problem 17
class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] result = [&amp;#39;&amp;#39;] for d in digits: d = int(d) tmp = [] for letter in letters[d]: for word in result: word += letter tmp.append(word) result = tmp return result</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem 19
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeNthFromEnd(self, head, n: int): p1 = head p2 = head for _ in range(n): p1 = p1.next if not p1: return head.next # in case: head=[1], n=1 -&amp;gt; return [] while p1.next: p1 = p1.next p2 = p2.next p2.next = p2.next.next return head</description></item><item><title>LeetCode</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</guid><description> Получай решения LeetCode на email: Подписаться</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem 22
class Solution: def generateParenthesis(self, n): res = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: res.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return res</description></item><item><title>24. Swap Nodes in Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/24/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/24/</guid><description>LeetCode problem 24
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def swapPairs(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) pre, cur = dummy, head while cur and cur.next: t = cur.next cur.next = t.next t.next = cur pre.next = t pre, cur = cur, cur.next return dummy.next</description></item><item><title>42. Trapping Rain Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</guid><description>LeetCode задача 42
Задача Дан массив неотрицательных целых чисел, представляющих собой карту высот, где ширина каждой стойки равна 1. Вычислите, сколько воды может удерживать этот массив после дождя.
Подсказки Мы можем решить эту задачу, двигаясь от краев массива к его центру, отслеживая текущую максимальную высоту с обеих сторон.
Подход Простой и понятный способ решения этой задачи - пройтись по массиву и для каждого элемента вычислить, сколько воды он может удержать.
Алгоритм Инициализируем переменную для хранения общего объема воды, который может быть удержан.</description></item><item><title>92. Reverse Linked List II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</guid><description>LeetCode задача 92
Задача Дан односвязный список и два целых числа left и right, где left &amp;lt;= right. Задача заключается в том, чтобы перевернуть узлы списка с позиции left до right
Т.е. если список 1-2-3-4-5-6-7-8-9, left=2, right=7, то итоговый список будет 1-7-6-5-4-3-2-8-9.
Подсказки Для решения задачи удобно использовать два указателя: один для сохранения начальной позиции участка, который нужно перевернуть, и второй для выполнения самого разворота.
Подход Основная идея решения заключается в использовании двух указателей: одного для начала подсписка, который нужно перевернуть, и второго для его конца.</description></item><item><title>118. Pascal's Triangle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</guid><description>LeetCode задача 118
Задача Дано целое число numRows. Верните первые numRows строк Треугольника Паскаля.
В Треугольнике Паскаля каждое число является суммой двух чисел, находящихся непосредственно над ним.
Подсказки Для построения каждой следующей строки можно использовать последнюю строку в текущей итерации. Например, если есть строка [1, 2, 1], то следующая строка начнется и закончится с 1, а числа внутри будут получены путем сложения пар чисел: 1+2 и 2+1.
Подход Для того чтобы построить Треугольник Паскаля, начнем с первой строки, состоящей только из числа 1.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode задача 138
Задача Дан односвязный список, каждый узел которого содержит дополнительный &amp;ldquo;произвольный&amp;rdquo; указатель, который может указывать на любой узел в списке или быть null. Задача состоит в том, чтобы создать глубокую копию этого списка.
Подсказки Простое копирование значений не сработает. Нам нужно создать новые узлы и корректно установить как основные, так и &amp;ldquo;произвольные&amp;rdquo; указатели.
Подход / Идея решения Идея решения заключается в двухпроходном методе. В первом проходе мы создаем копии всех узлов исходного списка и сохраняем их в словаре, где ключом будет оригинальный узел, а значением — его копия.</description></item><item><title>172. Factorial Trailing Zeroes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/172/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/172/</guid><description>LeetCode problem 172
class Solution: def trailingZeroes(self, n: int) -&amp;gt; int: res = 0 while n: n //= 5 res += n return res</description></item><item><title>173. Binary Search Tree Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/173/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/173/</guid><description>LeetCode problem 173
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] while root: self.stack.append(root) root = root.left def next(self) -&amp;gt; int: cur = self.stack.pop() node = cur.right while node: self.stack.append(node) node = node.left return cur.val def hasNext(self) -&amp;gt; bool: return len(self.stack) &amp;gt; 0 # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.</description></item><item><title>176. Second Highest Salary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/176/</guid><description>LeetCode problem 176
Drop any duplicate salary values to avoid counting duplicates as separate salary ranks Sort the unique salaries in descending order and get the second highest salary If the second highest salary doesn&amp;rsquo;t exist (e.g., there are fewer than two unique salaries), return None Create a DataFrame with the second highest salary import pandas as pd def second_highest_salary(employee: pd.DataFrame) -&amp;gt; pd.DataFrame: unique_salaries = employee[&amp;#34;salary&amp;#34;].drop_duplicates() second_highest = ( unique_salaries.nlargest(2).iloc[-1] if len(unique_salaries) &amp;gt;= 2 else None ) if second_highest is None: return pd.</description></item><item><title>177. Nth Highest Salary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/177/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/177/</guid><description>LeetCode problem 177
import pandas as pd def nth_highest_salary(employee: pd.DataFrame, N: int) -&amp;gt; pd.DataFrame: unique_salaries = employee.salary.unique() if len(unique_salaries) &amp;lt; N: return pd.DataFrame([np.NaN], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;]) salary = sorted(unique_salaries, reverse=True)[N - 1] return pd.DataFrame([salary], columns=[f&amp;#34;getNthHighestSalary({N})&amp;#34;])</description></item><item><title>178. Rank Scores</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/178/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/178/</guid><description>LeetCode problem 178
import pandas as pd def order_scores(scores: pd.DataFrame) -&amp;gt; pd.DataFrame: # Use the rank method to assign ranks to the scores in descending order with no gaps scores[&amp;#34;rank&amp;#34;] = scores[&amp;#34;score&amp;#34;].rank(method=&amp;#34;dense&amp;#34;, ascending=False) # Drop id column &amp;amp; Sort the DataFrame by score in descending order result_df = scores.drop(&amp;#34;id&amp;#34;, axis=1).sort_values(by=&amp;#34;score&amp;#34;, ascending=False) return result_df</description></item><item><title>179. Largest Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/179/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/179/</guid><description>LeetCode problem 179
class Solution: def largestNumber(self, nums: List[int]) -&amp;gt; str: nums = [str(v) for v in nums] nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b &amp;lt; b + a else -1)) return &amp;#34;0&amp;#34; if nums[0] == &amp;#34;0&amp;#34; else &amp;#34;&amp;#34;.join(nums)</description></item><item><title>180. Consecutive Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/180/</guid><description>LeetCode problem 180
import pandas as pd def consecutive_numbers(logs: pd.DataFrame) -&amp;gt; pd.DataFrame: all_the_same = lambda lst: lst.nunique() == 1 logs[&amp;#34;is_consecutive&amp;#34;] = ( logs[&amp;#34;num&amp;#34;].rolling(window=3, center=True, min_periods=3).apply(all_the_same) ) return ( logs.query(&amp;#34;is_consecutive == 1.0&amp;#34;)[[&amp;#34;num&amp;#34;]] .drop_duplicates() .rename(columns={&amp;#34;num&amp;#34;: &amp;#34;ConsecutiveNums&amp;#34;}) )</description></item><item><title>210. Course Schedule II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</guid><description>LeetCode задача 210
Задача Вам дано ( n ) курсов для изучения, пронумерованных от ( 0 ) до ( n-1 ), и массив ( prerequisites ), где ( prerequisites[i] = [a, b] ) означает, что для изучения курса ( a ) предварительно необходимо пройти курс ( b ).
Напишите функцию для нахождения порядка, в котором можно пройти курсы. Если это невозможно, верните пустой массив.
Подсказки Топологическая сортировка может быть использована для решения этой задачи.
Подход Создадим граф, представляющий предварительные требования для каждого курса.</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</guid><description>LeetCode задача 215
Задача Найти k-й по величине элемент в неотсортированном массиве. Примечание: это k-й по величине элемент в отсортированном порядке, а не k-й различный элемент.
Подсказки Можно отсортировать массив и просто взять k-й элемент с конца. Для более эффективного решения можно использовать алгоритм быстрой выборки. Подход В самом простом случае мы можем отсортировать массив и взять k-й элемент с конца.
Алгоритм Сортируем массив. Возвращаем k-й элемент с конца. Решение def findKthLargest(nums, k): nums.sort() return nums[-k] Оптимальное решение На собеседованиях обычно ожидают от кандидата более эффективного решения.</description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</guid><description>LeetCode задача 236
Задача Найдите наименьшего общего предка (LCA) двух заданных узлов в бинарном дереве.
Подсказки Используйте метод обхода в глубину (DFS) для решения этой задачи.
Подход Обход в глубину (DFS): Используйте рекурсивный метод для обхода дерева. Поиск узлов: При обходе дерева ищите заданные узлы p и q. Возврат значения: Если найден один из узлов, верните его как потенциального предка. Сравнение результатов: Если оба поддерева возвращают узлы, текущий узел является LCA. Пропуск пустых узлов: Если узел пуст, верните None.</description></item><item><title>237. Delete Node in a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</guid><description>LeetCode задача 237
Задача Написать функцию для удаления узла (за исключением хвостового) в односвязном списке, дан только доступ к этому узлу.
Подсказки Обычно, для удаления узла из односвязного списка, нам нужен доступ к предыдущему узлу. В этом случае, у нас такого доступа нет. Как это обойти? Подход Поскольку доступа к предыдущему узлу нет, мы не можем просто &amp;ldquo;вырезать&amp;rdquo; текущий узел. Однако мы можем переписать значение текущего узла значением следующего узла и затем удалить следующий узел.
Алгоритм Перезаписываем значение текущего узла значением следующего узла.</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</guid><description>LeetCode задача 240
Задача Вам дана двумерная матрица размера m x n, представляющая прямоугольник, и целое число target. Отсортированные строки матрицы по неубыванию с лева направо и столбцы отсортированы по неубыванию сверху вниз.
Найдите элемент target в матрице. Верните True, если элемент target есть в матрице, и False, если его нет.
Подсказки Попробуйте использовать двоичный поиск для каждого ряда.
Подход Самый простой подход - использовать двоичный поиск для каждого ряда. Хотя это не самый эффективный метод, он достаточно прост для понимания.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</guid><description>LeetCode задача 251
Задача Дизайн и реализация итератора для 2D вектора. Итератор должен быть инициализирован 2D вектором (vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;) и должен поддерживать следующие операции:
next(): Возвращает следующий элемент из 2D вектора. Если нет больше элементов, возвращает 0. hasNext(): Возвращает True, если в 2D векторе есть следующий элемент, и False в противном случае. Подход Мы можем использовать две переменные: одну для текущего индекса строки и одну для текущего индекса столбца, чтобы навигироваться по 2D вектору.
Алгоритм Инициализируем переменные row и col в конструкторе.</description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</guid><description>LeetCode задача 277
Задача Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?
Имплементируйте функцию int findCelebrity(n), которая вернет знаменитость если она есть, иначе вернёт -1.
Вам дана функция bool knows(a, b), которая скажет вам, знает ли a человека b.
Подход Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.
Алгоритм Инициализируем переменную candidate значением 0.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode задача 287
Задача Дан массив nums размера n + 1, в котором каждый элемент принимает значение от 1 до n, что означает, что как минимум одно число будет дублироваться.
Найдите это дублирующееся число.
Подход Один из способов решения задачи — использование двух указателей (tortoise и hare), что известно как &amp;ldquo;алгоритм зайца и черепахи&amp;rdquo; для нахождения цикла в связанном списке.
Алгоритм Инициализируем два указателя: tortoise и hare. Используем их для прохода по массиву: tortoise двигается на один шаг, а hare — на два.</description></item><item><title>300. Longest Increasing Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</guid><description>LeetCode задача 300
Задача Дан массив чисел, ваша задача — найти длину наибольшей возрастающей подпоследовательности.
Подсказки Для решения этой задачи вы можете использовать динамическое программирование.
Подход Инициализация: Инициализируйте массив, который будет хранить длины наибольших возрастающих подпоследовательностей для каждого элемента массива. Обход массива: Обойдите массив, и для каждого элемента обновите массив длин наибольших возрастающих подпоследовательностей. Максимум: По окончании обхода найдите максимальное значение в массиве длин. Простейший способ решения — это использовать двойной цикл для обхода массива и поиска наибольшей возрастающей подпоследовательности для каждого элемента.</description></item><item><title>328. Odd Even Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</guid><description>LeetCode задача 328
Задача Дан односвязный список и задача переставить его узлы таким образом, чтобы все узлы с нечетными индексами шли перед всеми узлами с четными индексами.
Вариант решения 1 Рассмотрим вариант решения более простой для понимания и реализации.
Подсказки Использовать два связных списка.
Подход Во время прохода по связному списку указатель для чётных узлов добавлять связанный список с четными, то же самое делать с нечетными.
В конце прохода список с четными узлами добавить в конец списка с нечетными узлами.</description></item><item><title>341. Flatten Nested List Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</guid><description>Задача Дан вложенный список целых чисел. Реализуйте итератор, который &amp;ldquo;разворачивает&amp;rdquo; этот вложенный список.
Подход Задача состоит в реализации итератора, который будет последовательно возвращать все элементы из вложенного списка. Вложенный список может содержать как обычные числа, так и другие вложенные списки. Наивное решение заключается в том, чтобы сначала полностью &amp;ldquo;развернуть&amp;rdquo; весь вложенный список в одномерный список, а затем реализовать итератор для этого одномерного списка.
Алгоритм Инициализация: Создать одномерный список и заполнить его элементами из вложенного списка. next(): Возвращает следующий элемент одномерного списка.</description></item><item><title>377. Combination Sum IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</guid><description>LeetCode задача 377
Задача Дан массив различных целых чисел nums и целевое целое число target от 1 до 1000. Нужно вернуть количество возможных комбинаций, которые в сумме дают target.
Подсказки Построить дерево решений Задачу можно решить путем разложения ее на меньшие подзадачи с помощью динамического программирования. Нахождение целевого значения в дереве решений
Your browser does not support the video tag. LeetCode 377 Решение Подход Если целевое значение - target=7 и nums=[2, 3, 4], то в дереве решений может быть несколько путей до этого числа.</description></item><item><title>384. Shuffle an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</guid><description>LeetCode задача 384
Задача Реализуйте класс, который принимает массив чисел в конструкторе и предоставляет метод для их случайного перемешивания, а также метод для возвращения исходного массива.
Подсказки Для создания случайного порядка элементов можно использовать алгоритм Фишера-Йетса или другие методы перемешивания.
Подход Инициализация: Сохранить исходный массив в переменной класса для дальнейшего использования. reset(): Вернуть исходный массив. shuffle(): Вернуть перемешанный массив. Из всех возможных подходов к решению этой задачи, наиболее простым является использование встроенного метода random.shuffle() из Python стандартной библиотеки для перемешивания массива.</description></item><item><title>387. First Unique Character in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/387/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/387/</guid><description>LeetCode задача 387
Задача Дана строка s. Найдите первый уникальный символ в строке и верните его индекс. Если такого символа нет, верните -1.
Подсказки Использование хеш-таблицы может ускорить процесс поиска уникальных символов.
Подход Инициализация: Создайте хеш-таблицу для хранения частоты каждого символа в строке. Первый проход: Пройдите по строке и заполните хеш-таблицу. Второй проход: Пройдите по строке второй раз и проверьте частоту каждого символа в хеш-таблице. Первый символ с частотой 1 будет ответом. Этот подход прост для понимания и реализации.</description></item><item><title>388. Longest Absolute File Path</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/388/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/388/</guid><description>LeetCode задача 388
Задача Необходимо вычислить длину самого длинного абсолютного пути к файлу в файловой системе. Путь представлен строкой, где &amp;ldquo;\n&amp;rdquo; разделяет имена директорий и файлов, а &amp;ldquo;\t&amp;rdquo; обозначает уровень вложенности.
Подсказки Задача заключается в анализе строки, представляющей файловую систему, и определении максимальной длины пути к файлу, учитывая вложенность директорий.
Подход Мы можем решить эту задачу, используя стек для отслеживания текущего пути и его длины. Каждый раз, когда мы встречаем файл, мы сравниваем его полную длину с максимальной и обновляем максимум при необходимости.</description></item><item><title>454. 4Sum II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</guid><description>LeetCode задача 454
Задача Даны четыре списка A, B, C, D целых чисел. Вычислите, сколько существует таких кортежей (i, j, k, l), что ( A[i] + B[j] + C[k] + D[l] = 0 ).
Подсказки Используйте хэш-таблицу для ускорения решения.
Подход Создание хэш-таблицы: Сначала создайте хэш-таблицу, которая будет хранить суммы пар чисел из массивов A и B. Подсчет сумм: Для каждой пары (i, j) из A и B, увеличьте соответствующий элемент хэш-таблицы на 1. Поиск в хэш-таблице: Для каждой пары (k, l) из C и D, проверьте, существует ли -(C[k] + D[l]) в хэш-таблице.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode задача 725
Задача Дан односвязный список и целое число k. Задача заключается в том, чтобы разделить односвязный список на k последовательных частей.
Длина каждой части должна быть максимально равномерной: любые две части не должны отличаться по размеру более чем на одну единицу. Это может привести к тому, что некоторые части будут пустыми (null).
Части должны идти в том порядке, в котором они встречаются в исходном списке, и ранее встречающиеся части всегда должны иметь размер больше или равный позднее встречающимся.</description></item><item><title>777. Swap Adjacent in LR String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/777/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/777/</guid><description>LeetCode problem 777
class Solution: def canTransform(self, start: str, end: str) -&amp;gt; bool: n = len(start) i = j = 0 while 1: while i &amp;lt; n and start[i] == &amp;#39;X&amp;#39;: i += 1 while j &amp;lt; n and end[j] == &amp;#39;X&amp;#39;: j += 1 if i &amp;gt;= n and j &amp;gt;= n: return True if i &amp;gt;= n or j &amp;gt;= n or start[i] != end[j]: return False if start[i] == &amp;#39;L&amp;#39; and i &amp;lt; j: return False if start[i] == &amp;#39;R&amp;#39; and i &amp;gt; j: return False i, j = i + 1, j + 1</description></item><item><title>779. K-th Symbol in Grammar</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/779/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/779/</guid><description>LeetCode problem 779
class Solution: def kthGrammar(self, n: int, k: int) -&amp;gt; int: return (k - 1).bit_count() &amp;amp; 1</description></item><item><title>781. Rabbits in Forest</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/781/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/781/</guid><description>LeetCode problem 781
class Solution: def numRabbits(self, answers: List[int]) -&amp;gt; int: counter = Counter(answers) return sum([math.ceil(v / (k + 1)) * (k + 1) for k, v in counter.items()])</description></item><item><title>784. Letter Case Permutation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/784/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/784/</guid><description>LeetCode problem 784
class Solution: def letterCasePermutation(self, s: str) -&amp;gt; List[str]: res = [] n = sum(c.isalpha() for c in s) for i in range(1 &amp;lt;&amp;lt; n): j, t = 0, [] for c in s: if c.isalpha(): c = c.lower() if (i &amp;gt;&amp;gt; j) &amp;amp; 1 else c.upper() j += 1 t.append(c) res.append(&amp;#39;&amp;#39;.join(t)) return res</description></item><item><title>785. Is Graph Bipartite</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/785/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/785/</guid><description>LeetCode problem 785
class Solution: def isBipartite(self, graph: List[List[int]]) -&amp;gt; bool: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(len(graph))) for u, g in enumerate(graph): for v in g: if find(u) == find(v): return False p[find(v)] = find(g[0]) return True</description></item><item><title>786. K-th Smallest Prime Fraction</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/786/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/786/</guid><description>LeetCode problem 786
class Solution: def kthSmallestPrimeFraction(self, arr: List[int], k: int) -&amp;gt; List[int]: h = [(1 / y, 0, j + 1) for j, y in enumerate(arr[1:])] heapify(h) for _ in range(k - 1): _, i, j = heappop(h) if i + 1 &amp;lt; j: heappush(h, (arr[i + 1] / arr[j], i + 1, j)) return [arr[h[0][1]], arr[h[0][2]]]</description></item><item><title>787. Cheapest Flights Within K Stops</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/787/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/787/</guid><description>LeetCode problem 787
class Solution: def findCheapestPrice( self, n: int, flights: List[List[int]], src: int, dst: int, k: int ) -&amp;gt; int: @cache def dfs(u, k): if u == dst: return 0 if k &amp;lt;= 0: return inf k -= 1 res = inf for v, p in g[u]: res = min(res, dfs(v, k) + p) return res g = defaultdict(list) for u, v, p in flights: g[u].append((v, p)) res = dfs(src, k + 1) return -1 if res &amp;gt;= inf else res</description></item><item><title>788. Rotated Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/788/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/788/</guid><description>LeetCode problem 788
class Solution: def rotatedDigits(self, n: int) -&amp;gt; int: @cache def dfs(pos, ok, limit): if pos &amp;lt;= 0: return ok up = a[pos] if limit else 9 res = 0 for i in range(up + 1): if i in (0, 1, 8): res += dfs(pos - 1, ok, limit and i == up) if i in (2, 5, 6, 9): res += dfs(pos - 1, 1, limit and i == up) return res a = [0] * 6 l = 1 while n: a[l] = n % 10 n //= 10 l += 1 return dfs(l, 0, True)</description></item><item><title>789. Escape The Ghosts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/789/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/789/</guid><description>LeetCode problem 789
class Solution: def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -&amp;gt; bool: tx, ty = target return all(abs(tx - x) + abs(ty - y) &amp;gt; abs(tx) + abs(ty) for x, y in ghosts)</description></item><item><title>790. Domino and Tromino Tiling</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/790/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/790/</guid><description>LeetCode problem 790
class Solution: def numTilings(self, n: int) -&amp;gt; int: f = [1, 0, 0, 0] mod = 10**9 + 7 for i in range(1, n + 1): g = [0] * 4 g[0] = (f[0] + f[1] + f[2] + f[3]) % mod g[1] = (f[2] + f[3]) % mod g[2] = (f[1] + f[3]) % mod g[3] = f[0] f = g return f[0]</description></item><item><title>791. Custom Sort String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/791/</guid><description>LeetCode problem 791
class Solution: def customSortString(self, order: str, s: str) -&amp;gt; str: cnt = Counter(s) res = [] for c in order: res.append(c * cnt[c]) cnt[c] = 0 for c, v in cnt.items(): res.append(c * v) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>792. Number of Matching Subsequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/792/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/792/</guid><description>LeetCode problem 792
class Solution: def numMatchingSubseq(self, s: str, words: List[str]) -&amp;gt; int: def check(w): i = -1 for c in w: j = bisect_right(d[c], i) if j == len(d[c]): return False i = d[c][j] return True d = defaultdict(list) for i, c in enumerate(s): d[c].append(i) return sum(check(w) for w in words)</description></item><item><title>794. Valid Tic-Tac-Toe State</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/794/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/794/</guid><description>LeetCode problem 794
class Solution: def validTicTacToe(self, board: List[str]) -&amp;gt; bool: def win(x): for i in range(3): if all(board[i][j] == x for j in range(3)): return True if all(board[j][i] == x for j in range(3)): return True if all(board[i][i] == x for i in range(3)): return True return all(board[i][2 - i] == x for i in range(3)) x = sum(board[i][j] == &amp;#39;X&amp;#39; for i in range(3) for j in range(3)) o = sum(board[i][j] == &amp;#39;O&amp;#39; for i in range(3) for j in range(3)) if x !</description></item><item><title>795. Number of Subarrays with Bounded Maximum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/795/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/795/</guid><description>LeetCode problem 795
class Solution: def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -&amp;gt; int: n = len(nums) l, r = [-1] * n, [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;lt;= v: stk.pop() if stk: l[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: r[i] = stk[-1] stk.append(i) return sum( (i - l[i]) * (r[i] - i) for i, v in enumerate(nums) if left &amp;lt;= v &amp;lt;= right )</description></item><item><title>797. All Paths From Source to Target</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/797/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/797/</guid><description>LeetCode problem 797
class Solution: def allPathsSourceTarget(self, graph: List[List[int]]) -&amp;gt; List[List[int]]: def dfs(t): if t[-1] == len(graph) - 1: res.append(t[:]) return for v in graph[t[-1]]: t.append(v) dfs(t) t.pop() res = [] dfs([0]) return res</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</guid><description>LeetCode problem 799
class Solution: def champagneTower(self, poured: int, query_row: int, query_glass: int) -&amp;gt; float: f = [poured] for i in range(1, query_row + 1): g = [0] * (i + 1) for j, v in enumerate(f): if v &amp;gt; 1: half = (v - 1) / 2 g[j] += half g[j + 1] += half f = g return min(1, f[query_glass])</description></item><item><title>802. Find Eventual Safe States</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/802/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/802/</guid><description>LeetCode problem 802
class Solution: def eventualSafeNodes(self, graph: List[List[int]]) -&amp;gt; List[int]: def dfs(i): if color[i]: return color[i] == 2 color[i] = 1 for j in graph[i]: if not dfs(j): return False color[i] = 2 return True n = len(graph) color = [0] * n return [i for i in range(n) if dfs(i)]</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1004/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1004/</guid><description>LeetCode задача 1004
Задача Дан массив A состоящий из 0 и 1, и число K. Найти максимальную длину подпоследовательности единиц, которую можно получить, преобразовав не более K нулей в единицы.
Подсказки Использование скользящего окна может значительно ускорить решение задачи.
Подход Инициализация: Создайте переменные для хранения начала и конца &amp;ldquo;окна&amp;rdquo; и максимальной длины подпоследовательности. Проход по массиву: Перемещайте &amp;ldquo;окно&amp;rdquo; по массиву, подсчитывая количество нулей внутри. Сдвиг окна: Если количество нулей превышает K, сдвигайте левый край окна, пока это не станет истиной.</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1359/</guid><description>LeetCode задача 1359
Задача Дано n заказов, каждый заказ состоит из услуг по приему и доставке.
Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).
Так как ответ может быть очень большим, верните его по модулю 10^9 + 7.
Подсказки Использовать комбинаторный подход.
Для каждого нового заказа у нас есть 2 * (2n-1) способов добавить его в текущую последовательность.
Мы используем данную формулу, так как:
Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест).</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1372/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1372/</guid><description>LeetCode задача 1372
Задача Найти самый длинный &amp;ldquo;ZigZag&amp;rdquo; путь в бинарном дереве. Путь &amp;ldquo;ZigZag&amp;rdquo; означает альтернативное движение влево и вправо при переходе от одного узла к другому.
Подсказки Используйте Depth-First Search (DFS) для решения задачи.
Подход DFS с состоянием: Запустите DFS с дополнительным аргументом, который будет отслеживать, в какую сторону нужно двигаться следующим (влево или вправо). Обновление максимума: На каждом уровне рекурсии проверьте, не превышает ли текущая длина пути максимальную известную длину. Рекурсивный вызов: Продолжайте движение в обоих направлениях, но учитывайте, что направление должно изменяться.</description></item><item><title>1448. Count Good Nodes in Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1448/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1448/</guid><description>LeetCode задача 1448
Задача Дано бинарное дерево. Задача подсчитать количество &amp;ldquo;хороших&amp;rdquo; узлов. Узел считается &amp;ldquo;хорошим&amp;rdquo;, если на пути от корня дерева до этого узла (включительно) не встречается узлов с большим значением.
Подсказки &amp;ldquo;Хороший&amp;rdquo; узел в дереве — это узел, для которого все узлы на пути от корня до этого узла имеют значение не больше, чем значение этого узла.
Использовать метод обхода в глубину (DFS) для решения этой задачи.
Подход Идея решения задачи заключается в рекурсивном обходе дерева с сохранением максимального значения на пути от корня к текущему узлу.</description></item><item><title>1481. Least Number of Unique Integers after K Removals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1481/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1481/</guid><description>LeetCode problem 1481
class Solution: def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -&amp;gt; int: counter = Counter(arr) for i, v in enumerate(sorted(counter.values())): k -= v if k &amp;lt; 0: return len(counter) - i return 0</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</guid><description>LeetCode задача 1647
Задача Строка s называется хорошей, если в ней нет двух разных символов с одинаковой частотой.
Дана строка s, верните минимальное количество символов, которое необходимо удалить, чтобы сделать s хорошим.
Подход Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.
Если проверять встречалась ли частота текущего символа ранее, то
Алгоритм / Абстрактный алгоритм Считаем частоты всех символов в строке. Сортируем частоты в порядке убывания.</description></item><item><title>2013. Detect Squares</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2013/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2013/</guid><description>LeetCode задача 2013
В данное задаче решение будет с использованием переменных на русском языке
Задача Задача заключается в разработке структуры данных, которая позволяет добавлять точки на плоскости и подсчитывать количество квадратов, которые можно образовать, добавив новую точку.
Подсказки Решение включает в себя поддержку двух типов данных:
Счётчик точек счетчик_точек, который хранит информацию о количестве каждой точки на плоскости. Словарь координат по оси X координаты_по_x, который для каждой координаты x содержит счётчик координат y, позволяющий быстро находить все точки с данной координатой x.</description></item><item><title>2108. Find First Palindromic String in the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2108/</guid><description>LeetCode problem 2108
class Solution: def firstPalindrome(self, words: List[str]) -&amp;gt; str: return next((w for w in words if w == w[::-1]), &amp;#34;&amp;#34;)</description></item><item><title>2130. Maximum Twin Sum of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</guid><description>LeetCode задача 2130
Задача Дан односвязный список четной длины. Узлы в этом списке имеют &amp;ldquo;близнецов&amp;rdquo; по определенным правилам. Задача — найти максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.
Т.е. у первой половины узлов списка есть свой близнец из второй половины.
Пример: для списка длиной n = 8 i = 0, twin = n-1-i = 8-1-0 = 7 i = 1, twin = n-1-1 = 6 i = 2, twin = n-1-2 = 5 &amp;hellip;
Подсказки У первой половины узлов списка есть свой близнец из второй половины, т.</description></item><item><title>2283. Check if Number Has Equal Digit Count and Digit Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2283/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2283/</guid><description>LeetCode problem 2283
class Solution: def digitCount(self, num: str) -&amp;gt; bool: cnt = Counter(num) return all(cnt[str(i)] == int(v) for i, v in enumerate(num))</description></item><item><title>2287. Rearrange Characters to Make Target String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2287/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2287/</guid><description>LeetCode problem 2287
class Solution: def rearrangeCharacters(self, s: str, target: str) -&amp;gt; int: cnt1 = Counter(s) cnt2 = Counter(target) return min(cnt1[c] // v for c, v in cnt2.items())</description></item><item><title>2293. Min Max Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2293/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2293/</guid><description>LeetCode problem 2293
class Solution: def minMaxGame(self, nums: List[int]) -&amp;gt; int: n = len(nums) while n &amp;gt; 1: n &amp;gt;&amp;gt;= 1 for i in range(n): a, b = nums[i &amp;lt;&amp;lt; 1], nums[i &amp;lt;&amp;lt; 1 | 1] nums[i] = min(a, b) if i % 2 == 0 else max(a, b) return nums[0]</description></item><item><title>2299. Strong Password Checker II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2299/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2299/</guid><description>LeetCode problem 2299
class Solution: def strongPasswordCheckerII(self, password: str) -&amp;gt; bool: if len(password) &amp;lt; 8: return False mask = 0 for i, c in enumerate(password): if i and c == password[i - 1]: return False if c.islower(): mask |= 1 elif c.isupper(): mask |= 2 elif c.isdigit(): mask |= 4 else: mask |= 8 return mask == 15</description></item><item><title>2303. Calculate Amount Paid in Taxes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2303/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2303/</guid><description>LeetCode problem 2303
class Solution: def calculateTax(self, brackets: List[List[int]], income: int) -&amp;gt; float: res = prev = 0 for upper, percent in brackets: res += max(0, min(income, upper) - prev) * percent prev = upper return res / 100</description></item><item><title>2309. Greatest English Letter in Upper and Lower Case</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2309/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2309/</guid><description>LeetCode problem 2309
class Solution: def greatestLetter(self, s: str) -&amp;gt; str: mask1 = mask2 = 0 for c in s: if c.islower(): mask1 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) else: mask2 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;A&amp;#34;)) mask = mask1 &amp;amp; mask2 return chr(mask.bit_length() - 1 + ord(&amp;#34;A&amp;#34;)) if mask else &amp;#34;&amp;#34;</description></item><item><title>2315. Count Asterisks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2315/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2315/</guid><description>LeetCode problem 2315
class Solution: def countAsterisks(self, s: str) -&amp;gt; int: res, ok = 0, 1 for c in s: if c == &amp;#34;*&amp;#34;: res += ok elif c == &amp;#34;|&amp;#34;: ok ^= 1 return res</description></item><item><title>2319. Check if Matrix Is X-Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2319/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2319/</guid><description>LeetCode problem 2319
class Solution: def checkXMatrix(self, grid: List[List[int]]) -&amp;gt; bool: for i, row in enumerate(grid): for j, v in enumerate(row): if i == j or i + j == len(grid) - 1: if v == 0: return False elif v: return False return True</description></item><item><title>2325. Decode the Message</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2325/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2325/</guid><description>LeetCode problem 2325
class Solution: def decodeMessage(self, key: str, message: str) -&amp;gt; str: d = {&amp;#34; &amp;#34;: &amp;#34; &amp;#34;} i = 0 for c in key: if c not in d: d[c] = ascii_lowercase[i] i += 1 return &amp;#34;&amp;#34;.join(d[c] for c in message)</description></item><item><title>2331. Evaluate Boolean Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2331/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2331/</guid><description>LeetCode problem 2331
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def evaluateTree(self, root: Optional[TreeNode]) -&amp;gt; bool: if root.left is None: return bool(root.val) l = self.evaluateTree(root.left) r = self.evaluateTree(root.right) return l or r if root.val == 2 else l and r</description></item><item><title>2335. Minimum Amount of Time to Fill Cups</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2335/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2335/</guid><description>LeetCode problem 2335
class Solution: def fillCups(self, amount: List[int]) -&amp;gt; int: amount.sort() if amount[0] + amount[1] &amp;lt;= amount[2]: return amount[2] return (sum(amount) + 1) // 2</description></item><item><title>2341. Maximum Number of Pairs in Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2341/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2341/</guid><description>LeetCode problem 2341
class Solution: def numberOfPairs(self, nums: List[int]) -&amp;gt; List[int]: cnt = Counter(nums) s = sum(v // 2 for v in cnt.values()) return [s, len(nums) - s * 2]</description></item><item><title>2347. Best Poker Hand</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2347/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2347/</guid><description>LeetCode problem 2347
class Solution: def bestHand(self, ranks: List[int], suits: List[str]) -&amp;gt; str: # if len(set(suits)) == 1: if all(a == b for a, b in pairwise(suits)): return &amp;#39;Flush&amp;#39; cnt = Counter(ranks) if any(v &amp;gt;= 3 for v in cnt.values()): return &amp;#39;Three of a Kind&amp;#39; if any(v == 2 for v in cnt.values()): return &amp;#39;Pair&amp;#39; return &amp;#39;High Card&amp;#39;</description></item><item><title>2351. First Letter to Appear Twice</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2351/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2351/</guid><description>LeetCode problem 2351
class Solution: def repeatedCharacter(self, s: str) -&amp;gt; str: mask = 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if mask &amp;gt;&amp;gt; i &amp;amp; 1: return c mask |= 1 &amp;lt;&amp;lt; i</description></item><item><title>2353. Design a Food Rating System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2353/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2353/</guid><description>LeetCode problem 2353
from sortedcontainers import SortedSet class FoodRatings: def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]): self.mp = {} self.t = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1]))) for a, b, c in zip(foods, cuisines, ratings): self.mp[a] = (b, c) self.t[b].add((c, a)) def changeRating(self, food: str, newRating: int) -&amp;gt; None: b, c = self.mp[food] self.mp[food] = (b, newRating) self.t[b].remove((c, food)) self.t[b].add((newRating, food)) def highestRated(self, cuisine: str) -&amp;gt; str: return self.t[cuisine][0][1] # Your FoodRatings object will be instantiated and called as such: # obj = FoodRatings(foods, cuisines, ratings) # obj.</description></item><item><title>2357. Make Array Zero by Subtracting Equal Amounts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2357/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2357/</guid><description>LeetCode problem 2357
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: return len({x for x in nums if x})</description></item><item><title>2358. Maximum Number of Groups Entering a Competition</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2358/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2358/</guid><description>LeetCode problem 2358
class Solution: def maximumGroups(self, grades: List[int]) -&amp;gt; int: n = len(grades) return bisect_right(range(n + 1), n * 2, key=lambda x: x * x + x) - 1</description></item><item><title>2359. Find Closest Node to Given Two Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2359/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2359/</guid><description>LeetCode problem 2359
class Solution: def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -&amp;gt; int: def f(i): dist = [inf] * n dist[i] = 0 q = deque([i]) while q: i = q.popleft() for j in g[i]: if dist[j] == inf: dist[j] = dist[i] + 1 q.append(j) return dist g = defaultdict(list) for i, j in enumerate(edges): if j != -1: g[i].append(j) n = len(edges) d1 = f(node1) d2 = f(node2) res, d = -1, inf for i, (a, b) in enumerate(zip(d1, d2)): if (t := max(a, b)) &amp;lt; d: d = t res = i return res</description></item><item><title>2363. Merge Similar Items</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2363/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2363/</guid><description>LeetCode problem 2363
class Solution: def mergeSimilarItems( self, items1: List[List[int]], items2: List[List[int]] ) -&amp;gt; List[List[int]]: cnt = Counter() for v, w in chain(items1, items2): cnt[v] += w return sorted(cnt.items())</description></item><item><title>2364. Count Number of Bad Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2364/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2364/</guid><description>LeetCode problem 2364
class Solution: def countBadPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter() res = 0 for i, x in enumerate(nums): res += i - cnt[i - x] cnt[i - x] += 1 return res</description></item><item><title>2365. Task Scheduler II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2365/</guid><description>LeetCode problem 2365
class Solution: def taskSchedulerII(self, tasks: List[int], space: int) -&amp;gt; int: day = defaultdict(int) res = 0 for task in tasks: res += 1 res = max(res, day[task]) day[task] = res + space + 1 return res</description></item><item><title>2367. Number of Arithmetic Triplets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2367/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2367/</guid><description>LeetCode problem 2367
class Solution: def arithmeticTriplets(self, nums: List[int], diff: int) -&amp;gt; int: vis = set(nums) return sum(x + diff in vis and x + diff * 2 in vis for x in nums)</description></item><item><title>2368. Reachable Nodes With Restrictions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2368/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2368/</guid><description>LeetCode problem 2368
class Solution: def reachableNodes( self, n: int, edges: List[List[int]], restricted: List[int] ) -&amp;gt; int: s = set(restricted) g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) q = deque([0]) vis = [False] * n for v in restricted: vis[v] = True res = 0 while q: i = q.popleft() res += 1 vis[i] = True for j in g[i]: if not vis[j]: q.append(j) return res</description></item><item><title>2369. Check if There is a Valid Partition For The Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2369/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2369/</guid><description>LeetCode problem 2369
class Solution: def validPartition(self, nums: List[int]) -&amp;gt; bool: n = len(nums) dp = [False] * (n + 1) dp[0] = True for i in range(2, n + 1): if nums[i - 1] == nums[i - 2]: dp[i] = dp[i] or dp[i - 2] if i &amp;gt; 2 and nums[i - 1] == nums[i - 2] == nums[i - 3]: dp[i] = dp[i] or dp[i - 3] if ( i &amp;gt; 2 and nums[i - 1] - nums[i - 2] == 1 and nums[i - 2] - nums[i - 3] == 1 ): dp[i] = dp[i] or dp[i - 3] return dp[-1]</description></item><item><title>2370. Longest Ideal Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2370/</guid><description>LeetCode problem 2370
class Solution: def longestIdealString(self, s: str, k: int) -&amp;gt; int: n = len(s) res = 1 dp = [1] * n d = {s[0]: 0} for i in range(1, n): a = ord(s[i]) for b in ascii_lowercase: if abs(a - ord(b)) &amp;gt; k: continue if b in d: dp[i] = max(dp[i], dp[d[b]] + 1) d[s[i]] = i return max(dp)</description></item><item><title>2373. Largest Local Values in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2373/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2373/</guid><description>LeetCode problem 2373
class Solution: def largestLocal(self, grid: List[List[int]]) -&amp;gt; List[List[int]]: n = len(grid) res = [[0] * (n - 2) for _ in range(n - 2)] for i in range(n - 2): for j in range(n - 2): res[i][j] = max( grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3) ) return res</description></item><item><title>2374. Node With Highest Edge Score</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2374/</guid><description>LeetCode problem 2374
class Solution: def edgeScore(self, edges: List[int]) -&amp;gt; int: cnt = Counter() for i, v in enumerate(edges): cnt[v] += i res = 0 for i in range(len(edges)): if cnt[res] &amp;lt; cnt[i]: res = i return res</description></item><item><title>2375. Construct Smallest Number From DI String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2375/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2375/</guid><description>LeetCode problem 2375
class Solution: def smallestNumber(self, pattern: str) -&amp;gt; str: def dfs(u): nonlocal res if res: return if u == len(pattern) + 1: res = &amp;#39;&amp;#39;.join(t) return for i in range(1, 10): if not vis[i]: if u and pattern[u - 1] == &amp;#39;I&amp;#39; and int(t[-1]) &amp;gt;= i: continue if u and pattern[u - 1] == &amp;#39;D&amp;#39; and int(t[-1]) &amp;lt;= i: continue vis[i] = True t.append(str(i)) dfs(u + 1) vis[i] = False t.pop() vis = [False] * 10 t = [] res = None dfs(0) return res</description></item><item><title>2378. Choose Edges to Maximize Score in a Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2378/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2378/</guid><description>LeetCode problem 2378
class Solution: def maxScore(self, edges: List[List[int]]) -&amp;gt; int: def dfs(i): a = b = t = 0 for j, w in g[i]: x, y = dfs(j) a += y b += y t = max(t, x - y + w) b += t return a, b g = defaultdict(list) for i, (p, w) in enumerate(edges[1:], 1): g[p].append((i, w)) return dfs(0)[1]</description></item><item><title>2379. Minimum Recolors to Get K Consecutive Black Blocks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2379/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2379/</guid><description>LeetCode problem 2379
class Solution: def minimumRecolors(self, blocks: str, k: int) -&amp;gt; int: res = cnt = blocks[:k].count(&amp;#39;W&amp;#39;) for i in range(k, len(blocks)): cnt += blocks[i] == &amp;#39;W&amp;#39; cnt -= blocks[i - k] == &amp;#39;W&amp;#39; res = min(res, cnt) return res</description></item><item><title>2380. Time Needed to Rearrange a Binary String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2380/</guid><description>LeetCode problem 2380
class Solution: def secondsToRemoveOccurrences(self, s: str) -&amp;gt; int: res = cnt = 0 for c in s: if c == &amp;#39;0&amp;#39;: cnt += 1 elif cnt: res = max(res + 1, cnt) return res</description></item><item><title>2381. Shifting Letters II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2381/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2381/</guid><description>LeetCode problem 2381
class Solution: def shiftingLetters(self, s: str, shifts: List[List[int]]) -&amp;gt; str: n = len(s) d = [0] * (n + 1) for i, j, v in shifts: if v == 0: v = -1 d[i] += v d[j + 1] -= v for i in range(1, n + 1): d[i] += d[i - 1] return &amp;#39;&amp;#39;.join( chr(ord(&amp;#39;a&amp;#39;) + (ord(s[i]) - ord(&amp;#39;a&amp;#39;) + d[i] + 26) % 26) for i in range(n) )</description></item><item><title>2383. Minimum Hours of Training to Win a Competition</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2383/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2383/</guid><description>LeetCode problem 2383
class Solution: def minNumberOfHours( self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int], ) -&amp;gt; int: res = max(0, sum(energy) - initialEnergy + 1) for x in experience: if initialExperience &amp;lt;= x: res += x - initialExperience + 1 initialExperience = x + 1 initialExperience += x return res</description></item><item><title>2384. Largest Palindromic Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2384/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2384/</guid><description>LeetCode problem 2384
class Solution: def largestPalindromic(self, num: str) -&amp;gt; str: cnt = Counter(num) res = &amp;#39;&amp;#39; for i in range(9, -1, -1): v = str(i) if cnt[v] % 2: res = v cnt[v] -= 1 break for i in range(10): v = str(i) if cnt[v]: cnt[v] //= 2 s = cnt[v] * v res = s + res + s return res.strip(&amp;#39;0&amp;#39;) or &amp;#39;0&amp;#39;</description></item><item><title>2385. Amount of Time for Binary Tree to Be Infected</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2385/</guid><description>LeetCode problem 2385
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def amountOfTime(self, root: Optional[TreeNode], start: int) -&amp;gt; int: def dfs(root): if root is None: return if root.left: g[root.val].append(root.left.val) g[root.left.val].append(root.val) if root.right: g[root.val].append(root.right.val) g[root.right.val].append(root.val) dfs(root.left) dfs(root.right) def dfs2(i, fa): res = 0 for j in g[i]: if j != fa: res = max(res, 1 + dfs2(j, i)) return res g = defaultdict(list) dfs(root) return dfs2(start, -1)</description></item><item><title>2387. Median of a Row Wise Sorted Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2387/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2387/</guid><description>LeetCode problem 2387
class Solution: def matrixMedian(self, grid: List[List[int]]) -&amp;gt; int: def count(x): return sum(bisect_right(row, x) for row in grid) m, n = len(grid), len(grid[0]) target = (m * n + 1) &amp;gt;&amp;gt; 1 return bisect_left(range(10**6 + 1), target, key=count)</description></item><item><title>2389. Longest Subsequence With Limited Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2389/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2389/</guid><description>LeetCode problem 2389
class Solution: def answerQueries(self, nums: List[int], queries: List[int]) -&amp;gt; List[int]: nums.sort() m = len(queries) res = [0] * m idx = sorted(range(m), key=lambda i: queries[i]) s = j = 0 for i in idx: while j &amp;lt; len(nums) and s + nums[j] &amp;lt;= queries[i]: s += nums[j] j += 1 res[i] = j return res</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem 2390
class Solution: def removeStars(self, s: str) -&amp;gt; str: res = [] for c in s: if c == &amp;#39;*&amp;#39;: res.pop() else: res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2391. Minimum Amount of Time to Collect Garbage</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2391/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2391/</guid><description>LeetCode problem 2391
class Solution: def garbageCollection(self, garbage: List[str], travel: List[int]) -&amp;gt; int: def f(x: str) -&amp;gt; int: res = 0 st = 0 for i, s in enumerate(garbage): if t := s.count(x): res += t + st st = 0 if i &amp;lt; len(travel): st += travel[i] return res return f(&amp;#39;M&amp;#39;) + f(&amp;#39;P&amp;#39;) + f(&amp;#39;G&amp;#39;)</description></item><item><title>2393. Count Strictly Increasing Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2393/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2393/</guid><description>LeetCode problem 2393
class Solution: def countSubarrays(self, nums: List[int]) -&amp;gt; int: res = pre = cnt = 0 for x in nums: if pre &amp;lt; x: cnt += 1 else: cnt = 1 pre = x res += cnt return res</description></item><item><title>2395. Find Subarrays With Equal Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2395/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2395/</guid><description>LeetCode problem 2395
class Solution: def findSubarrays(self, nums: List[int]) -&amp;gt; bool: vis = set() for a, b in pairwise(nums): if (x := a + b) in vis: return True vis.add(x) return False</description></item><item><title>2396. Strictly Palindromic Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2396/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2396/</guid><description>LeetCode problem 2396
class Solution: def isStrictlyPalindromic(self, n: int) -&amp;gt; bool: return False</description></item><item><title>2397. Maximum Rows Covered by Columns</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2397/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2397/</guid><description>LeetCode problem 2397
class Solution: def maximumRows(self, matrix: List[List[int]], numSelect: int) -&amp;gt; int: rows = [] for row in matrix: mask = reduce(or_, (1 &amp;lt;&amp;lt; j for j, x in enumerate(row) if x), 0) rows.append(mask) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(matrix[0])): if mask.bit_count() != numSelect: continue t = sum((x &amp;amp; mask) == x for x in rows) res = max(res, t) return res</description></item><item><title>2399. Check Distances Between Same Letters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2399/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2399/</guid><description>LeetCode problem 2399
class Solution: def checkDistances(self, s: str, distance: List[int]) -&amp;gt; bool: d = defaultdict(int) for i, c in enumerate(s, 1): if d[c] and i - d[c] - 1 != distance[ord(c) - ord(&amp;#39;a&amp;#39;)]: return False d[c] = i return True</description></item><item><title>2400. Number of Ways to Reach a Position After Exactly k Steps</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2400/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2400/</guid><description>LeetCode problem 2400
class Solution: def numberOfWays(self, startPos: int, endPos: int, k: int) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if i &amp;gt; j or j &amp;lt; 0: return 0 if j == 0: return 1 if i == 0 else 0 return (dfs(i + 1, j - 1) + dfs(abs(i - 1), j - 1)) % mod mod = 10**9 + 7 return dfs(abs(startPos - endPos), k)</description></item><item><title>2401. Longest Nice Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2401/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2401/</guid><description>LeetCode problem 2401
class Solution: def longestNiceSubarray(self, nums: List[int]) -&amp;gt; int: res = j = mask = 0 for i, x in enumerate(nums): while mask &amp;amp; x: mask ^= nums[j] j += 1 res = max(res, i - j + 1) mask |= x return res</description></item><item><title>2404. Most Frequent Even Element</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2404/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2404/</guid><description>LeetCode problem 2404
class Solution: def mostFrequentEven(self, nums: List[int]) -&amp;gt; int: cnt = Counter(x for x in nums if x % 2 == 0) res, mx = -1, 0 for x, v in cnt.items(): if v &amp;gt; mx or (v == mx and res &amp;gt; x): res, mx = x, v return res</description></item><item><title>2405. Optimal Partition of String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2405/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2405/</guid><description>LeetCode problem 2405
class Solution: def partitionString(self, s: str) -&amp;gt; int: res, v = 1, 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if (v &amp;gt;&amp;gt; i) &amp;amp; 1: v = 0 res += 1 v |= 1 &amp;lt;&amp;lt; i return res</description></item><item><title>2406. Divide Intervals Into Minimum Number of Groups</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2406/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2406/</guid><description>LeetCode problem 2406
class Solution: def minGroups(self, intervals: List[List[int]]) -&amp;gt; int: h = [] for a, b in sorted(intervals): if h and h[0] &amp;lt; a: heappop(h) heappush(h, b) return len(h)</description></item><item><title>2408. Design SQL</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2408/</guid><description>LeetCode problem 2408
class SQL: def __init__(self, names: List[str], columns: List[int]): self.tables = defaultdict(list) def insertRow(self, name: str, row: List[str]) -&amp;gt; None: self.tables[name].append(row) def deleteRow(self, name: str, rowId: int) -&amp;gt; None: pass def selectCell(self, name: str, rowId: int, columnId: int) -&amp;gt; str: return self.tables[name][rowId - 1][columnId - 1] # Your SQL object will be instantiated and called as such: # obj = SQL(names, columns) # obj.insertRow(name,row) # obj.deleteRow(name,rowId) # param_3 = obj.selectCell(name,rowId,columnId)</description></item><item><title>2409. Count Days Spent Together</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2409/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2409/</guid><description>LeetCode problem 2409
class Solution: def countDaysTogether( self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str ) -&amp;gt; int: a = max(arriveAlice, arriveBob) b = min(leaveAlice, leaveBob) days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) x = sum(days[: int(a[:2]) - 1]) + int(a[3:]) y = sum(days[: int(b[:2]) - 1]) + int(b[3:]) return max(y - x + 1, 0)</description></item><item><title>2410. Maximum Matching of Players With Trainers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2410/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2410/</guid><description>LeetCode problem 2410
class Solution: def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -&amp;gt; int: players.sort() trainers.sort() res = j = 0 for p in players: while j &amp;lt; len(trainers) and trainers[j] &amp;lt; p: j += 1 if j &amp;lt; len(trainers): res += 1 j += 1 return res</description></item><item><title>2411. Smallest Subarrays With Maximum Bitwise OR</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2411/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2411/</guid><description>LeetCode problem 2411
class Solution: def smallestSubarrays(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n f = [-1] * 32 for i in range(n - 1, -1, -1): t = 1 for j in range(32): if (nums[i] &amp;gt;&amp;gt; j) &amp;amp; 1: f[j] = i elif f[j] != -1: t = max(t, f[j] - i + 1) res[i] = t return res</description></item><item><title>2413. Smallest Even Multiple</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2413/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2413/</guid><description>LeetCode problem 2413
class Solution: def smallestEvenMultiple(self, n: int) -&amp;gt; int: return n if n % 2 == 0 else n * 2</description></item><item><title>2414. Length of the Longest Alphabetical Continuous Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2414/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2414/</guid><description>LeetCode problem 2414
class Solution: def longestContinuousSubstring(self, s: str) -&amp;gt; int: res = 0 i, j = 0, 1 while j &amp;lt; len(s): res = max(res, j - i) if ord(s[j]) - ord(s[j - 1]) != 1: i = j j += 1 res = max(res, j - i) return res</description></item><item><title>2415. Reverse Odd Levels of Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2415/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2415/</guid><description>LeetCode problem 2415
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def reverseOddLevels(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: q = deque([root]) i = 0 while q: if i &amp;amp; 1: l, r = 0, len(q) - 1 while l &amp;lt; r: q[l].val, q[r].val = q[r].val, q[l].val l, r = l + 1, r - 1 for _ in range(len(q)): node = q.</description></item><item><title>2417. Closest Fair Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2417/</guid><description>LeetCode problem 2417
class Solution: def closestFair(self, n: int) -&amp;gt; int: a = b = k = 0 t = n while t: if (t % 10) &amp;amp; 1: a += 1 else: b += 1 t //= 10 k += 1 if k &amp;amp; 1: x = 10**k y = int(&amp;#39;1&amp;#39; * (k &amp;gt;&amp;gt; 1) or &amp;#39;0&amp;#39;) return x + y if a == b: return n return self.closestFair(n + 1)</description></item><item><title>2418. Sort the People</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2418/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2418/</guid><description>LeetCode problem 2418
class Solution: def sortPeople(self, names: List[str], heights: List[int]) -&amp;gt; List[str]: return [name for _, name in sorted(zip(heights, names), reverse=True)]</description></item><item><title>2419. Longest Subarray With Maximum Bitwise AND</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2419/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2419/</guid><description>LeetCode problem 2419
class Solution: def longestSubarray(self, nums: List[int]) -&amp;gt; int: mx = max(nums) res = cnt = 0 for v in nums: if v == mx: cnt += 1 res = max(res, cnt) else: cnt = 0 return res</description></item><item><title>2420. Find All Good Indices</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2420/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2420/</guid><description>LeetCode problem 2420
class Solution: def goodIndices(self, nums: List[int], k: int) -&amp;gt; List[int]: n = len(nums) decr = [1] * (n + 1) incr = [1] * (n + 1) for i in range(2, n - 1): if nums[i - 1] &amp;lt;= nums[i - 2]: decr[i] = decr[i - 1] + 1 for i in range(n - 3, -1, -1): if nums[i + 1] &amp;lt;= nums[i + 2]: incr[i] = incr[i + 1] + 1 return [i for i in range(k, n - k) if decr[i] &amp;gt;= k and incr[i] &amp;gt;= k]</description></item><item><title>2422. Merge Operations to Turn Array Into a Palindrome</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2422/</guid><description>LeetCode problem 2422
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: i, j = 0, len(nums) - 1 a, b = nums[i], nums[j] res = 0 while i &amp;lt; j: if a &amp;lt; b: i += 1 a += nums[i] res += 1 elif b &amp;lt; a: j -= 1 b += nums[j] res += 1 else: i, j = i + 1, j - 1 a, b = nums[i], nums[j] return res</description></item><item><title>2423. Remove Letter To Equalize Frequency</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2423/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2423/</guid><description>LeetCode problem 2423
class Solution: def equalFrequency(self, word: str) -&amp;gt; bool: cnt = Counter(word) for c in cnt.keys(): cnt[c] -= 1 if len(set(v for v in cnt.values() if v)) == 1: return True cnt[c] += 1 return False</description></item><item><title>2424. Longest Uploaded Prefix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2424/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2424/</guid><description>LeetCode problem 2424
class LUPrefix: def __init__(self, n: int): self.r = 0 self.s = set() def upload(self, video: int) -&amp;gt; None: self.s.add(video) while self.r + 1 in self.s: self.r += 1 def longest(self) -&amp;gt; int: return self.r # Your LUPrefix object will be instantiated and called as such: # obj = LUPrefix(n) # obj.upload(video) # param_2 = obj.longest()</description></item><item><title>2425. Bitwise XOR of All Pairings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2425/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2425/</guid><description>LeetCode problem 2425
class Solution: def xorAllNums(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: res = 0 if len(nums2) &amp;amp; 1: for v in nums1: res ^= v if len(nums1) &amp;amp; 1: for v in nums2: res ^= v return res</description></item><item><title>2427. Number of Common Factors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2427/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2427/</guid><description>LeetCode problem 2427
class Solution: def commonFactors(self, a: int, b: int) -&amp;gt; int: g = gcd(a, b) res, x = 0, 1 while x * x &amp;lt;= g: if g % x == 0: res += 1 res += x * x &amp;lt; g x += 1 return res</description></item><item><title>2428. Maximum Sum of an Hourglass</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2428/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2428/</guid><description>LeetCode problem 2428
class Solution: def maxSum(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) res = 0 for i in range(1, m - 1): for j in range(1, n - 1): s = -grid[i][j - 1] - grid[i][j + 1] s += sum( grid[x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) ) res = max(res, s) return res</description></item><item><title>2429. Minimize XOR</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2429/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2429/</guid><description>LeetCode problem 2429
class Solution: def minimizeXor(self, num1: int, num2: int) -&amp;gt; int: cnt1 = num1.bit_count() cnt2 = num2.bit_count() while cnt1 &amp;gt; cnt2: num1 &amp;amp;= num1 - 1 cnt1 -= 1 while cnt1 &amp;lt; cnt2: num1 |= num1 + 1 cnt1 += 1 return num1</description></item><item><title>2971. Find Polygon With the Largest Perimeter</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2971/</guid><description>LeetCode problem 2971
class Solution: def largestPerimeter(self, nums: List[int]) -&amp;gt; int: nums.sort() s = list(accumulate(nums, initial=0)) res = -1 for k in range(3, len(nums) + 1): if s[k - 1] &amp;gt; nums[k - 1]: res = max(res, s[k]) return res</description></item><item><title>3016. Minimum Number of Pushes to Type Word II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/3016/</guid><description>LeetCode problem 3016
class Solution: def minimumPushes(self, word: str) -&amp;gt; int: cnt = Counter(word) res = 0 for i, x in enumerate(sorted(cnt.values(), reverse=True)): res += (i // 8 + 1) * x return res</description></item><item><title>3028. Ant on the Boundary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/3028/</guid><description>LeetCode задача 3028
Воспользуемся функцией accumulate из модуля itertools, чтобы упростить вычисление и подсчет количества раз, когда муравей возвращается на границу, пройдя через массив nums.
Применяем функцию accumulate для подсчета накопительной суммы и подсчитываем количество раз, когда накопительная сумма равна 0.
Решение class Solution: def returnToBoundaryCount(self, nums: List[int]) -&amp;gt; int: return sum(s == 0 for s in accumulate(nums)) Функция accumulate(nums) генерирует последовательность накопленных сумм элементов массива nums, начиная с первого элемента.
Затем с помощью генераторного выражения s == 0 for s in accumulate(nums) мы создаем последовательность True и False, в зависимости от того, равна ли накопленная сумма в каждой точке нулю.</description></item><item><title>3030. Find the Grid of Region Average</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3030/</guid><description>LeetCode задача 3030
Дана матрица m x n, представляющая изображение в оттенках серого, где image[i][j] представляет пиксель с интенсивностью в диапазоне от 0 до 255. Также дано неотрицательное целое число threshold (пороговое значение).
Два пикселя image[a][b] и image[c][d] считаются соседними, если |a - c| + |b - d| == 1.
Регионом считается матрица 3 x 3, где абсолютная разница в интенсивности между любыми двумя соседними пикселями меньше или равна threshold.
Необходимо вычислить матрицу m x n result, где result[i][j] - это средняя интенсивность региона, к которому принадлежит image[i][j], округленная вниз до ближайшего целого числа.</description></item><item><title>3031. Minimum Time to Revert Word to Initial State II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3031/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/3031/</guid><description>LeetCode problem 3031
class Hashing: __slots__ = [&amp;#34;mod&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;p&amp;#34;] def __init__(self, s: str, base: int, mod: int): self.mod = mod self.h = [0] * (len(s) + 1) self.p = [1] * (len(s) + 1) for i in range(1, len(s) + 1): self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod self.p[i] = (self.p[i - 1] * base) % mod def query(self, l: int, r: int) -&amp;gt; int: return (self.h[r] - self.h[l - 1] * self.</description></item></channel></rss>